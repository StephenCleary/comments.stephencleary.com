[{"_id":"931e7d52-f9ef-38ab-9549-0c63cc50b2da","authorName":"Travis","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/12471100110187013906","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen -  \r\n\r\nI often enjoy your posts, thanks!  \r\n\r\nI have a question related to this topic ... I know that in WPF 4.5 we can indirectly update the UI by making changes to data-bound objects, and even databound collections.  \r\n\r\nI assume something at some point gets marshaled to the UI thread, and this may be different depending on if INotify[...] is used or a DependencyProperty?  \r\n\r\nMy real question this is: when configuring an await, if the remaining tasks are just changing databound objects ... should I prefer ConfigureAwait(false) or no? Technically i don't need to resume on the UI thread due to the feature just described, but maybe I'd rather if the databinding will eventually lead to a thread swap or something anyway?  \r\n\r\nI may be wrong on a lot of my understanding, but thanks for any clarification here!","postId":"2013_04_ui-guidelines-for-async-da97433f-1ee2-3524-a949-cd4ed0c18844","replyTo":"","date":"2013-04-26T23:25:15Z","timestamp":1367018715},{"_id":"b0fca725-b326-3435-b60d-2d573cd08ab2","authorName":"Travis","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/12471100110187013906","authorUserId":"","authorFallbackAvatar":"","message":"I should have clarified ... the indirect updating I mentioned was that you can update the UI from non-UI threads through databinding... in .NET 4.5 this is even possible for databound collections which I believe is new","postId":"2013_04_ui-guidelines-for-async-da97433f-1ee2-3524-a949-cd4ed0c18844","replyTo":"","date":"2013-04-26T23:27:12Z","timestamp":1367018832},{"_id":"27e3119c-9ee7-3f07-b0ca-71ef8b1a95e3","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Good questions, Travis. I don't have all the answers, but I'll give you my opinion. :)  \r\n\r\nFirst off, any kind of property or collection changed event does need to be raised on the UI thread, so you'll need to marshal to that thread one way or another (either explicitly or implicitly).  \r\n\r\nI don't *think* dependency properties will marshal back to the UI thread automatically, and INotify* will only do so if you implement it as such. Some people do implement automatic marshaling to the UI thread. I have never done this; instead, I treat any data-bound properties as though they were a part of the UI (e.g., in async methods, I do *not* use ConfigureAwait(false) if I need to update a data-bound property).  \r\n\r\nThe new cross-thread collection synchronization in .NET 4.5 is not fully automatic; it's more of a way to coordinate ObservableCollection (or other collection) updates between the UI thread and background thread(s). I have not used it yet, but I would consider it if performance analysis indicated it would help. This is assuming you actually need a background thread accessing it (e.g., Task.Run); if you just have async methods, you may as well just marshal back to the UI yourself and not mess with the cross-thread collection synchronization, IMO.  \r\n\r\nThere's always been *some* support for cross-thread UI operations, but I just pretend they don't exist. For one thing, I try to write portable code, and it's always hard to keep straight which little features are on Windows Store vs. Windows Phone vs. Silverlight vs. WPF. Cross-thread UI operations are one more thing I don't have to worry about if I don't use them.","postId":"2013_04_ui-guidelines-for-async-da97433f-1ee2-3524-a949-cd4ed0c18844","replyTo":"","date":"2013-04-28T08:02:19Z","timestamp":1367136139},{"_id":"6d68713c-24aa-33f8-9aee-20a0df40a653","authorName":"Travis","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/12471100110187013906","authorUserId":"","authorFallbackAvatar":"","message":"Sound advice, thanks! The async/await mindset is yielding major improvements in code readability and performance for me, and I'm sure everyone else. It really feels like the \"right way\" to do asynchrony... especially since it separates the concepts of asynchrony and multi-threading. Some of the TPL code I was so proud of a few years ago feels like an embarrassment in my codebase now, hah... not all of it, TPL is great when used for what it was designed for.","postId":"2013_04_ui-guidelines-for-async-da97433f-1ee2-3524-a949-cd4ed0c18844","replyTo":"","date":"2013-04-29T20:24:59Z","timestamp":1367267099},{"_id":"61eee5ea-46b4-36a8-bf8c-bfdb214f5ab7","authorName":"Ondra Medek","authorEmailEncrypted":"SOdH1sBV2vi5Ee+4wChRBXE0LuL/+OYQXGXRyAqazDKw8xlhYrJpZzSIg6beLBOy5YtrmnwYx+ZELJRP9aEw7R55dKWHP+EiAn7SoF8k6oLj5rrXH8iyWbhBgiSBnMOmI0pYyl+lvHoZmhZdoQ4BQa/mQfqjxt4D5ZHae5v9SIEt7B858/GaeJl4+2pE9xHxcNb/gjF1IHXKwURmcOuHzYOkIYVqVTHSINHseAoOslVezpk3lsAhDVDEuG+IFmtAXa3ubpCbZZSQnNXPm1rf1LLyDBFevXM8QPz0enfntxRN9oCT8bbMC+JrsnI325r0szkrF2Uriot+Vka3+aWIYFXc0fBpYpkLx8AzerQ4Cs0zPEYjBYqSB33TJPtB9CeZgum3iB5UNPfZqGwAzdQe6ILW5W3kbVhK0xF4xWVY6cdQL/AnpORshuYZ2m8mQpA/ouanuOyT2w0XuTY9gLldn3HbaSiiEmH4zzWkHH8Q2BxtKYsCIbXfQM/R3x2QtIOmuEPUZdJFbx2WS7ZrF2LovLrz4OtA6mo9nJ4ofKT1Vuiu94W/NpW3fmkDY4Raxq8AwLoYxe08uLykExnD3IH9JoqX8dD6Df9BeAMg5F6Jj4lSYuawjr/xOyjoiarqz8YRPE7N2svnoIO3tixqJmDqX0QfsrE7+rlYDzd0SLHG+6A=","authorEmailMD5":"788da16a4617bd79f2bf91d8dc258455","authorUri":"","authorUserId":"disqus:xmedeko","authorFallbackAvatar":"https://disqus.com/api/users/avatars/xmedeko.jpg","message":"What if the my method \"ComputeAsync\" is not run from UI thread, does the \"ConfigureAwait(false)\" inside the \"ComputeAsync\" has some effect, too? Thanks.","postId":"2013_04_ui-guidelines-for-async-da97433f-1ee2-3524-a949-cd4ed0c18844","replyTo":"","date":"2018-04-26T09:31:10Z","timestamp":1524735070},{"_id":"81b84981-5a73-3105-be02-8e4ed102e915","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"ConfigureAwait(false) means to resume on a thread pool thread. If you're already on a thread pool thread, then ConfigureAwait(false) would have no effect.\r\n\r\nGenerally, ConfigureAwait(false) is used in library code or code that is intended to be reused, where the code doesn't know whether it'll be run on a UI thread or not. If you have some internal method that is always called on a thread pool thread and you know it always will be, then you don't need ConfigureAwait(false). (Though some choose to do it anyway as a matter of coding style).","postId":"2013_04_ui-guidelines-for-async-da97433f-1ee2-3524-a949-cd4ed0c18844","replyTo":"61eee5ea-46b4-36a8-bf8c-bfdb214f5ab7","date":"2018-04-26T14:30:23Z","timestamp":1524753023}]