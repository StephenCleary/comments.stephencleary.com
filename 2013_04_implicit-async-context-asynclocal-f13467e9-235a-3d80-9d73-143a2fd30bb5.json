[{"_id":"09a5e7c7-285a-349f-92c5-c1ab284aa5bd","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"There's no such thing as a 4.0 version because LogicalCallContext doesn't support async methods on that platform.  \r\n\r\nThe compiler will work just fine targeting .NET 4.0, and it will happen to work if you have .NET 4.5 installed, but it will behave differently (incorrectly) on machines with only .NET 4.0 and not .NET 4.5.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2013-06-19T22:54:39Z","timestamp":1371682479},{"_id":"cf1c29e2-e5e6-32ad-a81a-da86a752c985","authorName":"markell","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/00249008025035595944","authorUserId":"","authorFallbackAvatar":"","message":"Could you post a 4.0 version of the code? The reason I am asking is because I am unable to reproduce a problematic behavior in 4.0. I have written a unit test, which creates multiple concurrent execution flows and all of them seem to propagate the call context correctly. My unit test can be found here - [http://pastebin.com/tAgRfjrg](http://pastebin.com/tAgRfjrg)  \r\nI would like to know your opinion.  \r\nThank you.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2013-06-19T22:43:03Z","timestamp":1371681783},{"_id":"00642260-13a7-3328-b63f-08d62806be23","authorName":"Gav","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://twitter.com/gavinosborn","authorUserId":"","authorFallbackAvatar":"","message":"Excellent post Stephen.  \r\nTo clarify your point regarding mutable objects and Fork/Join operations... at this point we are simply talking about standard multi-threading concerns; eg: multiple threads writing to the same location; right?  \r\nOr is there something Task/Context specific that I am missing?","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2013-10-03T04:59:06Z","timestamp":1380776346},{"_id":"76fc4fbc-9698-3d58-acf4-72a9b5ef3baa","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"No; this actually happens even in single-threaded situations. Async allows you to do a fork/join (e.g., Task.WhenAll) on a single thread - what I call \"single-threaded concurrency.\" In this case the mutable objects will not behave properly because they're shared between the logical call stacks of the various concurrent methods.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2013-10-03T07:52:39Z","timestamp":1380786759},{"_id":"aadb083f-11f9-3e12-8412-b0373189b935","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The logical call context will definitely work for any \"tree\" of async method calls.  \r\n\r\nThe blog post you mentioned is specifically about a thread jump between BeginRequest and Page_Load, which I know nothing about. I do know that ASP.NET 4.5 rewrote the part of the runtime (AspNetSynchronizationContext) responsible for scheduling work for a request, so the problem in that blog post should definitely be checked again to see if it still applies.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2013-10-17T08:06:43Z","timestamp":1381997203},{"_id":"f7bbdeb6-a369-369d-a961-aa727afd3436","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hey Stephen, do you know if the copy-on-write behaviour also caters for ASP.NET's thread agility?   \r\n(Discussed here: [http://piers7.blogspot.com.au/2005/11/threadstatic-callcontext-and_02.html](http://piers7.blogspot.com.au/2005/11/threadstatic-callcontext-and_02.html))","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2013-10-17T05:15:42Z","timestamp":1381986942},{"_id":"be352561-e1dd-37b9-a1f5-c28787f033ce","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Paul -  \r\n\r\nYou may be interested in my AsyncDiagnostics library ([https://github.com/StephenCleary/AsyncDiagnostics](https://github.com/StephenCleary/AsyncDiagnostics)), which combines the LogicalCallContext with PostSharp. By default it just attaches the causality stack to the Data property of any exception that is thrown, but it also allows using-style constructs to add your own data to the stack, and a Current property that allows you to read the current stack at any time.  \r\n\r\nNote that you'll need PostSharp 3.1 for OnEntry/OnExit to work correctly with async methods. I can't tell from your output whether it's actually getting mangled (the numbers and letters are the important parts). If you're already using 3.1 and you're sure the output is incorrect, it might be a problem with MethodExecutionTag (in which case you should notify PostSharp support).  \r\n\r\nSteve","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-03-18T17:02:34Z","timestamp":1395162154},{"_id":"e4cdedc9-0f6a-36d4-8365-d8ad4dfb7783","authorName":"Paul Rogero","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/18276298439153144212","authorUserId":"","authorFallbackAvatar":"","message":"Looks like Blogger sanitized the comment code. Should be:  \r\n\r\nMain: <SomeWork>  \r\nMain: <MoreWork>  \r\nMain: <SomeWork>  \r\nMain: <MoreWork>  \r\nMain: </MoreWork>  \r\nMain: <MoreWork>  \r\nMain: </MoreWork>  \r\nMain: </SomeWork>  \r\nMain: </MoreWork>  \r\nMain: <MoreWork>  \r\nMain: </MoreWork>  \r\nMain: </SomeWork>  ","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-03-18T06:30:10Z","timestamp":1395124210},{"_id":"ee7fc027-87a4-30cc-b1f9-41b910a7c72b","authorName":"Paul Rogero","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/18276298439153144212","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen,  \r\n\r\nFirst of all, thanks for your posts on the LogicalCallContext. They were very helpful in explaining the concepts. I had an idea very similar to yours above regarding logging flow throughout a tree of async operations. A key point in my idea was to be able to apply the logging code via PostSharp.   \r\n\r\nI copied your code above and it worked perfectly, just like you described. However, I then attempted to replace your using(){ } blocks with a PostSharp method aspect. It did not work unfortunately. The code for the aspect is below:  \r\n\r\n [Serializable]  \r\n public class ClearyMethodAspectAttribute : OnMethodBoundaryAspect  \r\n {  \r\n public override void OnEntry(MethodExecutionArgs args)  \r\n {  \r\n var disposable = MyStack.Push(args.Method.Name);  \r\n args.MethodExecutionTag = disposable;  \r\n }  \r\n\r\n public override void OnExit(MethodExecutionArgs args)  \r\n {  \r\n var disposable = args.MethodExecutionTag as IDisposable;  \r\n if(disposable != null) disposable.Dispose();  \r\n }  \r\n }  \r\nThis is the output:  \r\n*** ConsoleOutput ***  \r\n\r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\n\r\nIt seems that it would be functionally equivalent to your code but there must be something I am missing since I can't get it to work properly. Do you have any thoughts on what the difference between the using(){} approach and the MethodAspect approach?  \r\n\r\nThanks,  \r\nPaul","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-03-18T06:27:22Z","timestamp":1395124042},{"_id":"9276f8f5-15b7-3043-a877-ded2078c8b06","authorName":"Paul Rogero","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/18276298439153144212","authorUserId":"","authorFallbackAvatar":"","message":"Hi Steve,  \r\n\r\nThanks for the reply!   \r\n\r\nI just checked my PostSharp version and I'm on version 3.1.33.9 which seems to be the latest. The output in my second reply is exactly how it looked on my unit tests. The numbers and letters are literally not there. So the MyStack.Push(string) method doesn't seem to be working in the PostSharp version I created. It worked perfectly in the version that uses using(){ } blocks however.  \r\n\r\nI see you use PostSharp in your AsyncDiagnostics library so I'll have to check it out to see what I'm doing wrong.  \r\n\r\nThanks for the original blog post and the reply!  \r\n\r\nPaul","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-03-19T02:18:10Z","timestamp":1395195490},{"_id":"67391f2d-6d94-3634-a20a-342bbc2f48bf","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I see, thanks. So it's something just specific to ASP.NET or rather at what point the ExectionContext is captured.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-05-03T04:16:40Z","timestamp":1399090600},{"_id":"89ee35a5-b677-38d2-bece-19183f51a99f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"\"Yes\", and \"yes but it doesn't matter\". When you call Task.Run, the context is *copied* to the thread pool thread. When Dispose is called on the original context, it doesn't affect the context that was copied to the thread pool thread.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-05-03T06:21:13Z","timestamp":1399098073},{"_id":"98b4b466-048d-3cd1-a0d5-13852b72d9cf","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Will the Context also flow through to a Task.Run() delegate inside the using(MyStack) block? Is it possible that the Dispose() is invoked before the work item is executed by the thread pool?","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-05-03T05:55:04Z","timestamp":1399096504},{"_id":"b7b399a6-c109-3c77-a66a-6637c1b014d2","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen,  \r\n\r\nWhat about this stackoverflow thread (I see you commented on it): [http://stackoverflow.com/questions/14700777/await-task-run-altering-trace-activityid-on-exit](http://stackoverflow.com/questions/14700777/await-task-run-altering-trace-activityid-on-exit)? The user seems to suggest that the activityid is not restored.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-05-03T03:23:28Z","timestamp":1399087408},{"_id":"f8e1fc03-b24d-331a-8cd1-bbdd81571747","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I believe Jon Wagner's answer has the correct analysis of that situation.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-05-03T04:02:30Z","timestamp":1399089750},{"_id":"3be90f02-a6e0-36f3-baf4-d4a7979b0315","authorName":"Flyer","authorEmailEncrypted":"wW7/1KyTKr0NlJESogWHQMavqAJ6NRnBJA+VLPJx0EMOGGZv/kn2XpEHMGRopmcuFEHTC/K9fOxlocEs6WOsV7eZ6cZpzUDLoM2TgQ6/MaAwoQtxe19pYnSSqJMwzkQidGWe2aJS8tHf6BXip/bTCrhU6rEwUBlwS9QxN6mUcKAeiU1f5fFr923Ku1TGNkF3hgBGjtqrz3zGrw92wn5ekyjgroeVMXSYzajxBMsjS8N3r1jzsZrbjjoNVyHUuZlFQCEYZ0nv7PTCp3Ey48eEkhPqpUvCwoxnxUvGbxg5vbWblGWOf0tygugtzq+0fuLqIm2YHiVD5SF7Yw8uqluahddLOxdgDSRBdXw22AFwv4h+qwRZzv1+8niXEuonYeLvHnaJig0AO5pBebzgKT+tdYLdqqxiH8w+4urhsbODiKgKvBioUyzGJ3nEXObp77J1bYuY8H6KoZRB07ztClhVN0j7kdcec51VW9wJMmIHod+AI2iVYaCYAtcRU8dc0WrxpJzzzyZhfwHrDZgSG/3h5Vb90R6cLH6iMCzXS8E3EEY+x4qmmh5P1N+SMNYE3JkfBRoWoIhtasCp6/H5zRkYmRXFxeEgBAAbYKuctMLIfBHEDbsbZaT1rKv3MmbQHiCEYiKD9qW7iGRWYm3ZV+tp6vODPNnQB/p/bzyO92mJVtM=","authorEmailMD5":"2afa12b80aa5dba93b288a50e6e70737","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thanks for a very informative post. Have you, by chance, tried to make this work with the unit test fx that ships with VS? It seems to dislike the fact that System.Collections.Immutable are non-serializable (which makes sense to me that they are)... Am I missing something very obvious?","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-06-03T09:04:53Z","timestamp":1401786293},{"_id":"e1f08703-e2ec-3e62-a576-84d66e98c82e","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I was able to reproduce this issue. Apparently MSTest now uses cross-appdomain calls, which are not supported by this version of the \"async local\" code. I'll update the code shortly.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"3be90f02-a6e0-36f3-baf4-d4a7979b0315","date":"2014-06-03T14:46:47Z","timestamp":1401806807},{"_id":"3ec3ab65-fc21-30a2-98b3-d55dcde86949","authorName":"bman654","authorEmailEncrypted":"h6RRucalLyPIJxDDAi+uv4sB95gKtK+oGTKbt8SD2lY0zdSQIgcV1wE2o3AujLvK7OVWRNN5ZUCQGgO6YZqeK7uSLVfRC8tTFJIBF5k4O9MMDjNZA0ih4M26sw6IVQaxg/97vV6d8OvckYyjXx3D9wvvD70XhXw6onXUx0Z1eObScF+l15+Q2sHSmdRUPkHk1NC++cqzyZDyKhJpaYDNiiuHvToV/sQcGUklq6WfUc9SeF/4vB7XEwMWvPxbQtKsDkjw5kS3c+f8j5lEKv5IqcO9sqV6LCGhxtRE+F5beVj/rg++SYYPGcwhAHluEIJEFfX1rhYH89ZP2XLvtPEJL8K6cU3jer4u1r7/2lNKKhc7TBajMX6KqHp7CESJgryqBgl0Q99HqaLoGIF6mmzlctT6Oxx91prfKkjUgNUjdE5x3rWy19d95dB8ZTQXlAkfARNpXa5B40QtyjtPXUaujI4iUxPsEIX/+lMKPXJbfKGeHKnuV0T2YhIxksu2/DYCtt+1dKWxCcrvi/W6ppLtsLJYNme643M5JsFNmjW2kfmaSoeKA7vHw9WP5U000YjPXKubXKmZG/j/kLFWeievkL7OEVZAmrsMJkV8l7CI2tgIZXNIC0krXLgs4z6wTEn4N9YnTgwHLdMwLI6oRdfsU/p73e4yjW4sKZSXGTaoOWo=","authorEmailMD5":"bb1ffcb8355a833bc34334d75cefeb3d","authorUri":"http://www.palladiumconsulting.com/","authorUserId":"disqus:bman654","authorFallbackAvatar":"https://disqus.com/api/users/avatars/bman654.jpg","message":"Nice post. This really helped me understand how the context flows with async/await & TPL and was useful in my research on how to get Reactive Extensions IObservable's to properly flow context.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-07-01T21:51:20Z","timestamp":1404251480},{"_id":"36934a44-f3ed-37d7-bc25-fdca37729a67","authorName":"Dirk Boer","authorEmailEncrypted":"pquOjDXiar1cvWuv/eXwLgx0sb1S5U2aYN0nou3gKN6BTsSGR572ZRscFsj7WobAecfAM8YU+qBp63z3MQpEaFNURVbqd12+KFWbVwMrsTn47LkCb/TJl6BhAU2hDuLbdgNAsjyKbuwE1R08NM0oOadnbTC9j8+tr5H/DR3QA+qRR+kkHicKIzSwOHAjj2sv/wBUUQHlSkKn//21aLd0IliQ4d4kGzy0jDD8YXDY86NR3LyXn1XmxlFKrpDYXWAB6AoEo7SKP3uUO8OHCRzcZ+DWqj7o9xBDsFTsuhN2inLjMfNAkMe/SGML0ysTQYltclx5jUZnVh2VpeHLJ5uqBX2GQI4VL2T36t/C88j+UK41BQi0YeoEWgiNQl2wQyk+ONPceQ86R8TP3u4F0U7hOUIrG+WdyRWQvqBSdZdeJpiUG3+rV7vz4q/7nFOEvb3PWD0U6yNiKIZleW85H0ThWKsM1KXGqMNg5+S9jriCAZMauuwbO7mI4kDdVuQI4ymPy0vHJ9peNjrlRPcsSX8teMW8upWvNVcRSe9foZTBI4GsbvmZCNHPwTYoCv6qwt16JQxz5JsmiIvcHai26+ZyCQyh4mYA7Z8VODwkO/X4Ov1zZQhXiZ0nuftMM1MywHMPrnwfaOjz4haXsZgrVjxUCkWuj8KLQWcEYOR6B/2/6kM=","authorEmailMD5":"16524861aa558bbd1b2af0a2269d6595","authorUri":"http://poules.com","authorUserId":"disqus:dirkboer","authorFallbackAvatar":"https://disqus.com/api/users/avatars/dirkboer.jpg","message":"Ok, then I'll just implement it, and hopefully never have to bother with it :) thanks again, great blog!","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"45b0330b-49a9-3a07-ade8-80ad78830d2a","date":"2014-10-05T21:06:57Z","timestamp":1412543217},{"_id":"45b0330b-49a9-3a07-ade8-80ad78830d2a","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"In the original post, I didn't actually have a MarshalByRefObject wrapper. The code works fine without one as long as all your code is in a single AppDomain - so if you Push and then further down your (logical) call stack make a cross-AppDomain call, the call would fail. What the wrapper provides is a proxy for the actual stack value so that the (logical) call stack can be accessed from other AppDomains.\r\n\r\nAt least, that's how I understand it. I do not have much experience with AppDomains at all.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"64341ca5-5b3d-3afb-8806-b880350c3531","date":"2014-10-05T16:59:52Z","timestamp":1412528392},{"_id":"64341ca5-5b3d-3afb-8806-b880350c3531","authorName":"Dirk Boer","authorEmailEncrypted":"FjDXLKYznIElb2ntsCTBuYD6Fukea0MKNLrSd2XmpSOC5kSvL0f8G3gcmERtdQGpOHyrT50z8ou/sdj1QDBNeWizpMYgB8LLWstc38G/EKicCaGVyH41cMD4+Q3UEvmrQ7PmwW60T38Sc91Sj4aRFU5mVRrv98Bqhwg9MqvGmKn0X7V5vza93O4LGAovyKk/1RpetCF/tpXKYh1ASrM+ocXD6Kj2hN19/C+N/D8iemuEhnLgZbGPBoBgNDZe7xKqlF7igZG3meuI8cM5B5eNKbBppmYik7RktNoTGUqi4aHeNEmJdLBI4mJlKfGzbu8aT7ADB3vKq1m4XAq/Iq3jUP4ZJETg0DI+Q94D8dxSkHIRLgiM/DkuAVVHLxAbu8sAo59j3UjE2E1WiaZsHHEYfSMRAfamjpDHzQfAyxbRem5T7EmJnk7tX4jo5nfsvnk3mTDx6E1mXy5N3ebGbI3xzOkMV6X44/sFFjZ0u3Wd0GG0Zr6TwwgOaZv1dj/SDfy7J/309H5HyAKZCHe5lrII7C4SEfAatls7yAMSl6zENd/WUv3ikClAWev2dSsqYW22UHk/psVXv0phT9a3AHkwBkR1INYjS/wswpECXetmZ0S1Gc1cCK1LEL5qrC938ZUD6u6YmSMDMrpgSco/ri2MFRAnE9zxwNJBGMRdyuxqs9A=","authorEmailMD5":"16524861aa558bbd1b2af0a2269d6595","authorUri":"http://poules.com","authorUserId":"disqus:dirkboer","authorFallbackAvatar":"https://disqus.com/api/users/avatars/dirkboer.jpg","message":"Definitely my new favorite nerdblog to follow! Question Stephen: do you have a little bit more background info on the MarshalByRefObject Wrapper?","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-10-05T14:42:50Z","timestamp":1412520170},{"_id":"51403dc2-c17a-3cd6-8d09-40199c253938","authorName":"Daniel Bezerra","authorEmailEncrypted":"h5mpDYZc8WI2xBajeRZm7UTuCDI96pZicTcecJxCKXSJUv+ST4FLEhSr8N5Vjotjf3t+nXn70WXnhkOfsGEi/F10T1szzqBPQ3v5Tz1oK8mPjN5qI+Uc3PdZlAW6mG9fiAWiSUjFaMixeUzH2QBXGNcjZkHH9GdXFIIba5frigLjMmipUjim1g2LWUaXBZTK2TR5BOMebo+ojZ79BylWM7TF/J+i0+4scApbi3y9I5CKhvoCHV9uXBCKsRiMbmF2cqcOxcDXPT9m2eOSGqLQpSESVkXQPC1/wbE8KBa6/hhizHgM1CM2YHZNTzVo7cG6VtQWxjPQXDnMovaa0oF8v4QyuLNOTm8ea80FyvX8pN1s5TYrY93EFcjyaf7BSApyjXw+9M1A50EmNOte5J1DvA83dWyngmu7OgtV0ZZAAxOldSCtK/GX8AVAqpOhi1QWT0Z/oIM9bc2K/4WnpVNL9NVFrVHK5ryUUm4phk5+pscNFuCZvKKPj3KnLCH6P6a30UZz1d4KdFXs1ztyCBsm04CzvUFzfJicY1MdkthPJ5mRUq626RpTmnu3/gcQkws5vgHAsjVIKvFwKbBCfrPsysiq6yCJpQ2IRKUohgMZHBTLMQZtkcu3rbBfqarbn7Xvm9wb+CBc8qgJfGsdt9aBPxq9J6BbHkVXv8siKJh1X8k=","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Stephen, could you explain why we cannot use 'LogicalOperationStack' with async in .NET 4.5? I'm assuming we can't use it, because you wouldn't loose your time recreating it in this post, otherwise.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2015-02-16T20:02:34Z","timestamp":1424116954},{"_id":"96f0b64e-c3a7-36b9-a314-6d4ad627e652","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Well, for one thing, this post is a more general approach for \"async-local\" data. It *can* be used as a diagnostic causation-stack, but it can just as easily be used to store other contextual data (i.e., a kind of application-specific HttpContext).\r\n\r\nHowever, I did look into LogicalOperationStack when you commented, and it turns out that it does (correctly) use the logical call context, but it (incorrectly) uses a mutable stack. So it will not operate correctly when your code uses asynchronous concurrency (i.e., Task.WhenAll).","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"51403dc2-c17a-3cd6-8d09-40199c253938","date":"2015-02-17T02:05:27Z","timestamp":1424138727},{"_id":"00997df1-3ab5-3354-b786-a30fcf15c157","authorName":"i3arnon","authorEmailEncrypted":"kjXE/NdVKwRxA5XshaT5rDUyxOK9J/cJujtATosXbdhtMQIUhrHxI3xnk1i4H5sSQRWoeluv0S6PakBTauP/3R/ExMled9DBSyQ55ubzIrL/uq4FDNRr7uv33XaV/m3k3UzDROpg51iMTl2lwuo6mTMGsOn5gCo05TqdDskC5XEaNKlu49yeM1lHIVxjNESAtl8a18DegevnN7fbrU/tYXn/EN/TOuzx8Uims/y2mO9p910IB4RM+nq6NF9O3d+GaZR7RB2C+ttVndarpND7XtQdrE40JGLB/M5Bvm6SS7zxEZs9ZLMgf8XjgXwI5/chFHlCWvwWKVnGcMtbfoimVVHTE+nxspsyLiiKujwJUDrAbdCCGMHGOLXhRFkSR+3IGqT0GLiW4s6jq0VaGRdZQG6LleypKuC7DgSGukIL33YUM+xrC7DCI9D3Ng1SJyVhG3f/2SW+3sI/C5uy7alCqdWpVX2d+CU+goL1gQTRElMwtbQBpQoPZTWCX1eQbfTaVoVbgdkMz+2i2VIndTOgJbrMt2/nRyAB4dLjuC84ROHTgSgAj07YIo3nrhvY4sV5TQEPabe+gPkPgA0o9SFzHzyr85H62rxIkKPVz68rLjQQWH5pb/hgZmTN4NaZ47KNf1/cNqQl/Rg+xxXHD5gNYYefyFrhtTx71H82jLNXC0g=","authorEmailMD5":"0caa455bd74c1d9d10d2af49afa18228","authorUri":"http://www.i3arnon.com","authorUserId":"disqus:i3arnon","authorFallbackAvatar":"https://disqus.com/api/users/avatars/i3arnon.jpg","message":"Here's my explanation on why you cannot use LogicalOperationStack with async-await.  \r\nNot only in a concurrent environment.\r\n\r\n[http://stackoverflow.com/q/28769483/885318](http://stackoverflow.com/q/28769483/885318)","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"51403dc2-c17a-3cd6-8d09-40199c253938","date":"2015-05-08T18:47:56Z","timestamp":1431110876},{"_id":"a9df043f-f5e2-35df-bc30-5dc7cdf2c8b5","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I believe the new AsyncLocal<t> type does use LogicalSetData. The most performant alternative is always to pass the data explicitly - either in a member variable or as a method parameter. ASP.NET vNext always takes that approach; they are getting rid of their SynchronizationContext and avoiding implicit context completely.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"b54def21-e983-325a-b4a4-94d8683f29a2","date":"2015-06-04T12:12:09Z","timestamp":1433419929},{"_id":"b54def21-e983-325a-b4a4-94d8683f29a2","authorName":"katoa","authorEmailEncrypted":"lHA6Y4aoebHDPbKNKU/aPtwSD2YsR0/xgbN/DE3jPO+CtcxEa5MYVil09wqSyTJtWVxej3BK+uPfTOo1wW4pspk+O9M1eRaQP3fIn/ObpykaLNtrjOAtOzOwwvy0Gq2vo7QYfLlDdc75fio2Vn+WsfSuliWx4E1gdoQhbRgc79mBaHvJXTCEtrSrPNHmM13aRgMluJDplrB+KO8mTpHHyMZcikk4VPGAFiuAWRD6wfMFQnm+V4nOdSKbuzB6ynnFHB7A1HnPiCBMywHfw2jasGWZ6y1vRZo9uXXiOmhDhcqE7cF0oy6oTyfrvW5N3XTOXTfg8rxuSfy6m3PoZDKSH63yOMbwCVJCsdscyXtHohNkye7TYBkh7Ub8wJB+49/hMCeGtPYZvG/lixrk38BNa5V9dIm6lIML7lg4JwkEbryn3Zn9xKVDBZ1qfX/OcpNW3aa8g+boC7rc8SyBKAZmaAgo4SHplbIsiFSMD8h7sz92j9xu3BBmeqND3jVSh8SLsRT0pS+Tzz56qR8P3SJXibbfWll67iVPIuTECZ3VtiVyE7kJ5zXrgXYfF9aTogKfLRWS+VDuZNon31hhY59xlnjhF6JIo04MCNh3h0jQhLjbgO4PfXlAUsv9xEpo+fDZE8XMAzfwsTLP1u9kNyOWRitjOcjbpgjc5JBS8WmIHtQ=","authorEmailMD5":"9f514733cf89f11f8504fab9e4e17c2a","authorUri":"","authorUserId":"disqus:disqus_CbudhwIpVN","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_CbudhwIpVN.jpg","message":"How does the .NET 4.6 System.Threading.AsyncLocal<t> compare? Does it also use the slow CallContext.LogicalSetData? In an ASP.NET context, is the most performant alternative to store data across a logical async call stack still using HttpContext?","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2015-06-04T07:41:43Z","timestamp":1433403703},{"_id":"a3cdcf12-a70e-39c2-9b4f-eb274a41add9","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Only one name is needed. The name represents the conceptual \"slot\" for the asynchronous stack.\r\n\r\nIt's an autogenerated GUID to prevent collisions with any other use of the logical call context.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"fac51a1f-7b47-3227-bdcd-1aa07d75b1a0","date":"2015-08-06T14:34:36Z","timestamp":1438871676},{"_id":"fac51a1f-7b47-3227-bdcd-1aa07d75b1a0","authorName":"senj","authorEmailEncrypted":"unjh2jtD9gEKBsA1Vm7R1ifVEF2cs6jJoKPZx76a79+iEUY4/9eJwiAGpxWGtLZzERn3esgKebIsCad9/8NDyLa0O70to1T1ZpJTPQVbbSFpRC/R4wwaK9yiNoW93GpXnTsFQiRSK3NSN4O4hvaOHUog27SLa/yrHIyMIQfseqoUcSU++om5yy0SRDp53jE5DH9fhbFh+71zCChC2LlYuCPXqsIZB5/YcgZA8m/SMMrvcr1Xwe4w7ilJX7wuwCUO/ppEArZR41gteY3o2Q9VTRPLY7FvLwnQq/ueOWaEEbDzjDF8ph1a8Lt2XZRnnLLz7JAX0Ih1/mIuW+ZmIhzJ0DaouWcsDpqmqYcLfDC/J0oSyImFW4kmePGb8tLX+EGTlS1QKFllaIb3IJBdmYL6Qz9RUuOh5syOFKYwLW7ehpUObaJruf23v7pEy9WCiB3msRPDQXE2u2iTl1ZfnTYIp9yFQfcwfNHMictrpvKqB6Us8IBEW0lGGMmxhJmHoLTUew7HfEetlRRxfk+VfJU8GBF3pXL+nQxyiz48qrnaj3drwVijgPRxqiH+DfzDMBARXhadrL2t6XwK8NYvdNpggTIx7zCIOktCznAzHxAIR3bHznd+rMY4YrnPzUrhi0NDmnVf7cF1eYc4mrXL7Wsh62f1S/CA9FKfwH2tB/WcTzE=","authorEmailMD5":"7260d095ae3a0869f217e689864f94e7","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Why it is save to always use the same name for every concurrent request? ([asp.net](http://asp.net))\r\n\r\nprivate static readonly string name = Guid.NewGuid().ToString(\"N\");","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2015-08-06T08:09:26Z","timestamp":1438848566},{"_id":"1e6ec1e7-bf06-3e7f-a405-a6c6878d10e8","authorName":"Brent Arias","authorEmailEncrypted":"sF17uYMvdeXLavlXhBffJYiz8YfuL/wfYnqiLhHtAhSzW3KvVHWiPV6M5bpv3x6L8lANg9yxoF2gqq6M15ufwMABR9G7Koyadny1FtmkJlyc7/CQz1oGLPiLS5/7lZE1UJdldzWd7F8/70FsfOCZHGwCwokn84bgSvCVKl5GIIyVpICcQrM2U7OllHiUziiPkTiqKS5GvTnKHVjOiCXCzzReNPYUE+H7kwjC/3fFatMdZyLS2YMeHlRCjKKcFgThFwJ6ylPBA+VAojewesEWCFbLIJq5ZGaZM3hTMuo5J8LLH+hSXb4BdBTxo3HWufHGrcF0vVCfQqg2gQNi/Ep8QSepX5c+expYcjcwwsemH7Ig0ZdRhSPXkGp1HPdCZj1Cz9bHmINoI+PKpwec5v8YX1C1DgRsIF9gm52MESiEhbUy7ku+hqWvBKbvId7jm8WbW3ZgmD1BysjyFb4D5BNvv7kjTLZQZ37NIw4k4PiEuX3ttIsGfgNyTtg2OWJZMYMlrKM6SxaDnY2CfNCmBV/HXIW8F3wIDKGo41XrNkl9fXc2I6fmtf6XbDGLKnpviQgs91CwmsR3Z5Pfy9yA5+ULgnC2a4ZBi2Whm73qHcRVpCPcCR5YyGKrRsrKlKhEYhlwq451WTNs880Sga4lCxvkp2bM+UEvYN4g42xKLS2V25A=","authorEmailMD5":"0c0a1f54ab0a0911fd931ae5e19a5903","authorUri":"http://www.ariasamp.net/","authorUserId":"disqus:Mystagogue","authorFallbackAvatar":"","message":"Three problems. First you said \"you can end up sharing data two different ways: .NET before 4.5 did not have the copy-on-write behavior, and the copies are shallow.\" There is something missing or contradictory in that sentence. I think what you meant to say was \"you can end up sharing data two different ways: without copy-on-write before .NET 4.5 and with a shallow copy-on-write after .NET 4.0.\" Am I correct?  \r\nAnother problem is that your article seems to insist that .NET 4.5 copy-on-write is only active when using async/await keywords. In fact it appears to work with any form of multi-threading. For example, I built a .NET 4.0 test app (run on .NET 4.5) that merely uses Thread.QueueUserWorkItem in combination with CallContext and it achieves the same copy-on-write behavior.  \r\nA final problem is that your sample code makes no attempt to call CallContext.FreeNamedDataSlot(). As a consequence you obviously ran into the \"...not marked serializeable...\" exception when a thread was returned to the thread pool - which is presumably why you created the MarshalByRefObject \"Wrapper\". Unfortunately this means there are threads subsequently being dispatched from the ThreadPool with a dirty CallContext. I suspect it would be better to revise the design of the sample code so that (1) explicitly freeing the CallContext is an option and (2) the final Pop() which produces an empty stack will in fact free the CallContext slot entirely.  \r\nI'm interested in your feedback on all three of these suggestions.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2015-08-24T20:56:15Z","timestamp":1440449775},{"_id":"744fad73-022f-3c0f-849d-b8319b25a376","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"1) Yes, your interpretation is correct. The two ways are A) If you try this pre-.NET45, then you won't get copy-on-write, and B) If you mutate the data rather than overwrite it in .NET45 and newer.  \r\n2) I've never tried QUWI with regards to CallContext. The scope of this article is specifically around an async-local context.  \r\n3) No, I never saw that exception. The MBRO wrapper was added about a year after I wrote the original code, and was only added so that cross-domain access could work.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"1e6ec1e7-bf06-3e7f-a405-a6c6878d10e8","date":"2015-08-25T11:23:31Z","timestamp":1440501811},{"_id":"f8c8da03-f469-3dbf-9765-a9c5c1942c4a","authorName":"Funbit","authorEmailEncrypted":"P5eBq1hpeJ8AkZxnkm0qyqOt0acCQhV3Jx5IbpsWU/4hZOdk3+vmgLtjR/XZeqc710z4+UWeMnHzHKHYTbKC9vk2KWorK/ZzTPLVHwroGzhswbiejMCN1VWRyj2rw1vf+fb+gp3HtGm7lcpVzmSBFGZkGK6CWWokfoahUh3F54O18PeDo2yLjvw5YBm5Hf06YcScC9kj1mFPZdzAf9NPTVfSWq47jmoKVS6mB5Zd/k9V2InEB6F2q9f4JVnP8O6QBc+O4mN0Kn9hOvSJI82vWNTK7/SvDyqISrdcGU+UGZe/kAZ17dslfvkzfRmb3utPumYFPI3w73flSdLK/iuxyOcWfR1r/5BoXN3I+0pBqXFnLtHGT4rI6xIR9K+Ie1wcuyPi1CrZQ33A8SEDH3xGi+H+9/d4wnGCiVC5/XefT52aflLeG2cyEHGvEQ5oKP8v0dpFmh0eDBFc++YjhgoNHR9fMNhjBOrgXkimNpD7aOU2zYZwCDdEa7Ob6hBN3IARv+FiYG7bP3oF23UrGC0osGcfIVvC9BQV7FdUL1XYwN0hEg+gpgLgd6O5X2X1rAUfrxTu74BoIMMPSynw1YqxXZjP7x/Me9PAxx3ms5FfeIi1jAVfAgzlUURKFgLmJop7iQ70HbJ6tZt+kk7URBeUEx4rEkXuWYjuQjghB+PhQzU=","authorEmailMD5":"1b66f6609067719d158ee9e7187b1f3b","authorUri":"","authorUserId":"disqus:Funbit","authorFallbackAvatar":"","message":"I think Brent Arias was right. On my side that \"...not marked serializeable...\" exception throws when I try to call my managed C++ library from C# code with something left in the logical CallContext. I had to clear CallContext before the call and restore it back when I get result... Haven't found any other solution.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"744fad73-022f-3c0f-849d-b8319b25a376","date":"2015-10-01T05:28:14Z","timestamp":1443677294},{"_id":"445aefca-1ea4-374d-a00c-626bf0a05655","authorName":"Vitaly German","authorEmailEncrypted":"nPQxw2WCt6f8+uORkPC2D49V2153P100rMsWRQljSJw+OIlU3IikNTCO1YSs6f/MWMBoVLQmmcxUa3d4hLx59iywPS6684xvKa2CP1bSTOgl4gESBTFxfHDA7Fnu6CIN/yIpRiKfKfyv5AJN1OzMtVG9uco96hbYp6DsZZ/p4DbceLEx3J8mv38EKabz6IC9U9h+zKu5EKKEfJA5O1PxYuWsZe0gzo2+nlWEGtvuPMqS1fYiszYwl32x4ocMyaQtAxU01RqmETgtbLKNK8TTw7LVHG1Q2MLSphzs+MsbpOSNjteho5N5Pv+hLrgjk2OWlsUYyuPMyqymCrCRRH8oeAIbf+F3P8mglOEHPI3oSsXMlQ+e9RY0dTe0NJnLsewHCPmGwh6Vm+Fw9vya9ecPM+YXVgqrNelNGBfRLJJdbYzG/LTEoPt7Irr7fePwL+jtvHIY6yPquUjOODfLSINCFEJY8KiRP94ITM0F2hcN2dz7GaU8oMpqPZDjgkt1HIe8ViOwemZoDN3yOJFFNZ/RE7QRuSzZw+9d726y+mr/UJd4e7evDHt2EsTnDmx6W3tvg4rTrw3/1g9CPDeyV4zK1r1TMdH0qipcuUuDWOtVbX1A3DiBS9VE3fgRTd19lb+jc9I7UOdJdZ0z98sBDenPmNS03hCafAOGkDdbr4v6eQU=","authorEmailMD5":"90fe6ddcf6ea152316d4e236146a1cc4","authorUri":"","authorUserId":"disqus:vitalygerman","authorFallbackAvatar":"https://disqus.com/api/users/avatars/vitalygerman.jpg","message":"The real cause: CurrentContext.Pop() throws if empty. The was race condition on Dispose() and the exception was not expected.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"c9006c67-bb29-37ea-8ead-e1000085e44a","date":"2015-11-03T18:22:49Z","timestamp":1446574969},{"_id":"85cf54bc-ed72-3df2-8e64-187b258d2c29","authorName":"Jiho Han","authorEmailEncrypted":"f3DBoyriBD4imiHi47kR7rqHA8yjT0QWvMBcbFDAcgmuZlpAv5j/Jpw0no2z5AdqLIwd3qDQfwq6JB/2S3Pp+rF268Dqci6FNXWfy5fRA4LcczNJmGFBkaoQ1oTI6seQXShcxERdDhu6wPo+5qUbIDK9u2igOatOqV9cikSOBKZtv03ziyEFudvQ4PHCfzz+eMmIE2qyeicbEHcHBkdbbfGu9tMnuTCgfLzltTkVcNArwbVejB9bAZdNKs9fh6Pejca3HzPGURmmfFqzobYrTaszYbEQ9gROe/CJfqyfXy9b26s7br1612GefYpIYhdhv5bvtktG0mWq7Mj8D6OkGpeLM0BEiLUBXvTp/SSB8dZ2ikaIG0ZuKqwV8niveJ2XR7kBNsYIQqX51/eVBw8831x+irS6pZpg85E7LEv1EVvVMHQDoV/c0/4tFHlz6/iOJvV+VEe1pQEMSmeTbA/0bi8+mTHaTEaTwF1SmgoMIIvlUcElF86NcWotoDPJwLnrEuGidUFcGe6rN9HntJdXdgZmggEQLHKA9MUzIoDog/D87qzaCKuXOUPW8CaHF0zItNhzBlqvjWUiS6LEuVenoKLIRzoDVnZuF6xxIvty3kniDnzhZqHB0ZM2r6bGGR9u5Cfu9L++DIZbbAD5s76IWA9NFEzV2WnoTLx4KAoA0X0=","authorEmailMD5":"a54c971c6f96a72032c4d8ae77bd6619","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I've used LogicalCallContext for passing down context variables such as correlation ID (a guid) via ThreadPool.QueueUserWorkItem without issues on v2.  \r\nWhen you say that this copy-on-write behavior is new for v4.5 in the context of async/await only? Because I could have sworn this was already there for v2.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2015-11-03T16:13:00Z","timestamp":1446567180},{"_id":"c31dc117-0d09-3c0a-b946-238a937f7ae1","authorName":"Vitaly German","authorEmailEncrypted":"OAR/rk5hrfCVVBF6VmYDooUjqrRpudaWdlKOE7MAG0ohAQWV1IN31s8/S5BJukb3GmCohDaoyygEWvSJR7Qff6wO7jVHsz5lKe0eRKBE7RgK9sebPTxXgJ6jKF2Zp0v1QpeXmgW+V1JNxiWmKQhfDTtWK9bzY1t6AohfpWzOWbLK8/CzawX75YiigePeF6ughCFHrU+3ioaCpAHcUq7fF96nojnUeqAk47gnURWXHA33BajKRfCJont3AEc1rY2y5zEUi2Pz+8p76cGCgGmvBJw+8Ynf65x0TRdLspYJMGgKm7rma/snksGiIrlHUR0sPrXdx4LSqG18O/7ZDRf1TNH3laCZOrSdzrsUTr09Xe04pL2IGOH22K5EyskfN8y8shS2midJusWZ0TFi/bQddXpR8W+tKhPSy3QNaerCB2LSZnz773zZOougS9WGtx9Rn25y6wv7xh+YwPyCLL0+4GtFEvbyuInbByymFs25mirZmcCMGQBMg7sBa4PLWzfrENxN0pr2DjKLzzg4fAqC04Qut5MFrTl/M7TWQbvPLY6+v0OJpz4PQsdZX3RYzW/DLT0xRck3vg6t1NSfgpVyA4VQt9X0PATgs48Z+LslNzicUxqQkkGj7cORuH0gYJCOGTJjLzB78X5ecWMXGnuOQtnUjBGBO0Aw1nn5ybTFCrY=","authorEmailMD5":"90fe6ddcf6ea152316d4e236146a1cc4","authorUri":"","authorUserId":"disqus:vitalygerman","authorFallbackAvatar":"https://disqus.com/api/users/avatars/vitalygerman.jpg","message":"Thanks for the great post. This approach was used to create some equivalent of Nlog  \r\n${mdlc} and ${mdc} mixture.   \r\nThe first thing which disturbed me that LogicalContext is never freed in the given code. This code functions correctly on my Test environment but hangs forever on the Pop() when embedded into the production code.\r\n\r\nHere are the changes which resolve the issue:\r\n\r\n``  ","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2015-11-03T13:13:29Z","timestamp":1446556409},{"_id":"c9006c67-bb29-37ea-8ead-e1000085e44a","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I've never seen a *hang* with this code. That would indeed be very odd, and freeing the slot shouldn't resolve the hang. I suspect you're seeing some other issue.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"c31dc117-0d09-3c0a-b946-238a937f7ae1","date":"2015-11-03T13:23:44Z","timestamp":1446557024},{"_id":"ce93ce2d-aca0-360c-9639-94e89c430408","authorName":"Vitaly German","authorEmailEncrypted":"owjuf270mk52J1QUar9TWNEunSrpIHoLsnm9MWy+F/5hYudsGkly47/dEGtl2rrYzlliOO051evUTrgb/zhGrYqk/oBfV8vuDICOb9bm0teVM1lKEco62KUr2Wignl8ysivRIBXiFJ2kREYNmsPMdgdmLG/hpX9ZNkavkp/zU6KF6TH4JDQLf1hbzVItFwbatwJHn91dyjszK7LedyN1SrmlCwAcx4lckF+7euVkQJvd7D05XsW869j5S4j0DUxm4VTZOBnvvRqPDCLgR5RrhXCVnyCZxsLgQaJ2Tlc3BDR8wIOxirBYn6YdSoUPshv4Nm0S6YdPvCo4JvvaMKQsHOHtg5j910IoL0i+WyniBFmmNDdzJAb30aungB+EQ7SBtE8YGRgwgUn6CMXcL4MCFGf923in9ezU+QQTyuIw/CfXm590N5SmeYp92Jy1YCE/5IlLyAcnIf27uj01fzWjuy9+2OYWCTEZCHHEK6cl3aEu/nKCJOzVwAZ8Vhn6wnPo4HZXGD5Hp6s6W/jJY+g9qmebF3unu2kp3DE/r4qciL9UZQNPnl1sFswX9nO0/a9u7GA64lVUdx5GYkS2fsaCddzuwokdl2fqm4IX27Cwnv+EWeo5ljGtE+62f2XSITfCdDjUiIJ3NAM/1BxOA3KJ2lfsYxQgq31KRCfY4k9LhyU=","authorEmailMD5":"90fe6ddcf6ea152316d4e236146a1cc4","authorUri":"","authorUserId":"disqus:vitalygerman","authorFallbackAvatar":"https://disqus.com/api/users/avatars/vitalygerman.jpg","message":"Yes you're right. This changes were accidentally helpful until debug print code was not removed. So debugging further.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"c9006c67-bb29-37ea-8ead-e1000085e44a","date":"2015-11-03T14:48:27Z","timestamp":1446562107},{"_id":"fc18e7df-8fca-3e6f-8231-21357ac66ca5","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes. There's a difference between inheritance and copy-on-write.\r\n\r\nThe logical call context is always inherited across threads (this is what makes it the *logical* call context; the regular \"illogical\" call context does not cross threads). Technically, the data is shallow-copied. This happens every time the flow crosses threads.\r\n\r\nThis is different than copy-on-write behavior. With copy-on-write, every time the thread enters a method that cares about the call context (right now, this is just async methods), the copy-on-write flag is set. Then, *if* the call context is written to, then the data is shallow-copied. This is important for asynchronous fork/join scenarios, where it's quite possible that a single thread will handle every step of the process, but there are multiple asynchronous operations making progress concurrently.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"85cf54bc-ed72-3df2-8e64-187b258d2c29","date":"2015-11-03T18:00:55Z","timestamp":1446573655},{"_id":"2a3f60fe-02c7-3fd0-9628-826b1bdf89be","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I'm having a hard time visualizing what that code would look like. Could you post the smallest example showing the problem?","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"445aefca-1ea4-374d-a00c-626bf0a05655","date":"2015-11-04T13:39:33Z","timestamp":1446644373},{"_id":"cf5cceb1-faa5-3765-8822-e4538ce3cd29","authorName":"Jiho Han","authorEmailEncrypted":"BGkKI36Mgif1WpfPRx89ntJ1s4/tSyxXf7UBTjdFR6csXh7kLNw2H4k4f9AozySKj1s46CarH1FzAaHWL51Hs2/L8/Ew1uAiNOC7poWTjF+FwQGk7arr7TerXcpxGyNXG4yxGef2wa8OglsmGXDoppHEA+JkzjRbTQ4mUCkP1cOBzoFqM8XYmFlqzJWNmXdDgjq5m8IP8I08FBdEhVwncK+wuskhlPAai++rjnQm2Qvnof9Ykn2Y0C5SRX0rjNOwgBS7T2uuUDAiBFEj8k15uvEfUOLVjFRXKh1XuKC8zCvU9V9N0URgSUwS36yL9K6+1x6SVOku8i8nv8g8EL8OSbAfWTiwoI1gaZFa6ZiVvCLs9Hla6BJSeYRr1bwSR/0HQB4inhvx9Veh/szXWOrTV9sDsutB8sOuEzkBW1wBHqTIy9W9TdvON912i/BKFhZL8EgIawOgej5Ed60e4inVLwKwgV0tgGkxzMtUIB8wmofYxV0sxFLIRcIElrDwqiHQeWpBarshhkwZWdXJcWbZbfGC2+Ce+jHnruDy8yR9rGtRP/Fk6SvnAXo/mn+iNtJ8y3RFXr3E+rxGOLv0XcRTx1WJut6NrKOaa3YRfqdo2GZcA8XM5l8wEmtuFeu37ZFh5B3I+FP6WrwUqyXsg8UozD0ke4y1Vij0iuM4oVbxzg0=","authorEmailMD5":"a54c971c6f96a72032c4d8ae77bd6619","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Great, thanks for your clarification!","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"fc18e7df-8fca-3e6f-8231-21357ac66ca5","date":"2015-11-04T18:49:45Z","timestamp":1446662985},{"_id":"6880bde3-dedd-3380-9008-ccf286152920","authorName":"Mike-EEE","authorEmailEncrypted":"K+eJUJjRkYs3IkseQatUNPFUmJorDGdnJfiHS/r9SW5WF8Yw7VxZ8Ifo4nQiJHJKApGtZM27I3YQKIR1HkhqI2+/YswhFJ4uBhu8/5OkeUBxrX+ylgmj5G8yKgFVMouqHmkCaCT3oL4xtcT3nr2xxVe/hxw0ENGFsQazc96ZfTVjMIn2mBo/TPf5Bg0U0vrsFEDteqC/x+zh/TkmuMlhXjCcTbQ+VM/HqGFbcozt9Cbqq22fyXtuQrCyjaXbA4zoOoJx0ITkA31RMLC0do+370NlkWM6DnCGi41oDYA/6l1zDXGGV2aLBmS9T9Kaij/36CiqtPCK5chsuXkFxEAX+DHr5FnUihouO2cIfuXmRfiXEiVzxfNFV/x9Sphcjbunh3JLJHqXVWn12Gz938NRjBmpiVxoIxN3cjehMZD1LDpPNtlbPUV7lstTwj++VenTszcB66fQpy2q0gxXIzqdI6cJZNQZ/+C9RRrC20tzzx9tJJz2VqL8wO528fs9vuzdjcUi8EOkz6br8Nql9cBnWRVohhNo2SGuqvucI1eg7qds3FbZNuGKI71OOfvpJAudjIlsAbgh7CNAGiwWYIc9Sm7w1hLCffTS9erD5P1Yw2NQ4jB2LT+G45UcOYBa1iIkpeX6F4N2EJPA4DLdyPKQ3seZii7HKAlg7h/BnanJhe4=","authorEmailMD5":"c7ce3b7185ea065d529fa4447263ac60","authorUri":"http://blog.developers.win","authorUserId":"disqus:Mike_EEE","authorFallbackAvatar":"https://disqus.com/api/users/avatars/Mike_EEE.jpg","message":"I am learning TPL, perpetually, it seems. I have done some testing with your code (excellent article, Stephen, as always!) and it seems that the LogicalSet/GetData flows down to child tasks and not up or between sibling tasks. That is, if I comment out the line \"using (MyStack.Push(\"Main\"))\" the data works within each SomeWork task (\"1\" and \"2\") and their child tasks but not between them.\r\n\r\nIs there a way to pass data between sibling tasks and/or their parent tasks?","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2015-12-24T22:53:41Z","timestamp":1450997621},{"_id":"4cb22e67-ba28-3443-b83b-ad481fb0ef44","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"By \"explicit\", I mean you have to manage it yourself. Like pass an actual object instance around.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"617f966d-e383-3387-bc7e-3e2243efc33a","date":"2015-12-25T21:33:30Z","timestamp":1451079210},{"_id":"617f966d-e383-3387-bc7e-3e2243efc33a","authorName":"Mike-EEE","authorEmailEncrypted":"M1LbSaHf/dGp7xGhs4EnVuJ3CnLc3I20dkHF+L58/c8ukuSNuOB0yd12NTJel4ddfV+pIHaV1I3379pIPonAN4iQa4Ohb+yMXIvZY8T28nPErXQ+rQIMdQbl/6mKSaG3aGdG6Y/r7fxkJ2Dmczad9udcIz3LIaRWYqZxKxUKoFwfRou6ZwbqBtYOtF3+f1sOYGiqtKMyAZrcQo1gQnqv8TQEiilOkybtXzZ7+qhaYu54ZKk08E8DrL4AYShunS0mPUIS0L3dlkpztEuFsuRYmAN/1P/Z6pMN5yZPX4ytjlgsPUy0IXM/xcBU3B6ewL5TieyKr94+JA101tZY2LQ6LObv4ld1b/B+mq/1jbGI2jMDCut0szjY5cYzd4gNnQ+VcdN5eLMfrm9+qnnRaCqsIaMTzT//o5KbTMzx2LDe5rWvXa046gwQCvqSDPn2U3VUEkEkH8xwkee8djAoquQhb8aqSv3Ad2SHtdkCjbwcmW20mx0SZ0Y5kwf+uORQmTHRsO7nKxNbZQV5PF5XjhHypo5SlzN4qaxKBDvdaRMK2MdXC5fDnn8wsUiPTzqN5c9MDIktLC5qXXYbTL0eh87NIr+WGGAWSs1kmfeJRCXrjBROEk0mu/TVtjGnN2VLS/21SoGHMFvFGQsk6+WPcZxhbOUfcFlRG/nUMBWYhciS96k=","authorEmailMD5":"c7ce3b7185ea065d529fa4447263ac60","authorUri":"http://blog.developers.win","authorUserId":"disqus:Mike_EEE","authorFallbackAvatar":"https://disqus.com/api/users/avatars/Mike_EEE.jpg","message":"Awesome. Glad to see that I am not too crazy in my understanding then. When you say \"explicit\" can you give me some more details? Again TPL is a rough area for me and I have encountered more friction here in than any other .NET area since, well, SQL really. :P Is there a way to say \"store this data in the my parent's context\" from the child task? Happy Holidays, btw. B)","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"faadcb96-78ab-36d5-91e5-2f5b0730110f","date":"2015-12-25T10:03:23Z","timestamp":1451037803},{"_id":"7538685e-7435-34cf-8862-60033a1cefd4","authorName":"Mike-EEE","authorEmailEncrypted":"VGB76O92sq2O5D9EUBcFMIuJFm0U9bx/oTXP07JLcOY6vcowQbDCbOsjKKnbNPPhdXbmvj5aYbQ+j94vz0nEGNYB8gRd6e1snXkqZniXFM1Ky504AScefzdpDDUTwdM+qD179fo5vKzc+alJd3kzlJ7zT1XaE7YvKJ1wH7DgqbCYqauvw79OVktT5W+Rlqk68lI44mN9shIqTm8/G+zyV8P0WTKge/AIRb+U56eW2Oflca0hcRt0xYYwtgC+3ZMsSulydSl5e76ZM9uQ+Vevbp1M4lZk8i1hcLoFh9HjKNOsjHnIkOcsnwpB1eN68/H0Qou3XNX+FGDK8dm8A6EHy9lWPVc0v+r+E3+rj+wK2T13vtFf8LXmlnO8xB6wb3lUbYPmiIhbl2BvMO83bSyB7d7ewtYn20ZXjT4FU/LSAEy1URP5K97Ton/h6cMbzNaGtvQWzKCm7grf7NQgS/7vkMpWqkkW98MZ15VU7vX/bXtTY9ev6ykmlaPJxiIlg9vYMzN0gOGGer5lCrx9p3ca6bOx4QZjFwSA4ah/CMZk/m1PFy/96LjqH0oHIFjip3jZ+kfYOKxuNTZHiNZXpeZMAqtLHl0ergTFDxqaXz79Z8TAy/bdiLA7vg+82O78O216JRq5VCCZQgzSKeJ9PD9SM2R/xmUr2Zk7n94Cu+amHn4=","authorEmailMD5":"c7ce3b7185ea065d529fa4447263ac60","authorUri":"http://blog.developers.win","authorUserId":"disqus:Mike_EEE","authorFallbackAvatar":"https://disqus.com/api/users/avatars/Mike_EEE.jpg","message":"Bummer, that's what I ended up doing. It is obviously a hassle and not as elegant as storing values in an implicit/ambient way. Thank you for taking the time to answer questions on your blog, on Christmas, no less!","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"4cb22e67-ba28-3443-b83b-ad481fb0ef44","date":"2015-12-25T21:36:28Z","timestamp":1451079388},{"_id":"faadcb96-78ab-36d5-91e5-2f5b0730110f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, the data flow is one-way (parent to child). Any other data sharing has to be explicit.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"6880bde3-dedd-3380-9008-ccf286152920","date":"2015-12-25T02:19:36Z","timestamp":1451009976},{"_id":"520e98ef-c089-3430-b83e-42a3accd03d5","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"It's up to Microsoft to decide whether the LogicalCallContext flows to timer callbacks. I don't control this.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"72e33be5-bfb2-3e07-ad2f-f94706f544a0","date":"2016-01-14T19:07:46Z","timestamp":1452798466},{"_id":"72e33be5-bfb2-3e07-ad2f-f94706f544a0","authorName":"Andrey Tomilin","authorEmailEncrypted":"TP7HKw9Owwel5cKiEUGDVqFocYmLZ3DmkJnxjDqd6zxhh5nylWsw3cl4hSdYaFoKPIXTuBi30l67QaZr8ZWlQR1D+FnEOXMLw5+Z0u/hhtxesnGQ7eYnl1C/1p9ckCpT1JlZGDv+ptSd0o0iPbl5QBmtaPlgd31+zgWn5uzW1Q618F3YTMMtspCgD37+1yvxeIiYCxSlKwS0ufZSBb41z4ZRDD0+ND55/vRDiPnZ2H6EbDzBJ7QsrDzcu7ZGCX1AKe1bfBwdnHJp01CfA2EE45YRrbbsZhb4AihVcaP7eZwPr+UvZo6IHFmp7Oe94QCWlHBGEiQydPp9seC38XY+09Q4uJXgpFBY6dtf3ENxBP4GB1N4ctF6tM8YM42DKUemzvMkkOBtrzFBI/3Q3uPAqEivGAjGBie2bHYz0wOb9FaQRolEQi8QZia06J+GI13aUECRVpvQSa77SP3OZAb3GM856/+Mb+Nsr68tzqN3PS+ORVXyoS8izkOAr1wlLp368XeVhi29/IDu1jWyq2zpd66CVmMSNSFGncnVbj+ApANsBBblymJmhQXuOwYvJOrgeMUorRkP0S99dooUsDgVZWTKCwkWamxEV6QZkqpATR9RF/NfRHvgzZXqn2THJ81K+WNARxwjB3Fwn5jAeEkDSIRkKGh0Rbhc31CysL8qf/g=","authorEmailMD5":"40ff0d4f17fee6de6426c55a6e96a45d","authorUri":"","authorUserId":"disqus:andrey_tomilin","authorFallbackAvatar":"","message":"Hi,  \r\nLooks that there is still a problem when using timers. The below code show it when creating the _timer inside the 'using'. But the problem disappears when moving the _timer stuff out of the 'using'\r\n\r\n using (MyStack.Push(\"Main\"))  \r\n {  \r\n _timer = new Timers.Timer(5000);  \r\n _timer.Elapsed += OnTimer;  \r\n }\r\n\r\n...  \r\nvoid OnTimer(object sender, ElapsedEventArgs e)  \r\n{  \r\n using (MyStack.Push(\"OnTimer\"))  \r\n {  \r\n // MyStack.CurrentStack here will 'Main OnTimer' instead of just 'OnTimer'  \r\n }  \r\n}","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2016-01-14T11:49:11Z","timestamp":1452772151},{"_id":"05345944-87eb-310c-a2d5-4b40303d25b2","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I'm not familiar with timers, but most of the MS code that schedules work follows a similar pattern: they capture the execution context, and later use that to execute the user delegate.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"9e9623bf-a772-3738-8f33-26ae49c319ce","date":"2016-01-17T17:26:42Z","timestamp":1453051602},{"_id":"9e9623bf-a772-3738-8f33-26ae49c319ce","authorName":"Andrey Tomilin","authorEmailEncrypted":"I8CwGl1IPbv+/CYSHDqLOGW+Y47W4M0qCp9+gH0PCRZZ8Tem/l8lwxDBlffpdNATJlQQkM5BYrtu8xGm1/xPvdw5xinreC+AubW++qxOi4wOed61frPRGwgXOnL0U1n3Onf40CTYQAgcOnLa9O75/Mh5AgiqdxfpM2a+v4AoRYUWs+ZUwIO2V2x0kbUmfCE8BbMOXuz1TsVgwRzbvjjdq15SMA48JC6bRM9auY6WTbog19A4ozJwfn4p7fazk2ZQ0TaZKsVJQcGtWSYyiP0EA2YsuU0LVQI2edD5XONhr1XKat0ig5UT+8+KjW+WBrQdZKhTgJM39QqmToEISj7pxyATDP3NnGzM+wGsNSnIG8SPyK/A0nzNcpKS+noP6/Khi3z1Sv5YOqTn7Mu1CXUb5cOwq5rAK4d5QHxyAFeALh1CSY/OKb0m+kjn7S3OI69uCIzlQ+GGmCBL9+rc+OuNuF+70jYYWcwny6DWSfiICN0iIEqhCSPc88g1i+InkKUu+Ww+EkTOOMqYGQS2fYZx3JxbSUK7vPKzS6RXjfmxwa67ye+9c2YaxmPenGBoOGTdmrSPkrZJQFv+OgtrceVgJtIU/s0IKrtAqu9ljPsYfq2GpWbAefw+H+mbFaiVBy63G3B0x2kOTr67b6mj5P955sCivtZUccy4PC7Gw7K7OzA=","authorEmailMD5":"40ff0d4f17fee6de6426c55a6e96a45d","authorUri":"","authorUserId":"disqus:andrey_tomilin","authorFallbackAvatar":"","message":"Thanks for a quick answer.   \r\nDo you know to explain this behavior? At what point timer gets a data from the original CallContext? I tried to search Timer's source (via reflector), but didn't find anything that somehow relates to this logic","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"520e98ef-c089-3430-b83e-42a3accd03d5","date":"2016-01-17T07:54:49Z","timestamp":1453017289},{"_id":"cad9afc8-548e-3241-b259-113ffb158fae","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"AsyncLocal is quite new. If you want additional functionality, I'd hit up @aarnott or @davkean on Twitter - if they didn't write it themselves, at least they'd know who did.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"d4ffbce9-e355-3aa0-ae4e-55e80ce31b74","date":"2016-02-28T13:42:05Z","timestamp":1456666925},{"_id":"d4ffbce9-e355-3aa0-ae4e-55e80ce31b74","authorName":"Pavel Voronin","authorEmailEncrypted":"psFGq7y4LFp5t408YuSxBEeK8dfXDH2cA+YV7UZrBeFVE5TMDbh7ZgdAs9kv93GClzYypGJaAeBXwVnakYOHmr2ZVmd9TbQF1aILJwPuHkVSfkMr9qb+1ReZ1eGWwZFrnbhbWy15yA5wgaPz3YSL8LzwhhNIhfqApQpSbSNcy742GMkQtG4jkirzNAXvNS9CKO+hj1TOq7L5WYRR1rpybCHWgdG0QOkxk7agggWWY+o3Vo/Ar09B9XUcqWy4Y1G9gEat6uJDh9MQxI3kmbG4yBLRssKVWG+wYKAMTS5g+pa7pCTLJ3H1ZRVLn4JzG0/qMLB1YDLwQTc1Eymqa+QuZ8pvGTXxYaXCnEgdB3TJpC5T9QolEM15RWZsdZJVbk/Be/RVFd0GuNxsr7hZAe8HZ50GtUhQwX7XVAydqYbk09ke4El+vQiH2QoRUG4sNqhanGg0JN8xnK4aLU33sviWR7YtXwCYqR22AdtQk6dgEkb0BlwxGFQHzP+k78RJkVtkokqQHRq1obodT+4EpPuIl/h8VNonDI9kA2UaLy29SSNN6FZqk0+J0CBxxHhb5eZtdXXgJRariNNa5jPOQ+CxlJVfvWK/JVCks2RwbEko2XPqmSdjqa/sbWPJAnUL0k+ZKf5A2ETGyn7lEF21K30JptQlI0RLmmaZGU4a19I5KDU=","authorEmailMD5":"b0455ce24e84a5cf7ba132bc7cb8cc2a","authorUri":"","authorUserId":"disqus:voroninp","authorFallbackAvatar":"https://disqus.com/api/users/avatars/voroninp.jpg","message":"What is a bit disappointing with AsyncLocal is the lack of the property to check whether Value was ever set.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"a9df043f-f5e2-35df-bc30-5dc7cdf2c8b5","date":"2016-02-28T12:59:33Z","timestamp":1456664373},{"_id":"8b140248-1961-3090-a548-545c105adbe2","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, it is available on .NET 4.5 and newer.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"f5638a9d-79cc-3fb3-9fe5-3c38592c6900","date":"2016-05-28T14:35:00Z","timestamp":1464446100},{"_id":"f5638a9d-79cc-3fb3-9fe5-3c38592c6900","authorName":"David Mack","authorEmailEncrypted":"TTPA/PomWt68vUuf2emhR45+OHE+T6SrpwOG/OPx42rBCZgffbK4zhqhPJQ01PlQJvxTDZ11Yu+oWI9jAfvqTlQx3cvpmqLXxUy4XIrlwSDnKInLmmcB435pKMY+uqMhDcrTz9jJEnH5YNVpgiRwrqi2YmzRIvP+WKoBSLCOTqln9tIfWv0tOWGyHmLjXXYmkT6Tk3EI1/vqeWN+8erIUNdkb9j7mSct/ELnHEfLaoroTUzVKe7j7lu/5vTTC0tiBcdI3sFtJ+xzO4mz7jQxUiBfVCV0PmOcp/Ou9mRcaEYo4Ntus8gt3LM5mZzbmD2E+IL7IE4144k08NbBnCe9KFJRIfTo9IlBTfyLJpjzMnr3hjWXfXgyETxV+1w6fM0uQrrBtc/BQ20NIDIgSI8OHvYDpaE0OwXEdCwjc889/82kE0QW8wDd6sjJ22rRdl7fdR1h1aJoUNXMmK2UNe06wapRxeIa9scvgFzK7V0TBjTAiF6igE/VXtkAMx5pt/BaQ7bpsyXXL0b11kCBAv4gg4MEdd6GN4uxx5fRLxro3XNdIezgXEslPAuubA1co3hs2ikBNbUHGgYdXaplMhKtmLyMZqil+3U1QIhXE6hNjFpKTFCAs2o2Hle2fZTJKHW7ETWPgzREPCTukrtZlezQ1Q6CqYSVinTKS6m2CanjI4E=","authorEmailMD5":"822a8fd97d95688a122b5d3fa367dbaf","authorUri":"","authorUserId":"disqus:disqus_fZvw93ZFh1","authorFallbackAvatar":"","message":"You say that \"Note: the copy-on-write behavior of logical call contexts is only available on .NET 4.5.\".  \r\nShould this now be \"Note: the copy-on-write behavior of logical call contexts is only available _*as of*_ .NET 4.5.\"?  \r\n(i.e isn't this behaviour available in later .Net versions?).","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2016-05-28T08:38:39Z","timestamp":1464424719},{"_id":"7d31d0ab-c611-3328-9c85-922fc08f219d","authorName":"Ohad Schneider","authorEmailEncrypted":"MtZj4hLiqRf/epDufVOCW/UcmzO6NeOo2GAvrOa3ieq803Sa/FVLR8rWVkpoQZStMZZcYaZCWbbr1ZPdZJkf5VSqIT02qXfuA3JXWEd7ITTQeuOUDpinCPFuqePfhEeNx6lB4CLzZn2FQ00NhcS2g4J/WyTnxUN5xGqCsPjOfz+dl5QioQcwoUbJDpae+UrTd/lad6b6woVGI3m5BJromHggYip+WrRunApl2SlzzRBIfmoRlxKb/pZMXAB6Kvnv7gD+C8UsoTgLdJqh03FKvPlf1ictBDn3VaGaD6BhaIJ4M4UiGztpHF1UcXmbFlVnjCPzfx3bDM2oXBQSHsM3UcLxNPxzcM6EQ1f06XlA/CGseun9lZZTBVD5QQ7iFKWLAMqDKNGGkWOB6L6n7u9cTme0dmR2cNofw7FzPuS0NSft2RCzuxH/4/7g5wbAd7EzSgYt37DI12Wx2XPJjz7kkvXgI+qyQRBawcU9Dqhsx07lSAqr2MV1QBBHRJQT4X4kI7wonZpchoOyMicrrQJxTYCyue5b4gzt8w5bS9fQLmBhuGxpfUBdynNqE7BbRLHh6lwLmlOEvmaMfw56jlyCKeDejdnViJRoAmsrQiz1bMlZtbvGLJUpLY5NME/kALTsd4FIp0BGQCGSefCJ5piD56YhJ55LYkbRMdANfHRTgEQ=","authorEmailMD5":"cacacd08cdb74729cd4a964ced03f62a","authorUri":"https://www.ohadsoft.com/","authorUserId":"disqus:ohadschneider","authorFallbackAvatar":"https://disqus.com/api/users/avatars/ohadschneider.jpg","message":"In this sample it seems Pop() is a bit meaningless, as the popped execution context is never observed by anyone. In each case, before Pop() is called, the caller has already captured the logical context he'll have his continuation run on (or in the case of Main, it's going to get its original logical context anyway)...","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2017-08-12T22:57:22Z","timestamp":1502578642},{"_id":"840b1b8d-438d-3bf2-bfb1-ae6d81c8bf1d","authorName":"Ohad Schneider","authorEmailEncrypted":"COGmAXIxscay+n5PZ+C5Y34ue58fwdKQMfKm5yoy5kh5CZT+O69JWfZWrr2FDxkT8HK2+AgkmrSrLnRN3SmnQce3KuGDHnvcuFyiVUCdhuy+06xRWm4qlmT3p0sSqqv04xY++DQrvKUNgDkIR7fq/Z3N+uWzraVhVJZKrjYlkxNq0vAnWd/U4ATQjSanJiS+YwIxGyO9xAyGNIZETbHQb3EOkF/JDaeCxlKrGHLvrkbAJkTm5Ho0EMsZXgXB7sZt/okYFRZkHUurV26+uUElPLa8bU2KNdiawz/Y+7A5LQ98IdmSlzW4+TD/nOx4wK7636ZY1IDJzXgyhERZy0Tbwd/Hn1EEvZE59sZ6A2hfnaazAu2YH+sec3ygq5PYyQgl1sEvIuXsO+fPKMN48g9bNcsEMeMA+ddr/l/196g3rovtGdEhxgWU+8CAihvetdg+REozmT8j2cbsKwnUuvD81nPCKc1jK50asuN0YAAhYqRKtqm5UStIqK3258Qv69G9Ehvtw+iAkPDTVEdI2h4SDTdLbZQxuI40ij3bvEMwsD84LU2hpCFsgPsUyKbcrfUdTCxXPbPDblscaO1c1DhMtm4Gr3Mlkr78NI9H2mi9iJEAhl7PslepdMHKo+o6Zenm8uTIrEQAvyAjLIB+Vhkn7e/DB0Xzh15dQLIqtR3l+Vo=","authorEmailMD5":"cacacd08cdb74729cd4a964ced03f62a","authorUri":"https://www.ohadsoft.com/","authorUserId":"disqus:ohadschneider","authorFallbackAvatar":"https://disqus.com/api/users/avatars/ohadschneider.jpg","message":"And just before the async method exits, it reinstates the original logical context right?  \r\n (so that the caller is oblivious to any changes that were made in the synchronous portion of the async method it just called)","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"fc18e7df-8fca-3e6f-8231-21357ac66ca5","date":"2017-08-12T22:44:37Z","timestamp":1502577877},{"_id":"421b7a73-d1c0-3012-80f3-fc62e80e6a18","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, Pop is meaningless *if* all methods are async. The example code here formed the basis of my AsyncDiagnostics library, which tracked both synchronous and asynchronous methods, and requires the use of Pop.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"7d31d0ab-c611-3328-9c85-922fc08f219d","date":"2017-08-14T20:04:55Z","timestamp":1502741095},{"_id":"ea9d0fa3-f5ff-36f8-a66e-b999c92ef082","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, the caller won't see the changes in the scenario you describe.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"840b1b8d-438d-3bf2-bfb1-ae6d81c8bf1d","date":"2017-08-14T19:48:13Z","timestamp":1502740093},{"_id":"3570db9c-8df0-345f-95bc-af4053ad7086","authorName":"Ohad Schneider","authorEmailEncrypted":"KzRKTFGQVwq0Vsvu7BAWrEI0+lGS1fvntYy8jJS4jqqxJRQEtKOPd6tva1Z5+JvoOtXXL7lBTi1o6q8+Ajxzo3w5U2ic21HRga6ihwYJC3uS1iCxGVffzHpMV3kFHirLi42hzHUoAw2af7py9RaiRnM7owWuMD1b+vAU85okLHdBNmPBwyEdOxUnqhtFZsOKlHfUwnI53r5dYosK+He6kGJ/oXz0kOOC3l6n5zWAl/qG6hTxzkFs+Zq8h9f4CJzu3I6cABon0K9PAzpv/G4omure/qGirqf8amhvy+vtnGZSfjP08XEfRtfVmEHu6OEKv53TJh/9DU48NyWjUbqiVBQe6HC0+Kf6NVR5KbZN6J/Y8BBbOvl42MHRfXUXCSyJpGHkPBkQWiGlhP6MDZRMkwXlmz7svLY8d25WoJWoxewoARVrNhUhTTFfysQSjWpSGRWdFX+oR4xZ6HhwDsN+4U3Fk0GYT4KMtmgZ7Hjw25Dz9GsraCu50RphM+Tl8PGKYL3vdiOQ1UMY8kKs0q6sj0+JZKqTN6VRhulH4vEwvctlg33jv9f8tk0cG4ltIrZI0EqlbGExTwu6Zb9hjY+tLx4O2+0WKUQEuieM9zdkXnPS7gORjO+jqQ0pq6ZsZawsa28DyJvTZYmNFKgR9L1YEwLdtYobB3C7P4dHTN7HKbg=","authorEmailMD5":"cacacd08cdb74729cd4a964ced03f62a","authorUri":"https://www.ohadsoft.com/","authorUserId":"disqus:ohadschneider","authorFallbackAvatar":"https://disqus.com/api/users/avatars/ohadschneider.jpg","message":"Cool. Small nitpick, saying it's meaningless if all methods are async is a bit misleading as an async method could still contain code like `using (MyStack.Push(stackName)) {Log(\"foo\");} Log(\"Bar\");` (where the second Bar is outside of the using statement).","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"421b7a73-d1c0-3012-80f3-fc62e80e6a18","date":"2017-08-15T09:35:59Z","timestamp":1502789759},{"_id":"7f86f66a-8820-33ff-a875-f2eb6fa68fae","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, that's true as well.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"3570db9c-8df0-345f-95bc-af4053ad7086","date":"2017-08-15T14:32:37Z","timestamp":1502807557},{"_id":"8e4702fc-7ed2-3fbf-a79f-13ae3a0c23b5","authorName":"Keith","authorEmailEncrypted":"L6neEyNLGDU1WuXnJtM1ql64uZ3ziWIrhiS7Ln9n9rrJ/RzZiMyT5Mtyg7vJ5eebgpgG7Rfvpxpub6YS6hkZeLzAgyOGB56yMCGw/9PGYmSOhvPKmcKbPFzKbs5lBsOcVxo28hIS9jzixjlOGfyDjN4VgiklILJcevYC2YcJ1kneiGDjrqk0ZhMPYTks32ob5zKzim897rjiKdMc7XWQL28oZHb+NGVklaQJWGe9kDYPAM271/9+fhuHVv7GKzOgXvUSaNIZ5gI1ohuaVmxwSiRGL5VKRBfX4rRyE3Kt6WEB/tJPGUqFL/ClvI0CfSl4D4VXc2CVup+SpQuUDmSSg41Dkkr0YO3IQw5kMsIiALIxLJ3h/duJMe1ZzD7E38a8AxM3zj2Vc1/8Zr+fyIWCua0Cx74OHrcCxkTbBv9WF20+TZxiUJ8SG1YDgIhWFORPKNbB9HJw9fS0o+XFK6VSxxh+SKNC6pC4HihZPKe3W7XHzhTsGXdeSXdyvtDGUc6OiAG4uQwgzpbvJbQ4LJH7G5TCk/Pf5CsHu+r5tdhpVPKKlMcQjB8Y1EjByf2X+OXDJ3gwh1tFyxfzsBMridOiiUvSs8e071IpPwu5D4BMqC4hFcuVM86C5ZaqEyL9C+TqkRKlqn3ET5qa+W/I2GZSKQNUFAqWB6fnrvBV6Aj1Shg=","authorEmailMD5":"59db4d88b2556b61744ad1a41143e149","authorUri":"","authorUserId":"disqus:KeithLRobertson1","authorFallbackAvatar":"https://disqus.com/api/users/avatars/KeithLRobertson1.jpg","message":">you cant opt-out of the logical call context  \r\nActually, you can with ExecutionContext.SuppressFlow(). Probably shouldn't though. With the thread pool scheduler, you end up storing data in the pool thread's context which remains there as it goes back into and out of the pool!","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2018-01-19T23:02:09Z","timestamp":1516402929},{"_id":"61f24610-152d-11e9-82d7-0bb39bf6d207","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"b7d71cb0-1517-11e9-82d7-0bb39bf6d207","authorEmailEncrypted":"WDL0nvV+x/IzumpeuDTerfS8sVrcXiPyA+LPoTk26jX9WPETzymd6aUROzu2VTOByMctwOqKOxEQrhZkOyaN+POlLTUcMTF2b5D6hGNuJX/AVokCkjXLLr9KEdvAZAyVg79dazB63bcIL8Tjgy3hT5tfYI4shebQq4S6IGTkUhtEnpAMNHiFEPztrW73R/fbHCgkJIYpMarBWjG3Jt5xmgOxeT+2SGY5/gTfoo4Y5qjns/x6ZB4MCq35rEE94qBET8a/UKPpL0hEbc1i5IcL7gdXOPjF9OhX3qUhs0yryjLTO5xTw8HO69BsJZP44R89dsWC9EJwD/01QSwpx5benW5rf9+glRi2t9cpPmWvjSFzn93hqSlUBJGGcATW+iOxQcdg6PuGTLronbwQNIay9Nhyx+IhEMW/4c1M9EyTaSQG4vnmfJn+aLAdh3sq1brUKYed7uer6XdrEc5IZJalzxlVVG+etpM/PyfvCceYYCgI7cZRSYbHpXDMhBlGYGbSamj9ATDR/kdnlYDLVZuP/5N30TF0AGhU4NAtdGujxpNKX+xizzI8Fsta94GDW0aQmILDdX7Z0UAT8XKrUOHfCQVRuXZaUbQy1jqt15FSpfQQ4Tyh6frsGk/mHhfRHoYsc6iGCrWmrFLinzRC+FL9aZSDSwbTsTWT/R0bQm/gYYA=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I suspect that this is due to this:\r\n\r\n> The code uses tasks, but no async/await.\r\n\r\nFor the implicit async context to actually work, at some point you have to establish a copy-on-write scope. In the `async` world, this is handled by the `async` keyword itself; the compiler-generated state machine establishes a copy-on-write scope at the beginning of every `async` method. I *expect* that xUnit's test runner does not call your code from an `async` method, and since all your tests are synchronous, they would all be sharing the same scope. That is, assuming your `AsyncLocal<ConcurrentDictionary<..>>` is a static instance, which seems likely.\r\n\r\nOne way to test this is to make your unit tests `async` (you don't have to use `await`), and see if that clears up the problem.\r\n\r\nIf that doesn't clear it up, try to create a minimal repro and open an issue with the xUnit team (or post on Stack Overflow) and send me a link to it.","date":"2019-01-10T23:13:47.747Z"},{"_id":"b7d71cb0-1517-11e9-82d7-0bb39bf6d207","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"","authorEmailEncrypted":"n8NA/hgR8l+giWefVNwCCdfP157UpuE1QArk2pBaxyLmUrUGBQYiMebOS4XGmFrSBoDDvVFjbOiX6NTFeqWC9b71qZNpJ5DsCaAFu1cQsUII+xVBkSW5Mi4R/hlZoweHDAnbZ1nFtsPlrmxI65gmstMmab7vPN/lo5KtqIKzhbSrQDfjWSy1s4V1kRK1/mh9p3bYZaR9Pe58DcS98tvyahUx6PTgkczA0ccwBPwh5BY9fxkr1LUe0FKNESIew7VGzoePLTyAiCgtY0I6jszInJ86nKsT9+9aJPMtWCWEwLBpmhlenAyvZoCbdJsULzxGisKSkRTLi6gXPGdT6e9ZfCJ94R6l4tq8jIi7M8B4/0M7mGu8qJ7pJYI6uU88AZoj/77VNMKRvP7sJng2X1lK3IQwqxRrMl+b1Z78+nlKa2i0LVsZzeEsM7vBtKPaYBAvNzrfy0OaC8YKVrjJwajIDBot3t8VDYzbuJidQiFfA/WnWv7/PzuVrk72ayi3IshccRmnXujj3ZboD3llIvVeckhSPfWVJfu6ZNurExyUXPZU4RZVXtR7Lu9zuLjG6orEtuOabyDh0uql4qS1yvmCHPaUQP9moow53JSsTl2cJ7FaHcji5n8JfqKzD3O/GFWoYmsf56/xugJBOLnQHBFOqrGlBwcPNx3vlJFSCJOiCR4=","authorEmailMD5":"1f5c48763ae2b49cf16d86d4a99ba878","authorName":"Manaus Lavens","authorUri":"","message":"Hi Stephen,\r\n\r\nThanks for your interesting post. \r\nI am having an issue where I am using a concurrent dictionary stored in the logical call context that keeps track of my registered instances.\r\n\r\nFor each unit test, ( I am using XUnit), I register my instances in this concurrent dictionary. The code uses tasks, but no async/await. \r\n\r\nApparently, 1 out of 10 times, it seems my dictionary loses some registered instances. (The act part does not seem to find the previously registered instance in the arragnge part).\r\n\r\nDo you have an idea why this is occuring? You state that you may only store immutable data, could this be the reason as my concurrent dictionary is not immutable?\r\n\r\nThanks a lot!","date":"2019-01-10T20:38:42.948Z"},{"_id":"5abb6be0-1575-11e9-adf4-89bb71bd4aff","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"61f24610-152d-11e9-82d7-0bb39bf6d207","authorEmailEncrypted":"Qq+dQJs+805SBW1v1TiT6MkxlGC3e8x5j9iAEXHlua6tl+T+Ve5pmr8TAc8aNP46ms1duE1JjI2opD1a3vZsdNN+A8lRnUY+JPDwSdl6FWWJMqdPx4irGiY3SHwYYNnt4wtmogsUXpApULPUHjWunYc0i6LRGrbb+OTjkkVMS2kwwFQCgQyuE44yngLEFeyl102WrnjijG8u5YhTQPF7ANzJ+IGb5z+YQuWgJ8Si8gN8TnANHww25A7UTilLoVmg/FcU1+sNiLnOyN1Cu44/vhASV7qqgD+iu//VjqyQNul5XMiMzDGZX68gp6L0CHyGdOxnItDyunKCf6n0X7EL75rWnDvNPlJsOz9glQV40qqtcHOt9Q4v9R95bz280ATbEbEO1YohNjHG5WjJLV3gb+YR9W8EuU0p2i6RZJowViP/DQOaceRkYlYnywfTTrnyl6CdvylbwW+f8KC/CpddSZTe5t2MHEh6fgrP+ZJJb/HsJtkewJkHS5+aehj/Jy5K2RsNtwQqCRkLGesY3Rg+0l+KxrkggBXuWZ/YCyGRDOjq79yuxRAHAZX6tUz1pzWr3R8VZyllWlL30rQ7jDWeE2WckrrC0f9DtQuGA8VMDEYS9UGGhGj3jIjrnQhD8s/e/kL7hMSeV9yE13JN6eH1NhuLBUS3jFwV03V3sxUjIBs=","authorEmailMD5":"1f5c48763ae2b49cf16d86d4a99ba878","authorName":"Manaus Lavens","authorUri":"","message":"Thanks for your reply Stephen.\r\n\r\nI am looking into the XUnit SDK and it seems that tests are run with async/await.\r\nSee the following class: https://github.com/xunit/xunit/blob/9d10262a3694bb099ddd783d735aba2a7aac759d/src/xunit.execution/Sdk/Frameworks/Runners/TestMethodRunner.cs\r\n\r\nI have opened a ticket with a pseudo code alike sample which describes my problem. \r\nhttps://github.com/xunit/xunit/issues/1880\r\nIf you would like to have a real repro project, I will try to assemble it today.","date":"2019-01-11T07:48:59.480Z"},{"_id":"e00d5120-15af-11e9-adf4-89bb71bd4aff","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"5abb6be0-1575-11e9-adf4-89bb71bd4aff","authorEmailEncrypted":"JGc1HSysusR3VOApeq6B8oJsyXaaXAwoplrOc8GvKeIYA85Y9WX3dQyrZfRaOE9k1y9lEGlkevJtg/dSlLLJE/X/OPnjLEdTY8cX8W1sHahWa+yx8lrdYgAT/mG2Sidt0dHt3sfNYPi38vIGovSn6OAUj/kbzNKwrVbaPaZKZiYSrGKMMGfT4E6csXSkOOKU14ePghrcz7ENx2JTYat41oPdWjmpMh4pJztHMtc7X9LU/DEzPYLwZOKQER2OZELOC9VJcZjY+QVKTfvgevUTe5b5NFMqMsz9nVHq10Zy3WLq5Glzm3qCbPxxW9LdqOvJ9CDvjERIUv7udFJH679zkgrhhwsFYzJPmir7RtTu66vl4mDb3i0g8pLsfk37n3FCe9DCYEd4APg+wUjUzLbTYtGobm2e9h47XjzeXay7XFIv2BQyWpepvaIfakDkVJyoTciSHTzAuuKJzERGKxYfRmOUT0rAtxRJZGhSmGS5LE57an/i1FqnirNbtuaSAxS+eOKsS3LQXVaMNY3Z6gxaJoMwOLHAo5GJyfADDDjhRMHoXasdvLd04AE6Saw/NuZOnSqP8t3cb6dn8vegziQB7eF/wZ//xwGNd+PR/6GFJKF/YqHcdYX3RDW0sYhHNq+ilr8BGvu3EyIU0SxgvSWqk+Heb/Ey+3zhQ7CMfhuMnEs=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I think we'll need a minimal repro for that case. This is too complex to solve by guessing what the details are.","date":"2019-01-11T14:47:53.836Z"},{"_id":"accdd8c0-1807-11e9-88e4-23fa58072734","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"e00d5120-15af-11e9-adf4-89bb71bd4aff","authorEmailEncrypted":"EmALfqDJgOwRkpBCRQoI99O/Onths3m6hUojIuQnic0FzhyXYruWLDGODi89itWrsFmBarOqtEtL++dGdAs/YJRW62lhFL5mWjov5D0G7nnSHgpb+I3Rkm51/IA+cR0FBg5w8pLiwgKfY9KsEN5A3cfBSbDizwbvLKbOKwTahxSXf3xDG0UZllhaddXKvoXFbxwojg7FDBcUsx+BpDKxMs1rXPRzP3PEXMnutuAJj63R7TFxz8vJqinWkq/0DfxOP9tc0hqiDN43GW778olk9QhkmZw4FLC6D1Cm6D50Nbt3VTIbchsX3XwFygoqZxdwvgP+HQf7Jk3nCj39G7JowlHFTRu2Avt3Q9ciBSyVyAwquz7YG1louepGER2vUxUUDtX61xEVpj2vLtt48eYN8MKzlXKGrOsJknWmudU6H46GVId+SvZY2Fn+tK2BnSMfGMu/OnCJU/QSrYwUfJGFlYEBFOvjrHNLbgInU7P6gIBtIlySWt6l3rhCCaeqKW6XoGct203LlPSItFdzZffXjJ4z+2//jTB6NMPx4iWhb/bk7pptBjkIu0KlxkOCU9tNYfuhIc3hNr6E5vHfw7xbzj5QGte6aaxX2ywerKKImQq5lA61ckuP1MPZ7vjxEDm57kSX60Iqccdk8PhpSwsFLYcT4t+R0aCFcIg7+V7KxjE=","authorEmailMD5":"1f5c48763ae2b49cf16d86d4a99ba878","authorName":"Manaus Lavens","authorUri":"","message":"I have created a repro scenario.\r\nThe tests run in parallel and as Brad Wilson stated in the XUnit issue, each test should have their own Async Context.\r\nTo issue was hard to reproduce, however, by testing the amount of registration in the AsyncLocal Dictionary, it was easier to show the problem. (Marking the tests with Async, didn't help either...)\r\nSee: https://github.com/Mauzer93/AsyncLocalXUnit/tree/master/ReproduceAsyncLocalIssueXUnit","date":"2019-01-14T14:21:26.639Z"},{"_id":"1fd40130-1af8-11e9-ba78-3d3ffff9172b","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"accdd8c0-1807-11e9-88e4-23fa58072734","authorEmailEncrypted":"vEQ7zl2+60d7Wd5jNbfysJOrhrKt47JJ1VBuIYiC/XsOezhhfMBtNFfubxiwFtfMBSaabFMOrvB4OJCKxYTVZcx81pPBH+BOrRQxwe8gZj06wwBU4Np+J+RqyYKYZDGapaOG4N7J6zxGVwukm9B/2v5BqyP57BJtY5ibzZvCEgscxjbkwxxTZ4hyDTZS/xUzynbESN6bHf8BB2wPlmDBG0brdE9BqI1VNQTeLW70jHW+Zq7iZ6wAcrEcTLDxTm9zHlAkfw04W+XSsnNxkG1nn+TwlwrbMKrL0FGU52TWr4AXWFoTD7OV0uy4CASgxxPBby2h1VIdi4E93L0pMXl8/g/AAozJfYZGdLEieYXCR2ehCQm7nwUGsv34ByIAKseT9yBQLtwdrXI3UAuXEZmKFTsE1fbT1Ta9EIUEZTL5IMCHIG7TRifrEFUxefvLMXZj2mja1hRdZCzNc8RdzPM2DHtvVX58wNM4ALjf7kMUPAQsLsK2JjB/Ym8fap8ABTwg7u1Rw5dzAieQZf1qxwU5HUMUVpmDAzy0bK3QnFM/VXDfaXC2sI1GEmjCdGOonchr7YQ2Vpsl3M/0wUG0u6nascNNc2GlkyY5janFgpZWlwXr0edo5cEV2hrHqO1Cq2E1PvH0RJR2cCtgk9xA4MLWGtQiAIT8oFOkovV7d74tPn8=","authorEmailMD5":"1f5c48763ae2b49cf16d86d4a99ba878","authorName":"Manaus Lavens","authorUri":"","message":"Thanks for you replies. The sample was not representative for my issue. We worked around by using another implemenation in the Domain Event Store.","date":"2019-01-18T08:07:40.529Z"},{"_id":"0a6ed5a0-2420-11e9-aa77-ffe40b10080e","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"http://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"","authorEmailEncrypted":"QZwWFR0d0Lem2hxVlAuA0769+9lgVP/wqmIaC9s1S9FoSN7ZaH6EwQ5bHpenoQROKYlr81O/bmV97jgI6+IMGXvMKsfMzSruFUchI4UFBZA/bE3t2NjIyb23q1F6R17l4aw26ggf/uqt1MniHKa2h9izA8tph2BQ0DlytNuLB0QFQXrsAL3bBzqSwBkrrCIkZJ1PekYJLlE1JGcFkfQTXlRpzqI/aCzRzp/79keUx6L53a2uXlEdeH0oCPYSMe524UXCEwJvo027mXCvrurS+ljtdrjmS5SmoR3dqlAa1voyZHBt6R7IVYU+QpSrH5EL0/qEfXea4QGD6PbAwELlM9ouaqVvgio9eARu1hCYOAFeDlXljCWDGjGdSdG4scl7XZzJFPMkvFuj+pB6tfJNTQJkAcrT25HpuHPJwM/76i6IhMdCLEYVOMzyCZoaltcy+Dw2PtlhrerQDEjkyo6rqQPD5PLcjnHwhXuYGIR1hT8bgwG0o9qmOyMXN4ijSeA7ZeAJvMGy9SIGQhmB9V9GstOMAKiIdU61T3v2FytVz9+GppgmyGVxBzZoJ4JuD4iioQxB/keZnwc5UOVJhr0qcR0l1T/g5bruZmQ0YJ9keH7uFhZ82+fntubzMn4Fttq+ZuEVXOUUEA4DmN8pQFFBIIH7pZJs03EwusF+s07dqQ0=","authorEmailMD5":"3061f3a37be78880d0961acbace3b785","authorName":"Danny B","authorUri":"","message":"Just wanted to say Thank you.","date":"2019-01-29T23:46:05.243Z"},{"_id":"29e9c040-3985-11ea-9fb7-dd74b7d427f2","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"ecccbe80-3941-11ea-a228-db01b2ef7800","authorEmailEncrypted":"ZorrKGXd+5FgeWdXivKi+onrzD8jrMUL13i0y8NKAViaQiXqzoBSA996I5F2/7r680jSEqk/UvSUdOLqVw1+QVl5YRRQCr7/ymwD24iVyOOqfrt6bY+Y4MBwhO0P28JuE7vBpSyPCLX3ZmJYC3daNU6OBTf1Pwq2iz+fXlp9EI/lBKsMSjLFngXdU6m60SX2bEHEat/xboSYm2hXjSwbYOjFiDDr+VdMkKn1wrUCG3qmnCEEF4mCK7LJEKnuzZ7ZAjLh+XRZ1ugtQTJoyLg/v3E6eMxZGFhwZLOTXr1kV5d5cIKP5XExC+4zr8UH5yswR96r7VPyFT3B0F1OUENeH8NKV0EzVkIlx/1DrtsoLXKrVKbTM4CMoYmQwAv/nkFZz30mY76414vPSydFDPHRQo+1FIxJ5upoBJSvSEUr3wTfZhbD917T/ZuVLiUxKiWMyDMXMT9IVdtln1yUm2+nWhDDT1J7cw3UKcbEUoUCKu9SDZlZObC4w9fhzHF760fblUfT4zvYcBfVziu3V3wVVYzaYxOyvvkFAhbUVlash2VGCxn2Je9+epTyR7zRj7ZuO/ialQIL7PXz0FBWelwuJZ3BfMosFf0EygLv0Z3xOWRFI/NJNEFg4RvaYGbfch8BwqLj/gqyOajy6OFvFbx26fCzZqw46jqCgMHscQEpAZg=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"`OperationContext.Current` should not become `null` after `await`; if it is, then there's something much more seriously wrong. I recommend figuring out why that property is not behaving properly, bringing in Microsoft support if necessary.\r\n\r\nRegarding call context data sharing, this can happen if there isn't an `async` method further up the call stack. An easy way to avoid this situation is to always *set* the logical call context within an `async` method.\r\n\r\nIf that doesn't fix your problem, then it's possible that whatever is messing up `OperationContext.Current` is also messing up the logical call context.","date":"2020-01-17T23:57:48.954Z"},{"_id":"ecccbe80-3941-11ea-a228-db01b2ef7800","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"","authorEmailEncrypted":"RTkaDH8glm4QsKyXdGWzkVVsVBTYgm5aREWm2qLqo7eGK8jVzI4FsdF4MsOfwvWb2ODV01ZMdmNMRFGsEjmw13wHOHYBjO/+liOGAlTI7jpZE+5Wu1Rn436C7Jedmd4kq+LzW4l2r9xbk+TL8pJ9tYFVg9ix2p7RCsOXWqv7a+zQ/AZujXcGF4tJLyoe0+Ge3d62Gdp24oxtjic695ErnFLRHtxXL8ocfLNzcqbJfBUG4z9AyVUz3zxj1rGTZa7ldQdqEoHGNsBpAtcXVR6ao+NyTSxHPrQXH1wd4kxEDXqVoV2rxgoFg/CIqLt4aXHh8FT63VjjGIsCuqtIsRRTioXu7qELZfkdQdf2a1csUN61VIo0IrHRGgHfENVna7AdcmwKrEPIH43eTfvvwaao0o5PbePKMe5LbmKB282vVpthYYQSahpyg5FuEBFwcxQoqz4pjcsZ45PRzW2d/CW9YV0Jay4D5hcKfkdhu2E0Z9Q8BrdBAcnibE5S0rH9FJFT+r5XGPiUCEo+n/ZI9vWTcPBtFF8onS6YXNTXUiEsxEFIdXnJ4ax0o3QpKzuT8W9NdaLwWogGOb18GWmYswvjvMMQG3pUhcj9iKn/eixyxokQ71/0hGVk6xkfpO06s9gWoCAbMjpU0CZIzDTo4Y0lGLGjtuHGCh5qO6lpwbZ8tVo=","authorEmailMD5":"08f7976637ff7b2937883996406aab2d","authorName":"Ohad Tsamir","authorUri":"","message":"Hi Stephen,\r\nIn my company, we've been using CallContext within WCF as a replacement for OperationContext.Current, which could become null after async operations. I've recently stumbled upon a behaviour that alarms me: Sporadically (more often with high concurrency), a request calling `LogicalGetData` will gain access to data stored via a **different** request's call to `LogicalSetData`. Would you have any explanation to this? Could execution context be shared between different requests to a WCF service hosted in IIS?\r\n\r\nIf relevant, the calls to both methods are performed via a `MessageInspector`.\r\n\r\nAdditionally: The original data I stored was not immutable (because I only read your post now :) ), so I created a new test case where I only store the string `OperationContext.Current.IncomingMessageHeaders.Action`, which in WCF holds the operation name, and indeed I could still (sporadically) access another operation's action. But I'm wondering if this is of any relevance? If I understand your post correctly, the importance of immutability is to ensure that the data is in the correct state, but I'm assuming that even mutable objects shouldn't be able to cross the boundaries of a single execution context, correct?\r\n\r\n[Here](https://stackoverflow.com/a/59787566/198797)'s an answer I recently posted on SO (feel free to correct / address me either here or there).","date":"2020-01-17T15:56:30.014Z"},{"_id":"f52b8680-41c3-11ea-a7f0-f30dc1ba009d","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"29e9c040-3985-11ea-9fb7-dd74b7d427f2","authorEmailEncrypted":"SBiGPbOWuGYBdbiyG9ma1wwjekrExjJGtE/KwspSBGmKs+7xK5rG2g/i92tO2Oa6s6GY2R10LU6m1rjttGJCcJamR97z357wzJabL1V9s6jUc7kHToC5wtfWGuTP74688datxHfl0Pa4ky3SatMKMp/kkmmIgiFu+kzum+XSq80xy4iAA3eUEf1VESY9hLc69Gktztxw4vSKyMNJWiB8tLFl2uwA0f6IRGH2mMkKIOZUTKWVrLPnlyN+zLrz8VT3aG+YHcUMG4WvbKcVbupt70+wIQrpuvHoL4znC+bmpHKKQ91uPV8wyQRtqwAv1njU42MPFY5wXV0UJ21S1SUw8OxLsN2cHh+KIfYlIxEOsJGLJO0U3dOJnxktS6E6bilFg01/jIQvKETQO2DlQ2aSFwb1/O3E30Uvk1ynyDqFEFAQitwLPeGu+oFpDYgRKixaerdB8N3XiAFsuNtAEpNe0ONc/3PGiGiKb4fyTJ4xq1wNLR2ZAOZ6hVsOzZmNRy/fqZE4RFRInHpWw7wwbstNGRx5sT5OwxXTKmH55xUXeMCGnvB5GPkhIZnGVhWnoaVSdDv3Otappcb+8C40GgIadxJA507lMXjlNP7Q/gFX+ERJMm1zzE9BYhjikYl/KFBNTPMB26st1JXWpJrUGfz4ElGeBgESIhitDTtqAxLpTuA=","authorEmailMD5":"08f7976637ff7b2937883996406aab2d","authorName":"Ohad Tsamir","authorUri":"","message":"Thanks for your reply.\r\n\r\nPrior to .Net Framework 4.6.2, `OperationContext.Current` was thread static and would never flow between threads, so any `async` operation that caused a thread switch would nullify the reference.\r\n\r\n4.6.2 added [execution context improvements](https://devblogs.microsoft.com/dotnet/announcing-net-framework-4-6-2/), which were turned on by default. However, that caused other potential issues with services marked as `ConcurrencyMode.Reentrant`, and was [turned off again by default](https://github.com/Microsoft/dotnet/issues/403#issuecomment-303778619) in 4.7, with the possibility to turn it back on via an appSetting `<add key=\"wcf:disableOperationContextAsyncFlow\" value=\"false\" />` (notice the double negative, this is essentially turning the async flow _on_).\r\n\r\nSince we have no reentrant services, we are now looking to implement this config change, so we can \"trust\" `OperationContext.Current` again. Unfortunately, we still have many legacy services that were programmed prior to 4.6.2, which cannot all be upgraded together, and are still using the `CallContext.Logical[Set|Get]Data()` approach to retain request-specific state, hence my worry.\r\n\r\nAs for your suggested reason, I'm not clear on how _not_ having an `async` method up the stack could cause this? Isn't a single-threaded, non-async execution the simplest for maintaining context? In my own code there is no `async` indeed (nor any explicit threading). It is running inside a `MessageInspector.AfterReceiveRequest()`, and I don't know what WCF is doing with the call before it gets to my code, but from the top of my head I'd assume no asynchrony is taking place there either. Reminder: `MessageInspector` is registered in WCF pipeline as a singleton. Could this be related?\r\n\r\nAs for your proposed solution, I've been searching but can't seem to find how does one \"set the logical call context\". Could you either post a code snippet or refer me to an online resource? Still, I'm curious if it can indeed apply to the issue I'm witnessing, considering I have no `async` operations (at least in my own codebase) around the problematic area.\r\n\r\nI'm aware this is somewhat invasive, so I appreciate your effort in answering. I do suspect however this may be important to non-negligible portions of the WCF-using community.","date":"2020-01-28T11:47:27.953Z"},{"_id":"fc93c4c0-41da-11ea-a7f0-f30dc1ba009d","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"f52b8680-41c3-11ea-a7f0-f30dc1ba009d","authorEmailEncrypted":"Hk0l+CL5AFUk4w64+RD6T/sFwsHVM4bdyPGbRRBoi7BKnaWYXdauDlBvc0iE6tfQOXAqYTuCxCekKnUEIFai7dIW4S7omkAXuEcs+/+NNU+N6AO80uKxhPG6ifDDzOQ9ROdSFUrlN+RrRE5DuHO/gEgdTbT1w+WHjLHZs/iARrHAQPp/fjhVZQ9AYRMgZvneJUaEl7TXgovs6MmaGd2cYq23xse1mG5zBSrBabPbYo+49Evjq2X1KQ8LF2xrtQBpBVChI5ulRIo+sN0vujORscrCaYsAXTkQUOlM1Ek8QbMbcWzTS39MYMMmSFRFtMhyZz4lcS3UZ/Rhd7rPDARQOmCBvSyMygUxoBAJusHfEzW3rDtQhtraOGmCE9AWY1tBaLy0mfLA1eWp71a857cpN/QszUpJvHo2OzOHpjYDI5BSt39tCpglxLXd774wPHoSLcrFUENh/pkRfvx3jk+FmRpzjUYl/HH3YLXFb1kh4hadsAQNUr/wrrUnEvUrnPj2KfpHvhOMNtCZWXTh5LPlJZXXT5nv7gjKiWN5oaJCk4WNIRZSG57TuTvYVJtzcmxtsR8/f1mhA7M7DD54Sv7+czMRS1xlud969BA8iTvxnR9H5QLH5EgaQnFwLg+e7qEcy8KURXIa4nS1Rzg6FEYQzom2NSlG99fjNhZNAunjLTo=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Ah, that context is helpful! It has been many years since I've worked with asynchronous WCF services, but let's see...\r\n\r\n`CallContext.Logical*Data` should work fine, especially if you need to use code across legacy and modern.\r\n\r\n> I'm not clear on how *not* having an `async` method up the stack could cause this?\r\n\r\nIt's because an `async` method triggers the \"copy on write\" behavior for the logical call context.\r\n\r\n> In my own code there is no `async` indeed\r\n\r\nAh, in that case the fix may be much simpler: ensure your code always calls `CallContext.FreeNamedDataSlot` to *delete* the data when it is done with it.\r\n\r\nThis step is redundant for `async` methods because when `CallContext.LogicalSetData` is called in an `async` method[1], the current logical call context is copied (if it hasn't been already), and when that `async` method completes, the previous logical call context is restored. So any adds/updates in the `async` method are removed/reverted automatically.\r\n\r\n[1] - Technically, this refers to the closest `async` method going up the call stack. So if an `async` method calls a synchronous method that modifies the logical call context, the copied logical call context is considered the \"current\" one until the *parent* `async` method completes. Synchronous methods allow the logical call context values to flow back up the call stack, and since your code is synchronous, that may explain the behavior you're seeing.\r\n\r\n> `MessageInspector` is registered in WCF pipeline as a singleton\r\n\r\nI don't think that would be related. The \"illogical\" call contexts are tied to threads, and the logical call contexts are related to call stacks; neither of them have anything to do with object lifetimes.\r\n\r\n> how does one \"set the logical call context\"\r\n\r\nSorry for the confusion, I meant just modifying the logical call context in any way, e.g., calling `CallContext.LogicalSetData`.","date":"2020-01-28T14:32:18.752Z"},{"_id":"a54ac280-468b-11ea-8709-e79a8cf0fe62","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"ae711200-4682-11ea-8709-e79a8cf0fe62","authorEmailEncrypted":"wiQcPgwor4XxEbb4j2aL3BHs88RCA99bcGgIC5ltLuwWA5mg3zWQYGgwxjI0PLT/i4MpGYWbliXJ1vK1d7bxcdxxTz657nkHxzuP+Hva6TdaBOiPxoLGlyLXUr6ilpzh3e1xLbkgNR88US2SavAxXRrf7LgqI3tUZSGxPsifTXF8/zPtwJnqpmXEfAtU9QB9qiyIvRKO4WzQXxMevR1OH6PZzQHcmZz8ROkZ2ueOEn59FIJJ7MwweSLFc23gjFibW7F6RcPz6SmyFZvw0hX+LSV6d+eePEL89LY3oCcBCfFJogVZoj59mzsNavwr+YIWQlrrpvEDQoV6FkmF8/Z28QmbWvZ+LHIrglzP0eljTy5WueIOpdwNvFtTAo8xg33B+/XqSp0wPJdGvL/Tcj3mMJueOugLlJr6m+BBnV/t3gEnUnlThsn5vx2hRCGZiXZkbLVNdbx2ZMyaf2tMSxXwXHF56GBbGzkYYMCfh1X5zOB9WQjCH1snBPzkZKnsBB5lybq+7emZEpni2pabBPWZrGYSh35tCsUy6WWOw+2jAx6DcM7fzijW/8X9vLKojshPOwCCZEDTTQbeak63Pk+FbXD370jkKb61ai0MvG9IOY/jtLEmTcBBf7g/s4HbJgWcTNRbL+mC3kBoBucpfYqbKkhKiidpltAZhrPD9I8zfsw=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"> for different incoming requests - it still should run in different `ExecutionContext`s. Is that assumption correct?\r\n\r\nI don't know. That behavior is determined by the WCF runtime, and I don't know it to that level of detail.\r\n\r\nIt's possible that the runtime is always creating a new copy of the `ExecutionContext` for every request that comes in. It's also possible that the runtime is (at least for synchronous requests) using a shared `ExecutionContext` for efficiency.","date":"2020-02-03T13:46:58.089Z"},{"_id":"ae711200-4682-11ea-8709-e79a8cf0fe62","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"fc93c4c0-41da-11ea-a7f0-f30dc1ba009d","authorEmailEncrypted":"npze4mULcpet5hFXG3JRtRTaaD5xt1hn50uzafaaMBYZIR0F2lr1hX2UCwBxeta8nVpcXogowGsWIYzaYRoejyYOFGocOSj4/G7ijRtCXbhkd5NWwfsOQILS9Nwq0GPSIU/DhYG181EF7gMdfdytrpf/waXuxQBOmAeZl5ZfhnK+kVDpRweJ2Voj2zIL2qV/RaOSoEr0619ZHNpySZL9Z/wRhLrDzvlyy9HkP6lUqPd4GUWGKIjCkNjmnMDUETC8+vQZk+siJy+3qA5qG9WP1865Rv95D/wU5/YfrDuWB3eJZj5Edx9lyyyMq00JWBcZ36I/a7/jaCv+sHkO2z9+wQKF7X8vi03nVQsjra4YYUKqjvlq77X2YaEGJmatOVJioZhLLdzZMjdp/i5qWGpIAqsYuAEcI/J3OQDdy2n2uZhk53ny1eWxv/VU+a4Oqk+y5+2qpUf4fkIcFjbH4w8PlkK6QJ679r3llzxH3rs9sX4SZTL90MRbPXxOD6FqUMxhmWvb1hBi46YyIAtgeeKJ6gfzihKEZevabEKixyk5nGL+yHguIcJ9kSTf1hHMO+TOB1pdvoRJKqCBe6plISI7oYNn2MmIJtTfGoqyUL3wfbT+yCKuMB8y+LnNWkXXK9LH2zHa9qWgoxOVFzIhR50fqV4ZGcU8gc93MfDk4mDP/Ic=","authorEmailMD5":"08f7976637ff7b2937883996406aab2d","authorName":"Ohad Tsamir","authorUri":"","message":"Thanks for the clarifications! Consulting colleagues, we've boiled our remaining question down to the following:\r\n\r\n* Even though the `MessageInspector` code has no `async`, we assume that for different incoming requests - it still should run in different `ExecutionContext`s. Is that assumption correct?\r\n\r\nIf the answer is \"yes\", then I'm afraid we're still not clear on how a value stored via one request could \"leak\" and be read via a different request. Is there any setting / configuration / environment variable that could make an impact on this answer?","date":"2020-02-03T12:42:47.918Z"},{"_id":"0bc7b1d0-474a-11ea-960a-59ebe4a70545","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"a54ac280-468b-11ea-8709-e79a8cf0fe62","authorEmailEncrypted":"fZebYnZv9IxA7HykXoEvpcBEJUuqf97R1zgGEDnF+mOWO/N42eBUhfrplnKz3Lm+HoRsZWXjH6e9YzsRoBegQ1i1vu5j5KYwKFAG2Vbncfd6FNHJPfW3A3eO5P9V4gNaEoa6hRxettpjEBnO1ucCeaERpR9SG/SyNjUfbXxxBkxmDykYc+4uNDSqUJaBjomRy3lvafEX7bK93W6s5wr3EwG8+O4o2AsDmbay2pjETlmlOEbperxDx4pS/9DzJytqXP1VA9aahB6Bkr3G3DKI7Uj3E36hlRZqPGPGjEJPIP+f7W5rA330Kt2pGsAvywAdpu0EDED+/A2ZviK5WnICOmsB8gZtzvcKnew3qKtdh99eo8mLtaV2QcH7fJY3BEymZ6I2LglBx0z8tn3UK/d7nW2Nzfd7FqsBGKZPWbp1gsDQvNkSezJvnB3i9olWhbEQIoj3wYHJwRpkKAI9o4yG2r+YHndhsE6tNQkZ5czkqXQsYM7z8eWXsr5i4HgDJ5MmIUU7kDC66XSGOPL4TT3+DAXzFwI4utsj78vS3uIDA92iqp39rJRt6hgVYhbWYhKNX8HmSRqit7/W6JiiM+6zJBhefrzUOZ/860M3rtjjNjpUhQ49g4a+GIbmBE8zTACTtrG7KOFM6B9dIbm4ddT2AXkv55incMyegTxuWzml9bE=","authorEmailMD5":"08f7976637ff7b2937883996406aab2d","authorName":"Ohad Tsamir","authorUri":"","message":"I see.\r\n\r\n> (at least for synchronous requests)\r\n\r\nBoth requests that happened to \"clash\" in my debug session are marked `async`. Do you believe that should guarantee they have separate `ExecutionContext` regardless of WCF runtime implementation? If so, do you still have an idea where I could look further in order to explain my observed behaviour?","date":"2020-02-04T12:29:54.232Z"},{"_id":"399b5a60-475b-11ea-960a-59ebe4a70545","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"0bc7b1d0-474a-11ea-960a-59ebe4a70545","authorEmailEncrypted":"TW90OjRzsZGxSdY/AqdZD9IuS4ZenbHzQn3pasMAbW4t09cwxXDISIHtqUhr2i6ABObqCwF2WLUlkhUy3OuDwjsnlw9d51HPnnpkRCxeFpLZfOSE2LIq46zpy42QHwV2APFsjZ0TR7uTPL5VRN7jglYRjoO4cxoyUZIw3XD16MCFOrfl90d4x+CP7qZfcHJ7drucbNH9ogi1cBWhWZpk96/v0WDvgUdiqC1IE+i5brT2srgWsVMfAUwdQnPpv1tT6EOhDa3t183ZWrgUvhpSZRYr2ZXlDRgvWcjLRusB7D+IfcQEq7r/5erwLdYu27JSgMu81DoBh0Ng3KRhsqO2VXz+aeXYQZTzOXRbtVnbwJAmwXKxrzMUy5cN3a4uTL33CtVtTU+xsYLWrSWsWdh/iAmsVzZG/h/6dJ7tqcTV+tFrqdNATfXejlx8U+7n7GlhQLtTtPgu/Hq3dRW9S2GiedcSF+FMiKYLHbeUy4TISgaCSNibpFZRD6lznbj0k6zZ94hDoK3PHQJw6uXAjYC85TDb5XN+klrkLHRoyMlBtm3E5Kc4XaVctdiAyH7VqAkRVXJWTMqwipJlQm/cvGf0Qc+C6ZsrzbM4V1FN7wFglxnW5xPoV4w8aByas3a0jIxJgYX99VC/ky1POKkAQsLttwhozDzjJ8tvByb19s4THwg=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"If your code writes to the logical call context from within an `async` method, then the data written should be scoped to that method. This should be the .NET Framework behavior since .NET 4.5.\r\n\r\nIf that isn't what you're seeing, then I recommend contacting Microsoft support.","date":"2020-02-04T14:32:52.561Z"},{"_id":"91451f60-483e-11ea-aa1f-e3aa3fdd1c82","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"399b5a60-475b-11ea-960a-59ebe4a70545","authorEmailEncrypted":"HbndPQ9zb+pgTZMA6HPQYVQfijqSFpqUk43lBfipVosJ7j8Yi/hFk8af2G6u1qADAOmHPuw+hlQuQ8PVC7OALzwj9vtKgt921VXd/DbTxYL7+InO0E2ul6paNVQHktxLJ64kDtcaEg7q9Br2zVEmQBpj/RMR3HkdY1gWb/Y1xe+G++x+DTFyRcDXZHnnttLOLRlwIGDISk49cRExZXi/DZifk67sV9zjsctLhBU/IhjVUOPDc7GWtRFmKhO5xp2/HG89enQ6+Rn06k4UMPHfM7gAJxIylvDfqrf/o2u/q7oy86Ndjb1sL0yyBi27RvprlDDcuB+pwuKOsQ6rRF16Ia5fJDq8I5xDXmDFSyZID+lksY1Q2ZAnr6ckHKaYuAmamCZ2dL0ueGwKlAtAY58YH8Q+dSQyXIkZ/ltJoo5qQ3XXbKvhD9OZddKZ5tEH5gjdnt/it3td06h2FAceO7reinK8gS76En4HDZbmSCxg5LLemlHaoYCye9pMhNv3OkQ3LqO8CKukfcrw7V5ju8VNO3ZymFGqoKL+k5VDAsiCxAxHrG/iy0cbf0KAAcoRCkinPYvudyR1kMPXoe+N1A79JWLok49rsBFuceaHuqGTm7pX1Wlsd2TIQ07Gzn9wA09g4jqvIZRkc7+SIZj06HlyyeSU75Et0dbUvh/nInoM8fE=","authorEmailMD5":"08f7976637ff7b2937883996406aab2d","authorName":"Ohad Tsamir","authorUri":"","message":"Thanks for all your help. I'll see if I can get a minimal repro and open a ticket.","date":"2020-02-05T17:40:15.443Z"},{"_id":"9e590260-a1fe-11ea-9f12-0313823397ce","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"36934a44-f3ed-37d7-bc25-fdca37729a67","authorEmailEncrypted":"r4KE5vTsRFhpulA5396f2gO6mABa+Sy05fXpN4FwRqED2bex9+gXTGvTQDe0NVh+fNR09k1f0K73En7gANNri0Iz2pENw2sxmSAZt2YLMQM0IMgaH3eq/P1lO3PXkN9FUflCtrMp5m/P0/y1GT2MdyVFwz2mCOnHQkhdP1u6T/0pbSpBQMy5AGiS8WbwPC0KL0qfjWWmyBz1vrmhE2q5685KvwPiOhomCHQMG5BgDypVHLp0EV+Q0GsG1YfTBE0mWuoiz/AwIx3W0P2GOdxI/JNCpggsK4aeaKKBHdw7AByfKawn1SG/FiHx0+qihH39B1CZVzlphgXHAzjw+oDjCeRPfwEGD822O7hKUogib/toRiGdLfNWezqk1+3Qa8FVROoBn9pyEyLBsqkpLUh0KEWHn2bANeGHNrPcvN5W6rG4BgfXJ+lkN7zbJKdDUECgRWBS5i+HdQ1xgN4sMqeyWkIICXv9D5oUNUoBKsrt4nf6glvpOzb8jqiVBM8vFPkF5SIbbxuqito3a4itzVd/irX1cw4qpOs+Vf5+gF5QpMFtzpuLQxbxudlRR42zU9fW1Ye2k61w/vUk9VVOEL8nPHJFZxb9Y+WonNEZfHguPMzFO9Z8jFEI1In+APPuqaluQoQUC3Tv194PWxxDOwxAEuJLtq5E1twLSgXsz196280=","authorEmailMD5":"8c13d58fcd1955ada6877e3d6140a33c","authorName":"Jacob Pitts","authorUri":"","message":"Hey Stephen, FWIW I found situations where a child appdomain would bring its call context back into the parent appdomain, which would subsequently dispose the child appdomain and break the MarshalByRefObject. For an immutable stack of strings (in my case, GUIDs), it looked better to just append to a new string each time, and then cut them off the end; thoughts on this approach vs others?","date":"2020-05-29T22:49:14.101Z"},{"_id":"eb9b7e30-a1ff-11ea-9f12-0313823397ce","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"9e590260-a1fe-11ea-9f12-0313823397ce","authorEmailEncrypted":"PPTQTk0w5HUV3JCCf7MFgLRirG6YVgsNq3qPYC7ysZhLv9/7NfXwbeWnmPkDVtB8qGgMCV0VRtyweIeDpSVBlMooFUgxOq9Vw1JBDxUjZfzS6srlmtdTw0fZRLlbhpRPY73t2e2ie/ul6FUYeJxQU4XPv0gvHkEmZFGKCwPCmjcoMgYNHRVPuKIBCQ3f6IZ+mM/sbEQTPtD5EJz+NfNsFFauyKR4qFk786xbMnw8467ME+k/6p2VuIS6p+mfjYhhJHIQS6WlAfvgDFKr6feh9KUjIWUla7ZCOSR4hcbKnzZCKwLg/6p6v4K3kcNaCYX8v4/h8Z2ymqHYrciJwstx7O1gyBmGs+nOZXkW+h9PejtBEYcOaV87MWldmsKSHkBdhIJw3lRO7w652oBM+/bHvDlDLhVoT3YarZxVZ8TsxcLXFrsMcYUAkjsDwjH8CQVgk9+jlaGMnflfEw2t+hJPsf+lfx94I+ku7vTRQbTPL64BAstE5UMOwJhBHs+InUzRrB8dL0JBvJPb0ppDIgNiPtf0mVd+wkvX/K9fHlpQFfH8q5ZYeZDc25Dae6Fdsge20egWgL8S50xlsgm8nsf+6qnC6PBQjaX4beKpkdQHu2wxXlzcOqYbzOaISHR3uqdYNklbGf6jMxftP8qJmUsDlFNip8hJ1FKB9VttbqxlcRs=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I don't know; like I said, I have very little experience with app domains. For my code, I always use the new `AsyncLocal<T>` type.","date":"2020-05-29T22:58:33.240Z"},{"_id":"30cee410-4fa7-11eb-a867-5507102e4024","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Yair","authorUri":"","message":"Hi Stephen,\r\n\r\nCan you please clarify how the copy-on-write works when tasks are being triggered by Task.WhenAll? If the ImmutableStack is shared, how the values are being tracked correctly? Maybe each task is getting it's own LogicalContext?\r\n\r\nThanks!","date":"2021-01-05T22:41:46.478Z"},{"_id":"17b9cea0-4fb5-11eb-b0d7-7f4815f9c976","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"30cee410-4fa7-11eb-a867-5507102e4024","authorEmailEncrypted":"GAEwiS7RD+1LVRwzrwmdIklU6t6UK7yxzBUUpDzKCyH46A+am5cSedcKFZ6qXAqgQH/8KmevhMGQHgRuR07OSIJHybPbI9Gx5YtzX8XgzKoW6IqZ2YQAMq2gX34MaCK4pdQed0FpCuAVzMDiRcK7uuda4rZ7bEEDgduh75VtGaGoFqCgxKFw5WYO6MXn2SgkgNmnuLY6ZX/0pFsHK1eg6qMg1CWhxOGpkPMiALbWqBWiBy37/azCVXC+omsQeIda5glYNOcRvRk185dNX2j16V3+Y7VjNToVwKwxqWHIDoCG66nxhssmNrUwA9OTf2KRh5qIADvrNjtvY0pFrk6p6aVWF2Jeyt868VeeD6beXT7bp87UVSGN8LLsE+SBzUQ7UDybH3TO4M70GcYuUAbCLq2M7MggC6GqJWp+VR3DBo7SFyCPEj3N16SmI2vLw2smVOz11K7ZoIRWwjhkqVb7h4hBVUtXBxxChLt0Om1gZJZ7kpaL8s0D85v91QWKc3QMRBvjdl802SENlLzye2tu5o2Bz+kREVudHOiUAG0/oHsmzsxpUdxxQg9XjK47HSOTJWQB5DXuCikcPHoY1y4hL4bBq3WS5AdGkScBbYcUjrpmnONImZMTGFZsp+7yVma4+w5d8sTqumjoGIGpdXQns7qPMr0/8XA33gilsSdHDOE=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"The `LogicalContext` is marked copy-on-write at the beginning of an `async` method. If it is modified within that method, it will be copied.\r\n\r\nThe tricky part comes in if the method *doesn't* use `async`. E.g., if the code calls `Task OneAsync()` and then `Task TwoAsync()`, and if `OneAsync` does not use the `async` keyword, then `OneAsync` will not have a copy-on-write context (or more correctly, it will share its context with its caller). So then if `OneAsync` modifies the context, then it will be modifying it's parent context, and that could be observed by `TwoAsync`. This is an extremely rare situation, but is important enough that I called it out in my [eliding `async` post](https://blog.stephencleary.com/2016/12/eliding-async-await.html).","date":"2021-01-06T00:21:17.608Z"},{"_id":"01cbc9b0-a33c-11eb-b666-538398651513","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"","authorEmailEncrypted":"RGOvq4tTqLOtJ1gYeHyqtBAmpRrc8Ic3EGs+yntknJKK2IlWvRaowS37bVdOFRSO2oeJuDyAuyexE/ASmMGrUjkdxQVxmxbyJFwqd6v7yytpdmEj0A3emX/peoMz1zvOt3usDObg2MRCG2MAL3OemSgCZTQOFX4peGor3+MFNAdQrw3I+/0IxIeknMbmyw6M8N37xM3+rRHiJs9xxAt2VOlxLbuRFWSdBCY6Ohg6t5SWRxSivyj+oaOvvw1MZdHXVsd7/1hkBeWIHoMi+xTDALuhou9AWlAUQN38LOcsCbEojyf5pzk9qO1AHlGBjhlzTihDlrbEDxz+jye0eDhykBHqWcFfiDPUlg19mLCfYHnG8tELaLCVAMXaQKNZckaBWyvelfvITXTNW42Alkc9J+mXzY6jhxVuGeZYjgXIQpRWyL5A/fGhnyKXWJNG8Ppq65X5S4aD4cwimYLpuoz5HST2ZqrMPKMs08pWq9xllKbupIBb+2iMnc2cI3sguZxD4yUDUC86rsWSwLMiNpLuK58qOChV1JbXzjlymXLWvyFfO0g3gxbWv40PBOwh9GPYchUrG+MbTYDT+mAVFm794/S1YU3nikYUJBQZOxn8Rro3lOLLMNvLPAHTxPuVOaVBmIZv72dodC/my39MjkdXMDf0l+Qq+jXq8j6y6a5ZBtM=","authorEmailMD5":"0be2d175837eede271b5a02849330850","authorName":"Melissa Wittstock","authorUri":"","message":"Hi Stephen\r\n\r\nGreat post!\r\n\r\nI'm investigating an issue where a user ended up with another user's cookie. \r\n\r\nThe following is in play:\r\n<ul>\r\n<li>Target The .NET Framework 4.8</li>\r\n<li>async/await</li>\r\n<li>.ConfigureAwait(false)</li>\r\n<li>static </li>\r\n<li>HttpContext.Current.Response.Cookies.Set(httpCookie);</li>\r\n</ul>\r\n\r\nOn digging into the code I found the following helper method. Try your best not to cry :-P\r\n\r\n<pre>\r\n  <code>\r\nprivate static void AddOrUpdateCookie(HttpCookie httpCookie)\r\n    {\r\n      // TODO: At time of writing this comment there were 102 live NullReferenceExceptions on this method in production.\r\n      if (HttpContext.Current.Response.Cookies.Get(httpCookie.Name) != null)\r\n      {\r\n        HttpContext.Current.Response.Cookies.Set(httpCookie);\r\n      }\r\n      else\r\n      {\r\n        HttpContext.Current.Response.Cookies.Add(httpCookie);\r\n      }\r\n    }\r\n</code>\r\n</pre>\r\n\r\nTo my knowledge the code-behind of HttpContext.Current looks like this. \r\n<pre>\r\n  <code>\r\npublic static HttpContext get_Current()\r\n{\r\n    return (CallContext.GetData(\"HtCt\") as HttpContext);\r\n}\r\n</code>\r\n</pre>\r\nAnd in your post you mention. \r\n<blockquote>The regular call context (CallContext.GetData and CallContext.SetData) acts just like thread-local storage, which of course doesnt work for async methods.</blockquote>\r\n\r\nBesides using HttpContext.Current with async/await being an obvious disaster. I was hoping you could elaborate on the inner workings of why CallContext.GetData and CallContext.SetData doesn't work well with async methods. Could this be a plausible explanation for the cookies being polluted across users?\r\n\r\nThanks \r\nM","date":"2021-04-22T07:26:09.118Z"},{"_id":"dd232160-a36a-11eb-bee3-87d89fd28a8a","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"01cbc9b0-a33c-11eb-b666-538398651513","authorEmailEncrypted":"scoeQNwI6iHC7OocH9C8RePDKuDjAXC9u/oX73ZLk+3xHdd0UYzo/TxJtsuRos3VvFx49oJSZ9o+4Q1+iOmFPjav2JIdF3ttEFHLSSAUvXMoDIE85rbPNk4eibg+EmgNkZcenAd3YOHMMaXfOoTe4DLMfEZhfxvIz5bnHMd9fLSytnRTVAoXOKHuIWrGnkT5Mo4IxG9+KSmLKy4NNPYueeV5N5HdyIBR4rUofTK8bhLUND7hHR2OQzCj1WQ4Q0qJasUbrSXAlJsCqJhAkrLivPBMe+3gM5G++JQw9GQ/WBUXaIc05jPsvtDCSa0P5cJoa64g6GQDZzUs6yNb9ANybmiiewGVTMjHz+Y+/Fj4hs1lREUic8ZjqpiV68AWIkRTmvNvEbOcDscjGXwMatA06D3AWl8CKQ2svtOO8/NYJ5n3TOMnPBzEtTczieC1CoDdK3pljeRVcTUYOBXf1NWaKO1N79A/r+nFkaaA17q14zg2IYP6TwyLs8kjvENcVWhK1RCkYA91bxRYCmq1w/a/hPmHCxYQT+kJCTjWPc5smh9ksRN9cR9T/yH78G9lm9tIpk1oixxrz6hn/qq5hrOZSYuQlZqU8m3ptJGUPPcp+kHPFdgiwKEqhstJkKrRd3H9Ve3arMHAsMmYwm5rEgSRwbef8PRxfCzy5duPQw9/VQo=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"`HttpContext.Current` works fine with `async`/`await`, *as long as* you've [turned off quirks mode](https://docs.microsoft.com/en-us/archive/msdn-magazine/2014/october/async-programming-introduction-to-async-await-on-asp-net#before-getting-started). The first thing I'd check is what the type is of `SynchronizationContext.Current`. If it's `AspNetSynchronizationContext`, then you're OK; if it's `LegacyAspNetSynchronizationContext`, then you have the quirks mode enabled and need to disable it before `async`/`await` will work correctly.\r\n\r\n`HttpContext.Current` ends up here: https://referencesource.microsoft.com/#mscorlib/system/runtime/remoting/callcontext.cs,94 - which does read from the async-aware call context (it's called \"illogical\" in the source, which I assume is a joke).","date":"2021-04-22T13:01:33.967Z"},{"_id":"26756c50-a803-11eb-a8db-f9080073290d","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"dd232160-a36a-11eb-bee3-87d89fd28a8a","authorEmailEncrypted":"WwnLv097Iyup32k/58W6lrxOHtwcfCg+wlDZfB4Vqpu6McOUdgsudgJP+95P9mrx9NM2Dp2oVS7/62hlKNMmKJncFlH5vP5oorsVuZ2LcOR3NKTdQeUYbHcOYZ1w/LOOQ8RfK1dwxnDB5GC8m9fhmpfBxxzzO8L4liUwm+GHi4sKKln+VPykNZA+lTrFO+CrkN6d1Ak3XmLLqkXpn5gUkkMmp1Q9vNOaqJ/kwfeoZCqwfzID0g/HFwoYTN8c6rfx7IQrRvB9s9nkJZaW8YZFYoJjdVVzjlTl/4BAs1E2rMaslliEUyIiFSBMprCwmFtko6NV/9hs8+5WWNzs+k2oYzYEQGe0eF9aFfDlf1AF9Chbb/thlvHe0lZCSUjYz5A4lsJTQf2Cd7MTLmlmOiq66mgKFotC/gCJhMYYnLc8lJF3nAFgT3WYiZMGMLpdGaewAbtCK8PVxwBC11pTJN6N7UZkjltHHEqOf+/lGsB4wr3WQ54KWp+e0RxaF6VnyPjpfxxoPrx9ISy4a1Wt13cN/TWXlmzuSoSrlQXng92eHzMt9PsLvDNbxGlvpeNiyL8wbRxbSiJYziKnzA3IDnf+zZd69taWBjj7Ma2Yeiv/dxU3ekGjUW3+qdEkDZaJezaExw27Gk9fL2uqueJeaPqYT4AHXHyTLFdlMmQlJBb78ao=","authorEmailMD5":"0be2d175837eede271b5a02849330850","authorName":"Melissa Wittstock","authorUri":"","message":"Thank you so much for this information. It's helped my understanding and I think it's safe to say, this is not the cause of the issue.","date":"2021-04-28T09:21:45.509Z"},{"_id":"0ca8d050-ff3d-11eb-9da6-05199e6c4945","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"91451f60-483e-11ea-aa1f-e3aa3fdd1c82","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Ivan","authorUri":"","message":"Hi, Ohad, Did you find something? Seems I have similar behavior","date":"2021-08-17T09:25:23.742Z"},{"_id":"1d6cdab0-aecb-11ec-8467-018cc2850665","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"8f4afff0-ae70-11ec-bc16-2dbe46c5cd1a","authorEmailEncrypted":"EWqIBnFDrwxycqsy3KbAC1Y50Kg4SrNENZdgA01m4a9UKfvi+thTGBAJl+vfPtDa4VvlhXoV+iwzUslZOFOzoFRMSbc6g2Jq/JZ8DHvwflcDF/9z++mPaldGYDm2026FfjagCckhdmSvmbYiNRg9k2ej2tKN8cfGDZN9Yc8xvS1o4Q8NvfRfZlwiNybVI3hl6slw1zRUlUnCY9uxH5691sQfIINv63G8Iyddlk21Zyxkbog3cDlY6StOANdlLIu6NucbM0NEiKLGlMjozUQt2Rw4ZN+hXIh7wIj8F4wsT3//jHE8Ei567MGdDmeuj20BvY5Ro0edg6JMnv2eukLesYR/gqGtaUPDO/1DaZEfsTvVL1PKuTDshsfoEn7H0HSX2f3afJb6EhRiWU3WZLO9dzliuGImptXM7oXmTVeYfBmYsMiqMBU/9p0v+ikrsIfe36eYmA7mkKoLARbdM/1KTltQsm2qkfBD076M1jr4jSd+SaN9bT2JEYy41HyxRBeTUnaRu86y9zGkVCHtYk2KnevXxnqCO9aW5ohIbUNPGHAPs1AMxmqriqZTe4JZOVuewqg8amSMeRERBih2svGZKzB1OkjWSFtJBhC6O6oKmmMm+NTTHSQ/Iex0D6l/Q6kV9eCbHdtddkGPAozkJ0kHOXObsnFoYMkqW4Ppq6Jctnc=","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Each `AsyncLocal<T>` is logically a separate variable. If you're familiar with thread-local storage, each `AsyncLocal<T>` is essentially a TLS \"slot\" (except it's async-compatible and not bound to a thread, of course). Or like a single `ThreadStatic` property (which is also `static`).\r\n\r\nSo, taking the `HttpContext` example, it makes sense for there to be one \"current `HttpContext`\" variable - which can have different values based on what code accesses it.\r\n\r\nUsing singletons is generally preferred over `static` for unit testing reasons. During runtime, there's no real difference.","date":"2022-03-28T19:13:13.892Z"},{"_id":"8f4afff0-ae70-11ec-bc16-2dbe46c5cd1a","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"","authorEmailEncrypted":"TapGEbrXaB69BUyepbNP4fhcQnIY0oi6QsSFmJ+LLOss64qOU5Y+JEuE1iD1VshJ69k85SI7jbPZOuFlvTC1rRIsAvjUoXJVwnPGYclz6PvfhpiTI43TjLOlHYZIOc9faYy5ZrAr8m9Pyp9Na2dH7tiBdBLk+0gZ8t1Y9CG95y1UXr+PoVYjqvJHyosAxOoVzDp1u977lhWw/mZSIryaUM4CHiGsEy0r1onkcfaixihSiFnjPrE21mq88I2nuquqyTib98tTdH1Uq3WGWD2Cy5zOXwPJ/fNQgHCEcyQ+JmVKXK1SFwFHBT/Etk5dVAVoJjgJbm9yw7DoaqtwjL2IAIb8upja3qCsfjR1Jx4TkMba6i0mcOGy+fQWKNFPtJNMo66mdwPhqCFDQAA+rVLDJvUFR7aSBzQ5VJw0Zu+0Fj+g7VYef/Al0Ib7c2+bRfbZoHk3UKqwaoL7O54CrXZSnodMJWNhxzu48vkOfX+wU8G/a1Za00UWG/RCpXfQ6F9VsaybReRsfsb7y/ICa4povsB7WwY80zLyXvWAe+4hPKUCVScKlM0+FsbWZujPGt56Y1bubyMVZfZBIGxKCkp7kP7V6RuR7jW6LIwG4EImmHqK0kUlqrGQIhHWvPVoO7CCfxDHQO7Qzi8bWe0sDmMypepPO37isiWyuQeXl9dXZ0U=","authorEmailMD5":"73297e3d31d61e97f2dd9e2c1a554f78","authorName":"rioka","authorUri":"","message":"Hi Stephen\r\n\r\nThank you so much for creating and maintaining this blog, you've been my lifesaver more than once.\r\nI'm trying to get some better understanding of `AsyncLocal`, and I ended up here (again...)\r\n\r\nOne thing I do not understand is: why is `AsyncLocal` data (almost) always declared as `static`?\r\n\r\nAnd (somehow related to the previous one), if a type is registered as singleton (eg `HttpContextAccessor`), would it make any different if its `AsyncLocal` were not declared as `static`?\r\n\r\nThanks","date":"2022-03-28T08:25:00.818Z"},{"_id":"43f0e380-b02d-11ec-82e2-516ed88685ae","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"1d6cdab0-aecb-11ec-8467-018cc2850665","authorEmailEncrypted":"QwuqCs1/xACBqwnIWRZ72sOJ5DZckRCPLPPCv+9fAxe6WLnGp9rJT++CCpc9AFjYbxJafelouKEGGE8ZKfYS0PIPTzQlwrfwxS5UojWdexkjmmam422WjcAxg8AzfzE8Y7l46ZtrNZq58D7WzpwT12mnxDyCZykEGFZeu8JYsqEHwaw+XLoF1zBzdE0uHqLmyTpVa1I6VnIyYLUuDslYcE1fyh5skOy0vViLGAQQrZx9qzibgiG/LHRSNv1LI44FB+PfIxhO2gUIJsg7yq6u94Zm10WhdNRFolmTm40Rbcon3lK1JxOAlQlHx38R/kBsES9mn9/yiZ97AgE2bcDrp7aUj+XkoKXhiE+PfJTc8sKfo+nHqYxfTi84Jg+tNo/hsjx1YtikDr+YjnHiB7+j7RM04BpyArOyKYjG0SGrUQTPLfiN2N4mTvWXHDCjtFGSCnQ73w143BawTbEg+22V91oewrhmScmyurP1ciuqJ7hqT6b7gEcDFq8qJ+UxtXZjQWBneLglQFvQzS28TvEN/MsiPNvwXiBkQqH4NMbj+4f41ZiVkOBknwj92G0SPegT3/gESqOnkQNgY+KuktgYq5v8swDJ7VnE0jl7lpcvH6KnOFIdbxicGRkEi8CKUxfUoOwfvxFXLOFy0JllSIg/J3asHOpMr8ptmj7YRKRlX9o=","authorEmailMD5":"73297e3d31d61e97f2dd9e2c1a554f78","authorName":"rioka","authorUri":"","message":"Thanks for your reply.\r\n\r\nStill not sure I understand the difference, so let me be more explicit; looking at something concrete, ie `HttpContextAccessor`\r\n\r\n```csharp\r\npublic class HttpContextAccessor : IHttpContextAccessor\r\n{\r\n    private static readonly AsyncLocal<HttpContextHolder> _httpContextCurrent = new AsyncLocal<HttpContextHolder>();\r\n    /* ... */   \r\n}\r\n```\r\n\r\nWould it be different if the code was changed this way, ie removing `static` from `AsyncLocal<>`\r\n```csharp\r\npublic class HttpContextAccessor : IHttpContextAccessor\r\n{\r\n    /* static removed */\r\n    private readonly AsyncLocal<HttpContextHolder> _httpContextCurrent = new AsyncLocal<HttpContextHolder>();\r\n    /* ... */   \r\n}\r\n```\r\n\r\nThanks","date":"2022-03-30T13:28:20.324Z"},{"_id":"ffbf7920-b030-11ec-82e2-516ed88685ae","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"43f0e380-b02d-11ec-82e2-516ed88685ae","authorEmailEncrypted":"RXtjigRTDzT4y5hCA0LSO6uGmKgkTA6ImkW6agpaJnQn03eb9JFQ3qzEC/mB2ZRsfRSuY8irRGSCfOmspr/RuXkA/RsEkAaStsFn2Nu2KmGzZxINr0AcqjpN8QAkCXZEL2Qyjb+A199AndACqc0Mg0pYW/SWVuLIMSAOHqR9mhkHVG6uvfkb2Js/EA8bv/ybrzFv/XC+l15WwQIfBy0fbAF+ZQsE5IyuvSRuqUVn8O1ek0Os4zeBWNJIj6udThd+34op+XYh6bh6SAZvXuvUAK2bwKgZrTzEN9PI7Tdea+JtiDjM6nZT+jkZpivhiic7KXnijBs0n4aOgJ2Uf/HaDoxK/fdpaUrkMwsAYFKYiJwkR7QLjMVHnrXTYwaBSJGbaAclO20GavLeaY2CodxYb6RKqFnX+j78VEAQy6FxYgS2CtMeKi7lhnNBJvLV9ergozrzII1WauTQ2ZQk37N13VBWyIhN8gQD0W7MRGFXCG0bI7RH36BsR11z8tdnjFxLz3NW9NKtkVOmbWJ6fYEiPRD4ZbeGDk7ZJ/ipgIua3eVYX5ymNsZJmamdGUxqNUaZvRurefn5Vy5gM1JvLldj5aGWeBlZJs6ZYv8vgf8LoRBNy6xdW+SVMddJp9kvZK1Z6eTPwm0hViFwcUfRFEyfDtyLpS0Lb2d3Dan8YZQE87E=","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"If `HttpContextAccessor` is *always* registered as a singleton, then that change wouldn't have an affect. Previously there was one `AsyncLocal<HttpContextHolder>` instance declared `static`, and now there's one `AsyncLocal<HttpContextHolder>` instance per `HttpContextAccessor` instance, but there's only one `HttpContextAccessor` instance. In both cases, there's only one `AsyncLocal<HttpContextHolder>` instance.\r\n\r\nWhile looking into `HttpContextAccessor` more specifically, I came across [this comment](https://github.com/aspnet/Hosting/issues/793#issuecomment-224924030) which claims that `HttpContextAccessor` won't work correctly if registered transiently (or scoped) - it *has* to be singleton. Which is odd, because it's using a `static` `AsyncLocal<T>`, so it should work regardless. So I looked into the source code history and found [this commit](https://github.com/dotnet/aspnetcore/commit/622d112372ed11075af160b1fb5a11a7637ff516) where it was made `static`. Indeed, before 2017-01-09, the member *wasn't* static and so it *had* to be registered as a singleton (the comment claiming this is from 2016-06-09, so it was correct when written). There isn't much in the commit explaining why the change was made (it links to an unrelated PR, possibly due to a repository merge/migration); but if I had to guess, I'd say it was changed to be `static` to *allow* non-singleton registrations to work just the same as singleton registrations.","date":"2022-03-30T13:55:03.889Z"},{"_id":"f9e722e0-d52a-11ec-8709-1bc3f7e870d0","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"","authorEmailEncrypted":"RbctucvPWQnHKe25c0NAdestKdQW6JO3YmuBFVHYu5WFFBRbK9NY9meEUrt+AKOypqwstgYIxV/rnRDKW1h++irn08s9/rnGjOIA1bny3zq7f6OQHH7tL+nRdsyOD9NPJ7E6JnAoFulgtvMe/lKRVNpOGH7danXWWz/UCdM/Uh7/cWVXWLkTaPZ02s59mZ7HH5W3p+DxMdeHtz3JG0tnV775W2vhnKv98gO5VTw1oUNBuFxerLUhzkEyjZ6q+GcaSCgJmzy9RJAse1SffhVd3liW1WgaUsz3LUdCIu3sH+FyouNMsA+WUWZzCu4JDmsMufZyML70lcZ7vd7N1qK3Lp0m5Y6wGMRCN6ADB1T4niOS2PkDD+bfiiTE0j0qfQD7GQvUo4spties+woSx/5FTmuC0RSTbH67lIShREF8yp1stTp7nQp2X0Orp1NAHaijeDCdl/EXfTCDiiHGcq7tSWWL3fglAO5xh1pENuk1oHx6d427ewLQkRRbksASnOe9ZN3b+roZuaFIzM3s7eZrlqAnuDOQfE7A0uHKjVH6Gfhh2CCFi5FUqmrzg1AIPvIEWkvri/q44Bs108Vbpe9tiP/UFXj6MnERoqIdSHEvVSX3raPyRhwJNN49Bb25PkYZERuFKeLY7FY3G7xrgZUDFqtjPngRD26oCjo9wAyL5XQ=","authorEmailMD5":"0ce37815e3d6a4cf1f701966b941bd89","authorName":"Liraz Shay","authorUri":"","message":"Thanks Stephen!\r\n\r\nI would like to suggest changing the usage of MarshalByRefObject\r\nand instead, inheriting from ILogicalThreadAffinative \r\nas MS wrote in their docs:\r\n\"Only objects that expose the ILogicalThreadAffinative interface and are stored in the CallContext are propagated outside the AppDomain in a LogicalCallContext\"\r\n\r\nhttps://docs.microsoft.com/en-us/dotnet/api/system.runtime.remoting.messaging.callcontext?view=netframework-4.8\r\n\r\nhttps://docs.microsoft.com/en-us/dotnet/api/system.runtime.remoting.messaging.ilogicalthreadaffinative?view=netframework-4.8","date":"2022-05-16T15:15:10.158Z"},{"_id":"1e13c770-ffbc-11ec-8278-c132177ae00a","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"f9e722e0-d52a-11ec-8709-1bc3f7e870d0","authorEmailEncrypted":"cW+Z0Fv8sbeTZrLJIfYdgiM1j6Q4uSNZDxX6KFXG9TM0ACPZnfKY+54t3udla4Io7cS19ll+ien2ZaTP+VMcnwLuhEldA19sgTInsNghrEHz9HO+kIf0dT7pQOlF9Zje9BzmQslqICVJvCLgff9DA/csBIWcIysPhdG9360hLNRONPLwpmlIv8Za3OIO/I27BDfP69qwbRMb6rdNHgdhxJiCwIiJ4v7p3yB0F/NPCNzZmLBShnP/oZThMWpDNGaxl9SvIUl2wsZbXCpaW/TzS2AcquUlPdKjxYK423qd7uMdoQzvEq4uuqFPVzBnDiPe8kVvUeB5o8vgqJmMLqDQFTlwkmuMtGrqLoa2tNHHtbb/2HL+/OAaq/HChbOiNKitLMq3F5SrhSRW4117tXd2DK6ensSsezsY881p2fc592TJA73u7kiSUC2dyKspJlstSbUgLRWHiuQ8kxZqFq9cn0XNvxgqN3eBUDYtJcC+zdY4neXp7XCRDGTnMcYvSdgV7YD4TKjyGTJApk4w/ZCN0OFFFYOYHTILVKRkI32+RwRhuFyZW3Azt2G1JXszEYXRHdunzgzjlPT6IsA0K6ecbJ8hFt/ij6yQ+92dUx2zuCWN1lm4uDm1Ez3+HfYK+FpLqNIXpr2AvaqfW5dbfmFQK+kCJATOPw/qKYhxTd1bWfI=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"These days I'd say you should definitely use `AsyncLocal<T>` instead. It's a type in the BCL now, which is nice because you don't have to deal with any of the logical call context at all anymore.","date":"2022-07-09T19:19:56.649Z"},{"_id":"f31382fe-9644-428a-beb9-e6921bf2aa8d","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Jesse","authorUri":"","message":"I'm trying to use AsyncLocal<T>/LogicalSetData to get a correlation ID into my logs. It was working for trace logging, but I found that in exception handlers, my ID is not found. Are we transitioned onto a new ExecutionContext / logical call context when an exception is thrown?","date":"2023-01-25T07:27:54.1014390Z"},{"_id":"08ca8437-1a79-4fd5-8899-f73b9066be0c","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"f31382fe-9644-428a-beb9-e6921bf2aa8d","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Jesse","authorUri":"","message":"I think the issue is in my implementation I'm setting the AsyncLocal or LogicalSetData value whenever the first log entry is written during the request. This can be well down the call stack but the exception handling is occurring farther up. But the data is only copied (or \"flows\") down through the ExecutionContexts, not back up, right? So I would have to initialize it at the beginning of the request or use something that already is like HttpContext.Current.Items.","date":"2023-01-26T19:28:04.9666213Z"},{"_id":"1ebcfda6-3da6-471a-afb2-db28dbd09196","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"08ca8437-1a79-4fd5-8899-f73b9066be0c","authorEmailEncrypted":"YtA2Af0HMeMlPZzcIO+J7w/AHTSVvuH+Rdjaf6F59J83z9Ld3d7aUbtLJcDMiJ1qwAq0Xr3NwX31Zni3YPppt0HpYQyeJoVTlSmwTuSKFGgWioNsgu5W86zdY4EconKfwRBgMLPBrOEB9CejqkRB+O4KPMCOxWXTwiEG0+RgoKOJZCuNOlrSrRFYJbKQkT4ZMYVH6pYRPrQWwfwca9Jp9JKRBOjyCIGD4T64CPbgySOqRl67ThBN6CegL5vdgb9h9HwuDBmlFfHtA8Zg/DYvsc9JLMcMg1Z8iymV35i1UQ1DxjFihwc5UfQsezCX8PQVSLtIsjvLuyevtQGNPckGIP+Z1RA16+4LxnPwqdTEbFRebsxD9QSfGAm221psbEoz5SjwxeDyV15Pz0kYhLxxCEo5eqfG0urv9zkApx7+B/mSEwJlX495180oViwqiaoAMQvg2GFf62L7dWAGbnKGnelIGNQQEOgjvUPYri987RiHUZJ0jhrgQIXnoMroSXUZj0wbiMHnJLiEnYwbFf3kaBSbIc8mNOz1IPgX9u2Q+gH7ePSYxafXg7V2DsLqL+MY7lRHA5c5NCsGhnDwK+3FOEdvdGYb47HRztH8KC1ctyjrR/drIRC+uyOLEuzGADlfhuDewFmQmkyznC0nIUJuUiffU/+7aV/oTMqI/fJr7jE=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Hello Jesse! So sorry for my delayed reply...\n\nHere's the common problem with exceptions: what we *want* to log is whatever context is current *at the time the exception is originally thrown*, but that is usually different than what is current *at the time the exception is logged*. Exception logging is usually very early in the stack of operations. This is true for all apps, including ASP.NET.\n\nI have a generic solution [here](https://github.com/StephenCleary/Logging), which uses `ILogger` and ASP.NET Core. Unfortunately - due to the limitations of Microsoft's logging abstraction - it requires a call to `BeginCapturedExceptionLoggingScopes` at the point any exception is logged. This library works by installing a logger provider (just to track the logging scopes), hooking into `FirstChanceException` to capture scopes at the time exceptions are thrown, and using ephemerons to attach that scope data to the exception object itself.","date":"2023-01-31T22:50:59.9185656Z"},{"_id":"9247cd6f-5960-4b82-bd4c-a0618451ad0c","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"","authorEmailEncrypted":"BbYlr429LxSny7mnThdXd1Umnwkqk3L2O5hHz+cZit28/gegRlgQAhuX67KTdJ7VbfRvLtZcdn8TEkGTuXtxTpQ3V8oBgGuYicll5bbF/Da11kFta2LU5JldkR9chzrNF9bst6bhoyyQ0YOKtaUTugVkrEne+KH3vnt6G5V4jfm3VzmbKZhiXtfEZEdn6v2hpMXiOHaebFywExyHtu2zmEkD8oM3mwMcen00/7NdV0Iif4ZrtPWuzwjZoTqfrGZbiRfz9K97cUumm2iQ+32yVdmcbzU98gyLqk6Fiepaa7ch5F0sTyTJfV53vxSDCJxGb3rYbbOLRnvzWY78POjrDg4vv5EdgNLAkIjA/TLoK3YM5utV1a09Cs37BYE1QkpySGMgyvbpHnCbpXNlI5Zx/CTwyYbMLgKBp4rGesbAuUZv24T6fzRpQxsm4oeocmtprZ97KljIrA2/r4iqfP9v7+5ump450d8SLmjoZ+ktWx6ZiKcS8dZLZt+jcDYvMjdBPrDvuscZjv9jNiloP/18UMQ4KlrAQX0W5IHhCCmV+OKniDT0sNGaaAXe8XlrZmgl9tDix7o0G49NWC3T5wW1q1Kp0HZmao0GTaLCavEFUlthTllRo1dQhfDyWZQkA9T75pdh58aHhmR/WtbAsfBwXYPzcGycP1TlbCne/M6defs=","authorEmailMD5":"d82b2d063193789f9ac1dffc0c36f0b8","authorName":"Glaucon","authorUri":"","message":"You save my life","date":"2024-09-25T15:05:27.9970166Z"}]