[{"_id":"9323c408-5fcb-3aec-86ab-8d3e91458508","authorName":"CommonSense","authorEmailEncrypted":"H29VhBzukfaBw36zhFP7IZzn+HCqxahs8/JH2jp66vLDz74tj5eH0GP8FYu4CIAWsxKaKC+c+ifav5qxeUyMrtNKAYoDDdx4e6dnEgz4Eu/QCaidRE3AcWYWT/QRC6A2grhEHxREe6BD4ilGeEQf7SkchoBow8A2B5nPX9h5UWUlYddYqdZgZ0gyD0HqiHpqXmYfPak2crecJ9ump60ZoebnCmW6ej1VsI7WjBGvomaeXl0ia/ivAa7Q+F/Ci3vy3buhTeupZmwnxt8npN+XJ8qdZmQhjDIEHB5m5B/6m2S2b+38PT4qCn/lt20inELsvoHRtjv52xg8kpB9a3vrKO8PqJRxiCMf2wWM6fuXDVPxJAcJ35i+4hXxssuUAOHgqVti3MtJuqyDefr6Lpznyk8Ql3gVAUysfQWg3AUcQDL4FcncE+zO0Ki84YDm5hENbui5StxUhb8PgRNHQoG2iXfxvM3B0nMnOD5qqI4TftsdOKza6tu7D9/ZCrj8OgmH07J/xfrXkhTTjPCWbK64zxZW5rh/la47QrHPUOCgr3AToO9mqRiJELmx3fpcjThs3eCCUPSSBwR+rWUHvdqKs8h3hQmjsFdZt4mdGzbkN3+B7Gsi7PaEEfxZIpe85oJIzuL3BlVqcvRnnUbwkeSUsj1LL7ydRsy6r5m3uQoNe5w=","authorEmailMD5":"18e162b93d134ed78478bd0c340dd1a5","authorUri":"","authorUserId":"disqus:InspiringCommonSense","authorFallbackAvatar":"https://disqus.com/api/users/avatars/InspiringCommonSense.jpg","message":"Hi Stephen,\r\n\r\nSo, let say I have started two running tasks, and use ContinueWhenAll on these two running tasks to aggregate the result. Then, I wish to start new tasks to process these results.\r\n\r\nIn essence, I am wondering if I can attach pending running tasks after ContinueWhenAll is completed. I tried it but it can only work when I wait on ContinueWhenAll. But, this locks up the program. Do you know a better way ?","postId":"2015_01_a-tour-of-task-part-7-continuations-de3f4e98-d7b9-38d9-b8a9-e608dcf2d0c1","replyTo":"","date":"2016-01-05T17:46:20Z","timestamp":1452015980},{"_id":"61f6ede6-ef35-3e05-ac1f-58561306966c","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"A \"continuation\" is just a task that is started automatically based on some condition. So, it doesn't make sense to \"attach\" an already-running task as a continuation.\r\n\r\nSince continuations are tasks, you can just have the ContinueWhenAll continuation do both things: aggregate the results and process the results.","postId":"2015_01_a-tour-of-task-part-7-continuations-de3f4e98-d7b9-38d9-b8a9-e608dcf2d0c1","replyTo":"9323c408-5fcb-3aec-86ab-8d3e91458508","date":"2016-01-06T12:06:00Z","timestamp":1452081960},{"_id":"9963e709-7ea6-3c18-b09f-3d39b054d8f6","authorName":"CommonSense","authorEmailEncrypted":"AkQyEC852lrbDRAQylto8PZeGjEX3FIIQ3NB5ZOENES5fpxo2SvdfYm+YH5elYV6GPNBx3L71UKzGmya376NEq2sVw8bMDBcfuRX3LCo2JiPH5KFh+dMte3tU9fyD4KyjBsUqbADjItaGaNZf80ws41kSKv9MyGueJneqBmFKZqzbiRSY9j8fB5eTH447wKLZrLrQeQIIpcbQqG+RDYosVdMrIToxSiOYvE1IZu5iC2wT27FTRnD+n74V2oNu3jwshm6B05xqwIRDOa7aeZvLh7YIgz2Jbue22Sk4Vg02JXYzj+q6jCyqWPvkFnvuUbfAh2dGEioHDtSEC8Hex5fz2BczXety3LXdQCoVmB3f3TWJ1R9TJcK5FBhcqUaApCbGrojakVcHETpSHbtSXQWod4WJ2pzn3quTr8L8kWXmcWTEEu1GHvi4Vg6ddwX+xyxcpgRKdcGL+SraX7JB14hmcyPakE+5lBA4CZPptnNGoJEKaFbGFnE3nkoQG51KNYvVHkiBC0HtI/PylxiSO5QuSbpm612ddouCFoQ3FbXDQH5+OMZhxx6u+e9He0kTWjefFzvN2vhtEjm1BQ3/xlQu5JbEZo48EshMC8q9ZnyDvpR/73KKSElsMJKhcl8uacT5plLSei7Z0BojknRHlh8pXnfvVDArD/Zpj/0DJyBCwI=","authorEmailMD5":"18e162b93d134ed78478bd0c340dd1a5","authorUri":"","authorUserId":"disqus:InspiringCommonSense","authorFallbackAvatar":"https://disqus.com/api/users/avatars/InspiringCommonSense.jpg","message":"Yes, I agreed. But the twist is that I am hoping to spawn off multiple task to process the results.\r\n\r\nI have posted a question on stackoverflow -\r\n\r\n([http://stackoverflow.com/questions/34619062/chaining-tasks-with-continuation-and-run-parallel-task-afterward](http://stackoverflow.com/questions/34619062/chaining-tasks-with-continuation-and-run-parallel-task-afterward))\r\n\r\n. But, I have yet come across a viable solution. It's rare to meet an expert on this subject, so I am curious on what you think I should do.\r\n\r\nThank you.","postId":"2015_01_a-tour-of-task-part-7-continuations-de3f4e98-d7b9-38d9-b8a9-e608dcf2d0c1","replyTo":"61f6ede6-ef35-3e05-ac1f-58561306966c","date":"2016-01-06T16:00:28Z","timestamp":1452096028},{"_id":"0f5dcb86-f8a2-3fcb-9673-3cef27edd19e","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"No, I would not use ContinueWith here.\r\n\r\nYour existing code swallows exceptions - which I do not generally do. Also, there's a Task.Run wrapper around an async method, which is quite odd and merits investigation. But if you want to keep both these behaviors, you could do:\r\n\r\npublic override void DoViewReadyCommand()  \r\n{  \r\nbase.DoViewReadyCommand();\r\n\r\nDoViewReadyCommandAsync();  \r\n}\r\n\r\nprivate async Task DoViewReadyCommandAsync()  \r\n{  \r\nvar result = await Task.Run(async () =>  \r\n{  \r\nvar accountManager = ManagerLocator.GetAccountsManager();  \r\nreturn await accountManager.GetEmailAccountsAsync();  \r\n});  \r\nSetRegisteredEmailAccountViewModels(result);  \r\n}\r\n\r\nOn a side note, why not use async void for DoViewReadyCommand?","postId":"2015_01_a-tour-of-task-part-7-continuations-de3f4e98-d7b9-38d9-b8a9-e608dcf2d0c1","replyTo":"e8221b81-1862-3b8a-916e-165b2d478b50","date":"2017-03-17T16:40:45Z","timestamp":1489768845},{"_id":"e8221b81-1862-3b8a-916e-165b2d478b50","authorName":"Stamatis Mavrikis","authorEmailEncrypted":"or/2Ul2Q0T+7Abwc4UVlOUGXRRwZlVBebxxzxpGrIaD6nYQsZ5PvEbkKfPImBWJoPjh1D+U2lOugMpmh0TilLWvN7yaw4GUcCfbjTvesAscSkHF/d9m7uKozithka3JCaUgZmYrxuHcALAin/LpcUTHuG9bqzQUIuffrhHG/4oJIdNoYJzqjrK1ZK7uV8knKC/DqdUekQlmtCSjcUXoD+M/ryTxmBUMghc2SdO2pBdirIoXm9sIckzxxcT8Ef0pXgn4xKYgeY5Fa8rIB4W2avrXr9jr7OhaTAS7pf8UlL9Z2O/KJaRZZVtvHwza/r1hQuEtFUbstSR76wxWcCqkZJ+4kf439dNlxdYi3mV3c15fl0ZTipcPIdFimq4bqv/AKKtNLvxRXSFSySWODBHQE4a5lloneUoOo7mO7gCSF34DVbBeH/yrx6Kc0fvLXWzh9DYSxTV5uN6M8DZIrg36e1fNyun9jpSR2bfbRTvB6qXxWG+jrT3pLDJU8T9qzK5VXUyZeXf6T0ZRIEf9+kl7sgl+r/azdMhqQqJKPA2fviUkWEdH++0yp1YCPH8RiGlRj4Xfq742SZ+YFrfUya0cMbOrtOjzQ8NnfFlldsXP50N5MIGWnnUglBXq7doXJIPPDZsK8lqECUlYH5iFynLRE6A9y3tpJnAQ5jfFwhw3qoZs=","authorEmailMD5":"adff651da65bdcee45b0be31824f43b5","authorUri":"","authorUserId":"disqus:stamatismavrikis","authorFallbackAvatar":"","message":"Hi Stephen,   \r\n I am working on a Xamarin application. Inside a viewmodel:  \r\n```  \r\npublic override void DoViewReadyCommand()  \r\n {  \r\n base.DoViewReadyCommand();\r\n\r\n Task.Run(async () =>  \r\n {  \r\n var accountManager = ManagerLocator.GetAccountsManager();  \r\n return await accountManager.GetEmailAccountsAsync();  \r\n }).ContinueWith((t) => SetRegisteredEmailAccountViewModels(t.Result),   \r\n CancellationToken.None,   \r\n TaskContinuationOptions.OnlyOnRanToCompletion,   \r\n TaskScheduler.FromCurrentSynchronizationContext());  \r\n}  \r\n```  \r\nIs here the use of a the continuation task valid?   \r\nYou do not recommend using ContinueWith. Is there any way, without declaring the DoViewReadyCommand to async void nor using ContinueWith, to implement the same logic?","postId":"2015_01_a-tour-of-task-part-7-continuations-de3f4e98-d7b9-38d9-b8a9-e608dcf2d0c1","replyTo":"","date":"2017-03-17T15:51:11Z","timestamp":1489765871},{"_id":"cf63fca9-156a-3400-844b-853f143392ef","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes. Avoid async void, certainly, but there are even worse things - like ContinueWith. :)\r\n\r\nIf you're concerned about testing, you could use a pattern where the async void method just calls (and awaits) an async Task method. The async Task method is, of course, testable.","postId":"2015_01_a-tour-of-task-part-7-continuations-de3f4e98-d7b9-38d9-b8a9-e608dcf2d0c1","replyTo":"fc41b1c0-40be-3c53-98f3-50d140db5f32","date":"2017-03-18T22:32:28Z","timestamp":1489876348},{"_id":"fc41b1c0-40be-3c53-98f3-50d140db5f32","authorName":"Stamatis Mavrikis","authorEmailEncrypted":"QRqPG5NpiRlvvA01Cyn8tzCWZWGdGM0dy6jh9kkLjbezwT25HYir/WVmaVO0PnuPTABBsBDOJVOLV9bt3MxpEoYBu8O8K92e92bgyy8XzzqgnEYc0RrpdDawmK8ScZWsh4uc/EMuAOyAcTG2UZ9m5hH47B/py5EKC8Zqqqn5y4f2DcvewLiWvBTyENuhnE+gZvUHwFYQKYL9sIs7za1O7zrhsmOkN0b3isdf0SQfg9EK+XqkWroH4mY4c3HKRc8h2HR1f1TndRjP4WCIB9ru5NnVPPR82xDgtAwlpvrRug8yjoyXvPOZGSCOx3TT0xreoh15Ee4pt9AP46UjHNNbYgsHGuc24wC1dHyXqcpq8Wj+fFRIUQKWK8g1sfLsZO4hXstv0VLrooeli5zmRVLee7HaRQ9b2rvTJURpCvCjql3RpuPhvRi5jAdFDqfmCRAOwcZh1ecThidjywv/Tct0EFEdMr2QzIjhXe3CxGBGc3FGnjAkLNJmHtfxHR4k3sqsDG2+gB6ml7J6f+8QkQd/cldOyh/SdA/SZYdCaLJgTdJ4k60upJRHYEFHKmD3L8qKxf5e+U+Pc6PJJVSS2niF0T19sv+Fw9achcxOUtAKUs5hoFGd5fZAAz0f3U9uXWMqDhbps/NH3DOUwRpR0cNLUxKorvZoq8MrY9qdj1bH500=","authorEmailMD5":"adff651da65bdcee45b0be31824f43b5","authorUri":"","authorUserId":"disqus:stamatismavrikis","authorFallbackAvatar":"","message":"I wanted to avoid to use async void because of all the disadvantages that it has. I thought it would be more clear using the ContinueWith creating first a task that brings the data from the db and the continues with another task that runs in the SyncronizationContext to populate the data in the view. But as you said this way also swallows the exceptions. And as I can see it will have the same difficulty to be unit tested as using async void.","postId":"2015_01_a-tour-of-task-part-7-continuations-de3f4e98-d7b9-38d9-b8a9-e608dcf2d0c1","replyTo":"0f5dcb86-f8a2-3fcb-9673-3cef27edd19e","date":"2017-03-18T19:17:28Z","timestamp":1489864648},{"_id":"1fc5e910-4793-11ea-960a-59ebe4a70545","postId":"2015_01_a-tour-of-task-part-7-continuations-de3f4e98-d7b9-38d9-b8a9-e608dcf2d0c1","postUri":"https://blog.stephencleary.com/2015/01/a-tour-of-task-part-7-continuations.html","replyTo":"c4dbd1d0-478e-11ea-960a-59ebe4a70545","authorEmailEncrypted":"VpQmCelMDwVfX4ous2oSdJeyMWKiT1zsOaVYO9ZtpE1MQ6usQ3lTjRM0cn2WxylJ7HBLwqU1nEZYmgJubk6rGFxkYAUCl3zBpIsDyI4nvEz9ruWiHyZHPut/EVXSLAtz6i7pyx3sUtOWD1EHrFlewNThLr/UBaos0GSmTVv7HMXR2O2BIrhwDoUhV7/Psslfi5UqkGhS4QbRP5TuobolU7nOCPmCRpgU+HIn6spOrvk5DdeUmSmKi9AiGk6TVPWHcDQ2FCMpAM2t2aSbdwFWyDuSrRlV/YonEvoltk0bjSA00fmlCyofd91Z2IEUIxTWz1uIOs5u8Svdb8GrqHyoFSrE7P9NY6ohBjB9ujLcdZw3akquHmaX7iKbsfPgALlSSYKOpwJN2NCxxlTEqXz/x6O9eZhqLpN/J+oWFZpVT64LQEdXGdKRZzj4Ce8UpK3goDd+0INvpinBSMXVV7jPNVrKROs0ZDnrP0DF6/cxFdXUOlyX1HjrQjJ5sDEiRn+J1PIbSoSmrZwoQ4E+WKvQ2p9zJQMLIWwOVCRpt9G3OU3jy6M3yNwC8c0NXF9QpcFarbCMLTZwwO8xmgvUW8K7rbdgkTpGlrPkhMCN8uJupPj2CzjApziN8pz+lAMloeNaN41E0NuYEjIBfb5Ixj5XMCtwGJEoqIgrinXxir/RoWM=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"The simple way to get the results is to `await` each task after the `Task.WhenAll`, as in your last example.\r\n\r\nAlternatively, there are a few people who have written [overloads that use tuples](https://github.com/StephenCleary/AsyncEx/issues/197), which can be used like this:\r\n\r\n```C#\r\nvar (firstResult, secondResult) = await MyTaskEx.WhenAll(firstTask, secondTask);\r\n```\r\n\r\nSide note: [Use `Task.Run` instead of `Task.Factory.StartNew`](https://blog.stephencleary.com/2013/08/startnew-is-dangerous.html).","date":"2020-02-04T21:13:01.209Z"},{"_id":"c4dbd1d0-478e-11ea-960a-59ebe4a70545","postId":"2015_01_a-tour-of-task-part-7-continuations-de3f4e98-d7b9-38d9-b8a9-e608dcf2d0c1","postUri":"https://blog.stephencleary.com/2015/01/a-tour-of-task-part-7-continuations.html","replyTo":"","authorEmailEncrypted":"dpe+9xITxU0IQu6uRNkH8plpJc7BUTDKNdNXsIsA0q+8Q8fTmaGR46aN9CyPEDgfAB+mMEbDxG8i+D++p+KHDdL472DXl3cGABQc/xoftN3qItYjTgA9i9+LamcrF1zSi9LH9XmhxLJzPedlXi8IsEdBBXw1s2YCD430ipXcErLSMgiwwH1d75K1JOHKG1aSApEyBU3z8GqBeuF6iXcEHunDkyq32zAa8csDIf0SkoUjeXK5PELn+BAtNy/lcOcBMtMFB7UapKbYdBPKrwtgOu3omOffHi7AXEiK0AqB/jTMRfHNE/+c2eRsSq7SNZTeQObdbQ+xxMgKDCSUNr7BgOZspvA7tu+SWdxHni2iP2BCZD9lACec3k4wp/zJBmLITWXPCF7MVZZjKQq6BMEQfZX1kKsEaNwuL3hFW4JsFPYhWLzqxyaWxjtdGe3iPhRGANDmgMD6e+GdNC5AR0hEgIewiKa7d2IMaCuPU3NY5ZjBGzYMj9azZXCIzPqlOtJ1W7WTk/tBXjC9ovW88VbFyzPxfRPLhmAmMEa0fUpowfDRNVjpw5No02kGXyA2WqNLbgQ7ZRudkc8jAUDhRUIhtP62I7R24IBS8XxBkoztfnsMttDeoBneZ7znZMWBgSOsgecUaD5Wvr1MDfE9fU4OnOqQk/iPstrzq8MrkJrhs1c=","authorEmailMD5":"76b4079c4c57a05531c6860ecd64aea5","authorName":"Aravind K","authorUri":"","message":"I have like 3 tasks and i wanted to use them in WhenAll()\r\n\r\n```cs\r\nvar firstTask = Task.Factory.StartNew(() => CallMethod1ReturnsListOfString());\r\nvar secondTask = Task.Factory.StartNew(() => CallMethod2ReturnsListofString());\r\nvar thirdTask = Task.Factory.StartNew(() => CallMethod3ReturnsIEnumerableOfMyObject());\r\n```\r\n\r\nIf i use, \r\n```c#\r\nvar finalTask = Task.WhenAll( firstTask, secondTask); //returns a collection of TaskResult\r\n```\r\n\r\nIt returns a collectiion of Tasks for finalTask and i can use finalTask[0] and finalTask[1] to access the results. I assume, they return a collection because, each task's return type is same. but if i add a task that is of different type, then it just returns Task object from Task.WhenAll()\r\n\r\nsay,\r\n```c#\r\nvar finalTask = Task.WhenAll( firstTask, secondTask, thirdTask); //returns Task as return value;\r\n```\r\n\r\nIn that situation, how do i access the results of each of these tasks execution? \r\n\r\nIn other words, if i have 3 different return data elements as tasks and wanted to use WhenAll(), how do i access their results? Is it implicit to use \r\n\r\n```cs\r\nvar firstResult = await firstTask;\r\nvar secondResult = await secondTask;\r\n...\r\nvar thirdResult = await thirdTask;\r\n```","date":"2020-02-04T20:41:50.564Z"},{"_id":"7b737e60-03a0-11ec-a535-975cb4ecea03","postId":"2015_01_a-tour-of-task-part-7-continuations-de3f4e98-d7b9-38d9-b8a9-e608dcf2d0c1","postUri":"https://blog.stephencleary.com/2015/01/a-tour-of-task-part-7-continuations.html","replyTo":"95b55a30-0375-11ec-af69-93cb661d0a0c","authorEmailEncrypted":"JVLJ6TXC2qG/Yn324xHHns9AnyIf9BtaLFaNkTbh/eFpBt/Ig7sKYxz/i/b511p2Ur3GVqrGyJrejn1EeV4spwwWMEu7dh7sghzdJhqcM9wsqNOR2zZVHoPvxgquPdSYQmdU6o7LCf2LWk4rpNjyRToL2/Wi20ZspYuuYXxnhL15Gxbp4mkdbI0lDyvloHXOE9KtPEi8+VCvWr0/LkwyDNfdbccUIiIII+vr/QQUlJ/j1uqbfeHpO6tobETdgfSxcWBGiq10EKvt4kDr/Qh95m4fuQjk2c9mETSwgXtWFwfvFNaRSaReHkVEeqnwFsBDR13Oyq+M8VyJlBMu19JcINrxOjm+UaxlGFgpX7pQinA6jNT+sgAcVpPYw+tZTIndydMr3h2PWg+cgwEoOWmYGfQ5KfwWZJPuERQia5mbxCwOHDH3JVBnkzq32iaUPZmAHLji4lftlAuSkuyiJmjJh4m+uqjacXeU92I0JQEEyYXcN0AMlWevkvmxFWP/Hy3T7Udqm0R5p82w7bvkiXJR+J6YKeQSZ04OOtigfELrGmIFafVIch3E+2BYsT/d/6RkR1/lzRNJLWWBBD9oxGcvmzELPuRtmNSD/fMwXVlAJzXOnZt+8Kv+q2hp574TLpeyswugbg5uTZSmgrul/YF/DvCT4/tWa4Oom/mxq+IxGAA=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I think `WhenAll` would be less convoluted than the same logic using `ContinueWhenAll`. In both cases, `WhenAll` does complete when all tasks complete, and if you have `finally`-style logic, then with `WhenAll` you can put it in an actual `finally` block.","date":"2021-08-22T23:27:14.425Z"},{"_id":"95b55a30-0375-11ec-af69-93cb661d0a0c","postId":"2015_01_a-tour-of-task-part-7-continuations-de3f4e98-d7b9-38d9-b8a9-e608dcf2d0c1","postUri":"https://blog.stephencleary.com/2015/01/a-tour-of-task-part-7-continuations.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Arty","authorUri":"","message":"You mentioned not to use TaskFactory.ContinueWhenAll and use Task.WhenAll instead. Generally I agree.\r\n\r\nHowever lets imagine the case when have multiple tasks lets say Task1, Task2, Task3 you want to await on all of them(probably go with using Task.WhenAll) and some of them may fail, others succeed and you want to have a control over it and add some post completion logic. Imagine that firstly Task1 is faulted, but Task2 and Task3 complete at some point in time in that case Task.WhenAll will throw the first exception from faulted Task1, but you wont be able to granually control Task2 and Task3(unless you will add some ugly await logic later on). However,  TaskFactory.ContinueWhenAll wont throw the exception of the Task1 instead when it completes, one can examine all the tasks process them accordingly.\r\n\r\nPlease let me know your thoughts,\r\n\r\nThanks for great articles.","date":"2021-08-22T18:20:10.052Z"},{"_id":"bdaff980-3784-11ec-a14e-9dd5c6f77a00","postId":"2015_01_a-tour-of-task-part-7-continuations-de3f4e98-d7b9-38d9-b8a9-e608dcf2d0c1","postUri":"https://blog.stephencleary.com/2015/01/a-tour-of-task-part-7-continuations.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Nic","authorUri":"","message":"<i>\"The “parenting options” control how the continuation task is attached to the antecedent task. ... AttachedToParent will attach the continuation as a child task of the antecedent task.\"</i>\r\n\r\nIs this correct? See the following code:\r\n\r\n    class Program\r\n     {\r\n        static void Main(string[] args)\r\n        {\r\n            var task1 = Task.Factory.StartNew(\r\n                () =>\r\n                {\r\n                    Console.WriteLine(\"start task 1\");\r\n                    Task.Delay(2000).Wait();\r\n                    Console.WriteLine(\"end task 1\");\r\n                }\r\n            );\r\n\r\n            var continuation = task1.ContinueWith(\r\n                task =>\r\n                {\r\n                    Console.WriteLine(\"start continuation\");\r\n                    Task.Delay(2000).Wait();\r\n                    Console.WriteLine(\"end continuation\");\r\n                },\r\n                TaskContinuationOptions.AttachedToParent\r\n            );\r\n\r\n            task1.Wait();\r\n            Console.WriteLine(\"fin.\");\r\n        }\r\n    }\r\n\r\nWhen running, the output I receive is:\r\n\r\n    start task 1\r\n    end task 1\r\n    fin.\r\n    start continuation\r\n\r\n\r\nMy understanding is that `TaskContinuationOptions.AttachedToParent` works only for \"child tasks\" - i.e. those defined within the delegate of the first task - not continuations. Is this incorrect?","date":"2021-10-28T00:19:40.213Z"},{"_id":"d08e59c0-3789-11ec-bf88-6d3329229fec","postId":"2015_01_a-tour-of-task-part-7-continuations-de3f4e98-d7b9-38d9-b8a9-e608dcf2d0c1","postUri":"https://blog.stephencleary.com/2015/01/a-tour-of-task-part-7-continuations.html","replyTo":"bdaff980-3784-11ec-a14e-9dd5c6f77a00","authorEmailEncrypted":"OakLQJzQk0I9UIh7NzrHPgs8eD63xoq29Yba+pFMWVEQowl2rgpGEyPxA/VF7dAJSwn3+TRwm80/5YOwvX4GZzntcsAoRbxUxnpuR1JQnGO2KhQ1qs5SVOyuYp0ZHKUJqJN3K61hRtfBbVjwgan079/wvseh/X7MPKe/gPaNSFcNjzj82fcQnkhyAgQl0YunPdnzaSwufiD7QDE5GtlJyvOedvshUlw/HBHvlIsJfU0brXtd8tydHOttkl4exv779L42qMbvwlfY8GDSv5UZIbDqjert4j7BQ/XbDJ7hPdEVjs4C6YXtmQb4an2JxAI4zhWpG9QGxfJ5IxUIjVB8XRrJrso/eSp3e46oHre9Hb/oaXpSmz3d2i3GgrzGA2le6nvIhdzBxBUyIzrbMe6/O9vWFRSZo7SmeEiTA3C5KcBC4yWRN9rcE+o8abqUYKYPo+GfKL4n+vle4kiUEShIoSInTUCOx6WLJmmq6osSd0NNQ66t7x4pYpPdiR6Rer2FFeJ6MG1ZjtM18ODQOGJrB6Dnd4usLG0Melt9vAwsVkzGt6xx+3aNTmePmQ8xR8M9dz9+rXbRe5cPbYlqj/yP1cRThTXzpAffzVX7Kd8GFeyBUuFNzkbSr+YtzAaYjeosxyyRBRg6wkGXqW4nONXSEjcdmZf8djAxdrMq8rSGu4E=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Ah, I believe my post is indeed incorrect! `AttachedToParent` will attach to the *current* task, not the antecedent task.","date":"2021-10-28T00:55:59.279Z"},{"_id":"36accaf0-567c-11ec-bfd9-430d00711632","postId":"2015_01_a-tour-of-task-part-7-continuations-de3f4e98-d7b9-38d9-b8a9-e608dcf2d0c1","postUri":"https://blog.stephencleary.com/2015/01/a-tour-of-task-part-7-continuations.html","replyTo":"d08e59c0-3789-11ec-bf88-6d3329229fec","authorEmailEncrypted":"jm8F8TLAZrw+lTZXpwwwbLqZYkXvx9pBD/LOpHXZkBCsnz1mqAP5HUweyC9xDLp4fl8ONEP2yQRoLlt4r9ObPWqasv42iDOxFp0aqdLSvHHBYnBCGljrP7dW1lQIHYaQDosu9eaXHb3GeH+7RPXvlk7JP7+KjcaKuG/LcjXTv2qjunlCkTTRhZ9gnjBqyi04wMsWqN2+x2C9yvBFxLb05x/h2LWXkmaUGkYLjeHN430mrjgccXdugjRD9bT6vaJyeccM1VVkxAelpy4vtO+XYUwxSBUKSFdNDIXHI8FwCWcQV9NwXvaAmnfw94lYDqwcwLpBVijXlwnKyXYwHj/X87D++AlG/nQVK5AxuzSMAb2fQpd3bcks2F2JwAO2oQzy5YpBrCKHRx4GuRIuXgUDdRLK3Hop1wRD8VVwogijd1+tVwvezkMdsITckGiIGAeNKTgdfKP0KymvpWEhDkVFlZ05rSyGruNgr8rDut55j28tUXmljecpcEN7pdmwkvzU/zP/iiGrv3u6nVkl7LJaS009U2ti5Z/pYjVlBlWcAimwUs1aBAuanSqmUAqFSnIRteyc5EgzlFWztBYsYqsExiaY9z3GujkUEVZC3orxulipP6q9v5OpTadmn0bvfya4Pb4NfZu7hnfIuTLn3vg5NeeRVZIzWTe/2bBtraHbt8g=","authorEmailMD5":"a1d253d590d0fdab24862a1bac08cced","authorName":"George Swan","authorUri":"","message":"Stephen was correct. In the example given, the  Continuation is attached to a live task. It needs to be directly attached to the declaration of the parent task using the dot notation to function correctly","date":"2021-12-06T10:06:43.716Z"},{"_id":"57b4f620-a95e-11ec-8b5b-77db0e60b2d3","postId":"2015_01_a-tour-of-task-part-7-continuations-de3f4e98-d7b9-38d9-b8a9-e608dcf2d0c1","postUri":"https://blog.stephencleary.com/2015/01/a-tour-of-task-part-7-continuations.html","replyTo":"36accaf0-567c-11ec-bfd9-430d00711632","authorEmailEncrypted":"Rt/zD+kgUjnzpjfINqtHFn1qYgIAMe7Aruyi9o5FThwv30bL+o0j/tDDzIsLYu63BrMXhYo1I6p5p790Zy11j5yTm/4i6ZnsO7H3qY0tcnShjVQ+J6pc58e6tF46OmtgoXdnVMaSTfN2C4dXW1Km/4yD8cTX+buELKGpnII9rqLqiLclCQGit/21X/0olJxdAkEMqEdPOOXO3axSNGQuG08Mul6ml25hE8H9NADCPsvsN4+Ou6/KF8kiWKPwcRLCVhEBvykZ+5ROP4JQlAlDBzZHP4F3pa/R5eNYYeikxm+hNP3aYljxl0k2OXVTpxtTRea+Gg15NZITyIKOYKu8XbIlI/oOiWTQXr8fLzHIRQJw+cLLDeBiZSo67GZQsYo8+sSIntgPVC9CvnLK7n0/iClgw8zOdfZka8mSA2MeWJNO5JtB8vVgqR81qRdNgSaQ0sMg5KE28/7r/mVUKemONyslf0ow2fkdzS0GdOxbb+biGgRh3V32RZS5IT4oEKgJKaHoGWy7ELntb/gb+PEklrogPNqchey3cXyRFdpu/nLVaQDQU2sbTRV5ZukxXRtXjY5tfnisW40WoRCO0DXwXabE90xe7orCvXA7bXVW3ppa8W10kvSzC6EmehdN6ohMhyhf3exTZ5LRq39ZHtdZByKiJy5v20IVr8MyJYABMNw=","authorEmailMD5":"f9794d1d7bff2b2c091ce74fe0068acc","authorName":"Nic","authorUri":"","message":"Can you clarify what you mean here, George? I don't think it's possible to attach a continuation to the antecedent task","date":"2022-03-21T21:32:00.739Z"}]