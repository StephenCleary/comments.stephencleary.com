[{"_id":"ee3e0914-d37f-39fb-9ac3-abc6eea495cc","authorName":"Thomas Levesque","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/17821784613704879657","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen,  \r\n\r\nVery interesting article, thanks!  \r\n\r\nHowever I'm not really convinced by the \"Complete method/Completion property\" approach, because it lacks an important feature of the IDisposable pattern: \"using\" blocks. Disposable objects should always be disposed when they reach the end of their scope, even if an error occurred, and the using statement is the easiest way to achieve this. But the Completion property needs to be awaited, and await cannot be used in a finally clause, so there's no easy way to ensure that disposal is complete before an exception bubbles up.  \r\n\r\nI came up with a pattern that mimics the using statement, allowing for async disposal, you can find it [here](https://gist.github.com/thomaslevesque/5936421).  \r\n\r\n(of course, 5 minutes later I found that [someone else had almost the same idea](http://softwareblog.alcedo.com/post/2011/12/09/Using-blocks-and-asynchronous-operations.aspx) long before me, but not using async/await since they didn't exist yet...)  ","postId":"2013_03_async-oop-6-disposal-bff8d970-98c1-3b7c-ab0a-504ab2504786","replyTo":"","date":"2013-07-05T23:11:32Z","timestamp":1373065892},{"_id":"4c63d10a-0f03-3c26-ae0e-f1198f3650a5","authorName":"Nathan Phillip Brink","authorEmailEncrypted":"oj/Wv4yvClpizPIz8Qz4QsSpv+K0o62x27CdNoHSWhiScI3mni6kjfjmCQRrO3bys6Tn5jafZZeq0MLbEursyuafdTMc+OcXD7/R19VHpyWlRxX5iXMvMOTsIH5JMI9ZgFSOnCdnP4QmjRck2blN9qy4iISbmskc7fajHLiEiPbYJWol11EiuyX6NFGUl7rWMR5uoathXs4bTLPvw85h22WVpIOBBOFWb9GuFS9x8AgZ2gcje06fWM4pdrCH8nn/Gj+LTSbl8Mb7jrNdMmVNpz9QVKf3OAe4Avor0fTslvnRtt2e3AxVeCr47EFxMxesHSDyYVv2y9qZQ+2WdtepO+d+oL1RTldZJurcTi6QHweXrsucwiNgCtWt61mtUKDwYchFnrSptnkP1yJLERsNr2GKubEAh9lLIro/Et1XtrMOud6SS3kEX+WsVvPvJ52X34VoZ13Nc+9c3tyMjXxFz4T3ukj3c9K/AzSvkeuIfoXsycXEBmC2k4lT2/KME/rkV6reUGbZZgOBR3f3enIaIowELZ8XO0gRsknOIUzv4QIJ5UFsbFJcb6Cz1/jsUUm0LMX+ZaK9xdWUvzW/eCAeBEuEUyuFE7z8rnmNWcL0hLJRgLq83SwrRy9I7sGbpVaRFBMMWpJxU9kWWgICsxr7xmDV2ptcC4u284umSJdFso0=","authorEmailMD5":"a8defe14b1c80bc2bd59a1fab3848cfb","authorUri":"http://ohnopublishing.net/~ohnobinki/","authorUserId":"disqus:ohnobinki","authorFallbackAvatar":"https://disqus.com/api/users/avatars/ohnobinki.jpg","message":"I agree. Scope-safety is one of the nicest things that `using` and even `async`/`await` gives you. You can `await` something inside of a `using` block and not trigger the scope cleanup—something I’d consider very ugly to do if directly calling `ContinueWith`.\r\n\r\nI think your pattern should be added to the Stephen Cleary’s cookbook. It is even useful outside of just the problem of asynchronous cleanup because it is, uh, easier to fall into the pit of success when the developer doesn’t even have to write `using` where scoping is critical. Also, lambdas enable this pattern to be fairly easy to use:\r\n\r\n await CleanupCriticalFactory.UseAsync(  \r\n async thing =>  \r\n {  \r\n await thing.DoSomething();  \r\n });","postId":"2013_03_async-oop-6-disposal-bff8d970-98c1-3b7c-ab0a-504ab2504786","replyTo":"ee3e0914-d37f-39fb-9ac3-abc6eea495cc","date":"2016-06-29T19:11:13Z","timestamp":1467227473},{"_id":"00d18e89-22e1-3154-85b8-a5e79e960a14","authorName":"Nathan Phillip Brink","authorEmailEncrypted":"j88/T9i/iUhyISr74wQwMpcW21knmIi+s4SpBAfIKXhRmqIlRRhGx5jsWN8NeY1UpJBlimnjbMMbjKGk68AOF/o5KMQmWMnru8oWM9L9jYw/bjNuY/JY4wGTFU3IXDrdWrUQy0V7CYiJz2SJlh0yXgZ1Hh8LRDinhyWuL4/auSlhjndSLBpi8alZfCDLHYH/+NsJkxQZr0ubELeh5UA1Dg8WnO3Y94I0vOjuOgVNu4DJroWyY2LGgCXDxvgh/vfPS//2hHV3Vo8+qosf0jEyo1shafbFl+x98orDHD/Aim3chiEE/B3avuMwN1YciFG/oG7VjfRBwnTvJ3MpSUi3RhmscNKfz6C5zxEafyaf3b41awAj/ipTJBrBi0a5zuiBl0TR4gEiktxEWxeBQuOCxjQVuKYn/3DWK2BE5cvPi7DSVcpxZLGFFs0chgjuaB6nrSUi3lp9oECtSS0nKyQeUDBGiRH1Z4kG+3VKtVnyiw/s8agt+6ed3xBwA46IXmxQBRS4Qn9PimCd8D4s3AIj91qOEqdEH0z9f1Lt3yys5uXvhnP9mD5zMnuhDRo7tLSdvzlx1tEw1s7nXqxUP1YV2gYeXEVKtLhiyfuSYgDOOo45ca56YWh3CU8p9lgZGornqeg1qfPnEDEJjEh4SdaqEob23Ge7vZWiFkXa/Iv3Hnc=","authorEmailMD5":"a8defe14b1c80bc2bd59a1fab3848cfb","authorUri":"http://ohnopublishing.net/~ohnobinki/","authorUserId":"disqus:ohnobinki","authorFallbackAvatar":"https://disqus.com/api/users/avatars/ohnobinki.jpg","message":"btw, I didn’t know that `await` was ever disallowed in `finally`. Your gist can be simplified—at least with a modern (I’m using C#-6) compiler: [https://gist.github.com/binki/6a5b69e28caf9cef291e09002e4755b5](https://gist.github.com/binki/6a5b69e28caf9cef291e09002e4755b5)","postId":"2013_03_async-oop-6-disposal-bff8d970-98c1-3b7c-ab0a-504ab2504786","replyTo":"4c63d10a-0f03-3c26-ae0e-f1198f3650a5","date":"2016-06-30T10:56:46Z","timestamp":1467284206},{"_id":"3444e5b0-782e-11e9-a106-db91135d280b","postId":"2013_03_async-oop-6-disposal-bff8d970-98c1-3b7c-ab0a-504ab2504786","postUri":"https://blog.stephencleary.com/2013/03/async-oop-6-disposal.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Den","authorUri":"","message":"I'd rather throw an InvalidOperationException when some tasks are still running. I think disposing and awaiting for completion are different things.\r\nOnly I need somehow to count the running tasks. Maybe just with: Interlocked.Increment( ref runningTaskCount ), Interlocked.Decrement( ref runningTaskCount ).","date":"2019-05-16T22:59:05.734Z"},{"_id":"77464930-78a6-11e9-8fc4-5bfc95b35edf","postId":"2013_03_async-oop-6-disposal-bff8d970-98c1-3b7c-ab0a-504ab2504786","postUri":"https://blog.stephencleary.com/2013/03/async-oop-6-disposal.html","replyTo":"3444e5b0-782e-11e9-a106-db91135d280b","authorEmailEncrypted":"At8eQ2lTpYsXjOtxdjCHnc+ouRAKnNQkbjjOCvjX/yVhf4nLRqHHIRDrHXEyi5BGgXVjsBcGOJs2N2d1yQaQ6Mb9Tp2OXjC+IKiJvbHPR6p93crUq1MvWNvqtsdvLoDkWLrg7toGsawhuBZogCWvAXF7GmxgDdiXCKEVEa0NUIPbKXPGwbMUg5fAkEZOgEtejFd0vfds3/RU2v9ZLy1SAkCqwYotwKUqingWQvUD/IGY5VjFIO/w6uhZRq/Nr6jtLLryG42IArdKIivkbNLeMxsh/xwNgH5X36sEguRWNAW1qBAHxGYZmaEmoxpW/SqxaWTa4LqUkGJhov5jnc+CFEUlGKEBtlSqx2V/Joa+EOWeNrSphyEyKDeECatpctUMuhPBoXFJUjdqzpge8Fl7Mru9IDAeoG/78GXtzOFcyJFoGxbt20QU0DCS+gw8OoPuKuUcHk9YQHYtag1ALCMAraTbFDGq7jB8SkQJte+e3+4b0DSBSePjBMS74l7dgWJnJfM9S77rH0kuDW7dVokFOoQUr0Wk/VqJgOUxoW239SEVNiU4jSyfjrGctxGHcSvo9RsQryUrlYTQjZDQIb8rBNzEHVk0nGZVpTwRocFOOSSUH4VhnmIm3+pJulWIt8tf7WtFI4QuktKlKntqU6xD6WBIzyE6PWA1RqD80jwKyg0=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I strongly recommend against throwing exceptions from `Dispose`, ever. `Dispose` is often called as part of cleanup when there is an existing exception travelling up the stack. If your `Dispose` throws an exception, then it will *replace* the existing exception. This can make debugging difficult.","date":"2019-05-17T13:19:57.770Z"},{"_id":"2d90f6e0-7df7-11e9-b0e5-7f43d0a655d3","postId":"2013_03_async-oop-6-disposal-bff8d970-98c1-3b7c-ab0a-504ab2504786","postUri":"https://blog.stephencleary.com/2013/03/async-oop-6-disposal.html","replyTo":"77464930-78a6-11e9-8fc4-5bfc95b35edf","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Den","authorUri":"","message":"Yeah, you are right. \r\n\r\nI'm doing gateway with http requests and socket connections. \r\n\r\nMaybe I could dispose it without awaiting for completion. But I'm afraid that some methods will return result or execute callback after I disposed object. I do not know what might happen in this case.","date":"2019-05-24T07:40:19.255Z"},{"_id":"be0fe430-8593-11e9-ba28-3542af84de90","postId":"2013_03_async-oop-6-disposal-bff8d970-98c1-3b7c-ab0a-504ab2504786","postUri":"https://blog.stephencleary.com/2013/03/async-oop-6-disposal.html","replyTo":"2d90f6e0-7df7-11e9-b0e5-7f43d0a655d3","authorEmailEncrypted":"Q5z7amlT5s644oephqEZFNKydsdwysfV5VQ+9tzw37DoJoVHCunFAizo5MEF/HFqBJZ7lgrEo3kEhW/obNXac183aD/K7VZIU4x0XNV7ZSHbRijEk1FYLy3Kq3j9k/wtZ1p/n/lJDSrQAWftxhcif3jh6iz68W9OluHLUniMCS1RSGezmrEJ6I5OTdV2prkWX3YWxmIDf8nfTLJ2G3f7BjdLYf0gYEXB7/HMsWSMQq0KzgUi56dBT+j2buP+FMfb2IS9VEsh+cP8HRj+bQZxpLvyhit5EQ0QSRoic43NLqWH2A8WED1MRJhPZOmlpypnE/SB6G0e/8l7VBI7qJAOSf6SsNy6Flje51qvC750pNLQ/LCLRr8UaxE39QI38hnJ7la4EBvrY9UjOGEkPbrWprMDUi9evtgvKWbR3T1fOEkLu6pikPEVt7vo2z8otcAj0NtrKBNFvc/B3wByKCWD3XE5AlqTP+U+iRrqoPjYpF32tqA9kD9/8XLFMrSL5eiqMnGU5hzMBaYyi0HJqjqPeKQsZ8NYeXyhbeXdr9yca/sKzI+geU2VncbgyPhWV+hxE+oPUUIX4P6+VoibrmB5hTBC8a107E3P2oxo1JJrfC9M+SFWg7KrKAE86DoX3UEeuGRxtcsCHKw7XHPAq6LiVK1pxmnYw4Oi7G3wSW9AW9k=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"The standard pattern on Windows is to close the handle when you are done with it. Any existing operations on that handle - whether synchronous or asynchronous - will complete with an error code. In .NET, this generally means that when you `Dispose` an instance, any existing operations will complete with an exception.","date":"2019-06-03T00:08:41.318Z"},{"_id":"5793c360-ce71-11eb-a13f-97c48c463d57","postId":"2013_03_async-oop-6-disposal-bff8d970-98c1-3b7c-ab0a-504ab2504786","postUri":"https://blog.stephencleary.com/2013/03/async-oop-6-disposal.html","replyTo":"be0fe430-8593-11e9-ba28-3542af84de90","authorEmailEncrypted":"SrxcQ9DmYlYhFhHokaCOKtJfTeqnScT8NmE2yALi5lU9bWMpr25R11z7/snXJ3Qp9f8kX7Kn6sO1jgH9RjfIkxR169m6l5iAKx4Qu4FH0lEI3ts2M7u/CeCJpNNeKMZnU15ovUB+dvKfdeUHhSNEUgHubN8VrFGyT6n6idP2COV2IooHTvytv1leH3KL4e8yrNKetQJxiEsyygJ97SMtBTYvnq2RHFbGXelIJYO6NLPlPDqL/Bjf1dNflDDvvUseX2Ik3l80OGS59f7aUpUkzc7N51UpMhgVM0JOWsP/ZM7i+gtEPeu95O1gsuEu+sRm46uVLgA7DugvbOwPTLKu/XDPqjlZgLEbCCVcMZarEyWHGjjcQniWNQuUaZbqtCFCupMXNh2y1UWMYwd6/ODw+90FVzDofOoWc8CLwzyZRYMTWmr+SXMQ0JbYPEps776SG5A0wnMiYCMjH49OtmXkPiC0lX9wRDXaLD80arrUmNl9GUHmrNEyQRLvyxR0rgFqQhiQBUBOb3UErg2D5ZjE0XMWKRgXN4h3NFwPFKQoZ9tdGuft57sLaTwhRnmTJNFNrrdnGEQJnZsG7twS0ib4Qw2jJ06WfliMNqlqb3wIWsTYmaA1YbYAW3vua/7Wu7WBxTb5YwzW/IPYn9ovwimJWHceOKf/T+IAdtcDk+EGglI=","authorEmailMD5":"3e574b5c31bd5491def59afc99d8cdb0","authorName":"Ganesh Hegde","authorUri":"","message":"What is the type of exception thrown? In the above blog post, you mentioned that <blockquote>Historically, disposing a resource on Windows while there are outstanding operations on that resource causes those operations to complete in a canceled state.</blockquote>Doesn't this mean that any asynchronous operations (tasks) that are using the resource throw OperationCanceledException? Or, could the operations throw ObjectDisposedException also because we disposed a resource when it was being operated upon?\r\n\r\nIs there any Microsoft standard on the type of exception thrown when a resource being used by an asynchronous task is disposed?","date":"2021-06-16T07:06:16.505Z"},{"_id":"9c3650c0-cf0a-11eb-b77f-0feccb61b004","postId":"2013_03_async-oop-6-disposal-bff8d970-98c1-3b7c-ab0a-504ab2504786","postUri":"https://blog.stephencleary.com/2013/03/async-oop-6-disposal.html","replyTo":"5793c360-ce71-11eb-a13f-97c48c463d57","authorEmailEncrypted":"A+aHLX1JRzdrr8RoWJ+xblAhnFTUqU1xvQOGhjjdpfFSri6zBgssQ5snHUQeCCYOKrOBKEoPq+ue8g57USdD7fgTmvZpmeHJrQrVvTDQ0bOW4Du1YnhwKhW+RM+OaLb0wcD+usC1NCWauhjweH6r7UazEjW86HGYA9utadAcc053nuIhiv63nAcmTx0NjOCVTZh3jxrVv/d3k4lHh8bWLa8QFbsmQ4mUUuME42GYF9vtCI2kRkw0lwqkDxUDEzCkyjK901tpS+wL5c9YQydwPYN2drlmnzfFJRmOtOJW4r7KqorQY424DBgzyyxtlxbODZ3i02c57VkhQTHlgD2P3gcrR5TVZhzeDAFmOidgQZ9equa7XA9Ruxoo7a8hf0ugMLRH7Nz8WB/4b4XE3+sGi98WZuzC0xIMjprq2Exwatzxl1MLXiavAwUFIRT1zhT48JynL0MMV8lPJ0jW5NB1bEAn16Fpi9pduoX9a32O6dru9LxeVPSeANxDBbMY1acyo/5lE5Y2rKonJsDrDauBcANg7obzYlnQfwECI9Og71p0GxwN10ELn29a6FlSd6nDW1WlYjyykh6p4ay+o2Au2M5X6tbOamwg+VvMEz46Bx77bNWhIBPdVO0pT7Ima2QF/qcEvolmTQsnXzQsRDOvpLQha5XWh7NVbqy+kPOTGQs=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"It really depends. Different Win32 APIs will return different error codes when they are cancelled, and then the .NET Framework may or may not translate those codes into specific exception types.","date":"2021-06-17T01:23:24.715Z"}]