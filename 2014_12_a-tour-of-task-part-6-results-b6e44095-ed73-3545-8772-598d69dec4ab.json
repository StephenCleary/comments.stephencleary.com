[{"_id":"06b5c0ff-eb9c-31d4-ba07-ced5bd2498a2","authorName":"Lukasz","authorEmailEncrypted":"AiPa7uVZzAl8AUVGIMtL7z5TT1x2PiIJuXmK+Pg5qQOv3p+kM++BB/qSy08K4FPCK/4wy/DNJbrM1x3OWD4ci/Bvn0Searcj6eIq0bh8VSf6xGYY7xuPsxdaae7nxhKtsTfTOUsjQ0GEmbSTJsc2619/r90KqSKJcc8WOgM2W8aqXpihbP30fg/GxLRt77ZUHrqmLaN8kMVO99zQe46m2JKuVchFaB0xE9NmgxMioc8Gp8a5Gp/O78IHF+jHDWz3YoDvRzVFuBWertnmuxSpO9jC+Y4ISST3Xs9xSlhvNnrLYdBtK2v3UnYTV5X76lznSyBrEpIROStZkYCzTt1LrNGM6NqUsZW+UXBPtrzuzSP+DoRiM2MuFLAk6yNYJr0Ck32tPsGtVeDCw27eNgk2FNBWUzPFDEQbkvtZ1mGdppBgNyXx4gmys+wO3CWAUyNcz/GXIK91hHucQggIe7kyLiQUJ//Dg/+YeKqSZQsaBMebPxVIpor2yEDDlsUaxJB+Q6lRcdFlGfLJwTZ2flqRN2mwubNeeWEApGnqLwUN5mmnbzLh11Xzxb3R5Tut0/xDSklE82g/Q6bF+PfZ8IJjzMkyfOlmYllMnrMKzwQcNCoU4lCqbaaG27rgxDUsYPKkKTAbNgg68r2Orecm2MERhB/E1FpFbpatvmCHLue7VCk=","authorEmailMD5":"95cf4b9626db3813c3f37b2d141b2513","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"hi,\r\n\r\nI have following problem. I was testing two diffrent lines of code:\r\n\r\n1. return Task.WhenAll(queryTasks).Result.SelectMany(result => result);  \r\n2. return queryTasks.Select(t => t.Result).SelectMany(r => r);\r\n\r\nSurprisingly it looks like the second one has much better performance then the first one. I know that the first line is not recommended, because WhenAll is for await purposes, but anyway, why it has so much worse performance?\r\n\r\nBest regards!","postId":"2014_12_a-tour-of-task-part-6-results-b6e44095-ed73-3545-8772-598d69dec4ab","replyTo":"","date":"2014-12-17T13:40:34Z","timestamp":1418823634},{"_id":"fa8ab494-dd1a-343d-80f7-07ff024a6704","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Hello, I saw your question on Stack Overflow.\r\n\r\nPlease post a minimal but complete example that illustrates the problem. Disqus isn't great for code in comments, so I'd recommend creating a Gist.","postId":"2014_12_a-tour-of-task-part-6-results-b6e44095-ed73-3545-8772-598d69dec4ab","replyTo":"06b5c0ff-eb9c-31d4-ba07-ced5bd2498a2","date":"2014-12-17T15:39:40Z","timestamp":1418830780},{"_id":"6969626b-d5e2-3f30-9758-367ebac3fe1b","authorName":"Lukasz","authorEmailEncrypted":"itZbyuivZjHcHZ1ukawmPpaSMxEyYjlemFeIfMbhYPL5gGGaVyRJ3sLLAX6CcLm5Djf2SVZcka2rCZsNWlIVvaG1tKINdVJzO+egU6u1UkOGXD1fioBxVs6kH/9UQV5pvstSDei5PgC2eozQ+y1ae0FRfjO1hdjXqwKyZxrM9gP7YQuD+BfBb8xvUtkKj+Z1B9MC3vZdU8oBIW/2e7lSG0b/c5JQDSwlA5t6MRySgPDR263Rnzw1GlTb4HfTOWm7rCUeiO6l+0ZsKwnqV27afCsaX26eYl23o1f7j7l8kfwyIWSBtmMX4WSDmsoFiYqAMWdS32zLdmBOJFHYUMbk+hnlYEuk2fWwwaVyPhty5ZKvFJ6r/l9BjmX2qEC9O41hSfLiwe0dbzbeyEhbgjN4uiPNKet10wloTta5SueynhbRZwFhKoHh4XMmmeUBaSUWayhWmiHZcNWXn2SsAlPOWYYn8ttmUPNopLtRqr/ZudID4TlFREy0BRzc4Dmhyc9HCaguUyvPNzkHvU8BqLqIr/PIg0GKaZcxwAzhMcSUfzOOtTB+jZOTW/jhNol44XSvIXj5yo8DEhmbNW4rzntVp8W1efnHlzSF1x2FUmiFSe85yrA1ZsjqLM9BWM/B0jSr1hvOdFAP1sj9kravf3Ko/ILFM38m/ist1Oj3R61VFKw=","authorEmailMD5":"95cf4b9626db3813c3f37b2d141b2513","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"As You suggested, I've added simple application that (I think) models the problem on Gist. The link is in my Stack Overflow question: [http://stackoverflow.com/questions/27527253/whenall-result-property](http://stackoverflow.com/questions/27527253/whenall-result-property)","postId":"2014_12_a-tour-of-task-part-6-results-b6e44095-ed73-3545-8772-598d69dec4ab","replyTo":"fa8ab494-dd1a-343d-80f7-07ff024a6704","date":"2014-12-18T08:27:06Z","timestamp":1418891226},{"_id":"4686f886-d126-3873-802f-f72e366b2d4f","authorName":"vetiarvi","authorEmailEncrypted":"HL/wpq4YVklDZ3/7yAZ4HOPV/abl7tZ8DhB6lGBhTSjxiCUynrV0XPV7JzQ5BwPlNnDqFEVdaYRVm9bslcLSziuncByTjn31WS/EfSGT5676CRxGXLD9L5mN95C8uA2lKb6Nq6HUwScBbxVXvTjr/TSAQVOc0r8ebrALk9ehjy5iYyiZJnZdWvFh9SLIJx/i6Ahp3XJ7cqkLJ/iFSetpXnRtfbYyQd2EP22U9D3LZfLyoorEhUtsS7tedYgx7h8GRwbgWS88dLjlevx4ApeghCx1KWuETZdJytgbzUqog1s6NypKWhUFT6sQHNpiTXYsktj9Q90mRnFCqjLEdennZIvUqmtYrd/dVqAe/APknIo2uzSR9dLtH4DzMXjekJjTVGDQ+ANN7Tz96XOxB+yFvvvT/CZ6+Bp02gow8YU5V/dFsfy4meMTJignuze57a63e1Bn31Ng2cxr+uiTPYP110RfyJ3i/llIdm4oERgtqERbLc4CHyOGoRw56uvs/FEv43uQh+bOvaxgl+8taU19/g3xWiI/xqfIGUeJvyDgiPV7aRtjELMdz7nrUBA4KXUbvUfYc9yWsqfCDx4iRAypgYreSilvwXBPBP3kujqq0oSVp0vonfepXbEx5kJZBhc3qvrLokq0NT3Acq1VzYEU/PS2YYOcuilmL4BnC3OuWjU=","authorEmailMD5":"7b6460d94795ae02211b102b0dfe5355","authorUri":"","authorUserId":"disqus:vetiarvi","authorFallbackAvatar":"https://disqus.com/api/users/avatars/vetiarvi.jpg","message":"Isn't GetAwaiter().GetResult() the best way for a synchronous top-level method (for eg. Main in a console app which can't be defined as async) to call an async method?","postId":"2014_12_a-tour-of-task-part-6-results-b6e44095-ed73-3545-8772-598d69dec4ab","replyTo":"","date":"2016-03-01T08:09:52Z","timestamp":1456819792},{"_id":"5a110b54-e282-3ac5-af93-e9b2c6d49086","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, that would be one of those \"rare conditions\" I alluded to.\r\n\r\nYou can either block the main thread (having all continuations run on thread pool threads), or you can install a context on the main thread and give it a main loop (having all continuations run on the main thread by default). One such context is the AsyncContext in my AsyncEx library: [http://dotnetapis.com/pkg/Nito.AsyncEx/3.0.1/net45/doc/Nito.AsyncEx.AsyncContext](http://dotnetapis.com/pkg/Nito.AsyncEx/3.0.1/net45/doc/Nito.AsyncEx.AsyncContext)","postId":"2014_12_a-tour-of-task-part-6-results-b6e44095-ed73-3545-8772-598d69dec4ab","replyTo":"4686f886-d126-3873-802f-f72e366b2d4f","date":"2016-03-01T13:00:08Z","timestamp":1456837208},{"_id":"70b8e7b9-783e-3c2b-8cef-996ae72eb625","authorName":"Max","authorEmailEncrypted":"thgAGs+ANRzIHdoOXDQbuANytr+aHs9EFr4r3IYNgqgP5HknCd/JWHz0pnDGgbkb5XbqbuixqXAxbRtYph60o7YnPumlwTesx8ojGZZWmN3uB13jXdRzpHIZRsT5b4Txdg+EtuNJwIKssAEKaml68BframgaE4E6nGg0iLrdW6vPl69KoCqu7EHYulDwdp6KaT6KxZ7JLjuI5FFzt0lpRwPA3QTW3uAq+a1UYwn+b3GPURDeiDzZ5iOsOnHXXJ2lrVmaPdHhRLkn0z5ib0ppVWhCw5Rps5khvk3HSM3bTu47EhRoKI2IcWguQWCQCchunJvs7u1GciLI6LasaVoHuJ84/GEokcsIqsQgSzO7uRViucdZsi9yrjtEXRmZrnXCXgaMd4/nbuRidVwnyn22jmrb5Mm7JdXpN/Gjrq1BQQoXfx/ClsUqtGpMGEOqsoXPGRWvW8+q/CqyaiQFmHSRqSR8g4Wsvm7dBg2Arq0ymOH1FYY/wMEsU482olQxrNwzIy8LUhED95EoEDsnLadBtHsMM+9aw/WMWgSY+D3FYGan9EQ6SPJeN84OuWj4HHq00jw4CODlpGDK1n+v9/61mAqXwDx6NGOH2Dxh1NtmGx85LLesBroU6x7qJ5kszIvdwVCZmZl8GAHlM1cLeEMvfeiAjoKQDXL7aTXOx+tHGXQ=","authorEmailMD5":"605b046ff2b480851e0607a41ed2215a","authorUri":"","authorUserId":"disqus:disqus_tBCipkZ9pI","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_tBCipkZ9pI.jpg","message":"Our application is still based on Cloud Services, so our \"background\" processing is worker role, which is just regular thread.\r\n\r\nI take your answer as approval for the first approach, to which I was leaning. Thank you for the quick response.","postId":"2014_12_a-tour-of-task-part-6-results-b6e44095-ed73-3545-8772-598d69dec4ab","replyTo":"d1f6b5b3-75c0-397c-a98c-218262cad02e","date":"2016-12-05T22:07:03Z","timestamp":1480975623},{"_id":"95e8a37c-81a0-32c4-b89a-c943dcfae0da","authorName":"Max","authorEmailEncrypted":"ZS5zUPFSIw+79QFXJGaxOrTDHrQIxrGTM3l9XJ6WGT5pxjdnQ4CrKufXjjkHBiMyXMIiicqirui9wZSgzrfDHVNwFQVU7DqtcJI0bAUVxiC1hJQ8jifmyYUW0NhO9oaqFyX/3MYl+V3s/P8UwKR6wZdadwU0A/Q6poD5S+2BYv8juKaGzy0toaQXe40lbzBMeIrQ5AaMmmCxEEkZ3xfbT4XyBcaJ0CglXZ1FKoIWhmi37rIbzsTnhQ0W1V95mcZY0o/rUDJvCROhbgJwOsIjr29FVSUwlU4SgaloAKg0dXW5QEDcbm13nAVloj4OusbVg7xJEmfW2LCTXoPEVqlLSdTJL6LwPN5S7i0coicnCnu0oCli9IuyJr3fC1aVO5ti9kVDARahh/xqK9c/1SQDeMNH2XbH47l3NHwtnKezMu0cC+Q+8zmaa50b1Wrnls5M6nwyZ+kNVF/c3Rsw44NRAeqpTJkwUJ80YrCSykntrabBFdPPnKZGmsSZlNlbyh2RdywIf35Wps17mYpvKuKuFHYoVfKQn/CL1bPCP/bj14HLdNdVJje/BHVagiJe2apUmZs9CSuYmmak4Mxl++/Ab/wH0KQV6PW20zzohPl72D7lqWtrDHwMbGZqYoG2HAr43ubgIQrQr08D50LKgCzfmqfoEuRSeobr1q31yoiVhps=","authorEmailMD5":"605b046ff2b480851e0607a41ed2215a","authorUri":"","authorUserId":"disqus:disqus_tBCipkZ9pI","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_tBCipkZ9pI.jpg","message":"Hi, we have fair amount of quite complex code (business layer, involves accessing data base and other services) that can be used both from ASP.NET and some background processing. I don't want to duplicate this code by implementing sync and async versions of it. So, I see two options:  \r\n1. Implement async versions of everything by default, and then our background thread call them in the way you describe here. I assume the preferred method would be task.GetAwaiter().GetResult().  \r\n2. Implement sync versions.\r\n\r\nMy inclination is to go with first approach. It is more convenient and allows flexibility of making decision that something to be used in background process to be deferred.\r\n\r\nDo you see better solution, or potential problems with this one, like deadlocks, or performance considerations? Since there are no UI threads involved in background processing, I would assume deadlocks are not an issue.\r\n\r\nThank you.","postId":"2014_12_a-tour-of-task-part-6-results-b6e44095-ed73-3545-8772-598d69dec4ab","replyTo":"","date":"2016-12-05T18:44:15Z","timestamp":1480963455},{"_id":"d1f6b5b3-75c0-397c-a98c-218262cad02e","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I would say the *ideal* system would be to only expose async APIs. If possible, modify the background work system to allow async work - if not, you can just block with GetAwaiter().GetResult() (assuming there's no context). Under the covers, the \"async Main\" support in .NET Core and the async support for Azure WebJobs just do this.\r\n\r\nIf you really do need sync versions (e.g., for backward compatible APIs), then you could use the bool argument hack in my article here: [https://msdn.microsoft.com/en-us/magazine/mt238404.aspx](https://msdn.microsoft.com/en-us/magazine/mt238404.aspx)","postId":"2014_12_a-tour-of-task-part-6-results-b6e44095-ed73-3545-8772-598d69dec4ab","replyTo":"95e8a37c-81a0-32c4-b89a-c943dcfae0da","date":"2016-12-05T20:44:03Z","timestamp":1480970643},{"_id":"c8fa1bc0-c885-11e8-afc0-9d2b83666f59","postId":"2014_12_a-tour-of-task-part-6-results-b6e44095-ed73-3545-8772-598d69dec4ab","postUri":"https://blog.stephencleary.com/2014/12/a-tour-of-task-part-6-results.html","replyTo":"","authorEmailEncrypted":"h4s+iDsPmN2UQHCDhL2ms6o1Zkq0NEEHJauYa+JM6j0wFrStO7VFL1J5AUe7gv5S34ZdxzJYG2a+X2Imo1KvYRHRHYnJVlPYUQOGMBBx0Ikhdle5ASv8quZ4brqMd9qHGRpc8686ZEafWeG+olsro0pIg703NA5iMOlW8mUUohL8PX3jrOa5YG0ErRQJDr/jqIzyPO/nS8ubz+ne3781ePlmGOITZWgnaAVyJ9mvbyrngphsDyXdDMBja9S6OLR0maqKdtgGuIO0dPgN16RMzPhifQXtlaU5V6u/RQHvoEjlFDMSjG1l34nDhbG6wcprQYH7An0Hha9D/TQ/6VR1bm9myIJyCYyU2OYt4mN3F0OYYswiEDA2DYBLQ7DUV3osJ6BKayOjI2P0H4EbHesAEh7JkvcLL3nwIthChzWGZyerev/nIlNNzjj1oO7JiYRRP1eg3kpJY/gHECNWH5pFsQIErDTI/R0DXt7tSlxBTsEIzSbb1ACMwOISTsSrNo1SfCkbjBIr8+tbpiosyZmWIeaRsj+b+G0l2ouKD41OH8lm7enRo2sNX/5ssFs7pc0ZyNEiXaMjaalEU8lLUDlzJL6FpIR1kZiGQCQtGo/ksc2NvOR+w8JIwy0kfU3n2W6lfQ0wm+oAt0B74XEQ8oocD834rG9IKCR7OB505oykq7I=","authorEmailMD5":"4ab2509d2e3e3d0c9eed5dc4f57d8b30","authorName":"Griff","authorUri":"","message":"What are the advantages/disadvantages of using .RunSynchronously() over `Result`,  or `GetAwaiter().GetResult()`?","date":"2018-10-05T10:02:36.707Z"},{"_id":"5609b4c0-d89a-11e8-9ea4-a996cd0c12ea","postId":"2014_12_a-tour-of-task-part-6-results-b6e44095-ed73-3545-8772-598d69dec4ab","postUri":"https://blog.stephencleary.com/2014/12/a-tour-of-task-part-6-results.html","replyTo":"c8fa1bc0-c885-11e8-afc0-9d2b83666f59","authorEmailEncrypted":"UHpCHk4kDx+gI78xjAJF50auzK2wkFxntgJn85vtuIHxCynOcovExUiAztxrhKS1a3aVXuV2qCODoQj+YqKFvcHQOqLy/vU7gaUEXd/M/QIIpBzaHXCfyb+ZbMl2Fmi7v2gz7NPiTgyyXpixBBCNaDkv1NGs402vgxnmJQqZ/49rdefA0S/EvoqXZirEsx3o+56cd69vrZXo9OWfNOL6z71c1+EVcdpbJFoogEKVyTTw8d+3HUJFNAbPAvjah9VysDbDp2j382bcd+88ihSuoaKIF75XJD3jujx6FmgL3KfAmPMXeHqZfPY0uGpJBtum6NQhRzWwVTIQRfeDUS1Yz2Y1y8tCE+UM8urARrnL56TN0wW6/oI5aZ2kURtjA/BQkzTLy3tL+lRjhJZLXBWrXo9QgNPt/wTxxaYXVFYjzYdr5qaxwdnVl4mFMH/64Mt7/6PsHrmyCLuAs6thactfaKeKlhK4fxOEaC+IT+s/lu1w4ktpov0x6wzyD3Qo+uckeRWT/HpI9fQ0lTQpQFBiCu0zMu0b3BSa2Lkaaj0D0C2hBgGZldJb/jAq0113Tsq1I8CF0KPZyxPGORkxGvKPujZFC3LTS8AeBm+R9uuPKClHE7fz6Z0sdOZ+y008h9LLv9cLYiDGQ7inEYGnIXhOWYbHlTDEFXE4w2vPirCQElw=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"`RunSynchronously` is actually completely different. It can only be used for [Delegate Tasks](https://blog.stephencleary.com/2014/06/a-tour-of-task-part-3-status.html) and is used to [start the Delegate Task on the current thread](https://blog.stephencleary.com/2015/02/a-tour-of-task-part-8-starting.html). So it *can't* actually be used for a task that is already running, or for any Promise Tasks; if you call it in those scenarios, you'll get an exception.\r\n\r\nThese days, the only reason to use `RunSynchronously` is if you were writing your own Task Scheduler.","date":"2018-10-25T21:10:02.041Z"},{"_id":"777d0640-f012-11e8-b04e-41a01f6f8010","postId":"2014_12_a-tour-of-task-part-6-results-b6e44095-ed73-3545-8772-598d69dec4ab","postUri":"https://blog.stephencleary.com/2014/12/a-tour-of-task-part-6-results.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Arash","authorUri":"","message":"Calling an Async method from Sync mehtod is there any advantage?,I have a windows service which does a lot IO operation ,that calls async methods (IO) from sync method  ,is there any advantage here for this calls sync => async ? end of the day it blocks the threads","date":"2018-11-24T17:57:54.387Z"},{"_id":"57580f30-f1df-11e8-b68c-e5773aea49b1","postId":"2014_12_a-tour-of-task-part-6-results-b6e44095-ed73-3545-8772-598d69dec4ab","postUri":"https://blog.stephencleary.com/2014/12/a-tour-of-task-part-6-results.html","replyTo":"777d0640-f012-11e8-b04e-41a01f6f8010","authorEmailEncrypted":"Hb6f26K4O1s9+B29/1hSs3rA8BuOvq3aLgfBg7KL+9vJl304Z0YQk2b54Qc9IYWRqbc/SF3tR7rtj+1jUMFifKBOUWXqTNnv+8InzKSSZ7vNBHwhmAWbTPMbhzQIPpj6zWvTYzhzoWxa2PnwScMXyhd7jyNDbTzNpmpi9tIlg6i7+S3K9nKKSw8uh8jRVwmyfAdj9cvCCW/Hmb6c/hcPgBLbIynGoCxkCaujhJLzZl6zMiGhmPjrizxO5sKYqySVEU7qak5o24ZspAfkuPrlb+Umqyc+kPGN6EoVfpry6W9o27tXwJwnTLDDOn79uu8kqUQ0wo9YkixTCzky3d/xpuXNTARY5ejD1NeQHFiL6MXbwYyMcdjp6PsJJzmfn0IxwOiuMrD2aAqtLy6bG3vZedd3kqS8UTN7yv16vRJ4uHPRheB38L7mSh37F2Ur49tPUVs/banFaamPLu10N65aNdkjltRA1IB1lFEb9PWwlbxhMV1fnua5MqcjbPTeMRiIU/7JkRaCkFGE4Sg7YpOsD44qmBRk5kigf0bqYbGMEQC5IEZh1fuZ+oumXWQYUec4L3xTWt0RffMVRmIAOMiOlC+jdGEHTdzo/w1QZkEFg5z8ppDcv6tvFP0CeDFNITMEMkAAqpgZAuDge1rMAbQVwDrIw9HMXA6KQaSmWIW1R/Q=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Win32 services may or may not decide to have a main thread. They're a lot like Console apps if they do have a main thread, and it's normal to block that thread on whatever operation you're doing. That's not the only option, though; you can have a Win32 service that does not have a main thread.\r\n\r\nOne approach I've taken with Win32 services is to have a synchronous main thread but keep everything else asynchronous, e.g., `AsyncContextThread` from my [AsyncEx library](https://github.com/StephenCleary/AsyncEx). But if you don't need to synchronize your code all onto a single thread, then you wouldn't even need the main thread.","date":"2018-11-27T00:56:58.534Z"},{"_id":"076b58a0-226c-11eb-8c16-05e84175b167","postId":"2014_12_a-tour-of-task-part-6-results-b6e44095-ed73-3545-8772-598d69dec4ab","postUri":"https://blog.stephencleary.com/2014/12/a-tour-of-task-part-6-results.html","replyTo":"","authorEmailEncrypted":"I0L/Pfk1/Leh13F3o9IAKinfXmMrJzwLNyGTFGlZpOl9p8LbYuESZoUOqAnacwCZ+ZexQCaOClJun6UOu1Ges2DnVvN9XUUCAXjiNMpQIM0Ayml2p+DFQRT4d0gY2yrPelgv+eEU37989vEfturfJzTlOofsK/cZUhK1rlsPniFlMX2t94p2z5KXxWuwIFZQy69l1SMjavL7CesqrMdcWdhR2OVdOmhhk+NrFqrYogR1SKp5AUU41tS+3y+FSXrhfPovunN0Tx6eU8Kr6silR2hGFoWetHEN4IUObnzCgHNDQwPKhkZuBHHzJmULmWWoRNV4frb4e/Je/byI18LUJVbuFQ4NITDwmCNtkY968R0W6Fbk36YiFW51A+jl8cP5fgcoApzP/NmhxrPlEPKsg4t4ao/biJHqzedAqSgLI5bs4grX6C/ZfMqMoGnrC2iMjhrOHWLKSG2Zts8UYwZR4ab/txE1UoGz2xXPt5RLqci3tcb5Sp9zOL56MLVzg1Wcu7UpLxbuw49QUhfUQSGnTz2jEf9fBuXotm2bUw8pWk7D/c9le5Hz5o3ELA6EpMqfnnA2wGgScZnqgVfla3xj41ndmi9dhOOaGzmKyaxqnHJeEA4WWGTCxHahI1hH9M4NkdzLG0CaoxRg6zqAWuhNuFTjobxNva8ExOhPWNRh2qo=","authorEmailMD5":"99ec52be71abeada99e5a93663f6e46a","authorName":"Vedran Mandić","authorUri":"https://github.com/vmandic","message":"Stephen, \r\n\r\nFirstly, an unmeasurable thank you for all you have done in explaining this truly uneasy topic throughout all of your online-offline writing about it. Sincerely, thank you. :-)\r\n\r\nA really quick question, please. \r\n\r\nI am having a hard time finding the answer for is it safe to access .Result if the task is completed already? I am using a .WhenAny(...) inside a while loop to iterate through a collection of tasks for which I do not care when they finish, but just want to process results ASAP. I'm reasoning that await would be overhead in this specific scenario? But that is just my assumption.\r\n\r\nThanks,\r\nV.","date":"2020-11-09T09:14:54.402Z"},{"_id":"f700c570-2290-11eb-a090-3b27858fcd8f","postId":"2014_12_a-tour-of-task-part-6-results-b6e44095-ed73-3545-8772-598d69dec4ab","postUri":"https://blog.stephencleary.com/2014/12/a-tour-of-task-part-6-results.html","replyTo":"076b58a0-226c-11eb-8c16-05e84175b167","authorEmailEncrypted":"IXI28EGsDq4PjLWZuOg8jTQdwi8CxWTywT4NHyUUsDl4XI0zWAf6Goa2knQJ7SDWESXN1rdcqQD5xGI2+YZGWxPBlwBL0SRSb323yUzC0EOZrFT+PnQRglQT5PnF+t6T4Pjz/tYmgSGFaSByEnP4CkX6HDG3xz8A2CUQTlTC1xvcxnatFUsfJ7utpTs3z0x9PvmV/W0TfGS4V+LRAM2Fzwmv0H+maAvedJK5yKeilaSb0Akv4J2NvRM6HEdMoZ/zELIB3S5XaPpzTqcv0VyQpcvTrufQecMuOVJlbjbUEzxTVUFfH0vnJpCH88Mgvs9Fa5T3cnD1sQYMZ365VYbUE+FKGvi5gzYmeF5KS4uh13BLaJnZbhM8NTtJ2Oxdkraz70/1O0XWbbGyiIDIZGEsrtW8YHiHTJxUIUuUoOTRRctG/M8+sZAcp7MsFCgMrm1rSkRoqxrOuCNjMpjIL2xSaGWqTlZfGwOBMhmLIYXy/9+57zmjH7EOLYODYT6YCipsfRC6Q6y4lqTSfRZP7gMUKD1EB43g4Ofjmo0Bne2xA/AQq6l/v2KSAdw9fe9YECeyv300CN14U7LhVkqe5uH/aD8oJThgoE6VVdwXNxkf9+j66ZGpph/a0tP6VjK8res62ewlNOo3ho6ptMH69YoIBPNubdP0t8rY6rT3oh3TJBI=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"It is safe to access `Result` if a task has been already completed. The only tricky part you have to watch out for is that if the task completed with an exception, `Result` will wrap that exception in an `AggregateException`. For this reason, I generally use `await` even if the task is already completed; the `await` overhead is minimal.\r\n\r\nIf you want to process tasks as they finish, then there are techniques by [Stephen Toub](https://devblogs.microsoft.com/pfxteam/processing-tasks-as-they-complete/) and [Jon Skeet](https://codeblog.jonskeet.uk/2012/01/16/eduasync-part-19-ordering-by-completion-ahead-of-time/) that I've [included](https://github.com/StephenCleary/AsyncEx/blob/8a73d0467d40ca41f9f9cf827c7a35702243abb8/src/Nito.AsyncEx.Tasks/TaskExtensions.cs#L184) in my [AsyncEx library](https://www.nuget.org/packages/Nito.AsyncEx).\r\n\r\nHowever, it's been my experience that most of the time a better solution is to introduce a new `async` method. So, if you have a bunch of tasks that are the result of calling `OneAsync` and you want to call `TwoAsync` on their results as they complete, then a better solution is to create a new `async` method `Task OneAndTwoAsync() { var result = await OneAsync(); await TwoAsync(result); }`. This generally results in cleaner code.\r\n\r\nHope this helps!","date":"2020-11-09T13:39:18.221Z"},{"_id":"dc707a80-86df-11eb-9ada-ff8d14726998","postId":"2014_12_a-tour-of-task-part-6-results-b6e44095-ed73-3545-8772-598d69dec4ab","postUri":"https://blog.stephencleary.com/2014/12/a-tour-of-task-part-6-results.html","replyTo":"","authorEmailEncrypted":"EBCeu+p7wrs+ZuUJWQD+pcjf1GfjYBjxPNbH/lbSAYrjxK8zrW0oXT2NQmBBfZNOVyMZMIw3GDbwJOTs6Ee2/wgx/7iNsjqB0fN4rDwuDMEHlH4HgT0ctXtRtANqNxtFhpiF08c3GOeIGpAZZeRcQxSkUOGglwvTgt712pWRRSBROT1rF/2lgFM55MzKuLDRFWK2pBI2o05INaEwxdUGM2Og0F5Her1IDfyfq9u5iqs18TyFGe2xlq54TPOZJgR3R0HDOymSSIia4XlnKCKpIo8lKaDyZ/S3IwfIOaozWxSJ/slLvPLjFb1o1U1++IanXwHkJGQ5ga429b4heBt/ij8Cmswbdv4FAkZ5JUj3GOfpa1HXITP7spRFWKhLo41j1seQg89g+VpW4+johOZFPi13Q4JCTpG00ucAr0kYDSLbRtLI6lDayRxVKNbDRc9/+wP5fhn/yN4FOVBhAMleu+yjoidC4IjuhQvXFirMoTOd15U2xQgGK0DxSTh3VlsSBrcgsnfBDV7yP1mJuWGumSCkKx6FpHoNEslOxQJl8Tb+Z/FehhwKaqZ0QQfdLaxwlBPMPx2LlLdQlOeIWUC13t6xwn9s52RFNZcL+jn1JfWmBLZkm+GoSI5d+sH3bykLIqCSroExdp2+cqlJnAgzfD+9g8xqlXZXLcnUqPrsKlE=","authorEmailMD5":"acec1be729daf61a6f026fc39b22e41e","authorName":"Jack","authorUri":"","message":"Hi Stephen. When dealing with a method that has to be syncrhonous at the top level, that includes a\r\n\r\n Task.Run (() => some asnc...).GetAwaiter.GetResult(), \r\n\r\nwould you recommend wrapping the Task.Run in an async / await block instead of using GetAwaiter().GetResult(), or is there a better way?","date":"2021-03-17T05:16:00.157Z"},{"_id":"4df14af0-87ed-11eb-a855-5582c59c7d03","postId":"2014_12_a-tour-of-task-part-6-results-b6e44095-ed73-3545-8772-598d69dec4ab","postUri":"https://blog.stephencleary.com/2014/12/a-tour-of-task-part-6-results.html","replyTo":"dc707a80-86df-11eb-9ada-ff8d14726998","authorEmailEncrypted":"W9yZ4kKMMbSubOmv8Qfha+8SRibStLYQwzsjzm4pYYnaTSM+kOGbnngjiYG94bUam8FCyF0OONqFF+qCTOr/4WuI4aJ34BPxrN55uSSYlImx+AXkNQcOLE/+zOrqOMkWWbmiuMdaQZ80idJuBdpXtK689Rw9/iBC8f2GHD3BeRb9MYp9EeRlxsR2sASZweYav/2SfUUB9y0KO14m7E552PS+hIxmSu2PGD9qZv+GnMzaQVEFI1bhIHj1LG5NSIP6/2Mvs4I6FropXZIekzIC2myWIdTLJWB4E6NQyAuVVtPxoOTxBc3lBse4xSJlfZXGNQi8yIta+uBBBAJCQBZNBikbMHLCH0nZjnNu5Ug/vGA+08texwdJrq+3+hn5cI5W/aqvkqHnGY8O9iDwkqx9AkarJG6k5N5LyvYmmCvyvZYJzas15q4HJua4s8Yjw1L4f35lIC313qCJ6S01so6792XA8GdtqvIW+za7zp15o2vs+dBmbxyeX3FJpSjKgXxfcZfsDomxxp0T5oezudb8J9xeUcbX9KOzmyKg1yklMhGoflCUW7xLh0aD/BstXrY50cCKWgK691FgLqbIbAjxP3u21A8+cNDI4kbvDHJlC7oFKGKHAGrhxuRlJq2cBZoDmzALJM27Sef35L9golDbf407wTMcRQAcXcngacUcVGk=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"The best solution is to go [`async` all the way](https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming), so no blocking necessary.\r\n\r\nI'm not sure what you mean by an \"async / await block\" - if the `Task.Run` was `await`ed, then it would be in an `async` method, not a synchronous method. That would be better, but it isn't possible if your scenario is that it \"has to be synchronous\".","date":"2021-03-18T13:24:45.359Z"},{"_id":"7ab4fb80-9040-11eb-bdc3-61a057cc069a","postId":"2014_12_a-tour-of-task-part-6-results-b6e44095-ed73-3545-8772-598d69dec4ab","postUri":"https://blog.stephencleary.com/2014/12/a-tour-of-task-part-6-results.html","replyTo":"","authorEmailEncrypted":"O431PNDzBxMjqMU8UjYS19WasZB1oNf0OAeMjraMc1iuZwUryqsQMXMVajQzBINcleFKYcmzNoU7TB6wMZmLpGTX7BBS53jWgWY5Fq/JPCi6qkpoIPeeqs9bNRnNzIdbVGKHpciEyhr/7Y9A3RwMgS1y9+hR5s/iukdW+d/3iYbkot6PMJyRH31ogRFoWlOwEyPlOa67iGhJ1drmkjeHnaC4h48YfDOk/RePdbgoZlDVwZhUfj6WZIN2ehcpREL3KMY+TtpdCB2+3k1r39CdtZFmCWeTItEJx8fZvoCYZ7YUIScLvp2n6pmjfiB8CFLS5gEqWi+J2pWlXt9uHm64wgCyzZsU84+eIkNM/aN5b0l+49kUZQ74FrzWWA4Cnzkx+RSK6Zokb0ttPl4KUQj8nOR6NETtNJsedN+Tk8clCUU/MqCuDAGXP/+Xgfpa/buCJrWm6NZkRQEPinBsbHle/IP5+WeTXHsWJwJY3a8xaCPaLi9IMGvzxhsliz59Mo7bTkLb30UEJO6hjj+6vvuDFHYZwige5i08tXeQ35d7IPZaLd4c/g5x5d603eHw0QqWQzCtb3X59wXOtt5YnfPzOB00zoXMJYQuIj7/LYfO/71Qb64b/5isCYxyqtEcL9t32C4oELvtndzuQpNBsYYhPxnLU4qB47Jk4RSgYXaHym8=","authorEmailMD5":"7ae8adbd9242fc874b6a1978d2722453","authorName":"Mike","authorUri":"","message":"Hi Stephen, love these blog posts and im really enjoying reading back over all your older posts and seeing how they may impact code ive written  in the past.\r\nI have a question about a project ive had running live for a while now after seeing this.\r\n\r\nconsider the following synchronous method: \r\n\r\npublic void doSomething(){\r\n    \r\n    Task.Run(() => AsyncRead().ConfigureAwait(false).GetAwaiter().GetResult())\r\n\r\n}\r\n\r\nWill this deadlock or will the configureAwait have saved me? My understanding is that it will only deadlock in the circumstances:\r\n\r\n1: The AsyncRead requires access to Http.Context.Current\r\n\r\n2: The code requires access to the return object","date":"2021-03-29T03:40:18.140Z"},{"_id":"6caa9a50-d8f1-11eb-b968-d76a3395ed13","postId":"2014_12_a-tour-of-task-part-6-results-b6e44095-ed73-3545-8772-598d69dec4ab","postUri":"https://blog.stephencleary.com/2014/12/a-tour-of-task-part-6-results.html","replyTo":"7ab4fb80-9040-11eb-bdc3-61a057cc069a","authorEmailEncrypted":"gOYzO7RU7cMTtk3GDgLRKbkAkx2hVSd89V59PmxVH+QESCkcWB8OzgKd3zg0zo1k/u8lRxnhvgEnEeCp3nAgXAMfqwfQDcTiBjMqiCcAwbg+dVC9vDueL7ZOnrH7I4S0NiE9XKfAtgNhNVyedGt8jqK5eJUnao1TSdOP2ixOYp1hqOZb4uEJu+7YvqvKMPNc4Q6IMARfNAq4by20RI9Ux3oTb7lbY+TFGVZSgkFH/0NH1Ol0XfdXi5DQzUaRquziIAHl9TOpPFpQHGYXyZNlF9LU49moO5VIJfDbC/9+SeEdDDJDYpzd/lOeNFV9mc9tjeXVKBs7iTiqlGYzQQDYfZVnpBsdj0u9k0UtmMz6LVC9sfLN0x0wVKd6AGc0Yy8Azz/bSvuAHp+6OQa4rlxotMy6tsFT8z24cacUDPcSjPrNTi0p6lDVoHF4RTTdXQhoeTv3gyfmSEjo0lwk3Mj5zDgqxYoYKM6Lb86E8ldnRavWeRhGzLOxyc6SeRa5XTuUfbs4tz0GmSqKbAzUVT89O1xQJ8MTAQn1dsth/0xkIDlTdkY155kvWFUwEW7w9NjI7Q7TvtSepFyU7u3POYWFu39jEFjV0eUr9Qaemzuq/i9mgRNaKJXfdWYjKHms0i1+M5RsoeQUJv3cbqCBXQsLujv1G5hP30+JTxfT5qfY61g=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"As I explain in the [deadlock post](https://blog.stephencleary.com/2012/07/dont-block-on-async-code.html), the two parts necessary for that kind of deadlock are 1) a single-threaded context, and 2) blocking on asynchronous code that attempts to resume in that context.\r\n\r\nIn the code example you've posted, `Task.Run` will run its delegate on a thread pool thread *without* the context present, so there's no context to capture, and no possibility of deadlock.\r\n\r\nThe `ConfigureAwait(false)` doesn't do anything since there's no `await` to configure (and since there's no context anyway, even if there was an `await`), so that can be removed:\r\n\r\n```\r\nTask.Run(() => AsyncRead().GetAwaiter().GetResult());\r\n```\r\n\r\nThe code is also odd in that it is explicitly blocking a thread pool thread for apparently no reason. The code can be made more efficient just by removing the blocking:\r\n\r\n```\r\nTask.Run(() => AsyncRead());\r\n```\r\n\r\nThe code is also doing \"fire and forget\", which is highly dangerous. Specifically, `AsyncRead` may fail to complete, and there's no way for your code to know this. There won't be any caught exceptions, logs, or any other indication that the work just disappeared. If the code must return early from an ASP.NET request, then I recommend using [asynchronous messaging](https://blog.stephencleary.com/2021/01/asynchronous-messaging-1-basic-distributed-architecture.html).","date":"2021-06-29T15:48:18.901Z"},{"_id":"aed76fd8-9d8f-4052-a65f-35ffef957865","postId":"2014_12_a-tour-of-task-part-6-results-b6e44095-ed73-3545-8772-598d69dec4ab","postUri":"https://blog.stephencleary.com/2014/12/a-tour-of-task-part-6-results.html","replyTo":"","authorEmailEncrypted":"aNAJ3KQ83nMUmBwR9mYQK4SbCwoAMpsofeWRj/e9fBiHStJPvW8MP7/PpRX90Pdl3CEH1HhRP4CBuNyUbty0x0GeFklby42UmCqFAKcJ9eIjPfcp0Ovh7bxIqlFnEgUilDOrW9I9424ed27ao1LWt5fcGj8Hw5ijas/OeX43mWyfEqYKt3tCFQCW2gfjGzRxBnf9sA/4sP5iAG27jsD3sNOUqdrlxUDLWOEIYHLnd3VsxhYKyhWpwOaGi7oDSysTvpar64nrdlvgWIpQdiNYPhaIJDVQ9geQ+j5aVA/+HEQca8A4Ho8LL3iq5AMFobJGcPoEg9e3NiVyDXe/EK9i0iy0aor2DcVVoH4zYuQOACZq0GdhbubkEsk+bYYNWZ/MIYXXm1bH1hRoHLLCX3NM8HvcR8fUsbTl7w4DXVdjpc52hVrmMOHh0T+wShZKSooHr4hAxkCfMNuJzJAMbKtJ4cw+9plKe2MWQgOguWr04Kp5j/Y8yEwBtqC2Zf5ncW9BFM0gyvCSnLQHkyns21Ljh1x3mzMDS+e4Ygr7iiL9FmShG5NMHTz3soalw4aFwNIj5xDavijGuyEHdPDNfRVfySQN6bLF6LHYgIgWWSA3tZohVtnvOOVrsr3eEbNWZQBqRbJ+i2+MBo9CROAfT9ZhnEsnwZ6xxmdN3slB0a7x558=","authorEmailMD5":"88b8601f2a393ae56e00fd79f61ecde4","authorName":"Lee","authorUri":"","message":"Stephen,\n\nWould this be of any benefit?  Could it be implemented to achieve the same results as an awaited task in the underlying internals of the Task<T> or ValueTask<T>…\n\nprivate T? _result;\npublic static implicit operator T?(Task<t> task)\n   => _result??=task.GetAwaiter().GetResult(); //this is not what I want, but I dont know internals as well as you.\n\n…This could, likely would, lead to some unexpected behaviors (due to the implicit conversation), so perhaps explicit is better.  I almost think an awaitable implicit operator is what is needed but, again, while I am pretty versed in TPL, there are parts of the TPL dependencies that might prevent this from being a good idea.  Thoughts?","date":"2025-02-12T19:41:23.5710154Z"},{"_id":"8b68676e-8bae-4690-bf7c-5ee535d18c3c","postId":"2014_12_a-tour-of-task-part-6-results-b6e44095-ed73-3545-8772-598d69dec4ab","postUri":"https://blog.stephencleary.com/2014/12/a-tour-of-task-part-6-results.html","replyTo":"aed76fd8-9d8f-4052-a65f-35ffef957865","authorEmailEncrypted":"VG2ugBH7waGyiQwV7H8qU6hPZJ76cpOoYxOqphkHAtYqbimXuvY6yS54kzv8H7nSs3irFwQPZ/YBfRNe9l15NCzKL/1D5xWEi2GGAspnho/TfMmjuHumqt0GPzaO3pLaRzx4XN+Y32G9lTVIKzVh9f/iZAw2Q2JVM/Jxuk4pZx3fSwPV8NuGE/dtfyoGj7/2uPy6yDjT+27YFWfJt09/cmOYsa38rOX0mBOCo75InIK2+z7so++1Ln3We37w3Qiv/060tB/etYF2bJ4sIm6/ekTrjK0HIILs5sakxgImaIGI0ySFoT8CixhbV2Du8wzFjopZ2hPYEmYFNe7F3SuP9pVnLzAzjuXd0ZxHtncnyNeeCXkCNpYiasccyT2Fi/rjcUvsnVHbRTk1CVEP4m4mW06O7EthcsW3VK8s6DL59LAPnEJb1VvMUggWibqer2SDqffm4J/tvGhv1ofcrF0Rt7xMqCZgV5K/mJydADEyFy061r18hRSjrIqEj5YvmhbqSH9bVk4le4vyrYulTzkyuSVDWQhl7tohkbhq6PTQb/R4yHf5GMpw2g0O00122QzqojBTEMmJRkvMSlfyBE/P33KoQYWXsVKnF2TglYs1YnMFnNV75WsvvfDDoDET3BA4g0XbH3/J846Qm4EC3eZkTD9dUIcG5phJvikT5o669kY=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Are you saying you want implicit awaits? Or implicit conversations that block (which is what the code actually does)? I think the latter is a really bad idea.\n\nIf it's the former, there are disadvantages to that approach. See \"inferring await\" here: https://blog.stephencleary.com/2011/09/async-ctp-why-do-keywords-work-that-way.html\n\nThere's been some work in other platforms (Go and Java) on green thread approaches, which have some promise but I suspect unknown problems.","date":"2025-02-13T02:45:44.1494959Z"}]