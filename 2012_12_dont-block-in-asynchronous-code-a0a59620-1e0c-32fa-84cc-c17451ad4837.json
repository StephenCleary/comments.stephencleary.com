[{"_id":"16191ee9-1c74-3f69-a4e7-3392e44c489a","authorName":"ndroussi","authorEmailEncrypted":"Q3ESk8r/C8ogao3OrHj4QTcL5BdLKLJJVj+zLwvpu3Q8dVpi4cQV2az1/ftfezYO5V80oOiK0+tK916SyH3r/M4jGA5aRplmXwtKIzYBTb1XyzLVA+w+hZn4FZCXDGs5NOca0a2vpKwzUpbqgmn8MA7lWOxRQWdtKJ7xNIXX3dK3tsJ+tLGudUmMmsl2kQYe+zrSl1bv+31jZjl2SSGpzNS6OgfvX4NcGKev0kYyykVZVYq0Qf5ipvd9pGLKheprWXRfucfs3WQRLaTJjuqavhlBHWwIhtmbXzwZ0r3PErT9kY0APfngFhzhxYm+9Qq8jtdDBV5Hz1Y1DL3FlWOubmsN4CSGi7FIYnv/adbBnB8GW93H3KsJXoKVjBCQWt18C9WBPOBlhM0oTnvR9cQT7n1we407LOLTDqacvbNFSq2vfNnyym18N4vK+fplQ5AvZDKvFC1ZbvpQ9K2f3Q1MTUed+CuNL4JKjlH/6MeXbRzRUK7iyf9rrq86RfGG2XXPUP8Q8NaekGzIKvlBpSM5x7BgmgHlomhDxqCZ1h6KdqO4KvbpOiTlPW1KpUarqQiUQIP0Z266EK1SXjkbtIapFnmRVX0/PM9zkaEwqecYg6C6DRHoIEVm/+dYaDe4bwU/HNOD/mRqyDUI8mPkVKlYnO2S7bMhVK8HZDFL5YD3CxY=","authorEmailMD5":"f9caf17e421cf018fb5fda1dd3c6e93d","authorUri":"","authorUserId":"disqus:ndroussi","authorFallbackAvatar":"https://disqus.com/api/users/avatars/ndroussi.jpg","message":"This issue worked as a charm, I had nested async tasks in my project so I needed to configureAwait each time I call one of them. I hope this is correct and won't decrease performance.\r\n\r\nThanks to you, you just saved my day","postId":"2012_12_dont-block-in-asynchronous-code-a0a59620-1e0c-32fa-84cc-c17451ad4837","replyTo":"","date":"2015-01-04T14:02:52Z","timestamp":1420380172},{"_id":"16ff0fe1-c715-344f-8dad-7fccffa89c4d","authorName":"ndroussi","authorEmailEncrypted":"Y8mQyEiE14EoNO9CSINZJMxwf11+Je0fGzXFtJFWoQP/BDSYBvsG3z8Ckg+zwfc1nfQlFCPizhVt4kl8CDfRsoWibsrQwmXnPt0ZmmBzK3sQwQH1nhvQx4pdFGz3pW347Yfik8lEQ+VzSHO9TScs75cgYEVSE5zmyTdZDg2yAodf+1Zza0UCW18os2+VPPNVJY584vex9YhIvL56Z5755kRDHpl6qm7y++gmbENFu+Lw2rXP3sFIq05lXCrBkdwCiJSoN7q6deBoUp6Hmmd0jhZx6s9qGHxDhJTiwewdoxB3AXTxma5MbxtltbFN0yPg8SaXSbrcgLFg8OkWiNJvFQyZVV6WnvOwTXsrns+gq8RUM3yrf7AHj7P0iwjj75OiXBA7hX2nJj4//VM8gnHj8S04m1BSpK4KOnXSdntqhkjyncp2AmoXttljm0iAfeaZXiczBmPDhbX+tIhn/VgHyZ+rcaZpQW/piUMpnhcFoQUYPa58fulf836qRAc5gMGMdC6ZgA4RFUD3hOAQHFwG6d0ajX678Qwwk2/cZGw5I6hLIOemXcHtdsQleP3+qXjyyQVuGdp2cClXs/WmX87qZqf/Wt2/AUpVlSfw7uN6rkzaSspA3U41f95BlogiX7DSyfIXZT9bgYeKwP9a1OeyKAkYuM1pp9U8m9JjkpqoWec=","authorEmailMD5":"f9caf17e421cf018fb5fda1dd3c6e93d","authorUri":"","authorUserId":"disqus:ndroussi","authorFallbackAvatar":"https://disqus.com/api/users/avatars/ndroussi.jpg","message":"I just detected in my WPF application that when we configureAwait(false), the main UI thread throws an InvalidOperationException when trying to access its controls, exception details:\r\n\r\nAn exception of type 'System.InvalidOperationException' occurred in WindowsBase.dll but was not handled in user code\r\n\r\nAdditional information: The calling thread cannot access this object because a different thread owns it.\r\n\r\nSo I removed configureAwait(false) from the button command and put it in subsequent async methods, it worked just fine.\r\n\r\nthanks,\r\n\r\nNabil","postId":"2012_12_dont-block-in-asynchronous-code-a0a59620-1e0c-32fa-84cc-c17451ad4837","replyTo":"","date":"2015-01-04T14:31:53Z","timestamp":1420381913},{"_id":"06e7d2ea-df9c-304d-b2fa-866f1c8d3c12","authorName":"Chandan Gurjar","authorEmailEncrypted":"aw7Ds6XWuch5m6koprDbfwcf5fNc519nbKCSsJ7b/pDQ5lif3Be4+X5vZ9y+LSZ/KXT7zUNLhN3GDRaFYbl+jpZuTau3l245ZmkDR3CGl5z/ABfGUNU5AkHfjNHIJgtEcvwLL6hRDsYHsF4+W/SK/lr6mtcluZesWmkUwRF8jZxPG5TDc1v55nbPJULJOLQlo2I2xPQ6OkIFb6xkO28Zeq26/hFqs6Nl4hRrgRjo7wyYjQey/tMOlYHECNaXEkwFIUzHYGUi5/dnAzFaJIdfSz5eN7RlfB4vFDjK5UAk2KrknS+ovgZUP7BMYFTyHa4xf7zaBPmEMFGFMIbL5zJB+Pogo5NvsOjUlA2EADsmoeOSJf7bniM6D8yX3FFFy8zUbu0cHl9MAmjdLWrEkUcKjQpFXLoioDHRMZiurGtrBTHDmMrFkJbWGayVYZpguDq78m/4V9WBj9m7FA4Cv3ilrFjCTYdPFaqdcLqRt5y3/qoHxeuAZoovyl2eLrEjcP8EaFzi8E2X7KX+nH9y/4OHQ2i+XdbqEnWmAfgydJQUz0rl/bkfC8osfUkBUpZ/F/aqRVkwQIR1DXlVVB+f5RaTly2zBgX3pAJumpYgMzGKmRa7LgvkusWkoGuMZWMwwosnFQ4ociHqkbWWXTaVuLZNOxF5D3rMY/YqekRSrkMYi40=","authorEmailMD5":"f40d82cf0c8e510ab553cf72c5b46551","authorUri":"","authorUserId":"disqus:chandangurjar","authorFallbackAvatar":"","message":"One question Stephen. Is there a non blocking async version of fill for SQL Data Adapter object from the sqlClient library?. Lot of examples I see basically seem to sacrifice some thread during the IO call. How can I be assured that atleast for the IO part of the call, it is asynchronous. I understand that we need a thread to fill the dataset eventually","postId":"2012_12_dont-block-in-asynchronous-code-a0a59620-1e0c-32fa-84cc-c17451ad4837","replyTo":"","date":"2017-07-06T10:01:56Z","timestamp":1499335316},{"_id":"69fa159a-43e1-3267-9a0b-8371b82a4253","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"No, there is not. Many people consider datasets as a more outdated technology; they're powerful, but they require too much memory usage. Only the basic ADO.NET methods got async counterparts (and Entity Framework, of course).","postId":"2012_12_dont-block-in-asynchronous-code-a0a59620-1e0c-32fa-84cc-c17451ad4837","replyTo":"06e7d2ea-df9c-304d-b2fa-866f1c8d3c12","date":"2017-07-06T12:13:06Z","timestamp":1499343186},{"_id":"c3677b50-22d8-11e9-897b-9f0ee46a84c2","postId":"2012_12_dont-block-in-asynchronous-code-a0a59620-1e0c-32fa-84cc-c17451ad4837","postUri":"http://blog.stephencleary.com/2012/12/dont-block-in-asynchronous-code.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"astrowalker","authorUri":"","message":"\"Most people would not write code like this. Itâ€™s very unnatural to call Task.Wait in an async method\" \r\n\r\nExactly like this of course not, but at some point you will have to wait this way or another. For example in console program you won't have any explicit `Wait` but the program will wait implicitly, causing a deadlock as well. So this is not some rare case,, all it takes that Try/Set methods are used in non-async block. Add `await Task.Delay()...` before the call to `Try/Set` call and everyting is fine.","date":"2019-01-28T08:43:20.282Z"},{"_id":"c3a23690-2329-11e9-b607-f720b75a151c","postId":"2012_12_dont-block-in-asynchronous-code-a0a59620-1e0c-32fa-84cc-c17451ad4837","postUri":"https://blog.stephencleary.com/2012/12/dont-block-in-asynchronous-code.html","replyTo":"c3677b50-22d8-11e9-897b-9f0ee46a84c2","authorEmailEncrypted":"fP5GGmDUdZBcGcNlHlucYX18RRBixrBARW7uJe717nHwrrKYz4i1ogoyb9GDuVashpNODD8B6BYgNONlPDs77zBmd8Ab2mxFX53BRq2GHOMTKzBahBRF2WmZNVm5jsPvKdjSwr+04LrjK7xS4KbLw4n8+ad4bW8VLT3QJNe7bfq8SSvv6WinlgotafQM2q+6O4ZAlCxFeaoJDVWyEuYGv5yJG1skRRPZo9jmzZG8pqjpBQGsSZHerpqgSj6a1gSpTaed6D3xtBw6xn/1/bmuutedZNIEQsLKXiBJ0j2guUNDxgI5AqNg+GRsDn/tnUzTmaDmFCUR3oPYb/ow97RJ8unQ3MF7ax4NtWyNtxD+uq5Tpgs9uvsgBl25vl2PEzM+/5vX3iZvkGBeGyEgLUki3KKMTgNqFor4Kn+dCedwXUyMT/DezDZfaNeG8CZnSI1CoROZVtMAq9Yg3fNgs71EY5qaWu+y4ONDg4301bVvQqVARW0GDqA8Z4jbyYpmjya/9v9/4ufJkxXWJAy6O53zkysYNPCVqHFk++riC8D/atWbhCrnUqrwGmWTs8HwDOaBKJCeGfR2pZwEbNe5cCJxa3Cx1Bd4mEeoSvP1yBdZ4J0PrVoA3rydlCpLygHnozP2U2m8zNtxaPEEBoF5NG1Hv7WP35fhkrCHiutn4i/m0sY=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I stand by my statement that blocking on asynchronous code is unnatural.\r\n\r\nIn server-side applications like ASP.NET Core, the entire stack is asynchronous. There is never any blocking, even within the ASP.NET runtime or IIS.\r\n\r\nClient-side GUI applications are also a natural fit for asynchrony; the UI thread runs a main loop, and async/await interacts with that loop natively. Again, there is no blocking necessary.\r\n\r\nConsole applications are the *one* place where blocking is normal, and it's only normal to block in one line of code in the entire application, in order to prevent the main thread from exiting. What's more, modern platforms allow `async Main`, which hides that blocking in the runtime.","date":"2019-01-28T18:23:09.852Z"},{"_id":"58d4f250-8a8b-11eb-9156-0ffeabd374c2","postId":"2012_12_dont-block-in-asynchronous-code-a0a59620-1e0c-32fa-84cc-c17451ad4837","postUri":"https://blog.stephencleary.com/2012/12/dont-block-in-asynchronous-code.html","replyTo":"","authorEmailEncrypted":"G9bkCcJ0Hp1syAT8KXmdLomlbF0Nt0dIKV9QCfk7SJG2pA0kuP+N41/blv6WlkYmfTgCQw6Lci97bCGDKZ2lmzS7TheKvUhsJt/43fbs/I4VQplWG4GuonNVVl9bXWy5AWSSXqhOCUVLfkhJBTsf5F8KMq9WvcVDpkBy8lcapAHDxF7RnVEoMzX1uLrzZXllaUZq8h7oCDNeQaCG08uZam2tTsANgWj4wX5TmJQQWEptuFXt7bcd2jPoYyB/y2zzyyaRMDi8kOQkwfkRfUh3d9m/MbY9omKKHhmXilf3O3QLoTkkoaGGEVvV41+oYVfbcQ3eryWUtvFclOPFlJb9/pxUD3ea0YlnDpXy1bJ8WbxTWLyuBbiZtul3XFTYcfm5PTvjLnFo81dcD28hwvLWST7eIb5soHVd5oIzaSqKiJ4cys27KfKP0qc5vPBmYL+egfRrAuDlOuHon1XUh6qRWLY85va8KUlAeBVck7gpD1nhev975PIxoaoimi4ZTMm/cv8HOC+/HfJxiggk2Cd98yUUdBFLzXqvsot9rVj3ZFSkJikQhy+MZiKJSx9s6V42r3CECI/Z+oLRwex7uwKbtf4mbmB5yBEozEzSRSY5tK7l2HDTRvdqM2j5XtCSJ2jqtkMR+Ac6vF+AbUo5cXn0g5baQ/HllMvfqHYlFMl/UHE=","authorEmailMD5":"b6f9b0b13c310b4001cc387f1ab670ee","authorName":"David Deley","authorUri":"http://daviddeley.com","message":"After close study I believe the problem isn't the <b>task.Wait();</b> but instead is the <b>await taskReady.Task;</b>\r\n\r\n<b>taskReady</b> is a synchronous <b>TaskCompletionSource</b>. We can wait for it using <b>taskReady.Task.Wait();</b>\r\n\r\n(Of course this makes <b>Test()</b> a synchronous method unless we throw in an await somewhere else.)\r\n\r\nOr, we can make <b>taskReady</b> an asynchronous <b>TaskCompletionSource</b> by declaring it as:\r\n<b>var taskReady = new TaskCompletionSource<object>(TaskCreationOptions.RunContinuationsAsynchronously);</b>\r\n\r\nI think historically TaskCompletionSource was released in .NET Framework 4, before async/await, so it was originally meant for synchronous waiting using <b>.Wait()</b>. \r\n\r\nasync/await was introduced in .NET Framework 5, which necessitated the addition of the <b>TaskCompletionSource(TaskCreationOptions.RunContinuationsAsynchronously)</b> constructor option to make a TaskCompletionSource that could be awaited.\r\n\r\nSo the problem might not be waiting in asynchronous code, but instead awaiting on a synchronous method that returns a Task. \r\n\r\nI'm not yet sure if this means awaiting on a synchronous method that returns a Task is always bad. I'll need to contemplate that one further.\r\n\r\nLove your excellent articles! I've studied them extensively! This stuff is really hard!","date":"2021-03-21T21:21:06.612Z"},{"_id":"33d56380-d8f2-11eb-b968-d76a3395ed13","postId":"2012_12_dont-block-in-asynchronous-code-a0a59620-1e0c-32fa-84cc-c17451ad4837","postUri":"https://blog.stephencleary.com/2012/12/dont-block-in-asynchronous-code.html","replyTo":"58d4f250-8a8b-11eb-9156-0ffeabd374c2","authorEmailEncrypted":"i2MzQg9okC949y1W1+8CLNnqokxInt5y4+ifpa/o/ordv3/VddaLwuhOQnrC4HtHiroZW1lNxlpTSGQAqbg1INJdBhnNfcH7R8LliW3VxStesm8+xBCRTh/oKcSwSEfQ3kNkliv3SmtYIXCb/8zy3DwQARU5YVgRqNeluf5FSJ+Qg9UXeDGq+8Kgoi6DGAugNFXEXZV2xYV7M0YHw6WoIHNx11NuWvSPxfhjWnxfk6MZdTJroP40hfn7kpHkWLpPuzMU7n9UELOWBrL1srkq2AiQd5Srwz/s6xTDFWshA/0vxYE+o8aE6IiXaKu3pZ88BgI08D5+sy2VjblrCJTx4Y/+JTpLfn/9vLElcA4glzxQ6B4GJ2b2DelZfwkvWQNixJYuX7NBWdZtPusGY37HwSdbBUShgnrlYqSolZYzgD52+GlljkqIRjbmI2EHq8Lj781dng5/VDKFSzS3kUo+vrvuwMkL+4o83xh5ytTeNmKWfyp5oS3Zbu3+v7jTmER0sdgUlQmrk26WISIi5eH997LNpXMhRuRNW0XNTYXMxLa4OsXvpxggW0KUZmR6Q+7RwIqM3sy9tdonuquoeZifkMJI2HNIea+/p6nd/bsjPAxytIWUYWT19zsrXEVx8vNalTG69XBxvckdHfFRIqppOTmUahYdzG4Qz1VDP3FBAB4=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"The history is a bit off: `TaskCompletionSource` did predate `async`/`await`, but it could be used with either synchronous waits or continuations (which is how `await` works). In fact, this blog post was written after `async`/`await` was officially released but before `RunContinuationsAsynchronously` was added.\r\n\r\nI believe that `RunContinuationsAsynchronously` does avoid this deadlock; it essentially moves the `TrySetResult` onto a thread pool thread. But using `TaskCompletionSource` *without* that flag and `await`ing the resulting task is both common and correct.","date":"2021-06-29T15:53:53.030Z"},{"_id":"1079eb50-9f48-11ec-a262-6f3418d05e77","postId":"2012_12_dont-block-in-asynchronous-code-a0a59620-1e0c-32fa-84cc-c17451ad4837","postUri":"https://blog.stephencleary.com/2012/12/dont-block-in-asynchronous-code.html","replyTo":"","authorEmailEncrypted":"d4btFqFLZQKhw7XiGuhMSqnvNgvFDDHu/xjEEqZccBpR2E8bCfWGlQNOTn1Tanp08dRQet9OAcmN+Aqkt8T7ttZx2lr5z5KCmjVthFXf27jdAPpPFsBAnNzIpQB/TpAv4oN8PM+bBevudW6tWiVzVUZVYNbI8qCbNDUufx/SmuUIOc7G/ADEP4EBKLIbqvQxG+Cu/mNHRMOzNwfmkTrmt7+iWTrGhMLnWxDB9lnVaLyvZMoQnQmJw3kWf0KygpLGTKjFzToOFGkl8Q3qvz2Z/IPrjCoB0juanVZTO71jy9EJeSdI9ChnyzJbdtAU7pDj5RxAdoh8WDSGrT7LUlibJR+hxBVzIy0pq+0zOb8kburxM8CTRwF4wfmV6CPGVGGIeCFoWeBdMTUlIiZEns5ppa7+VjrOOI0EePrkbUOucnEqub/AhcZjRhUqs5ZDwYgald4nsFcXMI8Xsah1D72uk5naLQJzdh3B89jAeh5DbROdACH6Ce1/pfXj2wDcuiUFzd60s/1qJW2vzoenT8hsiBWgwgGEwsG3DD4qkerV1mKMatL9GOFOslHPqTdiiPBZYkq3zIAIMurbM00zfD88DPF1dU+mkBHeXM06BURPRL5I0m0eP8TdsFZR2SAbgPcPiCEQhQ5imm0WdvS3/OKWR5P5Ea8HJjPhD3Zw35yeDvs=","authorEmailMD5":"d75ddc978943894043d988af89e1b8d0","authorName":"David Mercer","authorUri":"","message":"One reason I tried mixing asynchronous code with Waits was to apply backpressure to the caller. Until the first `await`, the task is not returned, so if I wanted to purposely delay the return of the task, I would use Waits until I got to the point that I was good to return the task.\r\n\r\nThis post was very helpful in understanding why my code didn't always work how I expected it to. Thanks.","date":"2022-03-09T01:27:20.639Z"},{"_id":"a4fa8d90-9f4b-11ec-a262-6f3418d05e77","postId":"2012_12_dont-block-in-asynchronous-code-a0a59620-1e0c-32fa-84cc-c17451ad4837","postUri":"https://blog.stephencleary.com/2012/12/dont-block-in-asynchronous-code.html","replyTo":"1079eb50-9f48-11ec-a262-6f3418d05e77","authorEmailEncrypted":"De3RDqrt611jxgyjGxM3+72thauEJQ4mIGtP2tHk/C1QrwzgdZqLS+jt3hQdIqdYYVVo7ZOfj1ENifNm3FE5142X6s1PN2pvpS5yBeQHFTwFPkCjhhEkRw7KMqwb9jqJFnsCNBBF9n5Bh7fE5vtVpjkyHYsRdL3K3sRr/KiVWPJf7IzOrS2ORg+8fo1VxT+rcl0pHWfvueNB9S8uxMZSbaD7akQ2GqkLtdGKQU0BwImCZ3afaIcKtc2PpOZd20uRcoaRtkH485JEf3r1gFO0ihxr/khc25hRFj5Hrc+5+w18WT0bZR/d5RIQEHVj1WBAn8PNea8mQ/fKwxKjjpG7OwlgIwS9RqraESwwEiF4vg3sIhgYtHiBz0S/c+eVI7Yj8RTZt8+gljiovhv2VKy4UH+gdujWC4q+7AkvFEr+Gk0/+lIF8NaMqngLOPL0f0LQscA3INvIrkGbjvF2zqX1CWhkI1d+btSDMMzouxGO6iV+ChZslOOreqk1Vtz4m2kW1XbpXyGBkib8edXE8/V6CQN/9tiNZYpXfeCI8BXnwD52FzNVtczA/mEoovM28X+k7tgUYqdz7kK8h9c5e64IjnaFtGNhcQ7zzZaR5ZZoUMeCuWNyeLVms6K0p4rfwFOV4yxVG727vuMj1nUIAWhjQZzx5HQwRIgowhyh1+8Z3CE=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Interesting; I hadn't heard of anyone else attempting this. When I do backpressure in asynchronous APIs, it's always asynchronously applied, so the task is returned quickly but won't complete until it has space available.","date":"2022-03-09T01:52:58.312Z"},{"_id":"c0ad248f-1057-4206-821c-a7aeea405101","postId":"2012_12_dont-block-in-asynchronous-code-a0a59620-1e0c-32fa-84cc-c17451ad4837","postUri":"https://blog.stephencleary.com/2012/12/dont-block-in-asynchronous-code.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Adi Avivi","authorUri":"","message":".Net6.. still happens.  +1 for this post. ","date":"2023-01-19T23:05:52.1566472Z"}]