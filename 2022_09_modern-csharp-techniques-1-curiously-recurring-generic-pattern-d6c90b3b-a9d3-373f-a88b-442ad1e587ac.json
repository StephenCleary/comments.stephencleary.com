[{"_id":"779cf190-411b-11ed-86ce-5d0cf55af7bb","postId":"2022_09_modern-csharp-techniques-1-curiously-recurring-generic-pattern-d6c90b3b-a9d3-373f-a88b-442ad1e587ac","postUri":"https://blog.stephencleary.com/2022/09/modern-csharp-techniques-1-curiously-recurring-generic-pattern.html","replyTo":"f6693a60-40d0-11ed-86ce-5d0cf55af7bb","authorEmailEncrypted":"QAoHI3q4BSH65k2yZ+YtinaouDbPq3ybnnJkXMXAq11Pucs60pd9CIdcJhEFs4A9j38A6qznrsmDpjpyaJpbsOlN4lTyLfj3Eu7iYa9uWpy+ckJ2mpAc25LKqoHo2gXl6CPeYldYjbN/RubNgs9gfr2xOBOrWAmdlvuegkMhQpVXKWWiwMlJinhWacYYEw8BteQak/y5lcX8PANorgdTBcqEqvs1+fwkB9R5/eKi1KUHvEldENHOuQS7A1nZCWTUXlfoi2sheNvP4yAwRwxfvGVnbtCAWJ/zbwDelyJA5aGafThGUVTz445AmFFCEVFZZE4wL3QdeuJjytzkQ/QtM5vWuhDMLj0a8BTjweGaFoBV6gloWXb0HWx6lLl64HfMayfxzuDXrjCnjd/dhA9Ee23qAQE0OatB1UwhNH9QEMFOsJGIQ27Def03N7P/ur7wleP4nJwV7PwfDtgkPwugTk3zF/zS1kkk9gq1pu4F7Dl/hgVrBCPYZNA10Fuy2+E24OscdCBxF83cTI44dRi4Zu+7MGhUh1uaohWWx8OFbeZsZA4PNBOL/qxvik26Ewwn5zPY7R35AHKn9NnBK0IkKm7PSe4MAfHC0tKpA655JcIMSrHFExW0TjtDpzVnT4ErF+Tpm2U6shyAcXN7lOF/tBc6uFxQ2kGucn7mTXQNpIY=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"> which is not possible for C# reference types.\r\n\r\nC# generics - as a run-time construct - are certainly limited in their form of code generation. But then C# also has the JIT compiler, which can optimize code to a surprising degree. In C#, *all* method calls are emitted by the compiler as virtual calls, and devirtualization happens in the JIT compiler.\r\n\r\nI agree with your point regarding complex hierarchies, though. In general, I avoid deep hierarchies.","date":"2022-09-30T23:56:14.682Z"},{"_id":"f6693a60-40d0-11ed-86ce-5d0cf55af7bb","postId":"2022_09_modern-csharp-techniques-1-curiously-recurring-generic-pattern-d6c90b3b-a9d3-373f-a88b-442ad1e587ac","postUri":"https://blog.stephencleary.com/2022/09/modern-csharp-techniques-1-curiously-recurring-generic-pattern.html","replyTo":"","authorEmailEncrypted":"wE+eMc83Vsf0kLQ6u5bq/PQ3k0FWczuwMnPTS7i0mAt1HR0XRgv4bxSoqZrYIxcRFMqIIy6J0t8SPCD/aTUQvCzW60KVEh8kuK3DTqgejxNRqpU5/Hn95BQWS4tFFNAHzIWQINqyBhXlX6pPs5nBJli7OgBkrOkcpSIUNSF+Lm//Q8wjuBDnJ3zEvYYhQxN186SMxkXqOgk0t52Leh8zHPdygTfBh7rmqpmA9KuYXlwslgrsEQXqAFxsuqofNgsF9JEd+AaO37zJZRrGmRNnUKOYopBl35LpnMULpEBty8oaS+zgvwcy7H01/XG/hYpmFTFPUu3LR3TLFVO6NzoBHAIs1NzcU6uIgZ5F3SpJIQgSYW9zH1FQcs4lTcjsemzNYMo1dNY0h4D/PziXKny+6R4UvevWxPq2qRrRLenLsAEwJ+wowTFdr1LEUOPWifF0An7N9KnayDDIvpm5owYT79nrBbC4yNfVNODFifad+D6g3KGFqHsMRyN444P0eKc0D4JEh1MtbUUtjZO4sFJDgzsRRIbMg339XNUXWxUES7ZRd1OyXdEvlDpDA6O8UouUBrl9TUm2vhODQCElzYmIfdI6OIg5pglZt7JLqtYI7Mfj/ODAvTv6bkykuwMO7cDBOQVmtvX+AVHxg7lEZlL113N6VSbZqIggm5SiQ78anPM=","authorEmailMD5":"fb194a78a1e9047d0d9d8226d6e81ff3","authorName":"cao","authorUri":"","message":"I would add that one of the goals of the C++ CRTP is to avoid virtual calls, which is not possible for C# reference types.\r\n\r\nAlso, this pattern is not appropriate for complex class hierarchies. Once you \"close\" the generic parameter in type X, it is no longer possible to inherit from X and benefit from the pattern (although when the pattern is used in an interface  it is still possible to re-implement the interface).\r\n\r\nIn my view, the pattern should generally be avoided with base types, and used with caution with interfaces.","date":"2022-09-30T15:02:55.221Z"},{"_id":"8cfddd80-5104-11ed-b867-5dc2ae03150f","postId":"2022_09_modern-csharp-techniques-1-curiously-recurring-generic-pattern-d6c90b3b-a9d3-373f-a88b-442ad1e587ac","postUri":"https://blog.stephencleary.com/2022/09/modern-csharp-techniques-1-curiously-recurring-generic-pattern.html","replyTo":"","authorEmailEncrypted":"asCm/GZJrWBdhJMBlEvlM5UaBEZaSR8YmfnnPDL2Z1ZDnQB7o7vn2c5gPyr+V29tgWIxnNuvMrP60kq4Pi2TFA6Iy7CHIlxOhdZeucr1XEWx18xxVBfS6xoJiGKSUwMROQ+2fA4HgEfEE9u70WyAQ5jSamMRcQ0RyT5qysEmyNo/hw6L0Tri9sIA1atsJV1shUA8GizwvHn8xU71gS82shpL1BJnVJHOeirQyenOR9Ck8zNoTQjho292Zl1OOm3hOzvvAM+4HiTb/fmekv0pSGRuEUsUfJfj63/H93wEObtD1Em3dz/nr8HqTWIvLysIrJ5HY7GeImVtgvGpM5NlH7CA28wlzIctqo8TczHOu2cR5mN+tARTlMSTz5nURvoJQFAzh22LW2OUmmWm0RliRFY8WWKdepKjtnS3g/U6sXfCSTNYM12CPYebIyspEsReDd+UkfJLv/x/2jb6x58ZDI0INUfDxetW062wTWuKVwOxJU77Ih4iw6HNEXmmpA3lighMhdtxFACYgNZgM79mpTsRWd+3i7GVVLeKU7zxP26MdLuBVGMErAzp3NIXHnlvpFEQM4s3i+eUdsAYAVAPTKyN98aRsZeNwZHR/JDhBznrB2S/zgNpnHeZlWYu6D3eu/T5J+oi3Ux6/RLR1u+F0vxDWVDZFN73uJHYCanP3Hw=","authorEmailMD5":"7bcbf5cbd8c19ed27fbc04388a1a2f48","authorName":"Sebastian Schumann","authorUri":"","message":"This technique is also very useful when you are trying to achieve operator overload.\r\n\r\nWe use typed id classes for our business objects. String would be possible, but then you might pass a wrong id to a method, for example. With dedicated classes this can't happen because the compiler prevents it.\r\n\r\nThe class then looks like this:\r\n\r\n    public abstract class Id<TThis> : IEquatable<Id<TThis>>\r\n        where TThis : Id<TThis>\r\n   \r\n\r\nAnd then operators are overloaded in the base class to make comparisons easier:\r\n\r\n    public static bool operator ==(Id<TThis>? left, Id<TThis>? right) => object.Equals(left, right);\r\n\r\n    public static bool operator !=(Id<TThis>? left, Id<TThis>? right) => !object.Equals(left, right);\r\n\r\nBut the best part is that the compiler prevents the comparison of two different id classes. So it can't accidentally happen that you compare `XId` with `YId`.","date":"2022-10-21T05:52:30.759Z"},{"_id":"4353ff40-51a7-11ed-8f6b-991934cb25fd","postId":"2022_09_modern-csharp-techniques-1-curiously-recurring-generic-pattern-d6c90b3b-a9d3-373f-a88b-442ad1e587ac","postUri":"https://blog.stephencleary.com/2022/09/modern-csharp-techniques-1-curiously-recurring-generic-pattern.html","replyTo":"8cfddd80-5104-11ed-b867-5dc2ae03150f","authorEmailEncrypted":"Fw0NkHnZGBM0bInkVQWlDKru/G/yxOJ7/0JwRW1YqMSQIu/jSN8BM0KsAIxLCXkwT5IaC+zI9m1/PDD4ItFtjPXhLbJYzlRklKZo0z2BcH9MbS3C6Td/97tznZ8y0KW3E5jbC2iy2VXg3PGvgEfAXrgFosG75N7Ho/zZLLhSNIUfEN8aP/AFOj73Y2ZiysmGjFX32t+Bq4wo6LdzPihxdH5ZYK09VR5pyLCHpr9pAxW05T9swIDGKI4LCkGCmSuh08UbMR4FwzIJL2/r9a5xRtwKUI2hWl2h4qAPkr4TycmBV1b5sw4KHXRtPwpVVuj57nI2wkJzqZ5ygv8G+pb2oDCLMCjP1i2bVLJSFXXQHZZHOm7orTWBh6ti3Pn3XooddoR49zxOMjlTMXACOu1lYZ4c4JcT+iEGfHitBzcCGZM5rtBidDWPrgO+0I4wZoaVtYwxKl4ScvCYgkLdHl2btYbtrxfDdc2EUZNtiu9Poos0ek0AIEPi/LNxg0hMGFRXVV8IhMn752wJNFjOLKgjiJ/yCWb6OrgeSHu39NEp1JW85TJ8DJz9kbAA9MVTLOcdHpbdl8JVMlCbIh/UglB+iL1/2t9ONCrznCZCv66gz2cdOBS/66SagogilSs1VV3ZgIq+kbXH4IB/psMPyXIot/SQWKWZadtQY+v9kp8NezA=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Absolutely! I use it the same way in my [Comparers library](https://github.com/StephenCleary/Comparers).","date":"2022-10-22T01:17:15.276Z"}]