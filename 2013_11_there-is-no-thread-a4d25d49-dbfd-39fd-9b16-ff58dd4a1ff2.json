[{"_id":"a9c681f3-cc6d-3c00-85e6-08c26258bb1e","authorName":"Alvin","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/03892201689252059476","authorUserId":"","authorFallbackAvatar":"","message":"Awesome post! Thanks for explaining it so clearly!","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2013-11-22T05:48:48Z","timestamp":1385099328},{"_id":"73a45221-7016-310e-b8aa-7f4a919ff779","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Amazing explanation in such a difficult and complicated concept! Thank you!","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2013-11-25T17:52:40Z","timestamp":1385401960},{"_id":"7ee10dd0-b43e-38e3-b875-2aed2bffd3fc","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"really good post. Thanks!","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2013-11-26T04:10:17Z","timestamp":1385439017},{"_id":"0f8f14ce-b74d-3ff6-b38b-3df24405c9a1","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Very enlightening! Thank you Stephen.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2013-12-03T17:46:41Z","timestamp":1386092801},{"_id":"53b9d541-3641-3632-b7b3-7d9774023b2e","authorName":"Noseratio","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/15542702475870519357","authorUserId":"","authorFallbackAvatar":"","message":"A must-read for any asynchronous code developer. I keep linking to it on SO. Thanks Stephen! ","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-01-22T09:22:29Z","timestamp":1390382549},{"_id":"62b1b4e0-4952-3372-a59c-feaad71d6b97","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Thanks for your comment; I love the \"message\" description!  \r\n\r\nBut I'm not sure I agree with you re DPCs (not that it really matters; the details of semantics aren't that important in this case). My reasoning is:  \r\n- A thread does not have a DPC queue, but CPUs do. A DPC can be scheduled to a specific CPU, but not a specific thread.  \r\n- DPCs are executed (at IRQL DISPATCH_LEVEL) when the CPU IRQL is transitioning from a higher level to DISPATCH_LEVEL or lower (e.g., PASSIVE_LEVEL). So they execute before normal thread code can resume.  \r\n- While a DPC does execute with a thread context in the narrowest sense (CONTEXT), it does not execute with a valid thread context in the broader sense (able to use the security context of the current thread). So, they may execute in a thread context, they must be written to run in an arbitrary thread context.  \r\n- A DPC is still very constrained in the code it can run as compared to code running as a part of a thread. In particular, no page faults are allowed.  \r\n- Interrupts are masked while a DPC is running.  \r\n\r\nAlso, these quotes from MS:  \r\n- \"The system schedules all threads to run at IRQLs below DISPATCH_LEVEL.\" (\"Scheduling, Thread Context, and IRQL\", [http://msdn.microsoft.com/en-us/windows/hardware/gg487402.aspx](http://msdn.microsoft.com/en-us/windows/hardware/gg487402.aspx))  \r\n- \"IRQLs at or above DISPATCH_LEVEL are processor specific... IRQLs below DISPATCH_LEVEL are thread specific.\" (ibid)  \r\n- \"Code that is running at PASSIVE_LEVEL is considered to be working on behalf of the current thread.\" (ibid)  \r\n- \"DPCs ... are always called ... in an arbitrary thread context.\" (ibid)  \r\n- \"Before a processor returns to processing threads, it executes all of the DPCs in its queue.\" (\"CPU Analysis\", [http://msdn.microsoft.com/en-us/library/windows/hardware/jj679884.aspx](http://msdn.microsoft.com/en-us/library/windows/hardware/jj679884.aspx))  \r\n\r\nI came across these quotes while trying to find out whether a DPC actually counts against the current thread's quantum. I was unable to find a definitive answer. :(","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-01-26T22:18:32Z","timestamp":1390774712},{"_id":"d059f9c3-04f8-3224-8b49-5289000e88ac","authorName":"Paul","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://blog.paulbetts.org/","authorUserId":"","authorFallbackAvatar":"","message":"Great article, though I am compelled to Well Actually you on one point:  \r\n\r\n\"DPCs also execute at a level so low that to speak of \"threads\" is not quite right; like ISRs, DPCs execute directly on the CPU, \"beneath\" the threading system.\"  \r\n\r\nThis isn't strictly true. While ISRs don't particularly have a concept of thread (a kernel developer would call it \"Arbitrary context\"), DPCs specifically *do* execute in the context of a thread. Now, *which* thread, is the question! They are run before the next scheduled thread has a chance to do anything - they are part of the scheduler. Since kernel memory is mapped into every process, what they need is always available.   \r\n\r\nThat word up there, \"context\" is super important - a thread is, at its simplest, a context in which to run code. Async operations *jump contexts* as they are being processed, they're not tied to a specific context (i.e. a thread).  \r\n\r\nIt's better to think of an async operation as a 'message' that gets passed around, and that message changes forms several times (i.e. from a system call => IRP => APC => UI Dispatcher Queue item). Every time this message is processed, it ends up changing forms","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-01-26T09:42:39Z","timestamp":1390729359},{"_id":"42f4bb1d-3d19-34c1-a1b8-98ed81ff3933","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, it's one of the I/O threads in the thread pool. The ThreadPool keeps a number of threads registered in its IOCP; these are different than the worker threads that most people associate with the ThreadPool. The ThreadPool manages both worker thread and I/O threads.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-02-28T05:46:02Z","timestamp":1393566362},{"_id":"77fa175f-daf9-3772-85f1-ca51cbfcd0c6","authorName":"Eric Lemes","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/04209337471330041525","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen,  \r\n\r\nAwesome post. I still have one doubt:  \r\n\r\n\"Since the library/BCL is using the standard P/Invoke overlapped I/O system, it has already registered the handle with the I/O Completion Port (IOCP), which is part of the thread pool. So an I/O thread pool thread is borrowed briefly to execute the APC, which notifies the task that it's complete.\"  \r\n\r\nWhat do you mean by an I/O thread pool thread, you mean one of the threads that are registered in the I/O completion port?   ","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-02-28T04:01:56Z","timestamp":1393560116},{"_id":"134e36ed-3980-31ad-93ab-0a06967de74b","authorName":"Keyse","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/14078171403075259352","authorUserId":"","authorFallbackAvatar":"","message":"Instead should the article's title be: \"There is no (worker) thread.\" ;) But GREAT Article. LOVE IT.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-03-15T06:30:02Z","timestamp":1394865002},{"_id":"90633b22-3a06-3948-815a-e9ea52c0a78b","authorName":"Guest","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"What nonsense. I suggest you read the following article and stop posing yourself as an expert. [http://www.drdobbs.com/cpp/multithreaded-asynchronous-io-io-comple/201202921](http://www.drdobbs.com/cpp/multithreaded-asynchronous-io-io-comple/201202921)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-06-11T03:44:31Z","timestamp":1402458271},{"_id":"2a20288d-f510-32f6-93f5-2f6dcb9ca8a7","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"OK, I read it. Not sure why you think IOCPs invalidate my post.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"90633b22-3a06-3948-815a-e9ea52c0a78b","date":"2014-06-16T20:39:14Z","timestamp":1402951154},{"_id":"ed864178-7dcb-37c3-af34-6345965278f8","authorName":"Rasik Bihari Tiwari","authorEmailEncrypted":"RHuevm7QTh8Jmm9Leh4ya+NvzwYZb2hHZ5Cw1u6luPZ2SiijeJTEg4X2/g2kRgfjkk8Mx1yxE4ogDld8olrJbQquwAQYeI1UysNDKVQw6TjFvpFyXK7C/BS9TiXrL4bkEkT2XH0UjR0ZWjVfwS7iwAItAILai195eAkfA4cygtramPvWpBotTH0ByqotQiU7BaJDwXf/ffi86D2c7xt+r98MN9FUk9pBajHTbQZXTJH2sd5s0Ku5VEH9zrWB/6ziwyHDYm8zMPczhEYOzqDk3Kv86jw44r3meJcnlxx57MB3nYEG4lgMTOamEhAo9cvx2jm0zvFsjuOV0wp75DCUNOPKrNDgCHOQ+PUOxybNYwE+tDPLI1/fbfLtoEk6Y33i2mCG6ALNn5RjcB8l2IvBL6N3nHtr5q73KTuK1AXMYnos4Oul7srNtted/D8Tgo+n+lC/wGz8mLdNd9YKpKpH096SwBYglBmcyaVFcGT54gQyGYAJegL/rEpBw7rOOy6+mmmcoGQdkhwqFz6/n+pZxA7exjn1hT8hcTqpK4UwqTK9hu25TRObxtUd+My8swUM5X+jRkWV7z3biQt4ZhlNJMO4ZMGdUngxvgPY8Ji+l8g0MNtI4XhU9pfdR6qv9Cp5xb4Av+VrzorUxe+1VkkZ8obuaZC6J7F1C7WYsgEhjhk=","authorEmailMD5":"27b1f6a2716cd1f8159480eb91abca66","authorUri":"","authorUserId":"disqus:rasikbihari","authorFallbackAvatar":"https://disqus.com/api/users/avatars/rasikbihari.jpg","message":"Nice to know the internal details of async operations. Very enlightening.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-06-20T12:50:09Z","timestamp":1403268609},{"_id":"0f4118e4-3ef4-305a-8b7f-ec2c77155ca3","authorName":"Sam Penn","authorEmailEncrypted":"USjWSek8b0Gn8+fTF1A64ldgU32hUssEW+V83JSRa4VMZ4aJnrFRU46/YrGj+61WLSh2E0yzFIczHgbiFntoNtA3rtLXAJR0gAsLCXOJn/X7KYxgp6boWQookcuFKRcVrt5tmM5d67Wp6IJ4tdvsizTUyArBAR0lQUmbki6YDnmSkULoovseW8YbsfNOthSIzWs74HcdzI+j0qKBsgdDoLyE2j1Lcbw10yx+D+qoVju1Ir38wr2XrjoNCc4TfWHuNPPslxBivlBBqgu3ZcnWuUzFoxEAxMA4/k9RUacU4KDZseVIRdJ6R1jeOyu69W1MP08yWF+t+blMDNMg7EjShhmTjd7pY5IUha/eK8V7zevUqgiJUiNu9SWmhNh7eY3LQ+yKRDiAXa5GfYfHYOj410wRmhhHscT6tKApQRB8sLfImy0odJYlxva43XNj5pa+tnyEXPt8gLB3lTCTEcyqi9lxL8wFyrmWHVG1useoDBuuNRPKV9bCaDhx1eOyTdqFJLkdh0vUrTe5egoj42YXz1S5TozEzZCfpU2siMz9rC25ak92PlvCJ7q6Jz9RlCDp2r1C7TW6yzFP+Kzl6eY/BLD7LWWhSEAuEjwXMkjqk5VqeTFW9WdA6cQndm7Bjuoe0h4q6vJriWLviSjKthUImoJgFoxitwanTSif4WP1KiE=","authorEmailMD5":"3c66282a10af8908ad315d4247c63f14","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"nice post, but what you were talking about is only limited to async call chains that eventually pass down to IO operations (or IRP). if the async function is just a long-lasting pure CPU operation, say, very complex math calculation that can takes 1 minute to finish, you will inevitably create a new calculating thread(Task.Run or Thread.Start?) so that it does not block the caller. do i understand it right?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-06-27T08:11:55Z","timestamp":1403856715},{"_id":"82a4ab2b-b9bb-3c6f-b048-ae7ee169f98f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes; this post is specifically referring to I/O-bound operations. If you have a CPU-bound operation, then that code must run somewhere.\r\n\r\nCPU-bound operations are inherently synchronous. One thread can *pretend* it's asynchronous by offloading it to another thread. E.g., the UI thread can *pretend* the CPU-bound code is asynchronous by wrapping it in Task.Run. From the perspective of the UI thread, it appears to be asynchronous (i.e., it can await the operation). But from the perspective of the other thread (the thread pool thread), it's still synchronous.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"0f4118e4-3ef4-305a-8b7f-ec2c77155ca3","date":"2014-07-11T13:24:53Z","timestamp":1405085093},{"_id":"d4692f6c-c3fc-329a-80ac-4cbb7e3c4403","authorName":"John Peters","authorEmailEncrypted":"SyPyPJ6COevS+xrjCetwZ8KxbgxybULNh+7iCGSam8G+vzyhvUmWJyY78GVLbD+IEsPj1tzNHyHFBsVQgVAq5pM/4sZ/TrQ1DiYtaRA7evXJsLyAJfv3BUAeVhzpF8OGAK089yE7mWT9hIyNO3PhNnftMz6dODzrUSnWm8wOyVLhebO8v0OL4VkcOkyWJPQkiLomAuJx5cqkEHd82WLZlJZsLwDhVg+wPrEwWlc9DXJN/LGQT0b1XIT2bDGpw+/Z/WvySrjiMGOW6lJNX9Zinmbg1ZShT2nBADqdGWNOtzuXyQqGwg5PzFztsWkV/n6TlUIFgtm3s9DbIT8+R5/35y37TVfzWHf3M3rkz0n5ZgMj9i6k+WtMji3OzgwxOM1wuy9Z1JyRnc1mNVGdsAYYuFceOJp40BLB2B8FK9piuaWNxeQ8z8oxgJPB740u2rq+XSx4riU/ErOGnkXGbLzwCLZrKjOlD0/uwJkHwtNBQLWMFztXdkyhF9sd9cTnJgt6JtBcQuuYtPHi+o7HOjVNyapkGUlWzr4MW8loUlNgOPh6nH6dOEARU3dOz5/ukeIsLIkXyD3LAZ+x/QJViOFbKAy79UVAeFLUn9SEDIlcPUArzu7umNcB9jMEpEdQHr1YJ2s/yGJcWxyAry9ZrMGceJs74ljkhzcXH3PrbDOpRLY=","authorEmailMD5":"b3d0b8f681ed398a28c9bd288d7c1f96","authorUri":"","authorUserId":"disqus:disqus_TOgNSvWnKm","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_TOgNSvWnKm.jpg","message":"Interesting, perhaps this is why MSFT claims that TASKs have no CPU affinity rather than saying Thread affinity. But I think the sample is too simplistic because it implies there is a BCL equivalent call to the .NET statement of WriteAsynch. What happens when some simple .NET statements like \"var a = 10 + 12\" happens? That code must be run on a thread using Gen'd IML code. In fact, when debugging Task.Factory.Start.... in the debugger by threads, we see a new thread for each start don't we?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-07-17T20:03:53Z","timestamp":1405627433},{"_id":"8b34bee4-7c15-3e92-9d68-c7c9be9bd10a","authorName":"Tejas Vora","authorEmailEncrypted":"sQg4J9MiaoAghcq4gQclMhDbSUrxnG+hBuO3gSdqIhjF0aFvssRG2W/8Ov97VierVNgN0ltNhNBbAdGjRwkcK0wi+TQDXZCRYffOttoA2rm9iq2KK5CFZQGvEK8s/pnezTskyL339Pa3VSGsobcCejKYh1ITAni6W4KTCb9rx5dD4d/IghfBKT+DpP6zioeWi1NDPLDp9yo453KvEGnhEVgIA5LJkP7BCUgyEc5FxWYRjFE/TaHczBAAD41yaZPOrGdPkITfmU8lRBiCU7cmSNCTqTz+H9sy8G97GT93OkrN+DuG0D/IAITq86kEGra8D7RQ8xcqfjQWaFHRcRmlxn819f2dKy23xaPT9krJbF3nJFH/Avtr0wCLGzyFeH10LQVrhdAhr33so6BCMCw7RFTFp9amTmHBRuY8hknv5RKK/8ThfNiWQPjcGoGMkXY7wyOJ+OSwEFaiASUg/w7dwgrN15Vc/9KHYfyfhR3yWDnPgLUs4YIhNNTikkdHCJoLHqG8aYqYhjtkMJlkPKcvRL2U/POePae2I9a3zxACkedEJkgsyE8hLZPBFWj3HOype1IqBp8onVADqWDTN+fVi9Q1QVYzk+LSlqIDAuUVFl6xDdxAPQ6LKfuunnsvCcxT9kqwbvQOwk8qUJKyKPAq9TfuoFo+r+AjX7Zogo1h/Uo=","authorEmailMD5":"69e47bbeae22b8dd9cb37ddcca94f6a9","authorUri":"","authorUserId":"disqus:tejasvora","authorFallbackAvatar":"","message":"So the question is: Should I use `async` and `await` for the computation-bound operations in UI applications? Or I should only use it with I/O-bound operations?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-07-18T19:11:32Z","timestamp":1405710692},{"_id":"8971cb8b-776f-3fa4-ac4f-20e38e50fe45","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, in UI apps you should use Task.Run to push CPU-bound work to the thread pool. Of course, the code must run somewhere, so in this case there is a thread that is used to execute that code.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"8b34bee4-7c15-3e92-9d68-c7c9be9bd10a","date":"2014-07-20T17:34:52Z","timestamp":1405877692},{"_id":"d8262ce3-d34d-3559-b894-7ba8ae9af286","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"This post is about tasks that represent I/O operations. If you have a CPU-bound task, then yes, that code must run somewhere. You can use Task.Run (or Task.Factory.StartNew) to queue that code to the thread pool, which will create a thread only if necessary.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"d4692f6c-c3fc-329a-80ac-4cbb7e3c4403","date":"2014-07-20T17:31:41Z","timestamp":1405877501},{"_id":"0524a472-b549-3281-918a-716fe8834378","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, as I say in the article, \"When the request completed, various threads were “borrowed” or had work briefly queued to them.\" Completing an I/O operation is not CPU-intensive.\r\n\r\nIn theory, it is possible that if the thread pool is starved, it would prevent async operations from finishing. However, this is extremely rare, especially since I/O completion port threads are different than CPU thread pool threads (the ThreadPool class is really two thread pools in one).","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"13b84301-cb0b-31f3-8b3c-79e2088f1ef1","date":"2014-09-05T11:52:20Z","timestamp":1409917940},{"_id":"13b84301-cb0b-31f3-8b3c-79e2088f1ef1","authorName":"Cole Thatcher","authorEmailEncrypted":"U3ZUNXRkcDV/GmijLx9548/BdXFqUVCMwMKc9XxIjO6xINXz0AHghlmG95En5+hMF6Zu2EzrulEzRPUkaCZwPOfqWQHbprvQwoAmSn2FugHKfo7YjSemKXqvrHZiG5ByCK1g0t2PJV6hMpnbc0eyBhVTCiEeuDyD0KR6snz6nwC4riaH/kFZ5Q7LksMF1Sv2ggEBofF3i5BXeKqXBBPiaTiUIQRdqtdlziIdZs7NcZh6bmx/tSint1OG+LJVfyj2pzAlwTOHMwR27tr5VEWAectdK91BW4HCcY3eFvOPBkl4wEn7hiJjUXQEfjGR0ZFpw1yIfBflYAkHGmJfi8RN8scK387+CRVxIrbXITADvmN71pE/sLfw4qxQUyJinC3ysjpWrs8TcJDJmAeurfNCpecw4ft55FhK1aJeauVYpyI8JTCwbZVoQNPPTCYUKlp1rMOUUFAbZfSgxC/2w1waSSTG7azNtM9e881Kva8vVnuBcfZQN2XjtWjthJPw0DlzOQyAN8Ic7nhkXPv5z+O/rVeiG5QlkEoOkdgYjezMCJppVDjqe6fKJhaoieZkqAeplItQoVQ0VLesA3tElIdgDCdIEdQAilJrhfEhuXsAVNWtI06oinhKU0QAMiD99STJysxu75NhDfAjCzAs1eWJyGVtweU14iP8ncssThGa70Y=","authorEmailMD5":"9f28cf5977385aae254f6d12251b6745","authorUri":"","authorUserId":"disqus:colethatcher","authorFallbackAvatar":"https://disqus.com/api/users/avatars/colethatcher.jpg","message":"Aren't you still posting making use of the threadpool threads though (for continuations and servicing completion of the async call?)? The point I'm trying to make is, it's not safe to say \"there's no thread\", rather \"no thread is blocked\". Developers should still be aware of CPU usage and make sure they don't eat up all thread-pool threads elsewhere in the application and automagically expect async operations to finish.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-09-05T07:48:51Z","timestamp":1409903331},{"_id":"0ab6974d-0896-3a5c-a067-a2f780792863","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"HttpClient uses the exact same principle, except it's a combination of operations. An Http Get is just a write followed by a read. So it's a bit more complex but the same principle applies: there is no thread blocked waiting for the written bytes to go out on the network, and there is no thread that is blocked just waiting for the reply.\r\n\r\nRegarding resuming async methods, I cover that in detail here: [http://blog.stephencleary.com/2012/02/async-and-await.html](http://blog.stephencleary.com/2012/02/async-and-await.html)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"d45d2368-4bf6-3b2e-ab4a-c5a3dc43a343","date":"2014-09-17T15:00:48Z","timestamp":1410966048},{"_id":"d45d2368-4bf6-3b2e-ab4a-c5a3dc43a343","authorName":"quazecoatl","authorEmailEncrypted":"u4QHkkqlh+cV6TCi3VvQ7i7g8Kh7DWyYAIJm2l3KyKqDV8C7HmfGpbRw42Kt2UGJR9xTh+FUhXG3hyXwTD+kxc2hcPSELBCDVpJxggu7wJKfpmliapC1JA5wWWxQGrDVSsrCjMRChIgWHNvGriZrwfirhJAwz5KsjPsCI/V5zS37ysyFpL3RiVZnaii47Up4gGCA8Yi5bfketO73pbMgAj5pMlEkPguE8XUdcPmVWDPOJ8S72iKn5Gz4kfJxyqcTzTy+vTUzoCoO9ycCKHuHgv47oXRIEzu8AOVbzd8pxrxyWeZ60Tlby/M9l/YshdonowmfZA/zesCn3S7haQeYyF1j9KsYxBTLy2ceBeLD1af8qbvRUb660qpNSEsA92UhSR7/ZXJzp9MqWsXsoxUuBWLRc9Hy8a8s/327DlUgrBdCloPsAWOGMuGys1vgdaZHkqrBlcdwurQCDziRP7H+/3RtNYYn7DugwfKfPIg4yBa8eitOvO7WjE+PvHj5buRkwS0pD2+Gcs0suxGc77cLYw4VXStptNUAMGNXIOMMTlGc2dSdcfR9OGP/AEiQjzEM/BppexI+qEoe5cnAGEP6GiYI7pOmA7UHDjo7n7rXdZ2myCym0iXexd2D+jRsS8HRJ5FRgHBO+DtgFMPTX72VuJSDMO86wRw+ySTOjQZojpQ=","authorEmailMD5":"02005278d93e3927c061d5022e68c1c8","authorUri":"","authorUserId":"disqus:quazecoatl","authorFallbackAvatar":"","message":"Thank you for this article, great info.  \r\nYour example is for a generic 'myDevice.WriteAsync'   \r\nI wished however if you could give the same example for a much more common one, using HttpClient.  \r\nAlso, I wished you could give a little more detail about how the resuming on the async method is done.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-09-17T14:47:43Z","timestamp":1410965263},{"_id":"2ec92642-9cda-3f30-a0f1-3b33272fecfc","authorName":"Flemming Bonde Kentved","authorEmailEncrypted":"sljNeIS/3H3LrLcHHeGfJ6esT+g9Zs0Kd+iZN+4rv22fGVFrQ1bjReWCSEnhzqGkRNxuHiqqhhz5iPSZqLhdq4tcLIpU9OX8Sc85bKx5WjEI6yZDPK2mMPmSN1b+iEjFwFInXlpILQWDjt+qrHSxRaCeVNLGnjKlUsxhKEAMcYv8aeWrjkCl1rg4wLE6zZE87vD9b11kHqLQIxxKNCkzSpP20TnmLSbHO1aoUgI9V0T9B5Spk5Kd8VoD9wub7vFSwK5/T2jVm0q9JZT9DUSUefjeXPdIUzgQv/KSISBnWmpdoSevlHWdxc7xCDgCRBVWQdJajEnL2uZUeh/drM5Wc6Ktx2h2veQoCtlZ52g7xQkuFOXI/kD6fK9DH5hP+hXVDpaOIp1qqgb+b9L3g116JwRAOEih4yeXr/8KLOzF/E0h6P+c4V6LU9LRUWwYs+sxf+FmJ0O6DbO95trJlJJBVitpObmEhN6MpX7WlWOOSeoAMtElIa+dV0VlpeiGATi0t15o9LQiE65jnxmssf1zuHoMX6pINtr3KR0y72oRe0cAfaYe4SlB/0AQ1qGmnJHITTVF4us4EcXq0KpPcUD/cmGrS4SAN7KCWZBGBUcWiFJUZNSBxbTN/7aadXXvHEESw5lf4h8gkoPeSAL1W2LxVnu2qOXxqiikOgxtsGS05to=","authorEmailMD5":"bb69b61815507f213ad10e182710e91d","authorUri":"","authorUserId":"disqus:flemmingbondekentved","authorFallbackAvatar":"https://disqus.com/api/users/avatars/flemmingbondekentved.jpg","message":"Thank you. This had been bothering me for a while :)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-11-27T14:51:29Z","timestamp":1417099889},{"_id":"16f3f266-623d-3eb0-8b9b-be0a9f347dc4","authorName":"Andrey","authorEmailEncrypted":"hWRxHIfvQmYmJRWFy8OjRhy9qkmWnUqzX76tYUWOm6XnlGTP1ro8CQOjqhKIrcoXLJtJOWrN/NfOYQ5+BCL5q0IpteDEplqnK0KCvccTGuq1gzr9YTaFisPSDeLdPm+/3s/qhpPDY5cRuAhW8gfMc+LdBMf+Y6GldS9XR7mscYHhiJKakjyA6AnNn3nF3PvX7qDHviXoUR5cEx84upt9K9Fuy4NU6tzO1dAu/fyoqmvnhCrsFnxvidoUidWQrxs6QhegUpkbr7eOXOcqucoUuHHgDoYr47nkdjlDJ/RDlEXa3RGAiGEqbj9oT3wDe8YZTkn2xEQOztx2J7cA572cHrgZjlY7vVoqVZWBBcAkti4zu93P34DlSlvVxsQ6kPL07OeqmlZWRZXy8tjXGnr0tIJkK2vUa/Dcvku6/bdqiN/4u6uFEegYrD9WXxq6fvpv0EA581WjIvvSZcNs+cky/HnH70MKwYe9HiphgtoxO0O+qBLPs36CBCJgs88FyGs2TroPbGIXb+fH7ze3wQAZJi+q1iPEWnbfKEkCt+CtBjC9BEc2hNZpPKCkND/omyP4toZK1sjdTP7xknG0NhA11cszd3AmR9MWLpYLwhpM+uavTVa3aEx3yxgy2IcVXH2VX4iZjdZt4HmzIYQXQ2ibi9qQpzTkvJkq3L6In219oL0=","authorEmailMD5":"34a7ca7a417b590cb4d11bfbc9613c61","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hi. Thanks for the post. I have a question regarding I/O threads (IOCPs).\r\n\r\n\"Since the library/BCL is using the standard P/Invoke overlapped I/O system, it has already registered the handle with the I/O Completion Port (IOCP), which is part of the thread pool. So an I/O thread pool thread is borrowed briefly to execute the APC, which notifies the task that it’s complete.\"\r\n\r\nAren't those I/O threads blocked while waiting to be notified to process I/O callbacks?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-12-02T17:25:40Z","timestamp":1417541140},{"_id":"d2dc9613-abe7-3ec8-a17a-4fe185bc7ca1","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I/O threads are blocked, yes - they block on the IOCP itself. However, one I/O thread can handle any number of IOCP notifications. The thread pool will inject I/O threads if they get bogged down, but a single I/O thread can handle a *huge* amount of I/O. The IOCP will always exist for an application - it's used quite a bit internally by the BCL.\r\n\r\nSo, you can think of it like this: the BCL already has an I/O thread(s), and by using IOCP you're reusing the same thread(s) instead of blocking another one.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"16f3f266-623d-3eb0-8b9b-be0a9f347dc4","date":"2014-12-02T21:38:15Z","timestamp":1417556295},{"_id":"5e64b4f3-00f2-31ec-ac78-14adcc352b51","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"You could think of it that way. Another way to think of it is that an I/O thread is waiting for *any* I/O for that entire process (or AppDomain, technically), and it'll do that whether or not you start an asynchronous operation.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"df81868a-30e0-3410-b1ed-7a739fcb2494","date":"2014-12-03T11:35:45Z","timestamp":1417606545},{"_id":"cc8a2706-ceaa-37cb-86fa-52a7f52fa29f","authorName":"Andrey","authorEmailEncrypted":"Nm/qPZPAUljThVs6tW2pYMoUStJE/nhBgCawQuy27bMM/rUTOE/MAhK/vF6E49vDydFuezVsLoC+zFTEoNLxaaNlV5OjGtKeSNxNpBQgKm/EH6TV24Bm8YDpfWZWvY2FcKNjiLfjUv2gkjlHtdws6JDUDuQ3szxYz0VqAbCq5PpOsidatvgW0uaJ/2M+RWzUnLoLhP+YuyQYiAJQO+/pWfUrwG8R71qJs6yBJtP/jN4TOp3wtDdGdrXJRrFu6zASlicOuGJsL0OdcSI1TW0uAkRtSSKdJSuIh6EsmStVzN01tUTZFm8o132kEopmXgoF9dMYZjDTfVMXkHqMUeXNgBXeyRNbAPHvNw/Os2o0WBgDk6VPD7Jvy0ojv7Ebk/Z0YqX11sfoi3BZi2r1jGeFWim8knh7qFBkqD6c9KVeWactu3U/ejiTq6GLg8cO+qaPTkSsoem7CXBvikMu6KBwe2bpv+j7no9HrhfHQv83mImcxfJnl8d6XuhD66wDhQVr692rUF0oaazlq9C77H0r4ErmgFVNEBMRKndMt80RmSrkbZ2C00N7I1F2lZiMMSddJbWldLiPuusQ0L5lPYdnk7obAVAkP1yRHmTFZlAxuYK0dk+sqzATxjrpSg/PlOdh2+rlHMLlpOteraHb182xkBL4o91V8LjuDlhJI7mioS0=","authorEmailMD5":"34a7ca7a417b590cb4d11bfbc9613c61","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I see. Thanks a lot, Stephen!","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"5e64b4f3-00f2-31ec-ac78-14adcc352b51","date":"2014-12-03T22:39:33Z","timestamp":1417646373},{"_id":"df81868a-30e0-3410-b1ed-7a739fcb2494","authorName":"Andrey","authorEmailEncrypted":"kIobK/w7DBKqy4qYFq8WzO6tYr7UzjxFRc21nrvfpC0XxjEa4PNhK7lcPym5HaIKOZh74rQi0ji2w9RMxbeeOKllRR0he1vyX1ytB+wTSrvLaGu+meLN0efAiKDn+uahlzpNTwdakKGV0byNcGt9HvIZjzRZBPRqtHDWYoV+cl9DGU6ecLJcinyXroZQdbMX/5MnwKzeSxHc5aMzo0NRDQkLI8TOdThE+raR9eI0xlkdGafYj4gBigq8XD6Y71/xeOx+t0iYvYYIMNzZZ5+Cd9XyxAQ2W+8dd8l8Z+JE0gfHdMKqep/mD1cIzNRS8T9JyW/nCMk0J4DTubbuFXSkBKQ1Jko+7BsoiIEZG48vLFUDOyXlaCSVaLlTih+WMFZ5oyE6SbB5Jge9GDKHBh7NMDpQOt4/ml+RrIA54l2c9ALfB+zkKq/WoYfknxNdvOnOONXcAE/MFsjqbNUo5lgkeWMsEH36ZhcVQbB+aCsAJMhLk1SU+JEKj3uwbeNDG73RFViE6prcwzXWnnukgxXszGK1yUzBT+8hgPKXOz9IaiwBlOerbDAP/kePlv+Nx1PIBSDosr6f/RNEDE1oB+ScV4C7ED2eE1nVYewlvlFaNTKt2lO7v3635wvOFq6dIrBkcS5xdAW9NuXP0cHZB3nzlQ27H9xGvHV8D0X/wauUpvQ=","authorEmailMD5":"34a7ca7a417b590cb4d11bfbc9613c61","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"So, in a way, the phrase \"if I am awaiting an operation, there must be a thread that is doing the wait!\" is *partially* true, but that thread (an I/O thread) awaits for lots of (I/O) operations?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"d2dc9613-abe7-3ec8-a17a-4fe185bc7ca1","date":"2014-12-03T10:59:19Z","timestamp":1417604359},{"_id":"206b600d-4804-346b-8a48-2f0b7fb90a78","authorName":"Joe Messere","authorEmailEncrypted":"ta59He4h0ow3byuq3MYIpK6DfTP6UyWlfEIxEHhZ1e6I5jzuPhW9HRAc7y0shthCQJyR3CaWwsutktbIlj9gm706t9B6ekwonG7BTuqm5kbFH3798aDZIsaigxOHsPAnbelqu4YKPIjiIsAyWjGCyyLvpOsvyIp3BMRb3gtnaJQ/N5URO6jO+tCtB8bbWM7fwmT6uyn0k+oCImKy6eprZIpDCQ/2ID1Eia/rEIAiXngYUqurbXSHv0IUDs9PTQroplvBTOmniHdm9lCUQUnWMk2xrKSheAsSEeKV/rxlsdtf3jcWjndcuFhC57TmCIw5pF/7EonzmofWyiZtREoeD4+JI8BeUW6TWZ633YXNZSRcROjm+qwz+J08mH0yAbxrUgqCTvQZ67FbiXPLKEQfs0GndEjHWEeDviNNMNIaAkmfYxIAiqgXnBH9ze6P3LFEJRITyEJqXX0v2/lqiSN1/6dBj0Tc3bvn3fUdeltha7mscjkR8VtXL0NLsHLf/aeLCukdg2iEoqxyOIF2v6z1oUgreSS5Zg0paoIwGub1gl4f60upPWlpdkMXtxEBt5Fw+FxAdlPUxWPfPl4JNpdp58oVwXTerI+Ds/n035ZzqZ+I/p6P8WTqsnisABwpgu5h9uoGiUeI9MPbqDZ7jSi1V+f9JDokydsgBxjtv+hnE5U=","authorEmailMD5":"6528723e3bca2d1b8a97f93ba1130c11","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I just ran some tests and it seems this is in fact the case. This makes sense as no new threads are created to handle the work. So internally I am assuming the tasks always return as completed right away.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"f6883af5-6da0-3dd0-9cba-ac5148b6758c","date":"2015-03-12T14:03:34Z","timestamp":1426169014},{"_id":"51d36361-6345-32cf-a840-ac49d5368b8e","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes; a method marked as \"async\" may only become asynchronous when it performs an \"await\". I assume at the end of your call chain, you'd have an async method without an await - and the compiler will warn you that it will execute synchronously.\r\n\r\nThe core idea to keep in mind is that a method should only be marked \"async\" if it has asynchronous work to do. If the method only has synchronous work to do, then it should have a synchronous API, not an asynchronous (Task-returning) one. So, in your example, the entire call chain should be synchronous, not asynchronous.\r\n\r\nNow, if you're in a UI context and you want to avoid blocking your UI thread, then you can *call* synchronous code asynchronously by using Task.Run. Task.Run will synchronously block a thread pool thread, allowing the UI thread to treat the work asynchronously. Note that I recommend using Task.Run from the UI layer rather than in the method implementations; this approach has two advantages:\r\n\r\n1) The method APIs don't lie. They have only synchronous work to do, so they expose a synchronous API.\r\n\r\n2) The methods are more reusable. They won't force work onto background threads unnecessarily, i.e., they can be called directly (synchronously) by code that is already on a background thread or from an ASP.NET context.\r\n\r\nI have more info in my \"Task.Run Etiquette\" series: [http://blog.stephencleary.com/2013/10/taskrun-etiquette-and-proper-usage.html](http://blog.stephencleary.com/2013/10/taskrun-etiquette-and-proper-usage.html)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"f6883af5-6da0-3dd0-9cba-ac5148b6758c","date":"2015-03-12T13:36:05Z","timestamp":1426167365},{"_id":"74e51b75-7b88-3391-a65d-025f569f62e6","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"You might find my async/await intro helpful: [http://blog.stephencleary.com/2012/02/async-and-await.html](http://blog.stephencleary.com/2012/02/async-and-await.html)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"206b600d-4804-346b-8a48-2f0b7fb90a78","date":"2015-03-12T15:39:50Z","timestamp":1426174790},{"_id":"f6883af5-6da0-3dd0-9cba-ac5148b6758c","authorName":"Joe Messere","authorEmailEncrypted":"vMJsPbcDoQyiGPlSERjAewiEZ1GcgSAzi/nHPW1RyeKLhg4Exbj42XM/N+D58rqvDl4IAjpPrl+qG7VkuM7igYhnXe4KEaZA0dfOgrXztVFuINp/uX9Ev3mgBZlkzjF8fKZiPqZ6D8Ayen1Sx3Yh7Zm+jP9J9PbCF0u5vLWTCeJfX0BYHCO0O5t2V+3MxknjyiJs+FyQu/pyhg1x2A9PSgH5cqOAkDqb5xeBnTvJqnF2rheT9FXe8shXGahpWX9Wbg5UWZZSDK44r2unLk5hYKkvr0/4Z0/6gjOhRTagTBd1nlUnjfjII2zUtuq70889Vj4cWToLqTJpQpY9rISmPzNtZ3puv7HcFwkDd6bN9NSAcDb850M7WfmM+1cws5zloef3YI9HakRd/r1tzWiFXCPoGPP22OkEYUAswseekpK/RUAFOcmXjnc1pLDmtvXp0OHb//eCHJRX9Cuh+nh05Z5Kq9JFr0ik2vLnHYrwD7e1xM0qVTmKIUW2JLGe6/vp+enVzcAuSkvXThjDvRbr14T+785Rf85OPLw8Et5lwSSBWNUDBuX5bkgXsYuTP/ZK1Cyl0nHiAyWqCWBPQ+rXiT2hksKcwRkFOHzDMbymr5oBDy24prkJmGD6k2k04GOLcoLZwoSm753xRS5tBl1/b8qhlHSBU4PGdb1ZUyqNy3g=","authorEmailMD5":"6528723e3bca2d1b8a97f93ba1130c11","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen. I have an extension of this question. Lets say we have a call chain of 10 methods that all return a Task of some form. In each method an await is done to another async method. However all of these methods are simply synchronous operations that perform basic logic. If there is not a Task.Run in any of the methods will the entire call chain execute synchronously? Would this just then be a \"phantom\" async method that you are calling?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"82a4ab2b-b9bb-3c6f-b048-ae7ee169f98f","date":"2015-03-12T12:43:07Z","timestamp":1426164187},{"_id":"731c74e3-f2a4-3484-a394-56a4ca97834f","authorName":"Borzoo","authorEmailEncrypted":"nzEm055eADKlvTr9xZIFEn4ZhSE+VS9Sef3wG/oWAmFC1o//5MW1lbmocrZp5plTE8LWxDI/M/A7gmLYHqRd6xB1TNpcQOm7EL1Isq0Pc5A8JloIAJaFhqMs6S2mXb2M2f6u8pABA3Y2iFsup/OqQU1KNaumdyNneCYQHHqETn7mAPiRT+yWFCC1EB0FBWztkj/g+j0gbWYkV0OnEkFqdEIqUr278JMnisAd3fjKgh/e29R/G0TLhGOqEWgi6w2hhxGLb/Fo/EXqCZnMH2ZU0vxlplZYZzg8uvAZZAy/hVn4pUltAxDnx5X3PS5cdZ4qXsMCKgjTf8ZJhSbyQDRYefifYxtKPt9TmPefLszhoisloKj3u9IxR3Zl56HHagscOTFiQomEcAMm4nUIZKtD3K0bbmvdgu6tU9zMiDAo4Cj8YhOotpqiXLvd68Lq5xJV+SECmS6MJbb83Dp3S903dfGDGWfx319teGNztgqu2P0OqYcRrsrBm/Sw2AeNd4s9QAl/vSrFPvJXvnP+VPHvUL6Jd19kvukzqIitr/ThC7apS3CPtKgE8YNmVLb0A/khuv6JX2eCHlHU9n7Q5pvYN32lSJoBxsTUjP3lg4nHPJjLNRJK6RSJ79rO9HanWBgebCp9ZL6gjlgZg28d8O6KC6RU7z6xMwGqI6Zgx/1aU88=","authorEmailMD5":"72159be3de5ca75a9d077acf5b80508d","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"This has been bothering me for quite a while. This is the clearest description of this complex subject that I've ever seen. Thank you. ","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2015-03-17T19:29:07Z","timestamp":1426620547},{"_id":"65415d44-a506-3348-99ad-5ad5193bd670","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"(Copying from my answer a year ago; the blog migration messed up the comment threads, sorry!)\r\n\r\nYes, it's one of the I/O threads in the thread pool. The ThreadPool keeps a number of threads registered in its IOCP; these are different than the worker threads that most people associate with the ThreadPool. The ThreadPool manages both worker thread and I/O threads.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"77fa175f-daf9-3772-85f1-ca51cbfcd0c6","date":"2015-07-27T16:34:33Z","timestamp":1438014873},{"_id":"a8dd8eac-88e2-3dde-b645-4a475a8dfb1f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"(Copying from my answer two years ago; the blog migration messed up the comment threads, sorry!)\r\n\r\nThanks for your comment; I love the \"message\" description!\r\n\r\nBut I'm not sure I agree with you re DPCs (not that it really matters; the details of semantics aren't that important in this case). My reasoning is:  \r\n- A thread does not have a DPC queue, but CPUs do. A DPC can be scheduled to a specific CPU, but not a specific thread.  \r\n- DPCs are executed (at IRQL DISPATCH_LEVEL) when the CPU IRQL is transitioning from a higher level to DISPATCH_LEVEL or lower (e.g., PASSIVE_LEVEL). So they execute before normal thread code can resume.  \r\n- While a DPC does execute with a thread context in the narrowest sense (CONTEXT), it does not execute with a valid thread context in the broader sense (able to use the security context of the current thread). So, they may execute in a thread context, they must be written to run in an arbitrary thread context.  \r\n- A DPC is still very constrained in the code it can run as compared to code running as a part of a thread. In particular, no page faults are allowed.  \r\n- Interrupts are masked while a DPC is running.\r\n\r\nAlso, these quotes from MS:  \r\n- \"The system schedules all threads to run at IRQLs below DISPATCH_LEVEL.\" (\"Scheduling, Thread Context, and IRQL\", [http://msdn.microsoft.com/en-us/windows/hardware/gg487402.aspx](http://msdn.microsoft.com/en-us/windows/hardware/gg487402.aspx) )  \r\n- \"IRQLs at or above DISPATCH_LEVEL are processor specific... IRQLs below DISPATCH_LEVEL are thread specific.\" (ibid)  \r\n- \"Code that is running at PASSIVE_LEVEL is considered to be working on behalf of the current thread.\" (ibid)  \r\n- \"DPCs ... are always called ... in an arbitrary thread context.\" (ibid)  \r\n- \"Before a processor returns to processing threads, it executes all of the DPCs in its queue.\" (\"CPU Analysis\", [http://msdn.microsoft.com/en-us/library/windows/hardware/jj679884.aspx](http://msdn.microsoft.com/en-us/library/windows/hardware/jj679884.aspx) )\r\n\r\nI came across these quotes while trying to find out whether a DPC actually counts against the current thread's quantum. I was unable to find a definitive answer. :(","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"d059f9c3-04f8-3224-8b49-5289000e88ac","date":"2015-07-27T16:36:25Z","timestamp":1438014985},{"_id":"3045767d-a518-31c9-a77a-dd85ce6fe9c9","authorName":"Chin","authorEmailEncrypted":"tyBsBm0mHNUtV1J0fHjQbmTCKuKFrrgrvkxVM3bLS9ME1ZzKfptBztiXF4YC9RL3erJT3qjoYAE9BpXh9wPgBKeQOjORC51xKzp4ov994jPB6rVPk9XCkorlzuQ8K/KEVEuzxQYtW+tSFGV2uhD3PzTiSAvHFG0cKd89XT1lmFUkmGGvdOxNEmTNkW8ISZHESJbGfFXWzTYJg+D9Q9VVX5Wh+12HJ83SKuLvoxf/rTPyy5C3lUKlTGszkIoltVEU3IUa1b3DCTYwmKmnMv9T7IB22UQxvYmys5m5toqlFAAczENsDsOI8bWNqkWW2iFJmhgR/OXzuwsJAl3xumf3vQTNCQEAOHaPNm8w7RUL6qa4Q/OQGGc75ZPJPOZlXj/YRquNkKLW8CXRnQP2FFyrroltcWkEFxM+nC9k+6mZJFFbbjyYAm7OMDxBJNDe+wlCYvEmthIx5+dQ5YMeBhqc13vXYr7PD55CdohY6bpZ8yxcqcrlO7WFEqKdIed/+w1ZJeJbjzdwCGA8WGZa/g53TdFUl6emWx11ojj0sKciU9WaI7buIAUHY9RBHtVQ6azkvCz9QRQ5k26/9wlSquYXmTWsHMt45SXj8fS3BtstOEYptmYjQ445y24rtw29f5qAYwyu0YPMptpb0mMpJuAVvlJwPMvY+1x2tDs+slPU/KA=","authorEmailMD5":"3decb53828ce2c77a7fb28f7fd987234","authorUri":"","authorUserId":"disqus:chinhodado","authorFallbackAvatar":"https://disqus.com/api/users/avatars/chinhodado.jpg","message":"I have a question: as you said, a GET is a write followed by a read. But for the read, shouldn't there be something that is there to always listen for the response? Like a socket or something. In this case, if it's not a thread that's doing the listening, then what is doing the listening?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"0ab6974d-0896-3a5c-a067-a2f780792863","date":"2015-07-31T04:43:56Z","timestamp":1438317836},{"_id":"8f1aa188-5516-3a62-9812-a9c5c0579dcd","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"No threads are \"doing\" the listening. Reads and writes work almost identically: a range of memory is set up as the read (or write) buffer, and an IRQ is used to signal the end of the read (or write).","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"3045767d-a518-31c9-a77a-dd85ce6fe9c9","date":"2015-07-31T10:50:11Z","timestamp":1438339811},{"_id":"e0f087eb-c5f2-3981-ae38-44042689b1cb","authorName":"d87","authorEmailEncrypted":"HCRNYt15z9/xFVA4EljcIt+ijU+0NdJE80YulcnCplnfCfY3zVIJ6/A9ZwSaITf0XwXRGv+NXN4N4FVW/PVk45Lt3ycQXrjKsu7H21z8jNcuaoFJXbFI+N88xOw3EiyYvnjuetrWBeoX3XfyvioV/Mw6MzB6Dx48P7p5UVMu5Y1t9djDbgjr91uDvVo7KQWIqV1SFxmwW/+TQRRAb4YGOJIk2Y/hVJfxZ7vSY5O41IiX1fn23nOdoERg6t1e1V6DeLPW2wWRP1Z4ICw9VLozDiiJkUmS6dqtWziCnnqcA61Sndor7AGeW9dJitRIeSfKIvjGwo9doByXDBzn5k5fwO8wWA9YgYi1pZCCjVsdcrYuj/sfpwf2odyj2Ml4+gnSCh8QnWkh44TkqbaqRNA9u3He3/HPNTP5H1its3yPxsSTvXe+YKSvFs7AwFCGhL1IFlgzKMSoC4ehUup1pdeu1/7J8Pmzwqw4a6QCo+QF4UKdH6FoVKEEHdoX0E7lKPGBXSV1B1T8RepANhTn0hLXv8sB4inxha2urDzfnmVz5UFlnVuOd/Nlpz0ZjrMs9k6qJ3W6+MWYSX4Ug4mLGf5/kzMJCRf3PaN3/FyqogRyKX8yAKgOEq0okpDKBc9WIb7KOikkNm5OdBq+9czNLFqKqBSqWWuFadC1eWIK0wzxPw4=","authorEmailMD5":"344364fed44a2fe2b4aca232d6d7885b","authorUri":"","authorUserId":"disqus:disqus_rdMSX7CHEi","authorFallbackAvatar":"","message":"I've been confused about the implications of async/await on threads for some time, and this is the best explanation on the web I have found. Thank you! If only MSDN were half as clear. I believe the explanation could be improved even further by explicitly pointing out the distinction between I/O operations and CPU-bound operations.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2015-08-24T09:14:08Z","timestamp":1440407648},{"_id":"b0566718-e448-3753-8346-7b80be263f9e","authorName":"Ghy1237","authorEmailEncrypted":"CvuuTofKR3xyBkQ0EGK80o6dt0vTmyPsM5MrNxei6A5QC9QpfigJrkDfzSOumNmDUNEmOI5SvGS/KmpRPxyZhzw1rkof0BXWWUM4e3nyJQwGoioFPQJEE2cXDmX1vBzyUA9LtU2uDd3KHFXvNfPjgwiMxNHeeYPEkuq4c34H9tT7tfqlQkbIrYkMuCjRLI3N2BAh0Zk7+9pgr2Ut8hRIaZXGNh8f/thGKZQv5bqvZFKHOzEO5rLMuZArgxjW90gStY2iz5fiyE0OdYrRl9vOFe8I5ewDj3NLf4noT98UIk8y/KkIQyUyBSTVZDXFPZ4KIPsBZuv1FFytGFiOGYcTSg9K44NY+s//cPT4LVhyVfs0q3+fL+VgzZ1Zj9vKNjGRR2pm58zVL6LuR/tzDzmsJai3ZlfDnJUzlUsMlxbLKG3EkzREMTjKocbZo45HDP+NbVUHiVDPtzkpW3WqxacQlozZ/oGdKAETMgr97QI+8rqg036clx74aBi2NeRFuiRtTvbpkI8Bpti23f7wp1w7HWRHb3l7+ZjXi0pEKrLUC0gYGI1nbCJQqLBayXpjyyOHPFQzT3iwcNTOQMgXoKRMEVQCoNUfi6AHpB1HF+GZ3IYHBsdIQlHXqn0AGxr3d8jS5WyUl5cvKj+BNJaoMCvleXaspjhQGb1mkCT8rDg87hc=","authorEmailMD5":"5ea1d4416410a7d4ed972e2ce9cb8111","authorUri":"","authorUserId":"disqus:ghy1237","authorFallbackAvatar":"","message":"If so, what are the differences in the implementation between \"normal\" IO methods and those marked with returning a Task? You said that the underlying work is already async (using IRP markes with \"pending\" etc).","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2015-09-14T22:42:36Z","timestamp":1442270556},{"_id":"9e6b735f-faea-3ec2-8b6e-346ca8c0b5ce","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I assume by \"normal\" you mean the Asynchronous Programming Model (APM), which follows the pattern of Begin/End method pairs. Their implementation is pretty much identical (they generally use overlapped I/O, IOCPs, etc); only the end notification is different. IAsyncResult is a pretty close match to OVERLAPPED, and uses a callback method to notify the application the operation is complete. Task is a more modern way to notify applications that operations are complete.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"b0566718-e448-3753-8346-7b80be263f9e","date":"2015-09-15T11:52:39Z","timestamp":1442317959},{"_id":"6ec9797d-39a2-3dcc-ad29-75f5d4a843ca","authorName":"Anton","authorEmailEncrypted":"q85HaHvSpDK0Pujj3/7+AsW8Q1ZBh0SHSeh+L8I21N+GBV/kE8DEFNZl8mKs921f0hf1s4lIcfbhG3RH19/om1V0fmhU+J6q9b12OF1HOsTHcaHYBQrlFODBjm7E0u2MP90c86zKBMnc4ZHilqdAueLXwlrMtMcd5s7Sm/Uy6ptu3ETu9MMoAaXnYxqXEd2x+pOVsVcfd2047pU9PVsxLAQNcy0wc3YuBJndMh+UDiz+Qx3xmS2+w9M814RLY7Yug1GIWr/q2eBPg40k0/g8eOdw2LMIFasl5A6TxI9/BUy9uUE4TmZtc2swB2izv2OB83moiDt3szZ8uRzjWtsyfAEVxoKtg32tWiYTZ1H7FvIgxF8wJ7q2hmEwmTmFFfo05xsDRFZuZc3IcVFEBvFxs0zkkp3dQ4vLcDpOUIiUyP0D5iBu0N4zk3Tgcix56s9bTky2ndmn48ojVTmyOIJDoDJmydtAJUNvArqj/oKmQhP69n+FJv12m6hM/IVuxQilBVTSt3rbFeqtq7Jv3gm05wX33xmAHcAQUAind5y+kL8lVl18dnYP95yQGEbTW/KjRmWHBXR7SSQC+Y8af7/zr6Kc003/GNOlPu0pFiaaMop06YBhDClKpewR8lVchC4PbYWkcncaXleynj+R3X22QaO8ekWnqXS5mqmvAktNJ1o=","authorEmailMD5":"d770c004f15102ff6d4ba80bf2f1bd9c","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hi, Stephen! Am I right that callback in case of APM will run in a normal theradpool thread? Not IO thread.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"9e6b735f-faea-3ec2-8b6e-346ca8c0b5ce","date":"2015-10-13T19:58:27Z","timestamp":1444766307},{"_id":"ca3ca8c8-6379-35d8-9d1f-79a85e1a9c88","authorName":"Anton","authorEmailEncrypted":"hKsF2Tlh0LgirnWlnDwya6ouuz9a6Za3CLKL8a88lTayJOzeptz+rIvTchV2YAuY+gGnNH0prI9yTbFlAuznybrB4BJKiP015PFG5vb1IZA7HvhpLJizOMcP4TCdmgEhBetLDvrBoq6TGkfOwwDJXvdNRWpL8qwMlLv0WIZH9XE6nNXK0JErgc014vf2ImmVgr+6eP6y6CVPlFV8FZcC2fKISWoE+xoI9zrFK0yA1ZvZMXiyk6x2w+5wZXpAE+E5YnAjm0YwghFXOXRcRHYo+0r4yZ2nIrWd+LaYP8gLqNdqnolFDbtOBs4sIfvEHEuNvo7SUq2Loix+OFWRi3Vm+XzJlpz1laisR36HXbMq1AHdGcvss+WjZqveowkDEqSXFfh/vOIjh+m3LgPbQyOgNi4KHQMlS/vj2gokQ2tzRke9+j7/+NC3nJu28xZagLK0ywfDXDeIDaWFpTaDZevcu9g6Jb+JjK1lXBkhy870fppFKypRBLgnB+07TI83y21Qv73HjjM2v0UEI5oVaIrhS+8Jv6PXm+LrHyXdkTUabEAtPRz9DSbYX43qhhxePNkIyQQXC7TBNVkMSoO4cUzRG0Vu6LeYdtZ2VY/a0UEiRQ9M5sqQN+9FKesTu/uyfgRafy4uezYT8dsIEEJ3b0WccwbcsQShGyBi+Za7j2ze0Wg=","authorEmailMD5":"d770c004f15102ff6d4ba80bf2f1bd9c","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thank you very, very much! Now async programming and threads in .net looks more clear to me!","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2015-10-13T19:43:44Z","timestamp":1444765424},{"_id":"ed3b4e74-6139-3533-ad5b-f57a1e5a61c5","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"It can run in either kind of thread pool thread - normal or I/O. It depends on how the API is implemented.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"6ec9797d-39a2-3dcc-ad29-75f5d4a843ca","date":"2015-10-13T20:58:01Z","timestamp":1444769881},{"_id":"c92fa5e8-d3be-3f04-93fc-1587b8dafb20","authorName":"Fiona","authorEmailEncrypted":"AQyCmB/wVy6/kFEHKB7nx30aleUOiUtUFeFI+GJ1+UbQzJ0vLnbGXGEoReeneI02L+cbB4bk7IEkD+kOsZ5S6CjCx96o0I/iUTBF++ArvSzA9gNFin1g6rBJow4JvNUjQoCfqejJhkUTWTXIkrzWfBBz/r3XRgqGEa56dhZK3lzThBv7EHIriz0hXGLADJqp+N8ue/WA1TfZ+JTnYsaOrraBdFSeGZ7FQNGrIZWUTktig/+CuF7RGWRxfyblnEqtd+50tP3tHJWVmzQVqJQVq+fCO441ts9fmbp0TyvryzVCWdxE3dS8DjjckKrnwpWd9toJtpyQrjp4HVV3im+W5JTWA9BM+WTirw2V5g6XNejFwQFn6kyzlFCguUmJdpeQarJ8ed/I6hYUpcgDyh1OrR9UQtluFj2j7DxZ0bbKXLVVqNmLGmPQFnLXhDhBGaK2NAns43nt9OFGSik2LwX+2BLO0niZ/T3LqUREAIWRcOoLB/2MtD/ZtRCJUasFMcRU+Y6Rf7RgE6khjluJ5Q1zxik0sRNpRrMIKaskonh8D6rk25d1sgBiMfN8dEi3t1klT2JO/2+0iFMCIqRS69kOOc/lAasBFAjN5NWYpi5+51lua9FICi78uvGBZ9TbsqdK2SSqirl/xt+ij/6Fw17beX5/U+qItZRJLYUMKFd7uIM=","authorEmailMD5":"2acc0293cdadcda24791c0fbd8be6c50","authorUri":"","authorUserId":"disqus:disqus_4WnuRt9ngP","authorFallbackAvatar":"","message":"Hi Stephen,\r\n\r\n\"The task has captured the UI context, so it does not resume the async method directly on the thread pool thread. Instead, it queues the continuation of that method onto the UI context, and the UI thread will resume executing that method when it gets around to it.\"\r\n\r\nHow about Console applications and Windows Service application? My assumption is that it will resume the async method directly on the thread pool thread, correct?\r\n\r\nI couldn't find any article that take console application / Windows Service as a main example. Questions that bother me all the time are:   \r\n1. what type of synchronization context it will be for these two types of applications?\r\n\r\n2. Could any deadlock in async code be there for these two types of applications?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2015-11-27T17:05:36Z","timestamp":1448643936},{"_id":"7ebec3d5-2ef4-330e-8311-1a575a27f397","authorName":"Jim Balter","authorEmailEncrypted":"sKkjOrhcPzU63pBUuqee34yZx+cGVgC0kSvKOC6VolsBmsYQtW/dKaYIslCbDl2bwV9u5bWiQXyrmP/yVGnfmnjgwORSiBLm/WPwqsyiNgppKijDaqxJ8sF9+B9hU+Mu79S8jZrXx5ZZxotD5obJaTOMKqfMcZXuXJyRoJ1RQTaGJ61oPGR2ttIPetdHhKn8JDHqiYUMMMaHsH/UVFmzoNO0omldPMgNMM5srneXvEgDZthJYMImmg/9XoAPMv4b6LoqnS1xPY/UUHSjVNiASfuab4gbwVAwNOoAsvQB8Gt6fvfvUUD7ptbluHr8gAv0fYPBnVLq7dZ8mdMrBK0eZ61OFbu5uFFncDs2sgA24g/uOAwcJChIhCnZ7mLkBvtspEGRdXwLEvtRYLpwNP4M+8kurPLjsTvtVy3iAk7chnShUvoTmjsjpUE6QNjlvfLDYdYzH6QoAgySpSQEPv2pNwk30k8z3PSB7k3EfYGzwbQO4kYACmb8mpLU9cHE4NL/yAswSdLP9zK4Fjop2//pbKs0rXm61KY3rTrHXA9IgXE0/6sjT5TZdEbt3hOBy+x4XowIJqocLbysm0KRDWf5EWMeH+Ij3kXKDfu5VWYZAV13VbJH1aLEjaqhbOhK+i2FfCktrn1BAz6+v9B/hIdRqQgIYjybum30Qkr7L8FylVs=","authorEmailMD5":"ad1df76ef4fab96ec67b2afa080b3a0c","authorUri":"https://www.facebook.com/app_scoped_user_id/YXNpZADpBWEYwdm1Od2h4SjlJeThCVWY3OHIyTzc5N2pwek0yM0t1RUhQb2x3VFJqN01iM1hjZAnpVRlpHSmRwMFRMSldKMGtYRHQ5SFA1OUFhNWFueDRSb1dYNDBqTlV2b2VpZA2ZAZAbERY/","authorUserId":"disqus:facebook-1026609730","authorFallbackAvatar":"https://disqus.com/api/users/avatars/facebook-1026609730.jpg","message":"What's it matter whether there was an actual thread? The suspension of and resumption of a method is logically equivalent to a waiting thread.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2015-12-30T21:08:43Z","timestamp":1451509723},{"_id":"3fabd9e6-0108-3fe1-bed5-238eed5b953c","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"\"Logically equivalent\" - yes. But not literally equivalent. While you *could* block threads in ASP.NET, *not* blocking them allows an order of magnitude or two of web server scalability.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"7ebec3d5-2ef4-330e-8311-1a575a27f397","date":"2015-12-31T02:28:06Z","timestamp":1451528886},{"_id":"923aafa7-8632-33b7-8034-5667f92234b8","authorName":"John B","authorEmailEncrypted":"OJgadD3pJRGosBuUKJI3+rL2mkVlSJ4h+jt+ENKFGKeBNOaXAHRrSvw/vXanoOpa8Uhv5Ua15WbJYlW5B6VYhCHgcN43BjW7fP0OYYGdEFMwKth8I7j8Axqsc6TRLRClrz0bJH+O7VUpAoU6IDim92qsGCVt3IdCC0s+c+MO2aXQYtjVbKAk7iCc4VI1oai3DEGhGsHHiTBqGIuy+i8VM97mY6IhQjirlZb8pYqtgNnDwfU+VrpqAk+C07Wbbc8JA6/35cNTyeoVO/cweXkJMzOnRlsZA9ysFtvEiqGJwkJGetkpYthdQ66oXaeAjR9jGbNlPh2swHOwf6g05t4QSWsTFqFxgMSwlp7bAjn2D3egt05gs4tp3LpxMInnynZ8CFFCeAY1Mfop0cEVz3NTX0DVv7fcVG6uPWae99dNs6tI7ZwQUGsr/79TGaJ22lBdUmxVwAgIv6J+C1CS5s8AMAY9WVkY3QD6FGHAPjATzLr9Ecj20nHAIlOKqYtZdR6n+doOXMleSpLSeQwGkKqdRt3vchU7F8YHNqAh7Fi3LUvWE1xuuP500kpK0455Km2KOqEeUl0xVfntxKhGZYfcgRg1uz42ssKJ2DOEDoxAWp7AePRl0wsO0dtyQIjyp9FDiPMv8X5ibpShVXyJ5nucVJHGYRqua8UDLi48HaQu358=","authorEmailMD5":"481d70341c9faa90e85885faa2295f47","authorUri":"","authorUserId":"disqus:disqus_BXp0qg0lUk","authorFallbackAvatar":"","message":"Really appreciate this article.\r\n\r\nDoes this mean that it's essentially impossible to write something that's truly async in C# alone? In essence, for a method not to block any thread, it must call another async method, which calls another etc that eventually gets down to an OS level call which is inherently asynchronous.\r\n\r\nI know the \"top\" level of those calls are available in C#, but say I were writing against an existing library that blocked. I could kick it into a background thread (which would block), but I can't see that I could somehow magically make the codebase avoid blocking altogether. Am I missing something?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-02-01T21:29:56Z","timestamp":1454362196},{"_id":"c3a25ea0-8bc0-3da9-b1e1-795f2e0e6134","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"It is possible (though rare) to write an inherently asynchronous operation in C# alone (using TaskCompletionSource<t>). I use this to write things like asynchronous locks in my Nito.AsyncEx library.\r\n\r\nHowever, when you're consuming an API, the situation is a bit different. An API method is either asynchronous or synchronous, and there's nothing you can do as a consumer to change the nature of the API. So if you have a blocking API, you can't consume it asynchronously - that doesn't make sense. If you're writing a UI app, you have the option of pushing the blocking to a background thread, but since it's the actual API implementation that does the blocking, you can't entirely avoid the blocking.\r\n\r\nIf you would like an asynchronous API, the best thing to do is let the library author know.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"923aafa7-8632-33b7-8034-5667f92234b8","date":"2016-02-02T15:04:30Z","timestamp":1454425470},{"_id":"628a3edd-4ba1-30f4-881c-1e0c4fd05c51","authorName":"Omega Point Singularity","authorEmailEncrypted":"s3pC+d1O8wriafdQLzmw3s1W4AztViIz2mZo7k1vk6fE6XvsCSjsIv1nokNzzMnaZNLZpgeK7yt+OSicw6Xk6Gd+JkPxJXJL58yU0kQcd9PEpoEoYfmWGOzW30RqVRqen+9KJBZs0QytNRXG/hlzud27joMFdHomzIO7buC8OkYVmfAvYEn6BXsAlSnSECmbcbQAgAXYGP744nBeHhqgh8rtCRZdSZcxAa/5cX5LfV3mnhpdfCJyfepwRdXDgXU5IniqPyzyxleyBbaHrCtuHxp7a1f87xsOfRyPodxFRj4a1XEn13VLBobrgfKA8PZLclVG8MUdXkOLgb7eOKucKzN6eKC3MsxbqxBvuWrvtJ4xB6u0XWrBMRGuK9k6DU2y7U/r1mRnFIqxIAELfTNxGdN1DHPWTp87Zy5+0fk9ZtXgss/NURiAh7MxtmLrff0KggC7VuqOVIJdZ11xbgRtHTv3tI60t3Nsgq3EVJO6+lS19cfgaYHoljAf5vVaviKm1AZCexFSQC+/Io4hS3LNnq/Liqf5dWWuZjeM97EsF6Wl2y1EqpZryzF3KJ7yoniXFB4QFMbGQ67bY4YLRyTECUYmCfaQ8IeQhGaBvYVRqk9LipOrQmkA59YbyzD+nfhTlOIvcFl44+vzconX0g2/eCcO7PVDzGZgsqVF3M62m7U=","authorEmailMD5":"95345f59cd3f6a28ae72bc99843184b8","authorUri":"","authorUserId":"disqus:omegapointsingularity","authorFallbackAvatar":"https://disqus.com/api/users/avatars/omegapointsingularity.jpg","message":"How did you get so much knowledge? I aspire to be great. Have any book recommendations?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-02-07T15:17:11Z","timestamp":1454858231},{"_id":"f6e83335-08bf-35e4-a5b3-154063cfc2c2","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"A lot of experience. :)\r\n\r\nOne of the best books I've read is Code Complete. If you want to know more about windows, then Windows Internals is one of the best sources.\r\n\r\nAnd just keep learning. :)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"628a3edd-4ba1-30f4-881c-1e0c4fd05c51","date":"2016-02-08T14:08:30Z","timestamp":1454940510},{"_id":"ccb4471a-1436-3c15-829f-730bbb168c07","authorName":"Ehsan Sajjad","authorEmailEncrypted":"NvapRE3A1k5+oHCA8so0X/XVRZ2KQedQJD5RWtNonoJy0LYSQ1yMnWz9vXrwf8m7Gs54ZIN+AMN8Sj48rWZbhQ/0CT11orY68CllWKRN5VIIh0HjICKMFwAgS/JuoW5xkbej9fixMosUeg1g+97DUtMhqAru0NEY+AlqX5GVI7gzBs0qMYSqINS30rOeh8GuPvSiAv7kBgJ7G75U13e+8bJlg9y0SI5KifQpNaYhlyclnRJ0bbQQ8CmfP+vU5DrVHiDa3DvDpluzSCmNbbYo212474A4Odx6JJGOD/BJe+e4V62rLWcjPZgE8lliz8V5sej7k3f0p6Hgg7ZmoKfrXiP5RbftXEH+0KDlElrXcL/iGFh3q2kWMRR+2ItEpjgkGq1oSTH6LRXqzqu1odaaxse8cqu5MJGpvkGrxW4Ue/O2vhnYJMqd3nLqC3opTBpVIGX8ZzSDvWIx0KbTrD7p7lVXPBptx9Dl5KnUy+PSHW377IT31BWWxBkEWmthljBmyOSxTjsdZwPCtXURXRErz8Zkiq7S1AduYoXzFBbzqItAFRP/jY4Y+FnCkUlAUwvBEXvX+hTBwSu4dw0HsBVblTAvomYHPcl2ewsM92isdSPOnkEup8So1OQjTX3oLb+jZdzuUL2nd9zW+2LVCYHU+m7ywC6eXh3PknavB1M0EdM=","authorEmailMD5":"daacb17064e6d03ddd19ae1930bec563","authorUri":"","authorUserId":"disqus:ehsan_sajjad","authorFallbackAvatar":"","message":"Thanks for clarifying this mystery of async await","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-02-10T13:12:45Z","timestamp":1455109965},{"_id":"02b35c6c-7c4a-3226-86c3-8139c1f74e5d","authorName":"Empereur Aiman","authorEmailEncrypted":"kiIlJ67jF9+Z0AKy68/OPplpu/9CIh+qUUnHI0+77JmBnyEDxZ852t+zGChnJ46OpZa8hrRAZc9EX3X484Dw9dOyCMHpE7Dw8iftlm41xC1/CrIzW/yoEJBNWeIVQms3n3S3mHmKTR/FsfMBG1Lb6QYLszYSJLBNpasY1LSF+3yARUuzc3eLxeoGUf2Gtlj/537Tc9JAoSaKSOeIb5BBG2mF2RPgrHI6j/4/d3Nb614v8dTa8tuLRKDvqJBq9ABqnvhvMZOL0uG4LrQU1630C6Z76dqBv6jj9c/ZHMzbvxQn/uFYfyshxS/Ro8Z+vp9mSuIInohUXjBPyy70HPMlJ2aWPYLNkMjzjWj4rs4ZgziCuOgk/hy9r9APNJbIHP4fhLC0VrLdF4k5PM4Z1/7XVkU1GWK8Fl4MZvnRFzcm4a33pldAo2d+ddleclGyn2Vg4BunyseDmNnG8C0RIW0TaX1wRhSypAEJi0QW5z2s+TRH+CLXC6GWp/PzAbA4bZeNws0eanLMoMwQB74lqXUz00v/uDcx8uL9m1B/LlFabXlmha5ubQa6D1xGC/eI4mbjCCBPTuAFeS1z0FPAvbZb6uai6tQ3mbuCcBBSYiKSwQS5sTqWXTNoa7zqccae3A/YMEWA61VCo07Ail1mQ3Z6/opCPqTepisgI2UwStULbAY=","authorEmailMD5":"fe585c62d5b87f7172d4e2d0b5968e3b","authorUri":"","authorUserId":"disqus:empereuraiman","authorFallbackAvatar":"https://disqus.com/api/users/avatars/empereuraiman.jpg","message":"Thanks a lot. I have been wondering about this for so long. This cleared up everything.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-02-15T16:29:45Z","timestamp":1455553785},{"_id":"8b152c93-4374-352e-98d4-49fe8390f2ab","authorName":"Ilya Nemtsev","authorEmailEncrypted":"DEIKtcNADcUcgSNZUz8oqTc1XiigXxl+GTcoVMvofVdniva1z2GBNGd8AN5ABv3TXdHRWoOPir3/um7s2oeKHizwPF08ggM8H4OXnSMDCypDQtQe2YittfuYMCODfOGTI7mXxhlsxu94T2pcc8A2Bvwr7+s+lSZ71KP4oo2ABFrA0EirPNjWtw+DzttKaCiv1pTr1cQ+OMpVfqDIGnu/qLYYJpc+34ohm4seoQDQO8kOAbdzPN3fhI+XhWkZgdIK22d7lgH46U0CW5gDwkQhXuQ44q6fef7QGamCYYxmEIlPoiXsaeVUoLZntM5fA/pErSilhlDw4LjeAE5vdphomd4ni5aLO8XcpC5LWd67BH3wkCIaPVDZZ5ShgQUh8u8ZsQG1asoqU1p2vjTceH71N7pUUC1xUiNL+jXZ658slFQjY/2OFkb8s/NYsCm4Psg7PW7Nl/uTOZ4lh9ZvWYbee8yHqIkmw24cchAx/G8Zz802s4pBtzf2Tos1p2KU7y8AIis0lXwCz8GxqgSayKS/1K1s1Wa6YAa7b5EYH09sg/Rp+NENgcPMA/5BRhmh9r4TeVivN1P0NyRlcH29ZbWwFuK3j011gMPIn/Gcctn0gchsnpUp1GuiDv9gJewj1+ZwSbAN+XwxSXyi6nwQ3W9HfR6nVZKORN1lh3pVYENfgXY=","authorEmailMD5":"b37ebd4f61e3359655e42bcc1ad3fd92","authorUri":"","authorUserId":"disqus:ilyanemtsev","authorFallbackAvatar":"https://disqus.com/api/users/avatars/ilyanemtsev.jpg","message":"Best explanation I've read so far! Love the prophetic writing style.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-04-08T14:08:32Z","timestamp":1460124512},{"_id":"70f1f479-2026-37ca-b72b-c04531e07d1b","authorName":"artelk","authorEmailEncrypted":"dg6H9q4SueXHsI8Xug2e7FBDXv2bXyp3uHPJBcIlCXNvqe6oYLc5zUdZTmbKxP/VVugr2rCGLZZDf1trLWwQI9ffu+Hvz5L/3xSXIxRQ6S9IH5RBgqq+HXKt08S/TLfRKqoD167sut2NLizk6jghz9rkZhHnTsv0gY9hCbDvHqHQUJ3kwgMaYxWaig01iAQTfOIBKbMe7hjO83acVIkcrZSzsyZ0Ohsab6fVo7G38nm8AjAJA3PlZD9g7MD4ZAr1zdjstuZM0nmg92E6dYn0wGW/K2JTpkoNLi8k8y3ZtTKNhdXqLP3jSUf0MbpmZdA9mUdi4wotl2wEU808jX8bEADUxStuPZGDnKLyVy0xUbdZbgiH4gaL3hhTlSwG9P3jRioOUd6tXE5FaQPlFdWQ3Ch4Vqc0/wu3nv54F1DsTCFBDzGqqudhV/37o3OUEyPMRqpZ0060eXz0tBRQuxnadKASpVIydGbQDBjbmvxaPw5kucEFpKaidQOLg1KJ4RJ4TqEGLYKV/cKyZarL/eA76U2Zq6wehwRJd+uwXmSAcWnjlEYQRoPsmXklazc6jbgWFWnfL57U3bMz2YWB7yMQRFqOBueja9WnqQqSNDmSPqzWqVVnZGIzkz+NVelerxJzamJT6HNc1VwI/B/M85ohkIBhMMJIcHTiKaymm1n/qjY=","authorEmailMD5":"985fe39da7f73dd82f717764ceb17fe5","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"\"There is no additional thread (to wait this additional async IO operation)\"\r\n\r\nActually sometimes ThreadPool can create new threads to handle IOCP completions. But the number of that threads won't significantly exceed the number of CPU cores.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"134e36ed-3980-31ad-93ab-0a06967de74b","date":"2016-05-06T12:10:10Z","timestamp":1462536610},{"_id":"6625935a-675b-3d3e-aa17-db5949bf81d3","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"CPU-based operations are not asynchronous, by definition. It's true that both kinds of tasks (what I call Delegate Tasks and Promise Tasks) are both represented by the Task type in .NET, but they act completely differently. Delegate Tasks have code and have to run on a thread.\r\n\r\nNow, it's possible to, e.g., have the UI thread *treat* something else as asynchronous, like \"await Task.Run(() => ...);\" But that's not fully asynchronous code, so this article wouldn't apply.\r\n\r\nRegarding Mono, I haven't taken the time to research their implementation. They have recently absorbed large parts of the .NET framework regarding thread pooling and tasks, and are currently in the process of moving to .NET Core. The real question as regards this article is whether or not they use asynchronous I/O *and* whether or not the device driver(s) in question support asynchronous I/O. (On Linux, the device driver is aware of whether I/O is asynchronous or not; on Windows, all I/O is asynchronous).","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"f5f7916e-aaf8-3ea3-8f4e-f04d7352e160","date":"2016-05-08T19:48:37Z","timestamp":1462736917},{"_id":"f5f7916e-aaf8-3ea3-8f4e-f04d7352e160","authorName":"George","authorEmailEncrypted":"RgxOdDvIGeOBjaOMVK0DxeW3nNJmeN1JFXpxS/GQ0Wg+3rLJuAe3h8Cy4LFbdLP/f6kLYYsHYGHaYE08q+NSmcdNBA3A5VOSlIaCoLIUi1Nrei3HG/Cy220UI5QkcrJyYF20EaVdcomFuKOLJcrdbxGNXzC3y9V7i6VhEhoqxfRUpnXhNFklixYc0ZmfeDdgbgCJtyPhnnl1hK2TJcPgR43QOAPYTZ5HbbV69phuxzhLiKKYgpSTAcHAQbMfPYwAcVDFFH0Q00iIdly9EvbhdZjVLc32Vv3AkzRks+CFydFPexiM88hGWZRo7G/9A7By/gFPYWZJDVIL62UoG+KYJ3oXvAgNG/apW+lj8BEO3TYML0nX1HlhQPU8thQtkx6p59iKOJawgrcQ0VffrUyTgvV/hlygyPe2dgVUwar2/nijG1Q9OiEYYjLGo0bSkVBNUNDhPZM6x4OUfNCSZvGCksTrFJU2QQQi9aG2/c8kJtFfjYTPQ7fyrHvIivynU+Yr9bC2U4/WV4PN8InyQRn9EmQWGR3TT3QvEAJZNbzh/PP8wtWxV0H3EtXT4zGUldz25mnCaATS6EF0IYuYPVrCTj9n0IT7xMFzCTu8cx0LB4bt5A3stmMrdqriVggPBkJ145agZE8zmoW90Lae9HSMnuTGXwhKoBNmyPHMfpHsESg=","authorEmailMD5":"dca6908ca4a08b9c090990a094346305","authorUri":"","authorUserId":"disqus:disqus_YWGzSJ0SsX","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_YWGzSJ0SsX.jpg","message":"I'm not convinced. What happens if my async operation was one that does NOT involve an I/O operation? Let's say a complex compute operation. And also; what about other implementations of the .NET async/await, such as Mono for Linux or OSX or, Xamarin.Android, Xamarin.iOS?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-05-08T14:00:44Z","timestamp":1462716044},{"_id":"643a9b01-0dea-32b9-9ba3-a65fce4aed84","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Not really. I meant that asynchrony is a form of concurrency that does not use a thread. If you have CPU code to run - regardless of whether it's in a task - that is not asynchronous since it requires a thread to run on.\r\n\r\nParallelism is a form of concurrency that uses multiple threads, which is completely different than asynchronous concurrency.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"858e29c9-3fe9-315f-ac46-acc918336aa6","date":"2016-05-09T20:41:15Z","timestamp":1462826475},{"_id":"858e29c9-3fe9-315f-ac46-acc918336aa6","authorName":"George","authorEmailEncrypted":"EQa+KUHE18tNrYDFIuSN7CmIMTeVMubYno7Z9D3Ks4gcFJaiiAN8bRW1XLBHtV82F2rFzj+OvhW9ypMzc7CuUWo3t6Ij4DUqMPJ6IGbalMqtBFw8MGI9bxLvVv7/m8k5jJCk0iomCYCBiW2LonYl42WX6bdVB9LKY6EFN2p6qGUgZ1eVJUuyOzzsjDXTHFVra2GbyU3pZhsZTRoR4uSEwEs91DgMrhHnGOLFXqVArMTRltVIOjeox4Jffk5qWmQVv1Jh0p+chHtJTuabPkZNAEoxJ56D1do+84QYk4V8h1b79Rehq2KZOKwnTsAvdulCsc84KrjPekORdMoRBEeMCh5eW4R1se8nPtrHik+KuUXyiPdRFo6Dpy45L0F7MC2KqKvBH7tB2onDJCqMtVrHGu/51BHJV95mhPxIFpjXeDR1HQLNB8QVQi9PkQYHNmM/8Wp93pref441AKuQ8GW047yhhT0mqFo/yrYy8W8OwhWHZAuhibJbYPTAkLvWRS4wQxkTuB9m9my3Puc/kdM6L+EdPTDc0gqR2OxQn53iwZImR3hxtsAiKsE/EKPjPEbTXgpSUjxWCCs/y7XWw6c07L2nMsQJSZNbOjQ9fMAV/NXAQm8WknrEwRXQncAs8AF9NHurMQOyOjVKAh6JSbjT46HZAvTyorZQWa66dY7aQMo=","authorEmailMD5":"dca6908ca4a08b9c090990a094346305","authorUri":"","authorUserId":"disqus:disqus_YWGzSJ0SsX","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_YWGzSJ0SsX.jpg","message":"Hi Stephen,   \r\nThanks for your answer. But now I have a question on \"CPU-based operations are not asynchronous, by definition\". I suppose by this you mean that the CPU can execute one \"task\" at a time. If this is what you mean, then aren't you forgetting the multi-core CPUs? Each core can execute one task...OK I'm not sure now when you wrote that article if we actually had multi-core CPUs...\r\n\r\nThanks again for the article and the answer...\r\n\r\nR,  \r\nG.P.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"6625935a-675b-3d3e-aa17-db5949bf81d3","date":"2016-05-09T14:12:07Z","timestamp":1462803127},{"_id":"ce21b9f8-233a-32de-9a6f-41248900c901","authorName":"George","authorEmailEncrypted":"d/J8e8xH+MM362VJxupYh1Q1SYf/Ac0zNFuE38Wtlz0SjoDzSZBhnEVPxQZgDohWJ5yHpJdQMgWthHDNU/ILCvmljO1VoOJZWQ6UEwnk5V6hVnpkEtrrtJPLgqEBOK5sdNbeF/lkO6J5MtER1MfX0q1wc/7n/ceQoCNa+f5ewvQTrhk3/rhYKHW6uZBmmI5Uo0p/cKFIwTrZwSnQAWWZXABbJf5tYDmIKDiNjC2/HALpXm4lldSu3m63wEGwrE1AvbXqxOPVcpjRSet6bbFpQVxUpAeKx70cOHVn+oMvTt3xy3SlrVE7vkW0mtiOcReuSbmQPiUSZiMUX4E7EkPQ1kUD++yZU8XtsZwIlFJdz8pAUzHszHN5zt1O70Xapo99zDOHZYhRyUoxD9492Se98FvcAexnJBaly0MSPNCgvQSPbruOm8pdS55CGDENlx1oa7Ox5SGC44ofLz8rcvXnM6TWi7+JjTmKzxQbd/mjc3JJnxjZGrPd/b2PFv9PLSI95hAaNYNP3L2AOxbYWoJLFu4TEyGaRaKrujFNu4FNc/ZDZCrK2n3Akw8R7qczrah/NPKb0f57ClQgvysTn9iZb8lUCtWFKcWtKVXFCNC1ugKHzNteQHSwvUtiiqFUq20RntOrmjZCHKDtbSTv6eQDJR3iIiYlEIaFigRK5KDhd7M=","authorEmailMD5":"dca6908ca4a08b9c090990a094346305","authorUri":"","authorUserId":"disqus:disqus_YWGzSJ0SsX","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_YWGzSJ0SsX.jpg","message":"Then how does the UI task continue execution while an asynchronous task \"continues to run in the background\" ? You mean that the asynchronous task will not actually continue to run in the background, but because it's in the same thread as the UI, it will be suspended instead? Therefore, what we'll have in this case is some form of task switching? Not sure I understand...","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"643a9b01-0dea-32b9-9ba3-a65fce4aed84","date":"2016-05-09T21:26:30Z","timestamp":1462829190},{"_id":"5017bf85-ae7f-3797-be25-cc3d31d0414f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I try to be very careful with my terminology. In particular: asynchronous operations do not \"run\" or \"execute\". They have no CPU code, so it doesn't make sense to talk about them \"running\" anywhere. However, they do have a time frame over which they are active, followed by a completion; so I do use the terms \"in progress\" or \"in flight\" or \"not completed\".\r\n\r\nIt is confusing, because the same Task type represents two completely different concepts.\r\n\r\nI think these blog posts of mine may help clarify what I mean; I'm talking about the difference between Delegate Tasks (with CPU code) and Promise Tasks (representing some future event):\r\n\r\n [http://blog.stephencleary.com/2014/04/a-tour-of-task-part-0-overview.html](http://blog.stephencleary.com/2014/04/a-tour-of-task-part-0-overview.html) (especially the section \"Two Types of Task\")\r\n\r\n [http://blog.stephencleary.com/2014/06/a-tour-of-task-part-3-status.html](http://blog.stephencleary.com/2014/06/a-tour-of-task-part-3-status.html)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"ce21b9f8-233a-32de-9a6f-41248900c901","date":"2016-05-10T13:38:30Z","timestamp":1462887510},{"_id":"fcc0f242-2b22-3065-9fa4-eca43a8e4ff9","authorName":"George","authorEmailEncrypted":"kec4EajmOq5KR8vqc9IC4RZxfUa9pQJRPxyMI5/TCQ47dXFRD0hdHJCecNNc4AdfeciSBh8wT0COo+Fa8PWLezBGkacbG+Rv6m2FQ3niZdb0JyKhu+t70Q34BRmAmRyPHU+xG43zAud9mGwFbUFk8gThs3q+bAp5u+BSd9ee1+7L3fFqTIPLzufoRmbHbFSZGfDxUaQW9XgD7w6OAc9AOR7cbYI091dEDF1D0exJY9bLc/scpvNDF1zOeLxCkyPr/Xt/Nxkfgp68eV1gXQ+Avv57I3fLHNtHv+3fRyypqdpHMcPxpRoQAypnQyv/LtCmrAhI916/2DwwWNTEQSBTCa00s4Tk+3BsViewekqhi+A2HbiUtc/sJvfJ2PLwMSEU3WhsV5UoxAJO+g63Y53FHUVCJ9ukAYd0IDkWApzP3OX8mp6v8Zn6Y1cuoePSYVRQyrHPDx0ovL3hpIBUtZK3kZ1xMVJ4Npa9WSsLn0vG0769517bC7z5rK2WGqdtQxJrBrFODOwz6hlkBcIZrf9aPLztJWIxmoXR3vbtOixyQ9XpA/1CjrDIuBU0Ykh36puGLzXzvthzxQyKEj0lv/fFC5iGdDvoi1UmQR00NVdHmY4g3NIczrN8y/+cicVy2xs+YSG/v+lzjU3td8G1yJWuWjPuZzoaX3WLGdM5pn+zUPw=","authorEmailMD5":"dca6908ca4a08b9c090990a094346305","authorUri":"","authorUserId":"disqus:disqus_YWGzSJ0SsX","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_YWGzSJ0SsX.jpg","message":"Thanks Stephen. I'll check those articles out. I'm curious about the part \"asynchronous operations do not \"run\" or \"execute\"\".","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"5017bf85-ae7f-3797-be25-cc3d31d0414f","date":"2016-05-10T13:52:23Z","timestamp":1462888343},{"_id":"61f71b33-e69d-3944-8750-11c57ceb9b69","authorName":"Avi","authorEmailEncrypted":"XS3Fz1iz21Rx4bb4cWA3I1qeURKk1r/dcF9TNIyQVBO+rmHItid//xsow2cnxRluXGJHz7uzV10DlmxwFsRSQZlP06FfFKY7XDtIBEdLg4fPEl9BnVfDWOo+MQedCUwDLZHOVQMJhveWDJv3yNS3/AiAiBIDhFAgB3DYNcEIB9skk4ITG/XOcYemE5C+8giA1mFfhPKvjaxw2d7vaX+KBc/JiCO6FuxoEIj4Anh28AdK7MUbthRdxyP0L0iSEpaTshwtf5V2g+/wM2IDMMMmRMNa9ZW6uUbkha0I+l+9aYbCh9PIPtxBF2QVkQPHlj+bNVAzUl+zRmC31xlCzBjGZetUokeik1jKcP1i27WjwXUBcozmV3CaAyCwfPlyEGEBVrAyNjhRekFUU1FaZSIeO7cfwOIUPM7Q/ZnWcghgbf8YQsyBLwOhYGRrz3pjyZwUB39mWOF7fh3Zzah5L7cCj9D4yL2SvvNV1/UMms6ZitYD/RdJhj6MER1rv+t8TvaSUK3YXHix7ueLMzgni6TkDw0tU1zLTOcjVvckfS47yG2GhYmTrlfA9I17UJyRsx9XLuB940KGsECVvGOM8fVqLFlhvh85FKd/alIs9bWQzLqVmZCyDa/bb4KRyoMWjTH1XnPRXWnpruGZwGHZVKdG2mRbkOJ0/RAF96l4EVIDK/U=","authorEmailMD5":"98f19d70948a72ca4a5a99b7afb49494","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"\"We have followed the request down into the abyss of the system, right out to the physical device.\r\n\r\nThe write operation is now “in flight”. How many threads are processing it?\"\r\n\r\nI have a question here. Who processes the operation which is in flight? How come there is not a need for a thread to take of the operation when in flight, the physical writing of bytes onto disk, does that not need CPU time/thread? The actual writing of the file must be executing code surely?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-05-23T23:45:26Z","timestamp":1464047126},{"_id":"a10cfd51-6d80-3142-bc0b-32a272ec3d17","authorName":"Avi","authorEmailEncrypted":"LGuKEty6AZF0KoJEQwExynwsiRgLYGQirQx24/vr3AAmo+DbrFsdpWDdArScDlu+ZCIvGbnotqG4HHAuPtsIxRdaOVKtk/x+GhAoyVjigxpfll7W/ZaIPQtzbd09c0tTprR+fxi2Dw8xBQZXkBg0BSqvARFEz6bGHD4XUaeITKJI1ZbffVwQuDUTpix3Xla7D+wzRDh2Zpsn8ybrB0lOMLy7iSWBN3G1B1apbe7xdu2JMyYYRFfYGMGZhsa4GewH1tXExCzVDc0uUT9tFcYxmnkN3H+0eN0n3tq/VtVGpMwNPg7adecTNLueMZ/nWonnICI3xPZ3JY6nPYGto1Ag1K+3VvGXq5sWLsmGQDTMmhOWtVJNCzC37E5v08dmvuni8e3BhiOQj0kSJh+PdttZRs/UibYFNSehfyLMeNJ1EiTqC/JeYs0ybW5J/SThRklkCPsrwVUAwlaQ2RR5mFMHkINZXAVYwN4MhQZefzwViJco+8ZfUf1R+OerUWLVYfAgjYDuDkADcdOe3g2ATDDKju5bFtW0zGUoGvAzyMo9ryKHpFUbguN1OeXeZU5ZF1oRu2v4k7Q/elDxFcczZP1Rg+YvmVyEcWvKWjLV3GbfW6LJjtzuSNpZmCUpxEF8aSfw8Wy0TtwVDRb4dNZxTgqG9WD3A0IG+Ww76GvBAfijY+g=","authorEmailMD5":"98f19d70948a72ca4a5a99b7afb49494","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thank you very much Stephen. That makes it very clear.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"e9bd4d27-c6ca-3b1d-bd5c-03f537cda357","date":"2016-05-24T19:00:43Z","timestamp":1464116443},{"_id":"e9bd4d27-c6ca-3b1d-bd5c-03f537cda357","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"No, it does not need CPU time or a thread.\r\n\r\nHard drives (and other I/O devices such as network cards, video cards, and even serial/parallel ports) have tiny dedicated processors that do the actual copying. The CPU only places the data in a DMA region and triggers a signal to the device. The device then copies it out of memory.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"61f71b33-e69d-3944-8750-11c57ceb9b69","date":"2016-05-24T01:37:57Z","timestamp":1464053877},{"_id":"4513612c-028a-31c7-a1ab-feaf5b1fd590","authorName":"Gyozo Kudor","authorEmailEncrypted":"LL5cTP3OBykH8e967r+3+CIieRnZFq/KZxgPY+W/HGvHu05EHsuJnUp7ChsVwPkzdCOdicam77pazmLtfTH89aYKdxw3LRQn7sKRWkxy70GiwQfIsIe4EZAFIqHJRrnd6BGGhkyjL20JZ/LpCehWgZVDumDHTeg0oRDzWytipVOqc7m2AtTuNGkTXLrwn6N+RMHfDhqgwidtk+GqhNzMgbFqylyZITKFyu23IGCJNdjRTliZhY2NAGDJNFidWW6N1ezHux2563PyX7Xqak0HXg6vDnPIlbqdsBQvu7L4e6jxaB0UmGEz/+khMnbOHwrgI9l6hyYcxNuCJNQWjwcZNbxCyQNilckPx7ZQHGruokxPF6EBovEE8u85mgSzhUR/3RPwfZT2huceMwtDSWrPSjG97+EHPwjojFfdD89B3XHLLhKWoZyB31LxhU+C9T6dawCzd6LTaDFfd5hLjkIXwlk1wW7cEP+qb7RXRIl8JVtRzkSJSi3Q3nLj+jsRN6y9hqTNJ9zHJr907QiUvEh+uJXZpWKnr71SsgEvndOPF2oE+OwRgBmWJ8COJ42DbODdonI04wcvM4pjGoArB34hZ/gvseDcmJsGVK9a8vUanF6pJ4JHcgCRmYNrsnPb8Yj1yKqL5KDZsD8UVfXh/ZkSj7rylrwSWaFYzEMgT0HpQYE=","authorEmailMD5":"b4be580397a862506e2e256ca80a368f","authorUri":"","authorUserId":"disqus:gyozokudor","authorFallbackAvatar":"","message":"How could I be blind to the truth for so long. Now I see it. There is no thread.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-06-03T17:07:03Z","timestamp":1464973623},{"_id":"15d85c39-b4e5-3df2-8714-3a718fdbdee2","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"If you're doing a truly asynchronous operation, then that async work does not use up a thread while the operation is in progress. As I described in the article, it may briefly use a thread pool thread when the operation completes.\r\n\r\nThe thread pool creates threads as needed. This is normal.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"97014edc-d197-3dd3-b7d4-5d09522f3a3c","date":"2016-06-06T12:30:26Z","timestamp":1465216226},{"_id":"97014edc-d197-3dd3-b7d4-5d09522f3a3c","authorName":"Gyozo Kudor","authorEmailEncrypted":"HkuXBZH5gK7AXDXp3t6L29b8PdWeWw3QN7mCoj/Iq189il67vEWdKrRxDkxAZM/XJ0lhvWVWliYkxgFNPdH+bGTp8QhUhAGMJd+HBdNkanNourLOOtNkldejOC0SPjf5gcjqM6OrU+/yI5FfF7h5hVRfGxV6keNwPbTnmD09Yj5/81qYqA90ChK0CK5J8/DhOrVXWdrllNpiY2cbU1Uc4vqVSYFPxY+8p59XbzqkDYdITP0OVMXs0Mhf1FnhAX9DEGpbQhbiSBTBXwvhcz8N4WquM1WODgllN5UVaaNYbtbBIB31S3dronVNOS156E8vmoICCBvbIx9NJ4iRquirsf1VvE8HAS907A5p98y+wQGnS9SNlj3yueLl9/tFMTlbG3Ncyg/9hz9gjOyivkvk6ZM9/q9CVuG2Bb7uoMkLyw5AxHoNu/K1lCSYpe3Np4bFopJIkP6YHSuyEkhUhZFM0OXy1/JmzAaagperAJO3YWFBbCaRpsxENzMnFDLI3QJp4j74Wnw+dJ0Y4tcT5quOZGb5TyxXw9ML8/0/zUcw8qr60VPR00Nz19qZO8x8eCXtWnnWZBVdKkw6Mf3hfj2OjJK8QYteGzPom10o8GknJ7a8ZThZCa3vwnWqYI5cpwDwSZuRj/+k6xWM5+QJFyOCwxbiIA9Bsklg4XE4SPMVlfE=","authorEmailMD5":"b4be580397a862506e2e256ca80a368f","authorUri":"","authorUserId":"disqus:gyozokudor","authorFallbackAvatar":"","message":"Although there is this thing here, attached as an image that shows that one thread got created.\r\n\r\n[http://imgur.com/tb7rsb2](http://imgur.com/tb7rsb2)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-06-06T06:31:00Z","timestamp":1465194660},{"_id":"9572473e-4ff7-3551-92be-614b308d6ca3","authorName":"Foo","authorEmailEncrypted":"amR/nQJg11zIFAOqgqbjN2xJQ4GUrjdaXwHX9Eb3FtIV2uFt4rdueZj/4W2l+bllH95JXGjaGEgm0OKALetH8JW5lL+rjkPWY3qcdY4+clxGaZsyD2D2wKcFZm+GVaYhUp5j1tQ8kRShcIUvTsS2bwkkgSKC41guixfyfBBFvs9tzSzMqnkTlGK3IoqPVHd6b23sYWeTrtCrwOcuafYsomQsYdqXCjykjto8hynvY5l1obFW9kZ8m+UlIF016Q8HP4peDMd/JkqjoYJRYpIDupNs+BUaiG4DQ896GEzV0sb2RQZZdaVYEbGyUTx3nj1rx+nKCZJHV/ioFoIULcji1Ktr89ZCAx5p0lI9rTiKQwa0WS2HPf5BDQjSmHflocUIFX1xQ+A0vw2UPDUyMOrSyhe97ijeZHGsiFoBVoAXLUW00BqJQM07th6WsEsXlXS3iuq+UFg+mQ/w+e3uviRy6EbHUY3+7gNnJLnDMDUbx+f91sN2s3RdwV5ZDTdX+O+E9LdlDKwQXOKu0z+ZwP7mJC9EKKXSAjIR1C22dbRY5J2o1qgr32ASeWBLuMtzK/XWtYTdQxW3LTt9IVdshd244Cd222UMXSRF/waejUstaKE7b4Uo5eoK2D2JiJnjOrIU6Wxr8rsN49C35zKPYxY2b//xnagdFU4tu0L4Hx5zRjE=","authorEmailMD5":"2b225b0dd03bd728a5d1e51c031a34a6","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"There is a thread. There has to be a thread.\r\n\r\nThis was an interesting read, but I think there a few inaccuracies in it.\r\n\r\nFirst, the quote from Windows Internals. It's wrong. The driver chooses how it handles requests. It can ask IoIsOperationSynchronous(Irp) and if it is a synchronous request handle it synchronously. What is true is that when Windows passes the request the the driver it has to be prepared to receive STATUS_PENDING (even for synchronous requests).\r\n\r\nSecond, a thread is needed to perform the special kernel APC which copies data back to the user memory (assuming METHOD_BUFFERED). This is either the thread that performed the request (if you don't use IOCP), or any of the threads associated with the IOCP if the request is associated with an IOCP. Note that if the request isn't associated with an IOCP, the completion must happen in the originating thread, and if that thread is terminated before completion the I/O is canceled.\r\n\r\nI'm willing to stipulate that in .NET IOCPs are used, but that's just lucky. If it weren't for that, you wouldn't be able to terminate a thread that made an asynchronous I/O request before it completes and still have it completed successfully. So threads matter.\r\n\r\nI get that your point is that there needn't be an EXTRA thread for every asynchronous I/O operation, but some thread is needed - those thread that you say were borrowed had to exist so they could be borrowed...\r\n\r\nAdditionally, there certainly was a \"thread that was blocked, just waiting for that request to complete.\" If there' was nothing to do the IOCP threads were blocked. They weren't waiting ONLY for this specific I/O, but they were waiting ALSO for the completion of this I/O operation.\r\n\r\nIoIsOperationSynchronous: [https://msdn.microsoft.com/en-us/library/windows/hardware/ff548443(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/hardware/ff548443(v=vs.85).aspx)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-06-09T23:27:11Z","timestamp":1465514831},{"_id":"7003d7ac-f514-3215-b38e-245d3191a169","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Oh, yes, this article is quite incomplete. Among other things, I completely skipped over how caches influence this flow.\r\n\r\nBut I think we can agree that the idea [that there is a thread blocked \"doing\" the I/O] is incorrect. In my experience, this is an *incredibly* common assumption. When I talk about async to .NET developers at conferences (so these are not even the dark matter developers), it's always >50%; I'd estimate around 80% (or more) just believe that programmed I/O is still how it's done. :)\r\n\r\nI was not even aware of IoIsOperationSynchronous! I knew that Linux drivers know the asynchrony of their ops, but I wasn't aware that was true on Windows, too. I'm having a hard time thinking of a real-world use case, though; any driver would *have* to support async (the hard part), and it *can* support async-only (and most do AFAIK), so why have a second path? Seems like it would severely complicate the code for no real benefit.\r\n\r\nI also didn't remember the details around APCs and threads. Since .NET-based I/O generally uses a single process-wide IOCP, that's the only case I covered in this article. In particular, I did not remember that it had to return to the *same* thread outside of an IOCP; I had actually assumed that *any* thread in the process (sharing the same address space) would work.\r\n\r\nAnd finally, yes, as you (and others below) have pointed out, the IOCP itself does have (a) dedicated thread(s). But this would be true even if the end-user code never called any I/O methods. In other words, asynchronous I/O doesn't take up *additional* threads that are dedicated to a specific operation.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"9572473e-4ff7-3551-92be-614b308d6ca3","date":"2016-06-13T18:42:13Z","timestamp":1465843333},{"_id":"3f5eac21-523f-3618-ba24-1079bb8de4e8","authorName":"Robert","authorEmailEncrypted":"UybYxF1sGhQq+kBqgHXPVntfG/a0nx3QeiM0T5OoSHMxTmsqRReSl6TMSpwYzx+qEFLC0W1VKCXgYxB09u82zavscuz+ehmNl5bw7641IjACU87OZ9v/c/ohq/9Lk8lLlaFOHOwF5AQhwd4c1B9MX53a14TZP04TLMsfUDXephv8had/PijOp+eRRbptRmQd9ePBy2onFNc1kknDkJfWWmsfrPq/WZngf0lBg1jqxyj7D+xbMbU5MtbQ8wueh/PHzh9u6xjXVhL0ROmkhC/PIQJDp+y3Ed2GhnroznNUMhAlhXdK4XTevDat8m3nmuB9OaN6Et0KdrhU8RkM26TYdelLkPRpW5QcvDRO1Z5bHzqTELM1EDxIVWpm9sW7sCZ8kod6XHY3vwfemvIaCNsU64v9DEgT9cR+XlIFm8fjllMG/1HiVbG6UoMvkrf+ddLkLr0IIYs56Dt+rWA13HS10Vpk+P6ZNlIbpYSHg++aRwK0VacH7hE+Ia8wjX8Id1V9XY2XkI/7WB4Wmz8fzf7BKShZGzOQCfEesIhzG7AyFirDpgpSo71XlwIY9klAoEbl0CWX055h1OGL5iHp2Rr6FcZPzQiee7Y6q0m0Flo6k5pJBnnbxPxSSgMGpDXtSRy7e+oxnX8P/p1bJ4pJHOlLi1efXQmZZSU/1VjJ3AhDelQ=","authorEmailMD5":"9f9e018ec475cccb9da53d14305ac50e","authorUri":"","authorUserId":"disqus:disqus_JzQbO5CkOz","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_JzQbO5CkOz.jpg","message":"Great writeup! Russinovich has an excellent article that takes it a level deeper (helped clear up for me the details on how the calling context, in both thread-specific and thread-agnostic cases, is available when the I/O completes): [https://www.microsoftpressstore.com/articles/article.aspx?p=2201309&seqNum=3](https://www.microsoftpressstore.com/articles/article.aspx?p=2201309&seqNum=3)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-06-30T17:20:38Z","timestamp":1467307238},{"_id":"b89eb870-38c3-39d1-9110-33dd38da8efc","authorName":"Andy JW","authorEmailEncrypted":"N4ZyxZDaGBC90wOXxLesj0zMz2nOjKDD9wIQAnzZqKKi3ZBJUGc15XH/CxW3V8DHahTCTVlz5bMCH5691a2/uhiYUKrOJoFiAcSEgRH8TfwVwP1+JWMb2EB/ExoRrBYSoPhfPsQjZ///hGFJcE/5zTkQuLvdb526hyUt4Mf9yr4XtTLuJvKIq8NyLXtDjFu+b/6Q6HbAZAF1UBfVFYBB8ohSKz+Ak4f+a1AG67M6BaknMvCylEtmXWvx0wyT5n0x6p5G0vH+/kuHmPEIM6+h7j6EJSfe2gfl30+fYlpcgwiInyA5kTDrj5NskKFQjUkF0Mi1OVjslOQPE9mHMYxV1G90q4wGG8tn5mUXgkqN7K+Tlxo5qwdkQf6sR2muctbepnKSgKswA1iyeewJJSVyk8YCv5s4Cbbn3oyxYW1jrSeMQpgLi0pND0PgFT6wncUoVoJMhypmWKFuwmgJmRddCOB/zlTAW+Nl15YzzZ3CFKwf2m//19zgwa5HqmKc+1t1Q9aEgQesQIg1Kixbx6du7XWF7cnrKC45y3sBl1ShEpM6bd3H0qB8mUvkBdUS6gdTpT7t9PNltd/sQ1HQEizKHyRHAeNGRbUy3eoX9VcYKDtiCXT98ZjIXXGaSKVLvMMsXrgWoU37W3Su8npP7AReVmXRzOZu6tqCxgLgTTvi10E=","authorEmailMD5":"7a2c32431708704ac32f2e2637ef6b48","authorUri":"","authorUserId":"disqus:andy_jw","authorFallbackAvatar":"https://disqus.com/api/users/avatars/andy_jw.jpg","message":"Great article. IOCP's are a kernel-supported concept in win32. I am (or was) among this 80% naive you speak of because my conceptual education in EE/CS was the traditional model wherein the thread (or at least a fork/clone somewhere down the line) is blocked and put into the non-runnable state by the scheduler until the ISR is ready to toggle this. And we're taught that it's perfectly acceptable to use a small stack size for these blocking threads, with the only price at the end of the day being the context switches. I would make an argument there is nothing really wrong with this, since even with APCs you need to have one of those I/O pool threads get around to you anyway. Now, supposedly, the only equivalent to IOCP in linux is the epoll. The critical difference is that you implement this yourself at the application level. So it sounds like the exact model taken in win32 is the same pattern as what I would do if writing my own app-layer in posix. I might spin up my own pool and loop over epoll, and I might use the results to feed into a compute work queue, essentially achieving something very similar to .net async TAP.\r\n\r\nNow given that posix epoll is a user-level concept and IOPCs are a kernel-level concept, I do wonder what the port of .NET to linux is going to do. Will they basically implement the I/O completion pool as their own layer on which they will build their .Net I/O primitives? hmmm","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-07-06T22:14:30Z","timestamp":1467843270},{"_id":"84f59f19-b19e-3c5d-856e-292a331fc58c","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Good question. I'm not sure how they implement this on *nix.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"b89eb870-38c3-39d1-9110-33dd38da8efc","date":"2016-07-07T10:36:14Z","timestamp":1467887774},{"_id":"579cb753-63b9-3665-8f9b-5ccbdcc96f58","authorName":"Benjamin Holland","authorEmailEncrypted":"g+zEKJrRXhrqIAWevuNhCiXDIuuDAjSxPip+bNw2r8jgAJ6AU6eSr91BkuYUeQ/uZUCL37ognjpHVfz7hMv92lgh1TwfWG9SPvlBovEYvoBGIbJHWMQL4F8UWBqan3g3AppnMZ2IM6elEHIzWFLvJayogWBcq+RqY5VmuehbSPkaMzup3wS5NqtMfV8omOm6mvVCxKEVsBOCRNXnvBargpUE5KHSORd1aTZl9Qr2/zm9Mim6QSzKF7+QNYBq304xj8uPo8hhYNWCkxXgxYtbilGPfPRNOJeYCmGs60GBbV717eVNvz9UppsJn7jFb36pFqlsR0OY6WEeeZ70JiR7zxFwFCTwytp7ryh1n7JI9Bt7qkWcKrL2mf8OHJoBFcu2qXaJRK4TM30ROh9GevEmNLCnzB8ZSX2nJQL6I2NGvPCDuYhHiafpDfc385r0m3Oz2SOoWMCR0XPVZK/WDTYnL90Kdewl+my4/w5bWnI1C0B8C3fvNMhHpiXeceHUtoc+WRPZ0qwrQ3bkwhnZg92KRzYPBcih2MpM4Km+jotenrF6Ty/ds3zO+ds56JDxZXgJ5LSX0NSTODV1IAYOZmWyzH6oOC88JdPqZp3TngIDfUOPA0xW89PK7F0s5FB1vIegW/leKtkkKl1K7/zNYvV02+MLDiFRf3dw4l3cAQ9nGE8=","authorEmailMD5":"ec08164333e909baef436d182e7d8c0d","authorUri":"","authorUserId":"disqus:disqus_ClNCtMIgGo","authorFallbackAvatar":"","message":"I know it's been a while, but this is still a great series. It definitely helped me understand tasks better.\r\n\r\nI recently have done some work that led me to a question about the chart you've got. Why aren't there better mechanisms for turning Overlapped IO calls into tasks? I managed to do it by closing over a TaskCompletionSource, but it seems strange that I have to do that when the basic concept of the async-await style task and overlapped IO seem so similar.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-08-09T20:45:47Z","timestamp":1470775547},{"_id":"eda8e557-9f29-3fcc-b80d-5c65d3b21224","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"It's going to be awkward due to the unmanaged/managed transition. OVERLAPPED is an unmanaged structure that must be pinned in memory for the duration of the operation. It also only has one callback pointer with a single data pointer (though you can extend the structure to include additional data, such as more callbacks).\r\n\r\nFrom a high level, they are similar. You can see a lot of OVERLAPPED influence in the IAsyncResult interface, which is implemented by Task. However, OVERLAPPED is pinned unmanaged memory, whereas Task is a regular managed type.\r\n\r\nIt may be possible to create an awaitable extended OVERLAPPED structure, but I'm not sure if you'd get any real benefits. You'd still need a managed type that you can return from your asynchronous APIs.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"579cb753-63b9-3665-8f9b-5ccbdcc96f58","date":"2016-08-10T13:58:01Z","timestamp":1470837481},{"_id":"37f8ee4b-6fad-3ea3-9710-05e1c9587a96","authorName":"Benjamin Holland","authorEmailEncrypted":"mFBY88aohhrJd5sVRgue6FnrSuPJKY1l2t+NGLIx5xKikUdgXqoHaxNtWd7SZowxxIRnpLqLPGomuhIp6tzhHIO0tGkwxx+p4os2azL8/dEgLPsR6rR5naTmV3mzZfyibA5HX2qhQD/LO4zavj1KLabJf2RThZEv0g1+xtbLCH0L5iDWr548+O4pfsr9pcxlK2kZMJ24nW9AZy/xZiW2fJfxh+L4thtCeWnvPwSu/fFHagXfwQdiY7Z4zIw8j08qWulIBtjNYDiLChpWCvMZQ88uom48d/A1/nphCCEdpTkKTBDhLmp/kkVVhgQwiG1TeFtpUJUAofOqUdRKsf9cWkyN8KGv2v6J+cUYNGM8Qc+dSPAdCLR6vNJFHu4Rwnh28LlX7ljBHzx3IbIz2KCZbkwB5mKksdMqRSad84myx95qNQGr3DsGl8aNr3ZWd4BJbdkbGqqS/76tSXbIiw6OVpEyYazuH36pKHNJv/G9jfHz3/xh/RB+jgAMaHDDmrqyxjfDeqmkUkOevscF8+OMdo41bXwu5LD5AQOGTPngssg0gfi9ZsuGrcEd9zXXY2MNQ/LjWAEv36iHJgCEIZixlwI7IFkRBvGh1yvCQKSFavKjC4jEEzet5eeex22FBL4LAYb/SAu9AsUCU3q/fr/Ip3kKc7zibafrZbO1+Ghc0ds=","authorEmailMD5":"ec08164333e909baef436d182e7d8c0d","authorUri":"","authorUserId":"disqus:disqus_ClNCtMIgGo","authorFallbackAvatar":"","message":"I can report that it is extremely awkward. Aside from Overlapped and IOCompletionCallback using raw NativeOverlapped pointers,each call requires it's own TaskCompletionSource and a unique managed delegate, which seems like it's a bit heavy for handling IO completion.\r\n\r\nI just thought it was strange that MS decided not to create a better managed interface, given how ubiquitous overlapped IO ends up being under the hood. It's not \"hard\" to do, but the intricacies of overlapped IO seem sufficient to warrant a bit more assistance on the developer side.\r\n\r\nI hadn't thought to extend Overlapped itself. I can see it helping if I don't have to create a new delegate for each call. Certainly something to think about. Thank you.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"eda8e557-9f29-3fcc-b80d-5c65d3b21224","date":"2016-08-11T23:16:52Z","timestamp":1470957412},{"_id":"0082d642-dab6-3005-b23f-a2704b585f5f","authorName":"SharpTag","authorEmailEncrypted":"RN7ebZmQJBCWBHb+F5scsCFdPU5Ds9pPt2g7xD86g91LBHy15X9xBTUUgybt2eoLy7uJwOxEAScGfVAr+zA8lwwX5hMuS1q9++4l5uiED3sIp9qblFIVeCUXR6G1iA2wl9/XviyU0ALOpMjEPWgvS9Rn8XQrbeCM+0XyPBtP1Xgq67drj0PIviuoNqFeP3f/qr6j77Ki7QF2I9AyrpWiVaq0/IxYasfjKQ12tcrkWisjyxVpOAMyhN3YUHNOW+7HhBFmOpCaI6k9kz7DdYa8GDuuGZXThGJGNk0JM2Zic6FUSuzvHve7NjnZJ8J6eOhoA3CSU4H3jOf4D7AyNfdKiRqBTDQR5UednKQflSTOTa6IaO+BEDAqQRiAk0c9Mx3yLFdhd9TrG8yxylqD+2iixKlNBCJlFXj8Ol2KVjOONrCYvvAAz9yCSj13om8T8bBZs/mF3OHbjrDByJ+JRsuB0SidzEdOTa2F73jqVnEvC7h/XjXWZmxFVEB7uzNi5fC7FnITJSYtDkk2QMzOaNS1uVwl8F1xImmYU90DyOdoUlsc2u8OhZ13NcduOPktrG0SIrXpUDOl0ZVe8CLW3UCcUzYw1vv328Aad5RrTS+IgII5CMGdlFL9LSkg1SQ14eW3mu0nDgkbxnb6EKEX5jZgH5rENM1iTnRnk/5NFqYZ9i0=","authorEmailMD5":"5164af4f96639d26aa14d0570108de15","authorUri":"","authorUserId":"disqus:sharptag","authorFallbackAvatar":"","message":"There are lots of devices that don't do DMA so just to be complete, people can still visualize it that way since if there is actually a byte by byte transfer and it's more common than you think, it will be interrupt driven and then handled by the DPC so again no (extra) O/S thread allocated for that. The device driver just has 4 (*) pieces of code: Load/Unload, I/O API, DPC and ISR - In the I/O request, the data is stored in RAM and then even without DMA, the DPC sends it out or receives it when queued by the ISR. (*) giant bunch of other stuff involving Power States does not apply to discussion.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"e9bd4d27-c6ca-3b1d-bd5c-03f537cda357","date":"2016-09-06T03:05:19Z","timestamp":1473131119},{"_id":"0a5def96-9136-341d-807b-496d18c7f85e","authorName":"SharpTag","authorEmailEncrypted":"VsAk9zasqz5erewhD/rNpAf+2bE7absKJP5QoxEA2T4lr4nFLOUete9wTcQ+ZAR9e6YYqTxdYU3Ce5oOLoXw0VDTT5YMIzw04MZJ9LZMntYBBfhj4aoJAX0lHcgwdysDwUBcwwnuLpqpjAp11VUliao/ZAfwsXr4b/EpG9dv7vsl49ktb9pS8V9akoXG+D9riNny6uwq+WW9u2HB1GaoiWh4DX2TNKnOskvfLDRqoqj4ZIFNAUyhNwPBBSQ6FK3RWew9AZ/Z/g5XT273f5vKLOSe3zPylHW3IHO4qaB44D+QD+J6RuigUFcVuXsnOagBvRSUrdWjUhC2LXTP9H5Poo3RETZGaOj+8S2rK4CVv2TWYew5O65EWDFXsfinK2fWddt9WLJMmt4C0XTrwnjPOsVgTacTNDLgqKhEV0pKilRv+l0ocaLzwQ2SiMEfBlLVfprFyhXbnxlE/KgyK3RkY5rW7+hzKuX4jJVSjAWV+tDq7mVPlSfAKbtlIZyzgBm9r+yiQMf/7cnUvyZRvIiDJIn9P+hOG6ViatTLyaSXRWbBGd617fk53zGTRnUAcacui8xnWVuDs0cpod7d25ibFq3c18mmA7TvQrwhYtTYZg0fnXi++AdYMf69FWf5tz5DZqBT8NfF9EykgCY5Mua1A2KgRBh8UVWA8joGcIkVlfw=","authorEmailMD5":"5164af4f96639d26aa14d0570108de15","authorUri":"","authorUserId":"disqus:sharptag","authorFallbackAvatar":"","message":"In case anyone wanders by and starts to build a mental model of this, just think of the DPC as part of the Windows Kernel. It is just getting the next available time slice which means it runs in whatever thread or process the scheduler has running but it has no interaction with the thread other than the ability to clobber RAM anywhere on the computer. Although it can only be interrupted by NMI, the fun part of the mental model is that there is a DPC Queue for every Core on the CPU. So the next slice could be on any Core. If the device has another ISR which most often is the case you now have more than one DPC servicing your Async request. Now everything is at the mercy of the Device Driver programmer to SpinLock the right memory locations and coordinate all the literally non-time sliced but actually simultaneous DPC's so that I/O completes without incident and starts the more orderly sequence nicely described in the article to return to Windows Userland. There really isn't any analogy or sense to be made out of the DPC system from the perspective of a C# programmer, but it is awesome to visualize your code running simultaneously and that SpinLocks are executing constantly on everyone's computer to make this system work. If you have 8 cores, they all stop completely dead doing absolutely nothing during the few microseconds of the lock. Not elegant at all!","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"a8dd8eac-88e2-3dde-b645-4a475a8dfb1f","date":"2016-09-06T02:07:16Z","timestamp":1473127636},{"_id":"568d489f-1075-3c3a-8fca-3a20c845bc49","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The context determines which thread is used.\r\n\r\nSo, in the case of that example, the UI context is captured, and the UI context always uses the UI thread, so in that case, the task will resume on the same thread. Not because tasks *always* do this, but because the UI context is tied to a specific thread.\r\n\r\nIf you run an async method on the thread pool, then the thread pool context is used (technically, there is no context captured, and the thread pool context is used if there is none). In that case, when the async method resumed, it would run on a thread pool thread, which may or may not be the same thread it started on.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"df732c96-74c6-3893-9701-0391b60436b6","date":"2016-09-08T13:31:11Z","timestamp":1473341471},{"_id":"df732c96-74c6-3893-9701-0391b60436b6","authorName":"Ivo","authorEmailEncrypted":"IzDYldOB7ej4Xqg97r2qIAYykLFJgBjGanvz78I+UHKHZstwHAMniKTNQl0wnk5Qcc99nUaCe+6d+etrDgsopqxbmnVyWDgY6Sm9cWMvBK/zqMM+coXvvoN5Cb9t4q1M1iOrlLWOJ25xOH2bZhdaUywyn5c2niII+/1oDU8KdiHA7ewHG5DvARLK/82uXFhXl5OAYc7O+zdRd3OtpJq8N24Nb3Sd76+0XxIIWn11yg5aFrEplYWKf8Vz7p1nHls7li2oTR3Jx8vbb9QSiTcXN4sImyHHQMN56KbDequ4a00+VtHglwztUx/8035hOh92UFNtP3Jc3zkvqaKYSjaB07xzp34a/zGk6S2zTdff6m5TBhqcHhElMa7OCP28c/KnHhK0lCF3ekodw+s4Uj+vFqB7mmB0mOvpwwkeYuPPpKAHjd+A/TpwVhXmlVs5P/D86mM9BHteuFonaSHG6YwuygUbk+qJ3FF8xbFMmyf/RWoySBlekAlO/qwmj7t32KCqK1iCaHy6O5qFaAuNvAh7M6qBqacfCJucFNq8UxCRzwMpj2hA6R7zgpDjBpX8TEQ+YvBIDtnguFPz+B6cU6MHBzWZWoV0LP5F+S6e5KcvK4K6+zHUpsyIRc2aP+upae1WNUJI9srlrsXy6QweTm9ba76/nu3N+ZQI3bJBsm2IhDY=","authorEmailMD5":"dc149b2884327314254ee8a0b447e1ec","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen, excellent article. Very clarifying view over an obscure topic.  \r\nI know it's been a while but what exactly do you meant by:  \r\n\"The task has captured the UI context, so it does not resume the async method directly on the thread pool thread. Instead, it queues the continuation of that method onto the UI context, and the UI thread will resume executing that method when it gets around to it.\"  \r\nIs it that the very same thread that started the Task will be resumed to continue the work or is it a new (different) thread that will be randomly picked to continue? Or I am not quite getting it how this context is manged.  \r\nMany thanks!","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-09-08T08:21:43Z","timestamp":1473322903},{"_id":"54be7a0b-fb1c-300f-94cb-78c38c8bbb35","authorName":"damn_right _man","authorEmailEncrypted":"PPGTKD+yiFeXCo3uujD9YJkTTvaO8gFS41MeklgXoO2pdnnsZpie4Xxzq4VyBP3oYXcmMLQEMKQZjo5mh48vyOPBT/scfVgmguPG8RzrzY0IYGrhA0mo8MbOLCSOyh47gGn4Xpm2mj57XIjgs31vgwm4EdiZypF0rrwO4IxAiPlHVXK27pwSa1pB3YS/WM3MI4ps812AUmSZRa8jeirn7/us4kjb1ZgcI7aWDRiCrEaYRJ77yRVB+tFtIZa4wzrljd/SXBV4Tg+gbL1dPdNCmlyVwsHILU1OzsN20DzgK5zqqi9Brctb5ozDAs6etj0rhSNUhsdvXMQFsDX+ydH9V/W3pkAoDEZqpZLH+aXPpPngTCbg2r2f2tdBC0Getmq8TSooaTfQ9KwI37FqPYPRlwQeCgrSeujQgMMNsOiEsbyz47LGikdUS3czqAqmCKSz+elnTe6CQQHPr9KLdZ9Ome/oPG3l/nHpt/UfOoUrhhfHlzTkyE8GqevXL3SFAkEABWoaaYPwDfoX3SUpC9Ugo/ZS8JefSf1MqTs26blrzpPE+ny8irNfWB9BfvKR8asVYMn2AhlRLQ9O+OyfyiK6EYRA/1/SAGHI9PFwAJkrWBzC8QOYCYZVX+AAZtiq4reE9ZUBaWmhvBc+422c/nUmhZvlWXyr+4L+6UVt5ZZhu4E=","authorEmailMD5":"e27d0d968a30bd3ab6fc056fc5065bf0","authorUri":"","authorUserId":"disqus:damn_right_man","authorFallbackAvatar":"https://disqus.com/api/users/avatars/damn_right_man.jpg","message":"I agree. Nice comment on that topic.\r\n\r\nBut wait, and, sorry, that I comment that late. Perhaps we need an explained sample code, which does not involve io at that level. Let's say, the method, which is being awaited to finish execution, simply calculates complex stuff like matrix multiplications, whatsoever. Where is this execution context present if not in a threadpool thread?  \r\nTh UI remains responsive. The asynch method is re-invoked at the first statement after the await keyword (continuations allow the recreation of the context,etc...), and the callstack now changed dramatically. This can only be explained with an additional threadpool thread, can't it?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"65415d44-a506-3348-99ad-5ad5193bd670","date":"2016-10-02T09:37:35Z","timestamp":1475401055},{"_id":"837f091a-f954-3af5-8085-5b04c1d6058a","authorName":"damn_right _man","authorEmailEncrypted":"TmhP06/WL+wAEfWU0oMWJY4oAynau7NVrJIYZy4QGuNzIrCjZmQukfdv91LBwGrHnOdMmAcSurd8W9ejNmDHJRKWQlQc4yx6/Zno/AZJkBR2iZoWX4TjjHn4XE04pCsDYVQbuTDa4YCDWufjzP51h6FrfeB/80IJn3RWF9CKRgNpM+e2UvcYTMGD4hTVpPbLyI9ijgtn/iWMxvOIagMsvovLr8tKpdwD1/esAvfDosPw70iXj1z5XS1GImFbcqfqXkbuvBqDkiQOHlrxmZZySDbMjNyOLPWwWBK1s7iHG7yFJ0A03bS4BvTXc9oQeiekXFOYhkOsw1r3IrKI++BsfvIVTA6fhfG2RYMm7Ir/A90JtYmzho8qpEP9QXU2hDkFrUT5DKuCwnJD3xIZRnS7WQPf6g2EAjz0GCkbsAXNG6BlfvyOTtefZ+KMxiuVKOndAR7nh0ShRFlCtxUjdCslNAR7BdXSWWV3gGa5iLm0q5VrA8O32XWv3L9c6wuiXDIScaMHEir/V0WlmmTyVcp+E63wUFowR5H2irOaANE4gedpGPG8Qu/GEKqHvCbJnyHpSMyhIiQrT63gkLQDuyrcM3s2hE9B4kl10beAo9xnokpiGaMnhAFnm+RxyFgkR5tvZf7LVQp9izngDu6MIlSlg6iYLdzXxzuKMq5/ukivFyo=","authorEmailMD5":"e27d0d968a30bd3ab6fc056fc5065bf0","authorUri":"","authorUserId":"disqus:damn_right_man","authorFallbackAvatar":"https://disqus.com/api/users/avatars/damn_right_man.jpg","message":"I know, that spawning a thread makes the thread itself being executed synchroneous for itself, but globally, at the program(process) level all threads together run parallel, and therefore asynchroneous. Ok, one thread, which awaits the results of others, can only proceed with a logic, if a thread returns, but, still, it can process other code, which does not depend on the said threads result. ","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"d97855e0-b7c4-3f65-914c-d5acc5c4f23e","date":"2016-10-03T17:26:26Z","timestamp":1475515586},{"_id":"c1ed4292-d186-3d4c-a3d4-184f2287b1aa","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, you can think of the term \"asynchronous\" as requiring two points of reference. A background thread may be treated asynchronously by the UI thread, and would be \"asynchronous\" from the UI thread's perspective. On the other hand, I/O is \"asynchronous\" from a much broader scope (it would be \"asynchronous\" from the perspective of *any* thread, or process, or the OS, or the CPU).","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"837f091a-f954-3af5-8085-5b04c1d6058a","date":"2016-10-03T18:41:55Z","timestamp":1475520115},{"_id":"d97855e0-b7c4-3f65-914c-d5acc5c4f23e","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"If you have CPU-bound code to run, then that code has to run on a thread.\r\n\r\nNow, you can push the CPU-bound code to a thread pool thread (e.g., `Task.Run`) and then await it from the UI thread so that your UI thread is not blocked. But that's not an actual asynchronous operation - it's a synchronous operation on another thread.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"54be7a0b-fb1c-300f-94cb-78c38c8bbb35","date":"2016-10-03T14:10:34Z","timestamp":1475503834},{"_id":"ee9053a3-1323-3b33-89e8-47d4f8b9ca69","authorName":"damn_right _man","authorEmailEncrypted":"TNrixeR92+DKqx1U6hqM59vBVnx+d5coDc+5aLl6MxcPOpSqiQQ221BxFhylbmUYotZEawCbtBbTiegAmerM7A0MhV+r77+8LjrhamzJwi0uCfUUm7wR8l+upWyD/CgxUMSvlsSRTzYGl3SA281Pw3UvVBWufOJaxLKyKLlzb09+XD2WnDse8bZalFHJCwVgJMiNZx/GpjtXg87AG6lPmo4OLpT6Y1NBGBC7lzOdyi5jNN+/gRPiQEFpu/2Zz8GEWpCusdkiEfls3hYCFdHybCR37M6SDcf4Sn2mtjcKwSRKRFE8rh4WblDZjwc//oP/ekzYsV4C5/EKOS8QTWx+PvT3xbF4TSWsD9emTCDTHkKoCTwp3B6q9alTQhJdoS+YPhavIkF5Kbp+Sx3gLP25rpptwhYWirFwxNzotPB7G8vY/rMFP4x9Rz/BTYjCwmCx6aIpaRFed74BjoT6RO+696pQF5iI7o2CB9LS4LPU0JaCN3Exlq3X4bXtzFTc9QUlYL59yX2ZzejGn7uWz/VfX4f/eHtkM36xfQE46egnUhqBGWBHkqZD5YlWoI3W0mT4iyTvBiXLxzlNyF7va2IX7juhxLOVe0y6oGUbL57QdPsLxw4gOhHb12L7BCvlF6CLt6PKW8J21i0Wgkg8EJwBeAQz4dahnpinautx37c9q4M=","authorEmailMD5":"e27d0d968a30bd3ab6fc056fc5065bf0","authorUri":"","authorUserId":"disqus:damn_right_man","authorFallbackAvatar":"https://disqus.com/api/users/avatars/damn_right_man.jpg","message":"Hence the request for another explained sample without this io. ","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"c1ed4292-d186-3d4c-a3d4-184f2287b1aa","date":"2016-10-03T18:45:00Z","timestamp":1475520300},{"_id":"f4f38efe-a439-30b7-854a-eaa677a09d34","authorName":"damn_right _man","authorEmailEncrypted":"hXYTTK/ybKbXtBfseZ8ddv6pHBEBuikSmrPbWzR8ThuKiIu2S1f5TJtXIJTKGYaQvfg69mHEdKca6DKYxoMl8IjsUcm/45/sQvzM6Rbll0C0aTeD5QbcEmk4s5Xbh37tM0PiNu16x5rhrmli036M92BnpBpmC0bp6DzV2GKO93zRFzjn9e2wZ4lSA5u/NWd3x2ZlW7NDJVuZo/mwQRsBfJ2rNCD+qh1Dj1FKUH0MmQDdccrkBPBNagvyIUPsvgc5IU8r8ch4zsZ+kE5g2iIIRUvBPf+PVGHSRNGCnu3VJlJvdZldORL0kSd5sv/UF43Gr07Dv+WhD36YyCe6W3Yet2ihgWsb/oXnuKQ4J/y9WEo3Em+eIvjemxCKJ61axk1JGed9eNOsnHGyVLfdlXdzATi6oA1as5/9VMyRWCRmRT5z1D3VHPUEhjeMxtOlxsS/LY6T6IxEVoxroEbeYVMR9i+uQBPk5oSkMswyDZIbKaeQcPpzBjBZOBjo3ixEx99d57hdg4EMwQKKOKCnAglWSk61VVoi7JxA+fDzX0U9aP2FVGZKsMmXegAJRqsFZ8omQsv+MGy8xAKbDNMeedv5zdclHD5zZ7WbDdrc45QlAHdzl848XomdsBb9JM8sfPuUKtCpkTIaniuvJTEkM1MnGS4yrEdLQx1yUJtc6ghl3rA=","authorEmailMD5":"e27d0d968a30bd3ab6fc056fc5065bf0","authorUri":"","authorUserId":"disqus:damn_right_man","authorFallbackAvatar":"https://disqus.com/api/users/avatars/damn_right_man.jpg","message":"Hence the request for an explained sample, which does not include this io. I think, You get, why. ","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"d97855e0-b7c4-3f65-914c-d5acc5c4f23e","date":"2016-10-03T18:43:54Z","timestamp":1475520234},{"_id":"6c3a31ea-e886-3621-ad39-d126aee909ca","authorName":"teoman shipahi","authorEmailEncrypted":"UXvscYhPRLxxycjNDuEwxmRCKTe7XUpwzRZuuTECGMFJnNK9zpCXtM/zHxh1o/IaEaLVVtdgvjeKztKm0ajdpmnjOzghsr07k5at2Pp2Wonsh7Gai0NdKHi+tG6A8E3zcryC6Sx8YdbXdzyvZ/3KWQ6d1zOkjcdO22tI/FDtlsrQ1f0dxqhdIaoQiqAdmWarexBl1QwU+HPrjryubycBeWJPfwiHv0DPJrsQq/Cxv+QYp7OG7PJsOzAARMYJFi73WrnQqL792SGp0uavmYHUE2/r9itlqjlHuDn27FtlULW9yJ67smqvxgE2KbVWx3cW7JMEdpHiCtbr2jJ2yZvZpC2KR29eYFNFJ6Z37DUJuaH2RWg2QDqlF1jpF9QgGbIV+bwQtFV9oUEPI1eht1o7dU/uk5COJ/S9Z0QM5texrESbJ8V0hzsQvcuZE3m9UD6xAx1AqDmK/YViQ+L4ed+isZafsTNK7VWszR5M+WttyXyYhXmaol8NBUvNLJWtWCB/PdwGn2y1YM8r/Ws1xA9LOL/Lbct8VOyqtqrkOKJfGxLSc9A2S1XWZH57hYUeDRfArZkHs1ddLMMd1TPsF6bKdXJQY5ARz0jOVWieqA8ANrfMhYExDAytd3AomHp8tbN+AodRiH8X8yHKoqMCSIENZOwm0uVlPzxIYDdPEB2063Q=","authorEmailMD5":"d7d0a9abf32a790bbef91e3f03a4154b","authorUri":"","authorUserId":"disqus:aytekinozdemir","authorFallbackAvatar":"https://disqus.com/api/users/avatars/aytekinozdemir.jpg","message":"Wow, I am enlighten with this blog post. I am feeling myself that I was in long deep sleep in matrix, all surrounded with async tasks, and for each, a brand new thread is assigned. Then I am sweating and worried about there is no more thread to assign for upcoming I/O tasks, I am looking into thread pool, but there is none, so I need find more threads to run those extra I/O tasks! What a nightmare. Then @stephen_cleary:disqus comes along and wakes me up: \"Shh, no worries; THERE IS NO THREAD\".","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-10-24T19:55:59Z","timestamp":1477338959},{"_id":"b03d0956-b5dc-3c0e-b680-01cfdf5ac4e5","authorName":"teoman shipahi","authorEmailEncrypted":"mkIuLA87BN2LZhVKuPmCjVI9y9w5nDDPCiif11Py/GvCdgIo5lYSrmM+r4g836Y+UgwXQRike2yrARu5kSfH+xEHsY03sZS1SwZypLh/bA/RyGPqTbZhYLZP2R5nPmmaqxNRHcxbl0wl8BWbzK5t2iZLb74Az6I91NocGP+ja2d5gI4ZjECyOGY8U6p20WjM2rBIGTA64D516Y0/hUGlsaXDx8zy/4U/8nZo6m+dzhs1VH3J4EEVs+nmRdXK6HnQrMwLZCULqLOMpP0JOLk0dWa4qeI0sZxzSKfPZBRR5Nf+tblV4Xy265I0EEDqNbviTey06MM2+jV1QdU5w5Jn76bhOfsaI+Tgo6je6754N7iGf7ksZy7yB7OeBfnwjFb5Kj89ucLjAqHhQYlcnxkrXMRNm95gLNLMHLhPnoFekE/0vbDItVbe42eu+evtIbIe6FfD5axFYpQTZvw0IpHh3Fed3OeOhLLChAiyyxxlreneFHD1Xg/7em17jPHRroPxJJrkqq20dCDlEy7h/B5MDsHtSsTK5dFCsRt9rjNHCdXMdFZTMqm63NHsYsQAAweg/AhxoK7twDEkneQB8tLm2TirR9xFV8dVnxhBwvcq8GToOU1dxXr4+oihdS7GHgL/OZdzHXlrfP4aQOuNJpFwUX04mhW+Rvo5Vac81gvIsMo=","authorEmailMD5":"d7d0a9abf32a790bbef91e3f03a4154b","authorUri":"","authorUserId":"disqus:aytekinozdemir","authorFallbackAvatar":"https://disqus.com/api/users/avatars/aytekinozdemir.jpg","message":"\"In the general case, an asynchronous call does not necessarily create a new thread.\" [http://stackoverflow.com/a/600804/929902](http://stackoverflow.com/a/600804/929902)\r\n\r\nIf you are creating multiple threads to simulate asynchronous operation, this will not scale. You are limited number of cores in CPU till you max out your thread count. So, your 3rd party API s or your own I/O drivers need to support async processing and they have to respond DPC fast.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"837f091a-f954-3af5-8085-5b04c1d6058a","date":"2016-10-24T19:07:17Z","timestamp":1477336037},{"_id":"4117516c-5210-337d-83df-b6943da3af75","authorName":"kandamrgam","authorEmailEncrypted":"lOTio28MkWJ32cyftW3+EZZmgsuxwmNlVD/Hm6/UHqawjCH1zBoKRHBskr5mEiRToVLzVcUK2W5q/FKQNKcFUR53/vz/+UJS+QWUcO+xR37acilZdvjPFJCRgDzC2ZP81lKUEz8aLNWCDKlHU7ykQ4eX/+gyoqNo3EUuvJh6s5IF9JdMDvgbRJJAtm4ABBLQTR4ertOaBA+hAtWVA4dC8pDN7rq7B6p6iNp7JzWAodtYNStAZN57K6z1X2vH3y2VolqKxaT65HmfYoxNSmKIneImpG8KIFvA/qgz1a+6BTw7Gmnw1jJM398WbZj7mzgnivODz8wg4H65uqdEqpx7OnVH6W3PMKuG7e90+SJPQ6ikjSK3f7t3BwV3wnBm7yD0/wMhN9rFt5xckLUQYTOMmT66uFe4tc+DndZPaPLv+1vd9DlkNXZWLbf00wB3pWGJtSFRr7HcZwIbtPeAG/tB6jPsgm0y78IWUcXhzSnWr8ehSsk+DipDUZ/KkdgQZDaGqP7n55zRHDGo55mIobvDI79m9wtb1xnmTnJm/ll/obcSNnTneO5511qX+AMq3GImoLQujwYrtGs4r3lv8WMO8/GrKPeGPgkIgYFKJw4Ya0caFeup2oMZmdjJnQZi7lTsgyWh8WvnBOuCB5ySDFihjZ3OKmKu/B7wd6odCWjfSvE=","authorEmailMD5":"a60e16ef8a1f18164882bfbc7d1a1ea1","authorUri":"","authorUserId":"disqus:kandamrgam","authorFallbackAvatar":"https://disqus.com/api/users/avatars/kandamrgam.jpg","message":"\"In particular: asynchronous operations do not \"run\" or \"execute\". They have no CPU code, so it doesn't make sense to talk about them \"running\" anywhere\"\r\n\r\nHi Stephen, some of your comments (especially this one) actually cleared the concept for me more than your post itself (which is also great). Thank you.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"5017bf85-ae7f-3797-be25-cc3d31d0414f","date":"2016-11-21T08:13:30Z","timestamp":1479716010},{"_id":"0e90fa6f-2303-3498-9218-93866ba61777","authorName":"Jeremy McLain","authorEmailEncrypted":"GtKOV/52I7lS/Dhjh/tmSSiO6O87e7QKSkECFFeTAhMZ481s5Y6ArVEDEOUpN7rdRGQamhCsU7cmB9URWAR+ZUJE3ABNrYft3181HlsWxYRGdi2JSgmRO0qkxOePPmbc5XKVjOz5UYCM4fzXWIfNCl6PM4K0yGL/vDKnScybvfzLZ1s/hfOgjXTSFX81TRwP7NjykkUyxxtFpQII8UD8/MJuRERmSjoLGwmBAKm5yZNfJRQMVtfWS1zitMCkoW2B0HQin9emPeqbZBS1qaVW0QR1LRXdNkuO0p0JniFgmrkoIjxiM1mj3wHajRn6Gmlt6IppqZHryxzmRsAqPCwiO6mClzg5+UaXe2xgmpUqw9S1S+doI4PuZvTk/n5KkJ0xiaVo4iYg7HaP+UtokuSzE1BvBGCRowUtnArmmPhJ7aLz1fGRstl616Qf81z0q5gJovenula0gtt2irWECbke9L9FUCrNMRrNKbiSjqL1ZUo1u2Nvq2+97qJGw7IIToCsrqClih8RYYbycEZOVyjHx6+K9a+jQSrzI1Ul1mnv1q0KYBpVCyNpeuf4Qc7JoN/lJco/yPE6zrEukWok/SjhGEgBcDUqLTdkRbt6DfUY7BRhtEu4WzjMly1JmFSsYMLHXMjVsFBe1/oU+30e1dcy4Kqe2CSxydaKw9MCcBDiUiM=","authorEmailMD5":"d2c9fd9e44004124f3eea85564113812","authorUri":"","authorUserId":"disqus:disqus_yw7A34vbfk","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_yw7A34vbfk.jpg","message":"It's not multi-threading, but it is concurrency. I think the confusion about threads is some people think that concurrency is always done with threads. With respect to I/O, the reading or writing of bytes is done in the hardware, concurrently with the execution of your code. So yes two things are happening at once but the other thing isn't happening on a second thread.\r\n\r\nOthers might consider anything that causes the context to be swapped out to be a separate thread of execution. While these may not be threads in the strictest sense, they are context switches.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-12-10T05:46:49Z","timestamp":1481348809},{"_id":"1a2a9bf7-2708-3682-b3e8-70f0fceb8f15","authorName":"Rafael Nicoletti","authorEmailEncrypted":"h+G/1JKShzH5afNSzwiJQktSFIH3KyWzawMXJK/Vlt3mY4HbPlrA0jtDvl66y+nHn4M2z/gBll9mhN8W4st8VUMNfTLtlqYoZeOYZhQ8ff1I0n/fAr3rXIljIPFJ81RL4yxmOEyUONk2sZP73RXgSZ4fnxPOLXzjatNbbnUFMHTbLITMDTB8OG73Hz+2ZVfX7jI9EV58kQ4rN6GbGxZLJI36lDVfYsoIHMRS1Jg8smssxrN1vAq1PnLFrxMAtusACZf5GXADvZKiX0SIiZn98wrl7Ysk8DlVqTJu9h1xBFIHKlA5K7WMsG1qoIlP8tMVT/ekmEUvuY9YjleapsBcFzziicYmishf7TMLxdsY2kO426E7XSFvAYcG5pkYmVR7xLSGphwAWjiTL6BkMr/HBqoa6uJBoefMeNr9re7NtzmkrOpMLhhJ+0wTQ7ZvkobIKqshX7y58kXFR0QZEeMAh6ozafFasCbfRlOxEHVazt+Jp5uDsFfXUya7J/6wPszbHVqP8SBgVFzFpgWXH3ydB64uRf6pVAiNVP0SxYx4/nzDlLxFqC/XQ/NgGU316/cVYGksccE9eiDHoOI48qgKpVxs/5N2cYzxFEpNWXAnjloJsJknMaRKCgehEGWC/BHik0shUJctN8Bzoiwae++J4Z1zXvGRl9kOZEB8Xioafrs=","authorEmailMD5":"fbff5199443cb5ba1600a2068af03964","authorUri":"","authorUserId":"disqus:rafaelnicoletti","authorFallbackAvatar":"https://disqus.com/api/users/avatars/rafaelnicoletti.jpg","message":"Using IOCP and ACP, you have no threading mechanisms working on.  \r\nHowever, that's not related to Task Library directly. You could create a Thread inside a Task action and make that Task \"wait\" for the thread to end. In this case, there is a user thread that might be awaited.\r\n\r\nUnnecessary to say that this is the worst possible approach to deal with \"asynchrony\"","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2017-01-25T11:43:20Z","timestamp":1485344600},{"_id":"3bdb1e74-f918-3885-831d-4f28c51c5b6f","authorName":"Rafael Nicoletti","authorEmailEncrypted":"vb38GUbJ8GrFwG8nz1hBGkv4wGqAB0Hjn7PZhbs5LD7/wTQqKzIzfIZ5zsCDlZb4FPoGyqKpooduq7WzJSzFlX02ukW9EW/quVCNkz8QXn1EM0EVO3bGAPYussqcB+sdbzVyE29OIDeLDueQdBavLQCHwmEOIz0N1bOWJBLsJCqAkRGR1vrUyKhX+iKYNIeq6cm54p5mxUaClIomAuBK0Fgoa+F6rP9WTLwVFcdGlRGmyMn2HqeEVlA/Qe+0E15l175w1QyXsbXbvk1tvgTl5k/qRyJpl9Zs2Op9HpleCKZNV7JIOuXz52x4+WKh+tQwNnuLgELL5xK/5nz9uPhy+skQejdS2mGJp+2519BExLSkjqY0ufZhmzmLOseCP1fPcRnA1SthBVYZz/A9HFEH4khF6welpKAlvBq5krutP4lEYb+NGEiMsjw1eLZlFRa1blvC3xZdH4jvVcPcf3hqjRwTGi6Vs/kmw05cVCQeDC6HMXkCWIrMVC9KaYfDYGjZQnpQ4DWaV2HQs3OxEtjfi63W+qERVgPX7vNrF8PAL0IeuyifUxZCdpoBjCCoHhcQF0YBGPqNH7S/TOU8TxboN60DSirDAeMvm48S9td52TWoRTPacBafeZuiN9qO5DQgW9zkl4rrRBrJ0g+nqy6sfnR5c9yA6bIkLwnWg5CeFIo=","authorEmailMD5":"fbff5199443cb5ba1600a2068af03964","authorUri":"","authorUserId":"disqus:rafaelnicoletti","authorFallbackAvatar":"https://disqus.com/api/users/avatars/rafaelnicoletti.jpg","message":"Let's suppose you have a tcp connection and issues a ReadAsync\r\n\r\nWhen you execute this method, it issues a read operation on network driver level and signal the driver you're waiting a completion from this command.\r\n\r\nWhen the read is complete (at network driver level), the signaled notification you sent together with readasync is signaled. Behind the scenes, the \"callback\" is scheduled on thread pool and eventually called.\r\n\r\nIf you do something that block on that callback, you're going to consume all threads on the thread pool (supposing there's a lot of tcp connections doing ReadAsync simultaneously).\r\n\r\nBut the ReadAsync will continue to be issued as the thread pool is not being used to send that command to the network driver.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"0f4118e4-3ef4-305a-8b7f-ec2c77155ca3","date":"2017-01-25T12:02:38Z","timestamp":1485345758},{"_id":"4541174d-bd4d-35eb-a22b-9174c01e2dc0","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes. Since Task in .NET 4.0 was originally developed for parallel processing (with asynchronous as an afterthought), there are built-in mechanisms for this. E.g., Task.Factory.StartNew will queue a synchronous delegate to the thread pool and return a Task that completes when that delegate completes. It wasn't until .NET 4.5 that Task was extended with full asynchronous support that was much easier to use.\r\n\r\nIf a method uses Task.Run for its implementation and returns a task (i.e., with an asynchronous signature), that's what I call \"fake asynchrony\".","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"1a2a9bf7-2708-3682-b3e8-70f0fceb8f15","date":"2017-01-25T13:16:36Z","timestamp":1485350196},{"_id":"1b5adb1e-72ab-3a96-80aa-35d657a281a7","authorName":"snielsson","authorEmailEncrypted":"bSS3D6QPtlfD8lXWztyz9efOGIWC8wa85FAqRwvSl41G7eOLEs1Ea2PiFdOLvR0i3SvWIiaNL/nve045+U4HagII3LtqE4mVJkpbwHhN3qgcxzynr+56gnGpIOLFfT+yw1Xu1SIMLVbl9Er8P0BsL2N8e8/plbtAd9AelHxObwPsf/uunWZSABsA4LB4dl+yu1fpESU97yBQkWVepgpVYes4Qzq6eWVs9+t8v4SHeh9kXpDmbYW3JMDqX2HAMs/ZVxSNz+jDYi3o8mZV+l5Nj/zo4r+fAJZs9sSHmH9XPEtXoJ6cQsrAOxgpPT1v1tDxBrOu9Bl5HHqSess75MVJRfgOOb1VtlWLbJ5j7Yprl4gco2dIhV4ObNg1pI83TTIF/LveEJP5uLDGBs7r6fltUIT892fEZk4QjefVj8WlomjH3YXk1ataU1MeE2vsRFySBv5pGdlB3HsxP5tzZ+WLJLLx+Vuuc9Wi0VWfOlXkzRcK/N8e0XL+us2E/VU0ZnEhaTY6T5rMYkqu3LoSxDqH8CcT877KxrK3otg1xH9RUa8Mxa6kAAhgskAgU8DnZE26RqeBT/ZFCXwl1Q9/lQboRn26sp0yOPgpOB6KzG2kDLMFn8WKc7qWj8ieQQT06KuEUVASrxj+OdmtOA3JIAl6yWRcaetkQ0lDP8/WdIKtAqc=","authorEmailMD5":"5f54b776d334bc43e497f50e28e5cd89","authorUri":"","authorUserId":"disqus:snielsson","authorFallbackAvatar":"","message":"Yes thank you. I also asked this on stack overflow and added some sample programs ([http://stackoverflow.com/q/41952687/193414](http://stackoverflow.com/q/41952687/193414)). It looks as if there is a limit as to how many threads will be taken from the thread pool to execute the async task continuations. The answer I accepted indicated 1-2 threads per logical core and my tests showed it was more like 3. It also did not matter whether a single or multiple threads were used to start big batches of async IO operations - the threads still maxed out around the same numbers - off course this can also be due all the tasks have been synchronized when waiting for access to the file system, which was used to implement the async IO.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"918fae56-7374-3f26-8e03-47fd4ea9005c","date":"2017-01-31T14:13:23Z","timestamp":1485872003},{"_id":"918fae56-7374-3f26-8e03-47fd4ea9005c","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"If there is no current context, then the continuations are run on a thread pool thread. There is no synchronization of these; they can all run simultaneously.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"e9009e56-72fa-3e65-b6ee-0c5c569c503f","date":"2017-01-31T13:56:49Z","timestamp":1485871009},{"_id":"e9009e56-72fa-3e65-b6ee-0c5c569c503f","authorName":"snielsson","authorEmailEncrypted":"dxONtePI9xUPGb+CWja+3WadcqBIV9YWY4GOuR4GM8e7jj8+xIsYOBBVbqHO9mc8Mq/OV7Do1IvgaRFmiAfIIHtXF6gcVfxgSjgcaPCtDgfSOIgP5yd+ExnWo+5FvxOFqrbyLkysacJbpwy+IlLzk73wI/O++AHbkop29X92qYa2tFs/SJpLBISrSsk31mkSnSyO/DuKe5rwqPEWs3vYp5UZmm8bi36npB72M4G2DIGl7ITubmqFrxOuYPSFqKjQh33hQCf6OUjIVaiEJpyuFdySO76PFAKkLw0gFCRdgMd+YjAQAv35uA4AHokLZw2lkwsG8L5ZLyETjbI36Tg7kbtecQno/0K3HnOzUC0+kPJ3rLYOxUjsCTELo71sCOTRbCyIoY0oo6sNHbcGeMw4t5+uHjaNqjO3JCNx6zbHkTIRGEYbjqN4MPMwsuIPGXryFhPywkIzDHmw3i7Uwhqaz2warOoUaIRxUkX72TS7DSsvP5i42tzOh4LHUwp8lkHTPICTxYnV0U+W/VWyYhtiI9Buf/56LW8xLsalypo/LBM/YxhCDHxr1HhfJMQrhqA3OxDx7cy4bkU9P6MDF2q2XSWQHD+/VCFBnJ6ijh7lAKVjoRLd7mFdvRA1uZfY99iP09eYgnsKiYNvMnnCVM8sNy3c/APQx7piCBaZxKoJyWA=","authorEmailMD5":"5f54b776d334bc43e497f50e28e5cd89","authorUri":"","authorUserId":"disqus:snielsson","authorFallbackAvatar":"","message":"What will happen if I on a single thread do a\r\n\r\nawait Task.WhenAll([items.select](http://items.select)(x => SomeAsyncMethod(x)))\r\n\r\nasync Task SomeAsyncMethod(Item item){  \r\n await myDevice.writeAsync(...);  \r\n do some cpu intensive stuff...  \r\n}\r\n\r\nand say there are 10000 items in the items. When each of the SomeAsyncMethod continue after the await, then it does so from a thread on the thread pool. So when many of the SomeAsyncsMethods return will several threads from the thread pool then be taken simultaneously, or will only a single thread execute \" do some cpu intensive stuff\" in SomeAsyncMethod at any given monment in this case?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2017-01-31T08:01:34Z","timestamp":1485849694},{"_id":"64a5513c-1616-33aa-a9c5-010f2f52da28","authorName":"Harold Chattaway","authorEmailEncrypted":"TjoCKRltfV+dZIeFErJ7LGRS/j6gw4jjR+2D9SyQxJanx3qeQAaoqXI+cPEhzDuZ3xfQk63ZSncqOEbqDGcvngOV149H1+wFPCYIRVk2T6p0AAzGVSiqjODVpTqCmTTyZC1hbNbgyhUCgFB3yr49Sr7xBuj5szHTd720Z3vg4FLoNVYO8avcFCZ6QGjx/gZG7oJtziry1RWhtZ17mY9jguxICY8gRudkhldGNU5d2iMXDxHSQJd6637id3bYxfGlnFs36OCn5JM+cdD5M8LXlS6y8rMj5HROmnQ1mpqOj0JT14T96KjA9EqL8djdazOWNf9yHQ7PFgNXF2tgY98WtEEtDe/bBSfDjDJ2dwVqpbvl33TzCNF8pcjfKcrYZs7cV/MT4V6GF8eejXO/+DSnZG+vPMlv72808KCbKH3VF6usrfyA2HvQXS1giP5pjUhi/dGyndU6hWJ1sYXv4/iZAjBKNvz/qyVYIdQYNbDJUUOnXgIaohNAJpWT+dq1v5n8Ia5ZhCJQfjXLN8KweHRim/7UeCtt+EH15CZsf4yZhRzcUC9dR+zEl6pw44uAhHJVXo2TUApg/NXn083OnCpO791bha13ONXNd2sUiLJha0jqDNToxq9RHB1xnoud9THKyV0pMX8HlhAlS8TJ4BxQLr3sg3EAUz+VugVZgmCsZs4=","authorEmailMD5":"f1490ab8bcb9f131f4defed453afe577","authorUri":"","authorUserId":"disqus:haroldchattaway","authorFallbackAvatar":"https://disqus.com/api/users/avatars/haroldchattaway.jpg","message":"So it's still important to use an actual thread when what you're doing can't be handled by one of these other I/O type processors?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2017-02-13T20:39:07Z","timestamp":1487018347},{"_id":"6783cd89-d9ee-31b4-81c7-5742669f95c1","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"If you have I/O, then use those mechanisms (e.g., Task.Factory.FromAsync).\r\n\r\nIf you have any other kind of event, then use TaskCompletionSource<t>.\r\n\r\nIf you have code to run and need to free up the UI thread, then use a background thread (e.g., Task.Run).","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"64a5513c-1616-33aa-a9c5-010f2f52da28","date":"2017-02-14T03:21:08Z","timestamp":1487042468},{"_id":"1a588009-cc96-3fdb-a2eb-b9449c0a9df7","authorName":"Dave Parsons","authorEmailEncrypted":"mF/OOkmAnoXPw9cJJ3/9C6Q5bBhITca+ED1qhiI4/XrDJ2hPCMJCVwqRfnyIHBecPfr2JST6jUpqON2T+z+5TN+cN8lWjRyXav5drA9f1m/88ou+BvYvhJlQI8vg3/XT56BqPa5/DOEL3m5PgJq51lJjJEEGWopI++GVzjOZo9MI/0y29cof11rB7l38DV+q+WZeTYQLtrhX3ZHTaPrw25CNXZVj2HeEgxwU9y1QihxTDBsIfBwVEy23+2yqBuQlUAdrrdvHf0wleDl2inKarL06JtqI5K7XHntg1G1VTY8dH80Dcy1892kU0LVw8HFNnlQEI+oxnYHNjVR8zr/O1uplpG4ZJWRY+J+hq0wyPFOrLzQK0gOZbxmhXzVVtCv0tsikl1AjEhrOc33+zrYJv7Cl3C+01qE92y5J1BxgvuMIXAiDUZdAOMQNFuf+mZVL14KmO8G0idrhZcsVC8f8TI9SPtNCw9UP8NN/jTRMAytDDiqGn1KM1rrNYmQ6rR9s13T/ciQr0GFrnN+F5cvTgYkiZH5kqFxE15LL9nvXIpVsTrs3WPtL0gWlvpeTb7rYmpCIX+tqyqiTb0irHPsK18nM9nzT3ZFWenWlhWv5yP91mb4Lvk+La6JDtFp+Zdlr/feFtwqFTjbco1+ZMDplgllqdnRzvitb6xu8Rsz89no=","authorEmailMD5":"82df17885fa751600eac9fa114cae9e8","authorUri":"","authorUserId":"disqus:disqus_SjnQZZNqZA","authorFallbackAvatar":"","message":"The I/O completion port is said to have a \"dedicated thread\" that tracks the thread at hand that initiates an I/O. This port also provides overlapped I/O. Assume a thread that is doing some work then asynchronously kicks of an I/O-bound workload ( a disk I/O meant to read a file from a file system). The asynchronous call permitted that thread to return to the user-interface, and thus avoid blocking, unresponsiveness, and overall window freeze up. Having returned, this thread then resumes to update, resize, handle events, process message in the message pump. If such is the case, then how would it process the data from the I/O request Packet?   \r\nThe thread pool uses I/O Completion Port resource, but how would it obtain this data to either queue or process it?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2017-06-05T17:00:01Z","timestamp":1496682001},{"_id":"e3ec4322-493d-3689-9d5e-f3d563e06ad7","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"By the time the IOCP is notified, the data has already been copied into a user-mode buffer.\r\n\r\nTo use your example, when the read is started, the buffer is already allocated and a pointer to the buffer is passed down into the OS. By the time the IOCP is notified the read is completed, that buffer already has the data.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"1a588009-cc96-3fdb-a2eb-b9449c0a9df7","date":"2017-06-05T23:46:07Z","timestamp":1496706367},{"_id":"d9bb392c-185a-3416-8233-860a4f140fcd","authorName":"S2RaL","authorEmailEncrypted":"Mx7ydVD1d2a0CLniGu+XbgGdUQi2ZQXlJwwN9L/6Oe3o7cpAnP2pXQO1tMjejl+D7NGWvGK7HJda3X8SZE6/iATpU30CJRo0NCaGNZ3Cn7izjN7paa6DzquRsSB2nyKbzuGKHJ4vsJkqSFAEnqYIICpOUEJHeZY3mEALWp4MwOhi8FwcosTwsMpjFKfJwikTj6QldEMmXwLNcVqur5WTpezwCrcTCQHIBETSa7m2m1PsKedez6VRfLyLPbBJ03l1GEmzouuf9B1GKp8hq/ShhCsPFOCAK1uFTSw4jN08SqcLN4n1gLECafJhb1ZLaPsoZbG8rWjOcvBZIqSaNZzo7MNlfwGmOf1lhd2A2mCGQh7Sw7c7Zpi0vV7BNY1nSLk1qhkDdTB+/FMGOsmLgfwiGjYWzdvyhkKG3wl8xwu6mluLOusK9Ff3mmrPey0yQVFNdvkZsy3HOqcYBYsHEqzouIIVOzp4do1+0+n6rN/NwJZax0TmFjxz7lMZqZegBNvxXn3UReoXYvRBZcBk069i22+Uxsgn/RX50hSowaPIeDHO5HEWLyhOaWYjlp1jZCwxo4tZt/S5rV4XkmPalemXIO5f5P0rBpZjExmETJBMInTOgnAWkLty3v7iA+pL1no7azl+e/i5jq+jJnSMKt7ci2uH1X0yz3FqecUlE8jmRpI=","authorEmailMD5":"1404bfd9442ce20ac0c2e08ec022fefc","authorUri":"","authorUserId":"disqus:S2RaL","authorFallbackAvatar":"https://disqus.com/api/users/avatars/S2RaL.jpg","message":"Hi Stephen.Thanks for such a great article! But if there is no thread,Why Visual Studio shows that it creates a new Thread?Every time when I call for example WebClient's DownloadStringTaskAsync method,it creates a new thread.Even all microsoft's async methods behaviour like this.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2017-07-04T19:42:05Z","timestamp":1499197325},{"_id":"d4ddb043-e5ad-3af4-8167-c7329c0999ff","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Thread pool threads are spun up as necessary. E.g., they're needed to be \"borrowed briefly\" - used for a very short time and then returned to the thread pool. WebClient won't block a thread for the entire download, though.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"d9bb392c-185a-3416-8233-860a4f140fcd","date":"2017-07-05T17:52:02Z","timestamp":1499277122},{"_id":"b6ae0433-0d51-337a-8a85-980cb6f50c53","authorName":"Harsh Maurya","authorEmailEncrypted":"e5txX2hPi/wCsv2blxNkgFrI6TQxOOJG6m1cWuoxccp9BZ77gaBH97B91Xg13DY6M1iOHJMnjUDArwj/VLR7bPomXxfNirZeK0Fk7aZ9nKrcVvPqIV3Wr+xw+7r5Yn6u++8Bc+bGI2+lbp1tsFUTF4MPPO7XLa9fpnmLwaUQfNSFhwDfPpW/NORjoOuVQEL0VzpawyJzdLKm8nABJ6O1/oC8SpAeLzGf8QJeBRPK6HN7bU9UmMxTwdZeeDhLn1x9qCbH55XQnvr9cwVaCVbFFrZHcSFhdMR5dd+pejUr08626+0waXbxp043wM5cnhbnnLmbb2tW/TiLKzpIfyutYs0mBuBn53zJtzvv5HZ1TLOhOLJiLmwpbO96VCdGsWwks+mpid/6nXpT83+Y0I+eS7EwnJjnsR4Ept2YZtO1ft0uIXyrgxZKiZt/mZN6H7tEQtblP+cBtaxQg9JDsHgBqPDHLCHj0tT/DXBNmMCeRQ8HKrt8zAOH1TjZTxwQK/EfqynWDgx1Aisvwq3yOP/9JAuet5zLPbPElwXiw6ZAGMQ2jlRoEERsUKRns9cY2qxjd/qUJB13xKn/vfGWIA5WlR1EFdztt29hD6LlKdJlYf0e/2W9+ph+B2UfeRB/nr+wlhgGmW39wZV3S+a6clOEk4j41qvz+OfO63hRVkTGFsE=","authorEmailMD5":"501fdb8376d6474f00f4dafe84ed5c12","authorUri":"","authorUserId":"disqus:harshmaurya","authorFallbackAvatar":"","message":"Is it possible to have the UI thread poll the IOCP instead of an IO thread? I know it is not useful but just asking a theoretical question for some reason.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2017-07-13T18:06:45Z","timestamp":1499969205},{"_id":"b6c5c522-b6ed-3eec-8be5-6c9f533fa71a","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"AFAIK, you can't poll an IOCP. It's a notification mechanism - an IOCP thread is blocked until a new packet arrives for that IOCP.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"b6ae0433-0d51-337a-8a85-980cb6f50c53","date":"2017-07-13T19:05:38Z","timestamp":1499972738},{"_id":"01c13727-850e-36d1-a4e6-603651c24376","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes; I've done this with C++. It's much more difficult in a managed language, but it's possible, e.g., using APCs instead of an IOCP.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"0cd5ca18-270d-3730-b707-e2f2899ef0f0","date":"2017-07-14T11:41:39Z","timestamp":1500032499},{"_id":"0cd5ca18-270d-3730-b707-e2f2899ef0f0","authorName":"Harsh Maurya","authorEmailEncrypted":"XKgg+eGqbrAT3yNfB+0QAPAjLEu3FfRepT2vvrAv/6vAnNSFuFbL4+J9guOjKZYUWdwBu7yDT34dXpAtsztRiN6D7syUTSUGeUh6Q9m78DzO3JEIWXaorPI7zEEAO09DyBvHL2DMZvW7VdmqLW4oKVGi773iiR1tHQIWDxNQos2QwapNx1EbLd8TOWxJJAi5rWC2QzCj2avVEaP730hV6V/cIOF0Fz38e6MJon49b80+2/hd+k9/tDiHIiaR8b3FQAc/zaZmqdNe34hMqwqC2XJeyEnWphOnhto8rOmI71KzClHP5iHX6ikOeCD0w9LDeL3vKCfN5/mkkrSd5y0ZLzl18pAnkfIKY0ICxT2jO4FwPxknHeYp3Kw6ADycp2V9Msjagov5Or6cwwC4iemPygyTOPb8RursZPZlnKleh7cjqTpfXsuT32en1vmkpMde/QUBdlx21s9C2amooQTR4Uwjac0n5X5ktsK8Pzq2OdoCt382Y33IA34OMd+0aNxfiKlgIy+z7INy64WlwgXQloDKWP/5ZPUW4D6JNQg5AOk8PurKCSxqDes6sde+0K1yhEKhpv5rke2Xdkqtja7/+TC8Lv7q4RjS8ewWhSy2DRqeu4FPshiK7JVdt8yeTdRLQQ96zxaM5PzP096nVjhX9Zd1nnTk7OM5JA0po5kdm9c=","authorEmailMD5":"501fdb8376d6474f00f4dafe84ed5c12","authorUri":"","authorUserId":"disqus:harshmaurya","authorFallbackAvatar":"","message":"Thanks. Do you think it is possible to write a single threaded program with async behavior? By single thread I mean, not involving even the threadpool IO thread.   \r\nFrom your article I understand that this might not be possible for an IO operation but can't a single thread's time be sliced into mutiple tasks so that client \"feels\" that it is async?  \r\nSee my question here: [https://stackoverflow.com/questions/45086555/writing-async-program-with-single-thread](https://stackoverflow.com/questions/45086555/writing-async-program-with-single-thread)  \r\nThanks for your time btw.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"b6c5c522-b6ed-3eec-8be5-6c9f533fa71a","date":"2017-07-14T03:29:20Z","timestamp":1500002960},{"_id":"73e28f7f-d003-39fd-a079-b211570134e4","authorName":"yue shi","authorEmailEncrypted":"gG6dUbGlr3eMZb82nsjRw1xzQgmDW5Y1YK/rV10tWzuqrJTymfNQfrbcquO3cIn1zCVHORPi/7LhKh4rPRsNibGgTUxp2BS9k3vAZZpBgIOhl3Zm2xrbGY8MmBa3OiizZFolOLzWRC52XQBlhY+HFpA6Pg+lwakzDZT8PGO0gdBqu4zMjlJoSMcZIZzeFEYT1NbcUl/mXR/3fv+lPHPpL3t1BPnjtMCnlQQznVZP5CkmfhHDhlRo+h35ikSS4CLtp54VoqMcaTa+T5mNfS9xUqI6BTTlRmkc+zZWYV6DPPFnlTmUnazOAR6cjh30rqmHwlj1XDhATatvjzcV9OZ1nXbPDTLIOLQpHCR8XC/F6c9r2dKUb1eROKI1svD7k2KGDRdB4AS0BFE0bSApZC3kHSrE7Ny4KQDOTRDYz1syCJzRzIdc5toZWpE3E3N/Pl/MYUnRLHKcxoANzNZIUAgQRoDlSI4GmCom0CtWxvMHNvcWFUEByLxNLVd9+BknFGMNUomQ2majcpxgi4BMAAQhK1wJe5dCyrIIPh86ERsLgKIxMLBAVrJqxvEhxdU+5w8mmHCJytn6A3jxDiCkRGJLulGysltmS+vQH0cmce5swcO/vI8ukhFD62V7HuCTmAeMHzWTZ9WLrD6F2KSQOQ6Ez/jQ9Ymv2dh32P/LQEApLss=","authorEmailMD5":"37511e0a682d90aae2b084830473e006","authorUri":"","authorUserId":"disqus:disqus_fPnmDglC7i","authorFallbackAvatar":"","message":"Thanks for the great article. I still have a question.  \r\nImagine we have another async method in between UI or web api controller and the async IO operations. Who executes that code?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2017-07-19T23:47:31Z","timestamp":1500508051},{"_id":"10f80821-adca-3491-a000-35c74f2d5c16","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The code resumes on whatever context was captured at the point of the await. The built-in \"context\"s are generally the UI thread or a thread pool thread.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"73e28f7f-d003-39fd-a079-b211570134e4","date":"2017-07-20T00:04:23Z","timestamp":1500509063},{"_id":"c51892db-596d-3cce-80c0-a11285a19ffc","authorName":"yue shi","authorEmailEncrypted":"qHR/w/ifsBOqEa6WVvDeEZeGAfcq/sixktz8iCVrylUAwZ6T4+i9HARFn0V2EhyMTA31VM2cgHBaSxH6egzKJnxzc1W43cxa54/fua/+Dfiiw8vz1XkCYPbjT3rwcjfS2424oveq0nU2FAS2NGd00kcn1YSkmz5nJAuf5heYny2ZOOnNqV76bOBZJspz0qO1yZbrLSkNPPH2svNJdDm6t6/ezTcGqFBat5OY413jy9Tvz8xrgyCmCkHNjMrh5kkW0Ft7ANK/Pgg1uYSXzf6y6KMkrGcmGn+lD0gF/VtLGXQiegPb/+M+R1hJWPp1grCyTiP/coPK9lrTHEWm0tNrq4/q8oGKiINlSoxtL2rkipTGMrT5MMuI1giWsGT4cZo3LlaYZSqTzuzgkzkcP+2ajVzWDCTGlNo0K3kaENJ8YGrj1AI0ToBSbtUVlohkxFIL/19Hp+KQ38a2UeQJ1XqQz7V3V5MAR4Lvh+pCLDJytLxnS95XJZ2ZTzB2gqLCULF2nIFx1+95Oq0GWdLJ4tN6yHem2y6cuvkmb0YVqovqRlTWZtfmQ3I5xoT6zlfiJigQlO/Rbg9G0ugDQ9W9270jDp8V599wVMlRk+mV5KOZJBjtD3Ey3MzRYPEF1APjEcUmPNTPCW2SPgNQTPqu2GKdO5qj/gUxnLY5981HK41rApo=","authorEmailMD5":"37511e0a682d90aae2b084830473e006","authorUri":"","authorUserId":"disqus:disqus_fPnmDglC7i","authorFallbackAvatar":"","message":"I got it. Statements like \"await returns control to caller\" from other web sites are over simplified. There is state machine generated when compiler sees \"await\". Thanks.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"10f80821-adca-3491-a000-35c74f2d5c16","date":"2017-07-20T22:37:58Z","timestamp":1500590278},{"_id":"02580edd-4ee3-3531-8954-eb31ac1c00a6","authorName":"Yogesh Dhongade","authorEmailEncrypted":"wUUzQbZJ41ADmOPYLW/g3Ygzhfp/asUn0VjJ8+NreUQYEDL5lxwkMdnoqwH3Ds0mFuTdB/EkI8ffhePMgEWkE/zUYmlKZNFGuI6JydOKtYhjfkQiPHkT0C1+9zF7T5d1/Djs3cmmVBRlcim2I5dLFpMZaDGZZ7LkRFisxLxgIeHhFO3CWPfbFURfF9wrlJaglRl3uh2BuMaYPbA02JxCbFbAUw58ELb4mA426iR77bt7TrYo23VP8m3b13d7cbNJFoHMgz1of1AzcUm49lCcyUfK7N3s/CrtL+2fNpuCSVvQR6Q3GYjm8gZkNKHGfXfMefwJUIYJ+xcuPUdzzjpYNgiqpR2RyQTE4yz2o8Uv7Y8vzZKL1bXRpMvfqMhapYmx6HS0STmbu7DKatLIr/yynJwmSO9YE5Q91v3ckJIhCUWWFT4UYaZH7R79eJYTS1dzaI9FnyhGnBZiExG/dS43CagQnZ52bJVIWVRaBVAB71wapqLAJCLPvqdgYD+Bx6kbzWCeEwA7QomS940uNZgN8apOkBoQZR4CYIpSdCiqhd9ARHfqnntqWs3sbcvS8dcZYqwQnsaygGVfmrb40a5wYAoChKSC7JalLdYZ4JYtoWL7h4D375EMMTKvyd+fEtnDHPnlc5msUCRhj4vwNGHSq9CfgoZKJGH9SqzixejMPW4=","authorEmailMD5":"a508eb724aeca6e480e74289ea6bcb9c","authorUri":"","authorUserId":"disqus:yogesh_dhongade","authorFallbackAvatar":"","message":"Very nice article and liked the caption and the explanation. Can we extend the functionality of async with pipes and sockets ?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2017-07-28T11:46:04Z","timestamp":1501242364},{"_id":"3bd830a1-cde0-33a4-bedb-b7779faf728d","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I'm not sure what you mean by \"extend the functionality\". Async can be used to read/write pipes and sockets, sure, and you can create higher-level asynchronous calls that include messages and responses (e.g., HttpClient or SignalR).","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"02580edd-4ee3-3531-8954-eb31ac1c00a6","date":"2017-07-28T11:54:54Z","timestamp":1501242894},{"_id":"69f33e10-dcd3-3206-b2c9-29576e5ef9ca","authorName":"Yogesh Dhongade","authorEmailEncrypted":"n1JXgQRoCdmyfP59N9aWtuHvcNEl+UZ3uTm9jhSXsyG0PzkHe3PPb4tkjndqUBcTxA3/3vaobbwnrUaTpTncLp4z5BhN77ROJzg5gDECyrDNgTG7prVL/Ct3txIIv/ew+CDAjjRPv4bBviYHlN1X79/jlIhSKOAAlW85I8VqxzBG32Oy7KO0sQhWfpBNNdHa0LhV26fragbX7qE+mSVwANqGYZcaitrKrE9WAnLz7AERCDpCaMdWJMpjOtWZyLpQGhi2TM820AoboTcqA6yVjwhbGZkUJ4AWLYL/8qAkG0MIWdkOE/MJjmw2WNxwtNdf2Uiillamp7sAtn0WtvHohZKl6CguQOl3zvbmWNs144NoAEqi5E91tfdgapp+9kZUSsI1fOAB54aC0Y7fN55//oklwzA8P0PzCHWsMiQ+Fhox3L8NieZnwRdblZy75XEj+mLggj91nSQZFr8tOYE2w0MNWHq5OYBN2FKSv/jGPyrDVY9zm2NJQjEgI1IDExmV98S1i1GQshnuKFB44pf7uTIPNN3xxlRWg4Yof/TI0UptJok8bd3XEi1LuYoqk3KxdDYoFmyFeU8XWqE+1280zZQ2ZJKvqIjlYpPsY0zoSmUY/GqhDQukqdzEHOkCLq4HH4ZaA4z5Oqbv1VRzJeHgjth1TWRiax/HyKzyBJ8gt+k=","authorEmailMD5":"a508eb724aeca6e480e74289ea6bcb9c","authorUri":"","authorUserId":"disqus:yogesh_dhongade","authorFallbackAvatar":"","message":"Thanks for immediate response. Extend the functionality means there are some implementations which claims that some .NET asynchronous calls are using IOCP internally. So I was not sure about the same and trying to use IOCP & OVERLAPPED IO in .NET for best performance. I stumbled on this article in same context where I think it gave me quite good idea.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"3bd830a1-cde0-33a4-bedb-b7779faf728d","date":"2017-07-28T12:00:28Z","timestamp":1501243228},{"_id":"3293c452-a66f-34ff-aa17-c9f3fa2f98a0","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Sure, you can build Task-returning methods around OVERLAPPED APIs - I've done it. It's not exactly straightforward but it's doable. I've been planning a blog post series on the subject for a while, but it's a big undertaking and I just haven't gotten started yet.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"69f33e10-dcd3-3206-b2c9-29576e5ef9ca","date":"2017-07-29T01:09:27Z","timestamp":1501290567},{"_id":"7dcb012b-eeea-3c6d-91b8-a985bd767cb9","authorName":"Machine Learning","authorEmailEncrypted":"dlDq73CSbbzx/qvybSal1MNu9lvuxnNqMa50BtyaHmlFQW0TUlhTnfz4rb3bLsyocLU5IMgXor0DCWg0JgFjNd4sT3cW3mHmvwbgm0XF8jRq+2mJ9e3xUPqhoCZRN8xiGRiRU49oHCt7pWWhfIsmpnuJ9IqBBpu/b+49rR58ceRpFpmVLDdF+l/MyiVeZaNNWY+CpvcR2pb2OiXxJH3EIbT7qLEGM4OzVImAXc2xTFEwUf8pmJCWFccyDCsCJ1SHfDB4uTWpcxdStb5SQOM04rk199mxtxDe1DJDR4QIyPS8rObrVA9ln4m6onOHdl/AsS8agOTWmlthD5zM0S3X6HUKy9sg9bGTOkVIOITtgEPdflasHavuh1UriAKrzWvhYqImq0ZFaQq2SkA76wqNR5bkD7hYL4aJPWXcWWNIMjAuTs4QsR9H8LaLgB56xza0/y1BpQLqXqZRd87OuW/2OoUVQU5/yoq0l/izSVGUzvxJNzp0xGMHoAp1y8b6JUb3hWRaCFKYd8S/17w9kVhdkYXi4qqq08qgIhQYcF7ViaeGxslD+wRfPSh0QwCUcN00JoLR+Vkyjhe9uQ7ZzvDbFOUIBn71Nr/wjWhnkvlBTT/1a2j4SrYWeNE0Gzo1t4Iy98Q6XQsC/7Wn7O11eoXx5fgL3g61gHP0WXfRK9sh10A=","authorEmailMD5":"003df623d728f783fdca0e70ce803069","authorUri":"","authorUserId":"disqus:machine_learning","authorFallbackAvatar":"","message":"What's the equivalent of this mechanism under Unix (Linux, Mac) with Core CLR?  \r\nWhat happens to Win32 classes like the overlapped I/O and how do an \"I/O request packet\" translate into Unix?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2017-08-22T05:39:44Z","timestamp":1503380384},{"_id":"83c0b411-2e81-3bd9-aa3c-20f31db9b426","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I'm not as familiar with the Linux kernel, but AFAIK on Linux, it's up to the device driver whether to support asynchronous I/O.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"7dcb012b-eeea-3c6d-91b8-a985bd767cb9","date":"2017-08-22T11:34:32Z","timestamp":1503401672},{"_id":"bcf69c86-e2fa-3b89-99dd-b124049f870d","authorName":"Machine Learning","authorEmailEncrypted":"hWjIA2DsqwXv/J3il24ag02mYOq9AzHJcyrTHCx+74Jeuxy9EqfKOSqGdDR2PNmg4/BdHN/FsP4bdZA4lRJevet2mVaGpYUSNc6i9hhqAMDEwxjeE0K766J6kAIS5L54q4UMM09IO5tQzdxnnHt81kWosqgLJd/dpUAAPgfe7FAskcj8tJt+sroEe87TI268IPUyLNgq6+kn8i+IWdAegh8GcTPc67UYFDQkQ0a4TRS3d3ZoEAynqKBP5E8oX6LkIDjpDjlDPIKfsUY3bKEZ0ZgoFm00SbY6ScZ086WpyFcdmAUwQBE9zHC1vycwmSeD0kB6bC0WShMFZm/TRjRWQAxRctQoYeWcOIF4IO0hUWlWTT8jXD89Xt4fmHXFObdp11UYmI7drFGDAYaYv9Vr0r0wcQmWgtJLhfaEqdxaaQIl2BCweWfU5j/QS/6xINE82yRDUd49frqSgqMIKYpFL4aSpKbhj41vA7x6dqNKje8p3lb+iJRPYsJ7AgUTrXNzjknJ2i3DcQLfXY/jyi/oVVixJ+/gwnKBuL5LrVVsztaTkmNg51927/4dQ5VxmQjdX4u2NGYCdMfsQ5Y5/8UWxOOgo24sx74tvFP3aiwd+0gKNR45kevUCvDtzPtw6QYrmLYHcUYfnaTV/OFpzXa+08Q0VSHFKcE9fs/D0UvloN0=","authorEmailMD5":"003df623d728f783fdca0e70ce803069","authorUri":"","authorUserId":"disqus:machine_learning","authorFallbackAvatar":"","message":"Thank you,   \r\nof course the device driver has to support asynchronous I/O, but what about the Net Core implementation of the async call (I assume it is the BCL library in your image above)  \r\nDo you agree that the .Net OS specific part is likely implemented in the sync manager of PAL in CoreCLR (or similar) as per this answer? [https://stackoverflow.com/a/45808571/6996876](https://stackoverflow.com/a/45808571/6996876) Thanks again for your help!","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"83c0b411-2e81-3bd9-aa3c-20f31db9b426","date":"2017-08-22T11:37:22Z","timestamp":1503401842},{"_id":"281fadd1-662c-35ed-9354-8a4279e863e1","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I really have no idea.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"bcf69c86-e2fa-3b89-99dd-b124049f870d","date":"2017-08-25T21:09:26Z","timestamp":1503695366},{"_id":"66589d6e-3555-37d0-8097-af3823ded819","authorName":"Machine Learning","authorEmailEncrypted":"sMcSp3D18zeDgqIXvHb2BxR71ur9GriakYF+mSk63Jf8IBSaHl83ONfRzJXMlTCzKmSMhlD2JdoLrN6ed5Tgod2/k3kWAHvC5ix1/7KNKIg1U0khRkRzfNQQCzhGacGBuf+imTlFeZ/L8+OZ0ScRlKrbOmM3rQHsUhHrOYQvQq9J26W/RTni7NEyV7zbdHHs3pMtQXw0DLyQCDkzQ8Um3hMV3qP3dA9DOuEB4ur5Y3io8xF3QOc76ckd6i2Le4+pR/VrXdeyrMtfSHag0l1Ofpq3/udvNtKF6m5iUzbtPuXE9JFXfJ3xJbnIdQw1HsbPJBKfp24SlGPpBfnPiYgYSMrdMmln+B5R9jyn3uok3g1B8WsR1uI7vBL42ao8Y/hReEg+yPRjWyrD0mYTsV+0I37iy3kF3nZuH3zkcxGKju5Z00++Gyq1WXvF12irGYqvF6tk8FCmkAYbrsDdgf/5fDRO4yD2gy2OPoZuIyNrL7svZTIuPPQ4Et+56C4cOa244F4gEyR31AI3sRP0EUoDtwfC81sbIBZtksm/u+ZOT2FoMa5oQZ38Limwp+xV6Di4lNaFn6e97VpRwt2XMq2JFahVD08Xo5kfqoE5M+VJs6vbQKY8TAND664udfJVg071Bt0S2EmbWHOO9OSFbufRRyawHeZ3s6TqElRGcPJOnWU=","authorEmailMD5":"003df623d728f783fdca0e70ce803069","authorUri":"","authorUserId":"disqus:machine_learning","authorFallbackAvatar":"","message":"Ok, let's forget Unix for a moment and let me ask a higher level question: on Windows, the fact that \"there is no thread\" is not an implementation detail, is it? You assume that the correct usage scenario of async is not a cpu bound but an io bound activity and that, in such a correct usage scenario, together with other truly async driver/kernel/etc... io functions, this dotnet \"async/await\" language feature - as opposite to a Task.Run - results in - 1 thread, correct?\r\n\r\nP.S. In other words, maybe more explicitly, do you agree with what DavidFowl writes about async/await in this comment: \"The basic motivation for Async I/O is to boost performance That doesn't have anything to do with async/await though. AKA it is NOT the basis, nor is it required for async/await to function. Async/await is just C#'s represenation of co-routines.\" [https://stackoverflow.com/questions/45808446/p-invoke-and-overlapped-i-o-in-core-clr-on-unix#comment78756598_45808446](https://stackoverflow.com/questions/45808446/p-invoke-and-overlapped-i-o-in-core-clr-on-unix#comment78756598_45808446)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"281fadd1-662c-35ed-9354-8a4279e863e1","date":"2017-08-26T09:03:43Z","timestamp":1503738223},{"_id":"ff3b0684-14df-301b-8d37-462f44674dc0","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"He's speaking from a language perspective. At the language level, async/await has nothing to do with OVERLAPPED or anything like that. It's just a code transformation. So, sure, you can use async/await to consume a lot of things: asynchronous I/O, CPU-bound thread pool work (Task.Run), timers (Task.Delay), combinations (Task.WhenAll), button clicks ([https://blogs.msdn.microsoft.com/lucian/2012/11/28/how-to-await-a-button-click/](https://blogs.msdn.microsoft.com/lucian/2012/11/28/how-to-await-a-button-click/)), ...\r\n\r\nSimilarly, you can achieve the \"there is no thread\" scenario with any kind of fully-asynchronous I/O. Whether it's async/await or OVERLAPPED or IAsyncResult or event-based asynchrony doesn't matter. I've written a fully asynchronous I/O model in C on an embedded system without an OS.\r\n\r\nIt's the combination of async/await with the truly-asynchronous I/O implementations that make the modern paradign so powerfully performant. All the other asynchronous code patterns are much more difficult to maintain than async/await.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"66589d6e-3555-37d0-8097-af3823ded819","date":"2017-08-28T14:16:50Z","timestamp":1503929810},{"_id":"02dcf8c5-c964-358c-9213-0d54e927c1fa","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I describe await semantics here: [https://blog.stephencleary.com/2012/02/async-and-await.html](https://blog.stephencleary.com/2012/02/async-and-await.html)\r\n\r\nYou are correct in that Console and Win32 service apps (by default) will resume on the thread pool. There is no SynchronizationContext in this case.\r\n\r\nRegarding deadlocks, the common sync-over-async deadlock will not occur ( [http://blog.stephencleary.com/2012/07/dont-block-on-async-code.html](http://blog.stephencleary.com/2012/07/dont-block-on-async-code.html) ), but there are other deadlocks that can happen: [https://blog.stephencleary.com/2012/12/dont-block-in-asynchronous-code.html](https://blog.stephencleary.com/2012/12/dont-block-in-asynchronous-code.html)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"c92fa5e8-d3be-3f04-93fc-1587b8dafb20","date":"2017-10-04T15:51:00Z","timestamp":1507132260},{"_id":"51bf0412-2e1c-3676-a17b-1a28b04adf70","authorName":"Dave Parsons","authorEmailEncrypted":"Nl1qlwc6HEKWGKJBWybsRgxyRG072RtXsYGXI677Nzwn3jKZOod58H047+TKYS3bSODQVzv7/ilmWa9E7mZRKWO+pXoYDYGfxVElS0cz+vOSzOZPq1AEeR/QIjfBoGwuY9Nt+mM4M3KjPbYCD5/gRIQZzhFRp4XZvna1eU+sCK2loFGpb1LoVtwRaxAwV2a9p8G48HjPaFmHEuQPSW6UZo/PCdg3ay1kXpHQVlyQTDb8A/ec9PNkgWtmxqxcaQSOj/ZxzdM7X56L0QeNLn44V03r68fPwvelJ9MleWZHOvOYp3nOkpAJdCz/f9Maz24vHf/cS6K5aT4wch+hkFc4uPdws5N3qVe7A3kGZAftX3NiJOX5cjCOIidLDPbxQKwt7agUQcyWFF6xVq45WOXEOUEaT+6oZe8CT2uVl4vdnLNfDhAxQe0iRWAV6ZqHQygwg8jEAgwnLvmSFcgWz7IdnLl2EUFMG6mcoaLLsvaamEDhd7aY6tCcHLnKUwSYEDzMKIfTJLvlea2hcbwdNksgRgBBD7UUGDIxDTP/Dph27YXlj94UM4b+TYs9vmRMMa1NMoRc6XvxYuAj/5xINsJm9/EIY+3052NeLYcG+YY0cdaBts33i+ccLXid2nW94vL+Xt79AKz5mRP9sjr0ckGrfUjMnOLDaZ0lMOJfY33rcgQ=","authorEmailMD5":"82df17885fa751600eac9fa114cae9e8","authorUri":"","authorUserId":"disqus:disqus_SjnQZZNqZA","authorFallbackAvatar":"","message":"Dear Mr. Cleary,  \r\nwhen I rears your series of articles or your book,, I am reading the words of a both a consummate professional and a man of God. As a fellow Christian, I say thank you sir.. .Please keep on fighting the good fight of faith while continuing to contribute to the rewarding world of .NET Development. And by the way, unless I am misunderstanding a slight movement in technical documentation, there seems to be a slight trend towards message passing architectures and even the use of the Message Passing Interface as a standard in a managed code. .","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"74e51b75-7b88-3391-a65d-025f569f62e6","date":"2017-11-07T02:22:32Z","timestamp":1510021352},{"_id":"6d18f128-2d15-3264-bc46-948e435c1340","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Thanks for the kind words!\r\n\r\nMessage passing architectures are definitely becoming more common, I assume as a natural outgrowth of cloud computing. I haven't seen MPI in managed code (or really at all for many years); that would be an interesting combination.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"51bf0412-2e1c-3676-a17b-1a28b04adf70","date":"2017-11-07T21:14:26Z","timestamp":1510089266},{"_id":"8736a9c1-67d4-3c05-9f05-103caf95f5fa","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I believe ASP.NET's design (in particular, ASP.NET Core's implementation) is better suited to scalable web apps. One major benefit that Node has is that it *forces* developers to use asynchrony (it has to, since it only has one thread). ASP.NET only *allows* developers to use asynchrony, and a lot of devs just don't take advantage of it (or can't, if some third-party library doesn't support asynchrony).\r\n\r\nIn the Node world, if you have a multicore CPU, one common option is to run multiple node webserver instances, and tie them together with a load balancer like nginx (all on the same box). While this works, I think it's more complex to get right than the out-of-the-box parallelism (with asynchrony) that ASP.NET provides.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"dd8249c7-5dd0-3542-a3bb-30c26e02ab14","date":"2017-12-26T18:20:41Z","timestamp":1514312441},{"_id":"dd8249c7-5dd0-3542-a3bb-30c26e02ab14","authorName":"Zubin Rakesh Joshi","authorEmailEncrypted":"Uzbkv9epbvg0Kjun7KJnI5aUSBXVnaFvAgsDY7JcPvZLYk6kO63Uwj1fWGZlNlkczyMxS9eqlo5aLAnJa+H88+NhZg7L+2KhY/A6SghXNY0rru8R6QAc0Z4+d4CI+xbdsOP6s44OVTn0L6vCf5O8Mfx7vdh+AjHnNukvQEVuhP4g7LXnOVae7K9C1FKf1FA8QgCg+lLLbGvUpJWIxRYzouc0MX0xdS55b+d6k88zgkLoAGuLVVEwhCArl26LTsJG5yqOSOUx9ZxsgYwBw1POXMqOFB3Mpfg94Z6pSsStAYCIhjY9UzWflf5jt4neMWlK3WIbtkZoHxIh86IhVpM2DcGF806nPqH57fA5wgH2dAccFBBru01wAcLpLhiaCYY2W6t8qrsUTP1BRbesF9GnTH3QMODpayR/05BX+HL1QSXIa89Y9MaA0jfeeTRffAa071LTTgQR1/nZdTm3DS9oURZFfkKunk/DiYRCbgKjdPXG/islg4NdybYAPB0L95tPRuE6TI6Acr9IwX3JvI6K7N2luhZeXaMa6grYMV3ecmC2oQS0h+HSi68KtDvvjSvtfidNrKZzKX4XRaysMfkgHUUUZMm+OLHRbYb6OC0rn7no+9OM/Z5F86jz++j8qI/kTjjSTvhHlmCwtIw5ZBWp+Q5BRfoVt0NYY7JGrHnr2OE=","authorEmailMD5":"f9305ce7b205cf5211f1b6a4aaf34c9c","authorUri":"","authorUserId":"disqus:zubinrakeshjoshi","authorFallbackAvatar":"https://disqus.com/api/users/avatars/zubinrakeshjoshi.jpg","message":"Great article. Have been searching for the concept.. thank you !!   \r\none question - I find article of having node js getting much benefit writing IO bound tasks with one thread and non blocking IO. I believe [asp.net](http://asp.net) with async/await features uses the asnc programming with multi threads is more beneficial . since it uses multiple thread it might be using multi core easily.. pls correct me !!","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2017-12-26T17:13:37Z","timestamp":1514308417},{"_id":"5645380b-1849-3ce7-8b78-22d3788932ba","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"As far as thread usage goes, both Begin/End and Async are asynchronous. The major disadvantage of Begin/End is that it makes your code much less maintainable.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"57f6a077-4ce0-3b46-ac53-4a9f96499297","date":"2017-12-28T12:54:21Z","timestamp":1514465661},{"_id":"57f6a077-4ce0-3b46-ac53-4a9f96499297","authorName":"Pradeep","authorEmailEncrypted":"ltvDGLzLl48j8WMlJtCm0FShKTqZhfQhKvs45JnstLb8teiOEl0qZgU+L13HUhlqb5lq2vi64bZxL/8cS1es2AmG6J1femHWd7H733CFHkWDOg1wLYUo7pB7FZlLx6PcaiV0vi4Q5T/QIIISi6jm4aS+plHBFdUp9dHZ14Utl/Pab1KmWNSjBD7EyRwnVw4du/cfi32r5t2DiH9ECNvNoaXVqHi/WTib74eFX5Gpt/nUqz6+D/QtF3YTeEXLPX5Dn6buGEZS6FmS74AjX5DEQCvbY8nFYQwFF41DizTu1llWUinVmiq8L+sV++Pf80B/cR+P0ifKv/NMVCJARslpn6td/oHlwcB87OvrA2LzeeCMIqRN24vtwMXnlIm/DUG/9c7XUkACYdrHHWkjpFj10Bj/YaJfRg2P93ebn8osns+t+c4ZSC9tfQt7CiGFuha2o/zQVkQY6kzdu7+gVzzzt7eLWLaJjKFg1eugqbwQ0hKeXBrCwGBYmT5o2v6tHTXM0wDH6zSYmXW08xs0EmOrF8T9jv6v0jitUKse9zS+n92xeQJDX9EyHkW8CEx6lBYiMKriPwD8Gd8N85mPmuO4Kg5G6FFgyqt8tDpZvfDtvX5BT8zC0m1gI7IGcalIZyZ2Wth0yyO+HJZoZommTnS8i4vAYSCm8zG3UkPqIL36qys=","authorEmailMD5":"c9fff93b0975f41010ae13dcb1a948f3","authorUri":"","authorUserId":"disqus:disqus_j9TS7gArn0","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_j9TS7gArn0.jpg","message":"That made sense. Imagining it that way, it seems not using IOCP or async operations is rather a brutal waste of the I/O thread(s) which are already allocated to an AppDomain.\r\n\r\nOne small doubt. I understand all this discussion applies to XyzAsync() calls. Is the same also true for the BeginXyz() calls? I mean, I'm still with VS2008 (.Net 3.5), so does using the BeginXyz() methods also provide the exact same benefits as using the later XyzAsync() counterparts? If there are any specific drawbacks to the old methods, I'd love to read about those if you can point me to a link. Many thanks.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"5e64b4f3-00f2-31ec-ac78-14adcc352b51","date":"2017-12-28T11:51:35Z","timestamp":1514461895},{"_id":"07c0d627-54b2-30f6-a7b3-3c1794aeda61","authorName":"pwee167","authorEmailEncrypted":"TS62CPynP0YnQGnCwYU9RmDg6WJXkQS1wnnV3/bhTB6lUn4cfDia3at11Z8Q523PeBtzPpN8yWZLTS3hiFh+HocSxGMIgD0/lgPxr/5iX5lItNb0bjIYoAB/ZLQ4JPdz9j27i1KQn73PZEo83LnkUcbOzDl+7v1fEq+ZhGD3uAxOAjtpYKdXIW5NAnOpgDpHQfawQRb/hUOqvJ9H0Is/JgFQwOPgrJ6u3NLvmLhVmSNTK5Rzo1B7utKP4/aw4+Kn9idwAlvBCkM6GzwGBahlhA9MZ4UNB8Jt17LP/w/R7eAwAXKngUh1rON6ldRk5rGq8rb4DS2faT586lgIgsY4DqtyaShVKrm22JFhzFFDJGDGJJYOlj4ICjA7NpBFSDOtn1MYVSd+kl66wtE0CNhbNPqZpKQp9PtPa425yj8V2fqEZwxbrUmVmx5TCoitD7Pi50qZ42qo7XIO9N1G0yJEsU75NL3FcrL8uRmQvkPqi+YQETLFB0A2piAMVVVkSnbJTpK7TrGA8D8Zg1Qw0DUzRek8Pp6jugu48YXqb8yNfcYtWb3A7fkyC/hI8jrqUlZksCWRShxJTe7RohR2nrDVgP4fYiDH7x9xqvpVsZaVZO3abSkeLcWDNgo00m3EDrqUfYpN89hIQrYc5ZPyc1riHPR/kCuCLMdYg6LmvOX6DbM=","authorEmailMD5":"1d071a2559b38acd23991885bfecda38","authorUri":"","authorUserId":"disqus:pwee167","authorFallbackAvatar":"https://disqus.com/api/users/avatars/pwee167.jpg","message":"@StephenCleary Where is the state of the state machine in an async method stored before it is resumed? I imagine this is important to know where to continue the execution and also to capture any previous variables.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2018-01-25T23:44:15Z","timestamp":1516923855},{"_id":"aa0a4b72-d3d8-3c9e-b468-9f3e8b599920","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The compiler creates a struct that holds the state and local variables. If an await needs to yield (i.e., return to its caller), that struct is boxed and lives on the heap.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"07c0d627-54b2-30f6-a7b3-3c1794aeda61","date":"2018-01-26T15:30:44Z","timestamp":1516980644},{"_id":"9432b305-cdc0-3ee7-8f70-95419d5b9476","authorName":"pwee167","authorEmailEncrypted":"h4Ps8nU1cG9V4pcNGK+dNQG5Wwxkv/LtOUkcM/rA5Ue03OKamOaGI1rb2x/1H+T9sqAMVG4h1KgoT6vac4ezngpeWJTGqYcIA65xWjK2uCC7p3zdbniHpZeX3w5TJlJOEUtRruxlDkuNDrM74zUUStsAYcMVLfN4Th0/cU7FYaBnKhdssrKjZ5Fiy9d7ykalniDxQE3U7G1nqcacu5j84KBLLs2H0cJn9LNfnTd4x3l7fL3V38cFeZ6cHSeyBHqEqHS8M/uYJgrE8ZsoPGD73ibO8VggBhXDegSkgOD5mabTz7mi7x+j7vgc1n9gYSJwAH4z058FBIuA+jxizNEs2McqKUAlc5G0NULJvjQxR9ntjX/tk50CapLpMmopkpwZYFLZvCPiFfxCUDQDPLR5kM0jPwPr3EnIaDbfb3CcnL5E3rT9wwOyuIcitdW6kVR4sFXeCsDiEaw3JKTgtbYrixCMStkK4XmVCA2sxJpNo9EHbKg/Vc4mXFXgfa8hzGaUwAzDcb0lKDdw2mvmTPhVlKOva0lR5DAYrFic13J/XXZGTrOTwU2SuPnIYHPDHhxkXsqBED4M/QNk6UeqF0PiL1FyPcB/nSYU7GaPL6W8yKzD/BYZnAzBlo+69TDqF6sAZToqj02FUyySs3kW46Kw2jEp4+RgwgLKq+B9nO5DnAg=","authorEmailMD5":"1d071a2559b38acd23991885bfecda38","authorUri":"","authorUserId":"disqus:pwee167","authorFallbackAvatar":"https://disqus.com/api/users/avatars/pwee167.jpg","message":"@stephen_cleary:disqus - Awesome. This raises more questions for me...hehe\r\n\r\nOnce the work is done by the device (e.g. harddisk), my (novice) understanding is there is a task or some sort of request queued up against the threadpool. A threadpool thread then picks this up to continue execution of the next part of the original function (i.e. past the await).\r\n\r\nHow does this threadpool thread attain the reference to the struct you mention to resume the state machine and continue execution? Is the call back information/struct address passed all the way to the device driver and it keeps this information for later when queueing up for the continuation?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"aa0a4b72-d3d8-3c9e-b468-9f3e8b599920","date":"2018-01-27T12:18:32Z","timestamp":1517055512},{"_id":"889e71e5-f786-3c7b-8328-390733e5e63f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"If you want to dive that deep, then think of it in terms of callbacks. The task callback (a.k.a. continuation) contains a reference to the state machine struct.\r\n\r\nAt each level, only the state at that level is referenced. The IRP contains the callbacks in the driver stack, OVERLAPPED contains the callback in the (unmanaged) user-mode process (processed via I/O Completion Ports), and Task contains the callback(s) in managed code. Only this last callback references the state machine struct; the others reference their own similar structures.\r\n\r\nSo, when an asynchronous I/O operation is in flight, there's no call stack in memory. Instead, there's a series of callbacks that all refer to each other, from the lowest level device driver up to your own managed code.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"9432b305-cdc0-3ee7-8f70-95419d5b9476","date":"2018-01-28T02:46:37Z","timestamp":1517107597},{"_id":"50443b21-769f-3b9e-99f3-b4cbfd9d449a","authorName":"Flow Bandit","authorEmailEncrypted":"ZurvT/mBW1bVoyNH3moZGghdM8FJCS7ToNE6ddkixH/Grasp7NAIte+3sdFdTf6jjSTpMqtm/ZZDh7Yt0jpF5anBzoQycg89Z7mF1k9EOfBu0oYD4BFNTr1KeU3ElOpib+IQU5cYKZcw/m7a+VN+WZj3hewjuQXaS9LgL+E8Gby03V48CdKUvd5Kj5Wot6edK84k+ZiOc7YxGaiBmspzqp7rtOiMYnQaKl6pTvCp3w1yvEWxqROD5/HfcAhKvSi7Qs5RBKSNZIVVf4jRIE9rOOV02R8awzND5JSdIE0mGCZhcXU9uNryVPdWdtwmTIqMVNc/ZNxz7V9xRSSFj93AHtziVhL6Vplh995a09CKSbco24c82mZ6RyyqyB+NHOCt3KRiFJusT2Z1wTa/peFcbzkNzfTeRp7kQI2X7d6q5zg7I5dSObnTE34Wk55AQ51At7QnaI1ekmTlKch1PGXDKIHklAzB6SQfZGpudUukyx07mM/PAdrrdJYVji79s3KhLMAFBDhsJWOizLjQz5U4okalVcSTE4HHb7q+7vC+FJinGVGGGuVGA6vVxG0uDmwMBclOQc5edS8d+CHTTJqpC3cubFjGTW73U4mIfDcqzk/GYXNgEi+CAPmXXgGijXECYRIqORVK8Z5RJnJMt7TeqLkMZTYydrSmPcCtSbHWrgQ=","authorEmailMD5":"ab366570c646860ad1011a4c0868c000","authorUri":"","authorUserId":"disqus:flowbandit","authorFallbackAvatar":"","message":"Thanks, This answered so many questuons I’ve had.\r\n\r\nOne of the only qyestuon I have left is.\r\n\r\nWhat would be quicker on a single core environment, asumming the burden of the task was network bound:\r\n\r\nRunning synchronous for a network bound operation, the thread should be blocked, but the cpu doesn’t not wait during the sleep it periodically checks of it has return correct?\r\n\r\nOr running async and having a hardware interupt signal back","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2018-01-30T23:58:11Z","timestamp":1517356691},{"_id":"4924d195-1e4f-3693-8924-a5ea735dbbef","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"As a general rule, blocking code is faster, but asynchronous code is more scalable. This is true regardless of the number of cores.\r\n\r\nWhen synchronously blocking, the thread is in a suspended state and not scheduled onto a CPU. Once the hardware interrupts, it completes the (asynchronous) I/O, which then moves the thread to a ready state, so it will then be scheduled.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"50443b21-769f-3b9e-99f3-b4cbfd9d449a","date":"2018-01-31T00:34:59Z","timestamp":1517358899},{"_id":"38b7b886-2a53-3900-bd7b-6a2588f633b6","authorName":"Grant Hoffman","authorEmailEncrypted":"sbrWum9TMzeiSz28aAHj0w8fWfdpU9GgR50Gjn3akstJ7QnwAkU9wv8KpO6ogqpjZ64tm0GNgVTWSuoW8WEm0TvXz8ddUncX8ho7c3viEzcN7W9qydkKJWdzWYxd7povbWNarpFNYT+8YAM+n3eJCpeiD1/Osc30tE4p92RgTx4U+MgB63/cI6wdCWfPx1tbLF0Ev0J/zm6t5gmq4qa4DgTMjtpT1SoXFm8qTgQ0AxOy1E3i25asCnSdzspNl2pOx8gaBdvxgsJSlg2oatjvG+gWbl3AeLv4ljaFR5JtT3cRWDyFx+6NLBX0s9ax47071LzF8Cm9zNz/uHjxWb0+sEUwjcanVpkRkHfU31sXZnvWE1xUV4JG7HONzYSIwMx8qjPkOvCjJw66YR/rTGkwGwCGhf12k6FFuWXB0Pldlj4F1fpzMx/qE4IMuKQ4yN/WtuVX3NyXBHekTRsT4U2ebA6snxExmLPU2Q3gMbiOcQTJgdxSIBYrN1eXVIiNKFO0rxFeqOG6Wpw/MW9iWXEou1S9cmEVNMTGbrpYqNef8Bva/DaFUjYTyM8t9lZI1TdQqIAT6P7h2xnlFM6LfBYCSVsXPOHyT1+tWrcM/DBfx6YGCcR0H4ALRnSPK4Rvu0SmHS18xKi5yfd1WOOekwvo1363yyggY3gk3QQ59Q6KF1M=","authorEmailMD5":"f55500eeac346a343ab1aebe3d734201","authorUri":"","authorUserId":"disqus:disqus_mKJKzNfDWl","authorFallbackAvatar":"","message":"Good job on the article, I'm just left with one question. I get that when operating ASYNC you do not block a thread, but don't you still need an additional thread for at least for a quantum. Say I'm operating on a thread which manages the UI. Then, I create an async task to do some background work. The thread then does a context switch to do the background work, What happens to the UI at this point, am I blocked until we do an I/O operation? Or is that task picked up by another thread in the thread pool?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2018-02-07T17:11:02Z","timestamp":1518023462},{"_id":"2f309c8f-c1b5-364a-862c-980332c3d6a7","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I think the disconnect is here: \"I create an async task to do some background work.\"\r\n\r\nTasks that do background work (e.g., Task.Run) are not asynchronous. The UI can consume them asynchronously (just like truly asynchronous tasks), but they represent synchronous work to be done on a thread pool thread.\r\n\r\nRegarding thread switching, there's nothing special going on. Threads and CPU scheduling are handled at the OS level by the preemptive scheduler just like always.\r\n\r\nThe key behind truly asynchronous methods is that there is no \"work\" to do. Thus, no need for a thread. If you, e.g., asynchronously read from a socket, then there is no thread that has to periodically say \"is there data yet?\" Instead, the task acts like an event callback; the networking layer will tell *your* app when there's data.\r\n\r\nSo there's actually no switch away from the UI thread at all; the UI starts reading from the socket and then awaits (returning to its event loop). When the data is read, the networking layer calls back into your app, (eventually) posting a message to your UI thread, which then resumes executing that async method as a result of that message.\r\n\r\n(the details are a bit more complex - there are some threadpool threads used for extremely brief periods during the \"notification\" phase - but this is the general gist)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"38b7b886-2a53-3900-bd7b-6a2588f633b6","date":"2018-02-08T18:47:40Z","timestamp":1518115660},{"_id":"f73cd44c-c2b6-3ad9-98f0-e160a38b127c","authorName":"NetMage","authorEmailEncrypted":"mrA5o9dju4/tjGYcgiy3iAgBe8H/XhVIYP9yhSiRy+dWBo+xFTwKglCl6qzaQosjMBCIQG0pRUebc7Bt3FdjbH86/prRCM3D4MwqpFQkX+Ii7Ro02RCuV3I2ZythrCGm+bwbX9mU1nGsCpNzQ08SdyqtFlOh6tYRT2Ay1Hc67vJbSg59f+xHStlXculUPaHLt5GX+J4xWSyf5t/jpXmQgvY1r3kfYVQhUGQJFn/n57It99vrDjoJdlrR6dWKqcvGWn7V1M79NxCdl1utkAFVB6a7mkwyoYsyyAi7zqagvhl7MD5s8LYk6l1HM0JYIlm4N+sjVZNAwSUE40/g2cNgdVYLeVmo0wC2VMtFY6EUVIapSmQHCnJzSo3x+l9e3UgbmzSQ6YQVX8lpY+MX/ytByUGyA/WvwnJGjAhVtVulCLg4NE2Ex3B0J1lve9FJeKvjRBph93G5Bif0rL+S+9wIddHxb5UMqGKI02FIt4pgY9ry9U76MlVwNQkydKtvbi1gh5f/650au3qxlfS8efzb2bCHmTubJHkjzMZxMF1Qrj0KhttOt0wbYUyTzypcOWcAfNDXi2KE5D001jwdW9PTkYVixG0/xvt9xTr9y7C0s/v0oVqD1kHf4gYqfxnxg5mpg6KmsUAevY5SQyMJTKlhYTXDVxBsgOszGKxlQOYLiQM=","authorEmailMD5":"f3cc7fed3c952511b85cfb1c822ecb75","authorUri":"","authorUserId":"disqus:NetMage","authorFallbackAvatar":"","message":"Now that kernel memory is no longer mapped into every process, I wonder how this changes?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"d059f9c3-04f8-3224-8b49-5289000e88ac","date":"2018-04-17T19:17:43Z","timestamp":1523992663},{"_id":"eb69372b-9186-3195-be40-68e194c091c6","authorName":"Agshin Nabiyev","authorEmailEncrypted":"CrWtQcitJ6iDBqVe0bdeNWipdAreGoWx7q3bLWD9ZUthNx7w2+8TPYIR/YIWhSX6JvODLm9kDLfpX3Er1jnnmM5aBHglwJ/8S7O8KcN7zM2h56Dz1EOU2+8BNK8wF8K1YJumJIjBzdf2Ky0HeA3cMtPs26HY/bl+DcZ0gMNYWMpx7oa6ebp8QCf3zzlF8GgY8jCt2yK1HaHsdPcwbDfR13k4JT4RD/O7EHBwjmKzqr7K8YnEYD0S66LnzFcF3Nd0NCXgyPyn5X6v9dEbEXAoPebUEzpu4nRTBs6rwSmWHVK58ahDvBaVv1geP2ZASbbE0w6OIsd6ocYjCYejhAyat/o6dFtPPhhPq0m2Om6hf0bZriXAiJsZsaQ+nyIImtxsbbQdVLr4HaXdcMBQBqiSYAaDWWqnfDsby2wj0tTVZx2qKEnwJZRkEHK9KzjiRHZTKLTc8iT8TKucpbq4SFzw80gqM04ISX0+Q2UNE9ebOku+tY4v+4k6yrzoNwhWG/isuda+5hljLPv/TaZADEpIcq9f4w0OiaLxP11cdvSKyA5XL/MwVv7i6Kqh9fiycoNWmu9nyirG+FfLwGJ3M8fWPL78IRsizwg1ip5uE+JSEc7S5wJ82selbeGdP/0NnjGkmz22PN1cjxIvfVWY/Z8EozeV/G6DBM2JF9jF1NCc2Yg=","authorEmailMD5":"92efde5d548b57c5f5ce697f25f88913","authorUri":"","authorUserId":"disqus:agshinnabiyev","authorFallbackAvatar":"https://disqus.com/api/users/avatars/agshinnabiyev.jpg","message":"Great article! I'v tried for month to find exact explanation.Here it is.Thank you!","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2018-04-30T13:21:47Z","timestamp":1525094507},{"_id":"178e2d80-9ad7-11e8-82d8-69ed00e8bcf5","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Amir","authorUri":"","message":"Hi Stephen, Great Blog!!\r\n\r\nAfter reading your tour of tasks section and this post, then I get to the following conclusions:\r\n\r\n1. Delegate tasks must run on some kind of Thread-pool thread since you must use a thread to run CPU bound code.\r\n2. Promise tasks are actually the real async operations. They use a Task an a \"interface\" wrapper but no thread is allocated since there is no use for one.\r\n\r\nAm I correct here? \r\n\r\nTasks are complex and I couldn't find an in-depth blog (yours is the closest). Most of the blogs focus on the async state machine. Can you also recommend a source for a behind the scenes on Tasks? I'm currently reading the source code using ILSpy and reading your blog, but I would like to go deeper.","date":"2018-08-08T06:48:44.263Z"},{"_id":"16f24680-a339-11e8-be2c-8d65cf80d10f","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"178e2d80-9ad7-11e8-82d8-69ed00e8bcf5","authorEmailEncrypted":"gUYDP2iNePxFBrUJ2Cp7kZ2Ck8D+/PhVyoADoHDe7/Ggdo/uyos3GSxT+N79xA4AfP12Sn7vPIRRsVv4RvAjEQRjCyFz5nLjx7loBYheXdE2FXIu42mNDLKrQYRLlGIwjjbHGq+nUs3KOuD+x6tfCmsO40lpyu1VmfzmVqOVA0nnPuAHHGTNdHxqlIeLuVd3tzlUhp3j9NSL2sKPKxLhz6fpDs5kH20D//tKojh7QMzDdlqa3alQYtzIPqN3t5WuFsAp/2rqxmTvktgpUTM81MpHXILrRgHEnEuaJ7KuhJe4VzFCRYl+PkIsMezSA62NRbd04kpYAWN624ART6+XBto68juzC5UMl4qWBl6ImH1TeRLPzCNlCNeOnPtTo66VAqfL7ncJfUt5VmQTUZ4lfDUEFFpPK54n5ULKZXrwvLli9WgMX/+wC4i9KZwaT72cZkZo6vZQd0wC5aiQGdeIu1Ni77OkAgRollgNUSbcfz+qqkrFrT1ca1LsySYXeDMFt5smr42XKrWEV0FWPSt+y735lhE/EImy5+SsXFYxzC1WSOSPpGmfKvrr5VK75veABEYcyBlU0AU5qpo5Tc+WoFjdp2K19fltRMq8M8Bx9jSBbHdc3sbYK3pv1+qKOS2r46kztvqo7SJ6DUAoWpZbXEuP29nnzXlc8elXWWip6mQ=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Yes, that is correct. As far as \"in-depth\" sources, there aren't many. I'd recommend anything written by Stephen Toub. He has some great talks from //Build, MSDN articles, and some blog posts on the Parallel Team blog.","date":"2018-08-18T22:50:23.310Z"},{"_id":"8fdddd30-d1c3-11e8-94ce-b56b73f5fd7f","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"gcmtIkmlbLU0gjPo3kUU8tEG6hHYdKpdlxZ4tuvclHfzpMIk2P37GNOXgf5x3QboJoOuvrjLRwXnxK+64RB4DaogtuL4+gzOBqDkeB8BiFsglcdZG8YMK6x7JZCxcQXabtXOwjDGIZ32TZJq5WjcVXzEgKQ3MrLzPnDiLiiFM2Tpvtd8iZBLP/tyT9xiISM4gfLNdxsJYRXJTPmtI6tMCT2Bfe/AF1dELEQOmylIZ4R1hZunUK8gIzeZxqbCOm2uDP5/+wjz6oAmMR5nQZHGwVeEpPPDdo7iFkncNGPwPOjDHeUHt9agKBEt/x2zgAVgo/eV5b8Ep4Wa4UlpRfX33Zp1PmgtMmv35np3U8BfNoBT2K5o4cA0N/wXVujuInfFpDSvDrQzv+zql3KTL8rNgkOKlAGB6rxWxSbp5uTBgp84ACM51keqhOS1YEVRixznr52VLXGe+3bMPrPcrx426cGY5R4WUcyIurk2WuEF5p0U4WW7Q3sM/BSgKnxc7rxUldXbh86N5EqB0N2Grf2dyFvzoQLEF06JTXylNbSmsdpKNXlFlMPmRR188SUTeQ9xtxn3kAjkPJRkJA1rcC31SnTt2ChfusnmiMC3fgfob/un+DUFNjfLfllihMqDkin9SjHf7YWrqAS2fGUAblMumPSLk10OfEpC4ljXifC+hKA=","authorEmailMD5":"fbd0de6ca98b9ab6d316ee57c4239058","authorName":"Mark","authorUri":"","message":"Could you help me understand the limitations of the \"There is No Thread\" scenario with regards to this this Microsoft support article (https://support.microsoft.com/en-us/help/156932/asynchronous-disk-i-o-appears-as-synchronous-on-windows), which says:\r\n\r\n\"On Windows NT, any write operation to a file that extends its length will be synchronous.\"\r\n\r\nas well as:\r\n\r\n\"The memory manager in Windows NT does not provide an asynchronous page fault mechanism to manage the file mappings used by the cache manager...so if you issue an asynchronous cached read, and the pages are not in memory, the file system driver assumes that you do not want your thread blocked and the request will be handled by a limited pool of worker threads...Because the pool of worker threads is limited...If you issue a lot of I/O operations for data that is not in the cache, the cache manager and memory manager become saturated and your requests are made synchronous.\"\r\n\r\nIn the first quote, it sounds like that the user thread will block until the write operation completes, and in the second quote it sounds like either some kernel thread or the user thread will be blocked waiting for the page fault to complete, depending on load.\r\n\r\nSince, in my own work, it would seem to be harmful to performance to use FILE_FLAG_NO_BUFFERING for reads, and pretty much all of my writes are appending to the end of a file (and even though I may know what the final length of the file may be, I can't use SetFileValidData() because my application does not run with admin privileges), does this mean that I would derive no benefit from using async IO? At least, no benefit that I couldn't achieve with just Task.Run() on a sync IO API call?","date":"2018-10-17T04:17:30.237Z"},{"_id":"a499b8e0-d7cf-11e8-a9f1-05b1ca7b5c0d","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"8fdddd30-d1c3-11e8-94ce-b56b73f5fd7f","authorEmailEncrypted":"pBGBxwXK0GyQQ+5F+9LgSpUqvDe3Zpbi7Qvt1tiZqTOPrJNpquzBZ+NzXzZQnFvhrSVYYElot8QqM6wYRIDMWW0kM1J2I1+FiopUTY56Fw33DZTwLutCeOYFRoutBqZF9tjMsaHeQqMTeFHjS+8b6ulf4iHtw8z+4eaiUjWrgfUWsamRZNjkP4qui+JMqwn48w/D6iw+p2fokbQGSk+89DUTLHcmFkKvEPVR2rxsyZQYGpQi/Gu4HhAzIvH8Rgl3mEzufv8XgiOY0eV7x7s3B5LoG5bRrzLc6dUma6bpFAnSMv1utPgRJd+CPSlgcVmpAU2qPfGR++yol4HoSS6xjC4XCssx9xAYxM7B6OrOnkvZDeFSfJjliKpuCPpegbFKDVO/Mw4JtkLuGG/TtgJMtUiN+FjbEYJlyvH0eetiZEooBtKsy87WbQSPDNImb7qVvo2lQK1B1czg4BJspSkQDxuVvCjveZq4dmX3xhlCOzRBkHwQzsffJ8fvpvggb5Sk7dCAXy06PpbOWS47aRF/90NOvaaSit+yU8L75YiNaH1ULcgNprCxwpY/giBrR3b+JjGX2/NRBA2zrA7XqqTrMC5BzWVNFHUYK2AFMnEIrDISOPqHXg4Rst3RlB1vCLLCixXAmj6bhHw89+5GazjlZ0nmbLfEEmLcMVp94ywn6fw=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"There are some limitations on Windows async file I/O. However, these limitations may be removed in future kernel versions. For this reason, I tend to write all my I/O as asynchronous; if I'm appending to a file and the OS makes it synchronous, it's possible for a future OS update to make it asynchronous. If I write my I/O as synchronous, then I can't benefit from future OS improvements around asynchrony without changing my code.\r\n\r\nHowever, I would recommend running performance tests with both async and sync file I/O running in your particular scenario. Last time I checked, there were some performance concerns with using BCL async file I/O heavily.","date":"2018-10-24T20:59:05.966Z"},{"_id":"703cdab0-dc79-11e8-ae79-43654a0a22ec","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"N0RzPjrEiJkMLle6Qx4VVLyGqGH7EkDlD4zX+mEKVWI7kXCGUZcQ/XAi6QxnnE3VP9RabC/tL1G+x03bHvrhKaCOTRdqvMp04YGI316BtBAao0JPQsI1SxiWt5oCy0SprtjwfVTqp8rco9qsYVVfmKAZ5XN/In6UZB1E8L8i8jq1vqOoARL4TN7DqhTAhXcU9XkAWmMkw81IlUeWOMqXwmsNwdiKiS6SvIiIsCVZbiNKlLMv4fH2ayLWlGK3J/fSnAs8F8RDSXA2D6CE1foRd2dPJFHD67OcN3MTr+RENry4LF7K1ODLrbOX5OnbE1qxotAmEnDba15XD+PNtyviV7vaNEHi92l91PBU3iAhCU2mDJPUY3Zy/wpW3zsXFPWkk88X2ENE9EY1eRFErKM0ByrnmgY5XWEbnaWkJ4gzklqFroe9hLDgL5YhbNnhHmdOewx7StfbWMg0F0UjuqgLcFWzCGQg8tqJuGyERijftk8aBORsl/DMz1S+3vd33xEUprtDQXo8aKY43NqHm3suchnCyROGORY7Si9+S2ZlcAqpeu2JlrJpis9b6CauJnmiizoGVmkaya6vNE7/LtsDYgk1hOPorM54q9vCgUo54TU+D2VUaE37nU7GceXfwiCRhDjFwCX47oaGDPVdZttnLzJ9wsszFC0DMKo4/ycW66Y=","authorEmailMD5":"63f3fb68fcc00284ed01066773b6c8ca","authorName":"Sean Vikoren","authorUri":"http://vikoren.com","message":"Thank you for that really great explanation!","date":"2018-10-30T19:24:37.152Z"},{"_id":"67aae750-0ab6-11e9-9bb1-17a44b157a7e","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"6e9c0a50-0a8c-11e9-9bb1-17a44b157a7e","authorEmailEncrypted":"OgI7XAiStLVUTt1mULR+weLFm1EHj8xfSbvrhP1FZTDjtfmi9IQD28MURPo8myg1YCF+GYkRgPT7afYWDAIF8BWnLLdSnG+yQ+EKrgGfbASWm7YyXZxQErir6mUjrvJ8SEbfcJ5lZVm/wKWcOjvcwK5OL5j67hHVNYqzPwhGBScs/Jun9dpXEY2+P2/eMw02JZb25PyzMUMzIpTS+hg3+/WS7aEnoLTWg4Jh9bUF2ZgHoSpWkz9Z6LXUZCWCYGliAQN95e9olQTMF9UeZcF5IQ1x+Imj0TSaBqocfT9nsQOlSTez/npZQg8KaZMfPHV1rqBlfD8xGnA6OldcUa2nCiD1zy963cg3TSRA9jpCjOrX2JVecj6l4MYfYGoHF2oSt2ROfRAYA0LdWJvgpZNsl0gQdSzxiXqOUDCl77Xtj1vTY0stxIRNBrNVY6U6e2zsJa1EsYYT9qjMPEB4YQn/iLA9AxXibcQIV2WKr/kf69Hfb2H1SRguhhZ8gM6AvIFXhLTFqfvHEzrNxnH2s7XBY4VmNkGZKAQrUC7sGw70tvZMJ6Rr/YcwdKKDJmPOPiF9XlJjezJspAqKEUC9jogbJ6iDbKmDC62FTrx2VdpPrG+PeyvYULGqcnQ67aCc6Z+uHgKSPk1HqQDJfbrJMJM+18ysQfmKst1AKXwz8aFlfLk=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"It's possible (in theory) in any language, but it really varies in complexity. JavaScript makes it easy, and C# / Python / F# / VB slightly harder. I've used this kind of programming with both C and C++, where it is much more complex. I believe Java would fall into the more complex category as well, but I have no direct experience there.","date":"2018-12-28T15:36:55.731Z"},{"_id":"6e9c0a50-0a8c-11e9-9bb1-17a44b157a7e","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Pravin","authorUri":"","message":"Thanks for the article. I googled to know exactly this!\r\n\r\nDo you know if the same behavior is possible in Java (or other non .net languages) as well?","date":"2018-12-28T10:36:28.378Z"},{"_id":"0bd991e0-1b5c-11e9-ba78-3d3ffff9172b","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"a7563b80-1b54-11e9-ba78-3d3ffff9172b","authorEmailEncrypted":"k58XSbKR2ESt6V5hm+pVNO3iyuCrk0sWmNCgQUIexGC5IEsVe3RdEK7HZgDBNkm65Zn6AmsG4wOeSCqnA4lk2rQHy3B3fWY7C4mk9ALPWRlnJFkuIPCVl/Qh6+E00KgtkrkfMp7pVDpluZ2BcE+NK4mr84wL582xJcnwz3b/pf4JXEtd/8XTJFTf0zQN0eLxTHN1tSDvn/KcNFtURdYfdIyCNIkL44eEoMjoTNTkU+7zEdbh6YSnMEXsvL/oYB3YjrSfX1LF94av40kq65TGeuO6yn5SxvtmKQEz1z0UYXW2Pvfwv/ZbSQhdvtF4cZ9ZzS8peyP75a2rFfVq0oKcOISIW3RS8xp3UwZxFWY/kMGo1G+5GAgLoEaxPaIgVKZteymy58aDrIWy/VjfIpARnI/41ftMR1viYVATmXGDZBQXAnslmpW9sb6bSp8BQfUA52EkyFzzJ7bY3yRfHrvbyY2V4RaNUQHF9e6hxrC3+TrbOm6IhZdmfpMiLcHI0pxQWWuOurpP1p/GuvnDkm2mrpiQTOHSjd7QkQCz2pW9PWoqc4TmRVGoO+f9BKShI0XlVz2xQIAGcmaxSTqOQG7gonINAM0LjVesDzo2l6SzVbZ83s1SQsFMYAdJgXPhcQqOl2REo47i3B+Jwi8FGPtIGTqTQ7zuK696MjtHJj1rmuo=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Hi Mike,\r\n\r\nThanks for your comments. They illustrate why it is difficult for me to explain what I mean when I say \"asynchronous\". In particular, I wrote this blog post specifically to go into detail (on one specific platform) explaining how it's possible to be asynchronous without threads (or processes, or whatever). This is one of the biggest questions people have after reading async intro posts [like this one of mine](https://blog.stephencleary.com/2012/02/async-and-await.html).\r\n\r\n\"Asynchronous\" (as used in the modern sense) does *not* mean \"runs on a different thread\" (or process, or whatever). The modern meaning of \"asynchronous\" is what us old-timers would refer to as \"callbacks\" - just a lot easier to use these days. It's true that asynchronous *used* to be more synonymous with \"parallelism\" or \"multithreading\", but its meaning has shifted over the last decade or so.","date":"2019-01-18T20:02:56.726Z"},{"_id":"a7563b80-1b54-11e9-ba78-3d3ffff9172b","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"http://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Mike","authorUri":"","message":"I think the author has over-complicated something that is quite simple.  I have been managing IT domains for 20+ years, and we know very well that IT loves cryptic sounding buzz words (so that people think it is all way too sophisticated).  Since ancient time faiths have also used this technique to create an environment of mystery (or even magic!) to create various beliefs.\r\n\r\nAsynchronous is a generic word used in various fields, it does not have a special meaning in Windows, nor should it.  Asynchronous simply means that two entities/things/signals/processes/threads are not in sync or are not finishing on the same clock cycle.\r\n\r\nThreads are really processes (piece of code running) with minor differences.  If you want to execute some function, but not wait for that function to finish, that function will have to execute on a different thread/process.  You can call it mama thread or papa thread or basement thread or whatever - it is a separately scheduled piece of code task-switched by CPU.\r\n\r\nUsing all mumbo-jumbo words and OS specific convoluted abbreviations does not change any of that.  Again, if you want to continue executing some code while letting some other piece of code execute also at the same time, you are using more than one process or thread (does not matter what terminology you use), and it will be task-switched at CPU level.  If you have more than one cpu (core is also just a cpu) in a symmetrical system (as is the case now-a-days) your 2 processes may execute simultaneously.","date":"2019-01-18T19:10:01.568Z"},{"_id":"62502ef0-202d-11e9-991f-271b0cc77544","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"e19c8330-1fa0-11e9-8fc2-efd230bc5aee","authorEmailEncrypted":"Kp3Uojr+9MD/Z7x2+ITmPZhbSMg+6NS5nOBIZvzUpWjIcQ1o8+CutB95X4rcUm/WftY0G/bExkyZoTh5+p2sV9yBMPiDZKNGLZzQKtj2oxKObomBVG9obbew+rM4ROFcLPS5v9Ra3Jf7mQbcfHYypGVkLbLrIUmxWH5BjIo3Ub6FfRxxzj+dJCd0kAdevoQyFDXI64CPlp7qVzpYqoLusUXXmz8FPOZBK4Wx9b8rPkYQN5y7hCq786wL5/UxT5Br+0538fA3gE8T8np2GE9q1xCqqfYeluHMZ2oco44ZcSVehzPcmZ6hkqIO/dcnLIP1RH+QecZWb3uiLAaYZTb1N75ZtmYoHwkThgyw3OVBrD6YTEBtnyT/6elxsaR9wq3hOPHi77KE3qLE3aOV/odnZrNIRuMjfm1CVpohzpCiV5amS/IxZNrt4I1h+Fnylan8L2MfCpQNu+O+7VHqInqSPLstxi+yazamXSWISyZ78D2Yh3ykbuKNFXBU7zgBeOYp43LcPyYClPy4FuLRKKpw8N48XAJmgP78AN7umYYpVqX2P7xtdH2bQq2Iy6hERsGUxhbUpOpt6ARbV1X6O1Fi72xS+rOCLBClejbijsg5MAwi4E+6lyu525tbZCasNuiknIfVth3FoV3LhID2cfb7kVwNipOLw1UIT4nnVZRtun0=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I/O threads *usually* are not blocked, but there are some BCL methods that will invoke your callback code on an I/O thread. So it can happen. I'm not sure if Core has fixed this or not. Of course, you can also explicitly [schedule your code on an I/O thread](https://docs.microsoft.com/en-us/dotnet/api/system.threading.threadpool.unsafequeuenativeoverlapped), though I've never been sure why you would *want* to do that.","date":"2019-01-24T23:11:31.151Z"},{"_id":"e19c8330-1fa0-11e9-8fc2-efd230bc5aee","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"JihUI8Ge5q7dKktgHvIwfJI15gTIJW+eJWyCRcvz14ct+EOoXsMq8LkjJ6/hzaaLuOyIPQsapsWChUlDUbW3oDAy7ZmwOKORDIWiM6BoEqCmR3bT4+DSkWzEcirqus03d9IVsUmBemsg7c2B1eCybEik1F39tkXCZMmeG6HxvV/GXdETMjfbHP9lgNivAg+/+4RoXVWBwJ/eYqmvjYxeDvC7yMyfNKasr/qgUhmFjaXlpGl6PKjFPJ7cYIU46edTmj2yBNb1CZlBJKo2WM9BhLIDxP4h5ZDG9r8GcSprc6JoDADUEp9XSTawRUb15ENDJ/fH+Wz3bNlM5lzn9fguaeInpjiWQBk9CsFp/3A8JaP0+H0ODscfI2yROgKgM11V7OG2SDTGPlOhSQHIkfhYhNXnufYZhR/l5JRm8wGlZmMfRc0BDh6O3firmjtBAbpWFYj87Bex08Efx9xddD+2y5tEsYR6XWcoDiZ2JW7nDubpOSTbvFFC0F+7QujbCjMz40wijqAUS9LRDQo4XzcrTLt185MG6t8QNe5Kej6HMbNwIDnBkpIH7RGNDPmUxpQs8AQ2JnwIbsVo5oD7riyj80hpesfDyot6r3abSovJN2RzlVeQFtIyneXWt9cKABXFyQKuwgD+ZWlrimq7Nxh2j/rZ3jgXclouHbMvYJI2oxY=","authorEmailMD5":"72b7a6fb3a3b4dcd8c8ada0586e0d8f8","authorName":"SangHeon Lee","authorUri":"","message":"Awesome article, now I understand how async io works in dotnet.\r\n\r\nI have one question, Do you have any idea about situation that we need iothread much more than number of processor? (like 10 iothreads per core). Because many article recommend user to increase 'MinIoThread' for better IO performance and people said it actually affect to performance. Moreover, default value of 'MaxIoThread' is 1000.\r\n\r\nIt depends on situation but as I know, if there's no blocking method in thread loop except GQCS, we don't need thread more than number of processor. And also coreclr limits number of release IOCP thread to number of processor. (https://github.com/dotnet/coreclr/blob/master/src/vm/win32threadpool.cpp#L456)\r\n\r\nSo I can't quite understand why we need more than two thread per core, Is there any blocking logic in iothread or am I missing something?","date":"2019-01-24T06:25:45.672Z"},{"_id":"402c93a0-309e-11e9-9886-cb4396af2ad7","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"Rlqdq+Y7frV0Zsd1igf4/Ta25tPx/zbRbv80Mrk2SfEgJEH9ElB8wXbweOY96j8LPNnwcQOTdEogM7wHWLv/B89KNqzAec6Fn0YHFSFN2PFsLDig4SmI1Bpz3SggIFDXJJhTe3FNAZNgRhnpx2YapN3kIAw3GRqBMvYdGGoe36/LaVBQc1N+w7uIDtGK6KARWrojzmIaL1yJBd7sTgSGbMWsw+0vQUsnk6o83KjwvPohWjcBSPheFe2QO1fVvxmenhdbgkCrIcUKa02akEiYqS3nW61Va8hSD0OwTPjjqLySzF4BWhMS1rsgTBkUby04IoUT176yYKpy+IdLivEo5u7XIu9JAeMOOoEP4UtmSGNq6qP2aorUuP/F/hbDgFDUE0Cpi+PAgCRkdRztIdsVHNj4jf58lf6zOYmEpayR4uP9qfb3yqIb6IvHmczWsrt0dk4t2L9j6HFNXVvhJZhLlsYhdUaLvXwqrhqP5CbrGM9+adJurIq5UiqpFRPMD0G61u2DkgC5iOb2KDwLrJubqADww7ZzojSd90tX0Wv2vc5O1jzSDfL8po4SW5OnxUmR03GW9FUv9omDU4jOOw2axTzmpIVmFGSoOX9IYPU/XFRrqIm35Da5yTeqkdqVmR8Okc5b19xNJGTrlmvmVvsp+kMmKTByk3XOcidrbW8g1yI=","authorEmailMD5":"acb477e35d3daa0bf579a3bfaefdfdc0","authorName":"Avi","authorUri":"","message":"Stephen, this question does not directly relate to the material that you dealt with and as such you are under no obligation to understand the question nor to answer it.  If you however do know the answer I will appreciate you sharing your opinion.\r\n\r\nDo you know if async/await are *NO MORE\" than a syntactic sugar to the *Task-Monad* or if async/await are *MORE* than just syntactic sugar to the *Task-Monad*?","date":"2019-02-14T21:19:45.674Z"},{"_id":"9a48d390-30a2-11e9-9886-cb4396af2ad7","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"402c93a0-309e-11e9-9886-cb4396af2ad7","authorEmailEncrypted":"fvzFj1CONlSZtQAMHvyAW9thXdITvbOBzsaFQ1bXAXO3qNKviVmMsKkReRFOPDaDh0m/HCBziy2MvpAV4KvrqbvUKNmrlrWl8VnuAF1MDkNuCrnJ2MCL/mCglIsYngDojkDt5YI4m21pGJa7Ap/oa0tKMGhA/ojsso8+8ntzK0dv0P9IBdFwsZI8iJf6ix/OWoIvaGLryZtRwNQzUVswI2kpgQfK9PgZjxIPrkONcA/4bBwlsWBjr/Ot98mIdMljVZGaRHcMJedM3h4EPbkU7CF27DZKxlu1P3NuW+u/VdDgFL8fyjQhKeZ3Xdvh86uMsCYJ2N06TyF3ra+bSt1g/3ToXAa8+i8oUTrXJa9iu6Jd5ssfURmGT80zpHR2vaOXJwaogja30ZLi1Q5aGuv0PQ+G8y+mBiLdKeIocxOthuDVMZGhJ20RiWEeezd7W/UOHPT4pRKqMsPU5iRtvLbmPPhkgaR/4gi4PgITTaPR5yK4oJtxN/sJ8wAkDAOONluaILoIKw7gILzW2tke8vLaSdPmTlEqcW+40o/xW3uTmKcMGYMbXALZ+rfsVM5EWfmXY+Nf+NWlbVWNoBCOXPicyxEfFiV7xf9jJeHu96k1kpiAHHoMclM5i4ed2Qo4O3NZAVB3qk8m7Lh3zeCZhQbq4EWm8bgzWWOeWMkBKjULgk4=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Copying my [SO comment](https://stackoverflow.com/questions/54681739/c-sharp-async-await-are-syntactic-sugar-for-the-task-monad) below:\r\n\r\n> I believe `async`/`await` are syntactic sugar for a Future monad, of which `Task` is one example. Compare the `async`/`await` support in F# and Scala; while not exactly the same as `async` in C#, those languages illustrate how `async` can be built on Future monads using functional macros.","date":"2019-02-14T21:50:54.835Z"},{"_id":"145d7ec0-30bb-11e9-9886-cb4396af2ad7","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"9a48d390-30a2-11e9-9886-cb4396af2ad7","authorEmailEncrypted":"YPVFAFSb0xm84id2tRSHpF/yScDONqHI8RZpHe0Y0q4wlI/U8adufTVNR7oBDfx8Jb+NhnAb1bGgOdvgkuumXR8PyDFL/Dh383IuNw2oCZY4ymzXdge9d/tKThDYf74jxeb4/59Mf808yuKvqTqgpzKb60EmCeewubwkAsnrodumPySiX/j9ZqRNIfek3yqhQZNwtrkNdZSAVF3fOhJN3atPB8Uvhz24wrvjDz6Z/pIc5Re6wyn2/0nGcHjs5yzTYjlgMlsgDQ+3XD5DrXHGXLrglN2SnIceZ7srDGzEd8J4yup80MmFXPU6rXAmAnVkPqSCvTCW2PHj5PXHukMH4G1PNr0EAJ4NBz2JvFjYZ7MuVP66ARoU5QYQE0CQUGah+J48NUX26IB+5bzj199h3GtQNtkB6ZLWVqBbL83eme1rQJMcVpUB8La1gTJvwZPVY4W3MBV8MgU0d4GkBH3iyuIjBu+KSnJs6aTM0PEiCIErfqTq4DPAM3gEoM9HdX2hH1mqXqtj33n6xmll2EAzqXUboy4aInXhTSburw3ebvp8bARGkRUs2t2UdSvc+pb98cq1pRrnJXDDZB96vP+8xx8RJrzcfzmSXJrjlYnt0NEVtqXVd3qfzbZ/HMR4rMIX4/GXjq7mAO5GNL/Lk3eRL9ent/rFf5a7ZdxuWqfcsvg=","authorEmailMD5":"acb477e35d3daa0bf579a3bfaefdfdc0","authorName":"Avi","authorUri":"","message":"Thank you Stephen.  Your opinion is always welcomed and valued.","date":"2019-02-15T00:46:07.613Z"},{"_id":"c603a090-5489-11e9-b3c5-295a240c9847","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"ff65bfd0-5461-11e9-b3c5-295a240c9847","authorEmailEncrypted":"cnxXAOLZdfk9uqKo1JWViI55wYrMzxO3M9R3coQBQF+lfp+YQyyyFsS5XYJ7ybIRckutV+aLgZR0tSpm/cy/oy+dglZ9mLVLXtTbl29itDIPH+VqPdnfH6Qojrs6suTY/B7QPoC8jpPPGCeHedEPJtZYsR4Uy+sdfedIwpUJ5FMyP/1BQVVEFWJ+zpROPujm2ndHvcmqcX2pQQIm6PDosIk+4lw2l2RuBHMaWzUjAmzUZGzE6DT8cy4+c4QTLFwAsM9MX137NqrIoI4SZyfzLilWyH37mTLIuA76VX7KR4yAd5/adC2VY3zDaQskZBfOfZlpH0NRG0LHeLsKvWNKK9Qk9387aoWh6SlmG1dt+ir4WKdQGKcJHH6i2u2q42k5eXjPB+MPg8OUqRl8zot1ObAl/4wINPVKxHNsfMeWpsbdVMRaLrEUgEU/T09Ug9ZN6tUkqpx0IH0AlonolsmOOikIYmu82ah99JS0Cu3leIyAfJo5IwiQ4uqnb3V8QpiIph2q8lg4nGPR5dsXKILFK8qWn17JTgLPp34W1PBADoYF/qo7rr8o4Pec3+upOjisJgonZmK3puZiNecLGOtOll6xZ0ikC4ywdjLJidpO1vFYjbDP7nTqLp+0GoUZoncC4MjCo79Diy7IQPLrqEtF+cpQPINeoStDugGANpuBFds=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"This post is about the internal implementations of the lowest-level I/O-bound methods that return a `Task`. There is no way to use `async`/`await` at this level because this *is* the lowest-level implementation.\r\n\r\nFor a more general overview of `async`/`await`, see [this post](https://blog.stephencleary.com/2012/02/async-and-await.html).\r\n\r\nIf this doesn't clear up your concerns, please follow up with something specific in this post that is wrong or misleading, and I'd be happy to address it.","date":"2019-04-01T14:23:52.684Z"},{"_id":"ff65bfd0-5461-11e9-b3c5-295a240c9847","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"http://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Akira","authorUri":"","message":"This post is wrong and misleading!\r\n\r\nRead the reference: https://docs.microsoft.com/en-us/dotnet/csharp/async\r\n\r\nQuoted:\r\n\r\n- For I/O-bound code, you await an operation which returns a Task or Task<T> inside of an async method.\r\n- For CPU-bound code, you await an operation which is started on a background thread with the Task.Run method.\r\n\r\nSo many views on this post, please edit, author!","date":"2019-04-01T09:39:09.125Z"},{"_id":"500aa9a0-54e9-11e9-bf38-c3a3a604c63b","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"ed07bf70-54e6-11e9-bf38-c3a3a604c63b","authorEmailEncrypted":"BaKuEjCdTNcEoLIcmH+5vUvyBV0dIAPASwyRLX3V9p7qwq017Z3JszMRgXtUlrxGH6e5dIur9I6jfrac5MnT3+4aMHbQUFlVsbcIHrx1Ah8OKkvisQEc2TLH6zpDXGAGp/MY4Q45q5pMy9o5ycCfhDORCicPFy01sC8WLuVh2h6n8XzxBCEUN8BA5kiuXSq48ufGE6rjqZBXyP/uZCpaBBMbr0FdP3D1Fep3rvYUUq+Ul/5d44kJXzPulRHN24UsSs2zMnzzpRxjVvTFsUVc8JDAIc2qSCei22yZnr2EEWTkZRt53J0sFyIoMosi/ZfHmURtqfULlHxfKstjtvVCmv2GxIC/Ccngp04yq4k73/LWlfl/wK/yjltSH3gTngcB2lXllDYiTTyE2JokGOUo60j1Q6y3rCsgpznzvJu7mYwzr5X7b1x8PEQ9XwKfAyvO/3nscAfbDJC+KsRHp9BW7aqdhNJ05J8yGBIs1Mk8CAuSpGs3EJlgP5HkA2TXO48o8hrnURAavU2Vq4mnHsJVIYQN/mqjnol5KU5ixJRXHToYmCVTyBpGdMt2Lx9ckEp+pbVW7CFg2kOMq/uq4uT2+ILFpdxU2ETmkga3eHo0z1IAItSkz/s/g/dW78vWDuOP3WkwngOsDfd/w9OKk4LIrc422ID5d0jP1IrEH8IMBe0=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Yes, you can have what I call \"fake async\" methods - that is, methods implemented with `Task.Run`. This blog post only deals with truly asynchronous methods.","date":"2019-04-02T01:47:46.440Z"},{"_id":"ed07bf70-54e6-11e9-bf38-c3a3a604c63b","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"http://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"c603a090-5489-11e9-b3c5-295a240c9847","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Akira","authorUri":"","message":"You quoted someone else: “if I am awaiting an operation, there must be a thread...\" and your statement: \"there is no thread\".\r\n\r\nI will assume your point is: \"there is no thread created when I'm awaiting an operation\". That is the misleading.\r\n\r\nInstead, you can say: \"It depends\":\r\n- If the operation is IO: no thread created - the system supports real async operation.\r\n- If the operation is CPU: new thread must be created (via Task.Run) - it's actually a async wrapper for sync operation. But you're still await on an operation.","date":"2019-04-02T01:30:41.256Z"},{"_id":"3afc31f0-718b-11e9-a6c3-add47ff521ab","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"http://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"67aae750-0ab6-11e9-9bb1-17a44b157a7e","authorEmailEncrypted":"YWv9B+iOruWgm08tkWZJBFDBN8bChAPMzZNdWyU14HJVf0EMFNbdQiRMpdH5a+EGQlOI3F4R2+Kw0itadRL1nr4Bw5EaPy7qsifSUiBUWdkgKiP+d1l3/TGrTXtXiTCX8HTVZoEnr7/NjNTsM0VdLkMEkr09AcNIog1FU967R5/qk2m4bJH3+HbZ4Ok3nGOQKfhKam3BtAh4ejt/8JPzDGomEs7GHF8UIpvunhsuSyAejO8iMbT91In8oeb9rYcMmU7md0sA3MfouHNKiAe8hfcVmdKqEzB36aNp5zUKjA2kr1yzhj4Ep2sVHWcvWugUhw5S+qrkuxkLE+S+eIVzPyqxZeXIDOIefnpPJWRXeGvje7nPHmFyfj/Iw6lkf4DqK31tF5uCDu0/wvGKDh7o1H7vN84sbg6zGuYguJ9lTsRo+t2QQRKQKXqDvJvbB8Y4+1kXfgJ8QD/ORNULXDy4OpG+n82AJ+G6PJXwy5PGv1WAauZ3ZJ5jsHnSbk17NR6p+FL78kkKaIY6TTAAEFIhR20RaS+xv/4NXKaTm7Th99hzWlj6gEIWtSylKMalZuJY6KVTJTvVbdINQKaiYMRfMIHFMt1xE/Q/BejKJvlSVkaW+ZqPmJhfVmBgVr/dikeztq/TCcdxnHkLWyYqFWb6eHmEyCBjCE3UMWuY6iJAHW8=","authorEmailMD5":"5441945c65e3a98df2e7a91dc7e9118c","authorName":"Alice Bevan-McGregor","authorUri":"https://github.com/amcgregor/","message":"Python support for async methodologies has seen some interesting improvements in the last few years. Core language support for \"async\" declaration of most control flow (\"async def\", \"async for\", etc.), \"await\" as a built-in statement, polished up \"asyncio\" (\"aio\") libraries (https://docs.python.org/3/library/asyncio.html) and a growing ecosystem of protocol implementations, servers, middleware, and bridges/threading interop, such as: https://github.com/agronholm/anyio — the future is bright, and lacking in threads unless absolutely required.  (See also the concurrent.futures implementation of that pattern, too.)","date":"2019-05-08T12:17:22.091Z"},{"_id":"7f72fb00-718d-11e9-a6c3-add47ff521ab","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"http://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"2f309c8f-c1b5-364a-862c-980332c3d6a7","authorEmailEncrypted":"iTIQT5rH+WyU95Pb8cKQpHPnZmkniqnLE5YKvvF7nvr2Q+HGUvDc8shmVR+Lq7m5IEJtwXSjziok+FbTNikfM0AGaOapYJidwPWBAZ1n6cCgbT4hyrzV+4OYLtl+VNVusnXzGVDmhBSxAfbbynFYCh8bogwXb1Wk+MpDT6hH5ERSKH9ZyEmLNrJWvrulP044xBdg3dPM10UTYKghW1xsOh2Ornl+gUZc/At0pOydmPeb+GELxHSAwG8/IPUm85p2Qu3kHOoD/43L0FdWs5u83/+ZnRv6Ae8Q3TG3kBGi1RTY0fAG7Bcmc12n4GrLAzJJ7KUL3Ovq0UQjYdihFCsu0S1nTS1XwUaHHUfmwGYoyL0tQsM9xNUGsvOysd1ndSsYfgUiFyijhTaeSp1yB6TG/qOA97v/701yCide43HvjK+Og5ipnubZeqkKywmwWFux9bHhUSp0reLxtAEr224aLoKAJVqbmD5mSF9Si1quWtReQvnziCTPsfJhzwkGTQKdeQiQggvHI+ssb5dWI+PmWSbqnGEs9IZNLQhZuVpIT34twOb8ZI2qtXK0UwK/hENwruDMLw8EAU5ZUSsQabJJqzsyizxXs08KHYxz8sKD29Um9P4EVwWO3a1wtPg02Q2yMRezeekNFoUFv5Bhc55xViTMsBo3tIzE+Fn2F/EaT7E=","authorEmailMD5":"5441945c65e3a98df2e7a91dc7e9118c","authorName":"Alice Bevan-McGregor","authorUri":"https://github.com/amcgregor/","message":"I like to use the example of the DOS command.com interactive prompt, asking students, \"Do you really think it's sitting there in a busy loop, constantly polling the keyboard memory area to see if anything's being pressed… now? How about now? Anything yet? So lonely… — no. DOS services register an interrupt handler to handle ISRs from the keyboard, make note of the press, then resumes whatever else was going on. Nothing ever actually sits and actively waits… except possibly the CPU itself put into an idle power management state waiting (passively!) for that eventual ISR.","date":"2019-05-08T12:33:35.885Z"},{"_id":"02bb4a60-83ec-11e9-8f9e-75cbd2e1542a","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"633412d0-83e4-11e9-8f9e-75cbd2e1542a","authorEmailEncrypted":"enH5u//kG9fQWyey2akdTQ1bUpp0ee0382HOnZi+YReIu0BoPRYmM5baGX6F26+gOj3inMlRHwszC/GZsXYHK0NdTGFcehoku0yt+wVz2nfgMyEg859IJd7LZib1BEBuFkfgcHIQDgnqFLjv21Szfl3rWfmqIhFV6SD9mTGQlDnl9fcO7YV6ZC5S+Ha3QSiXFcfXGkaf1taHq1zfBd2prqeKHIhRf9lpG7uC5XAGDNauHG+2JVoO46uhGAFAyMISMM/24M32uB2Wy1jo2nPB0pmvrV1EUcXoygGTDdqWpdZspdfC+ccxBvxtZgZAunqEwQX2GL7W8dI+97+1hxTirQ8lYflOed3KwD4H4MMG602K9RNSYc6mOcArjgrlLBanKd/E/ZOPHbjJCL89/5jImRUrnJly5Jnjyc/d/gSZMBWYwbXRdEu51hsHBAXeDoiLRZr1zIjclMb8GA/8TIP1fMM44wMXj/hA9nvbw+m+FAoxU1/omdO1U6qsvrRbjnEnlj+m57Z8ndgNabaAU4oWtrZFp2oTtsSejo9g547HeMqhxWxMyP3a0CiTKxmR4C43Ul+Cd+ju2XKjogUj71ZaZteqVCmZv75eIwHvPixEBhnrJl/mOFd3azV8tuYCyLG/2fHcW28ej6KRl0E3WhRpPbQ7aE3bog0EmQiZiE+wWxw=","authorEmailMD5":"924f058369af9b8d2b51d03470f9ea27","authorName":"Dave Black","authorUri":"https://dave-black.blogspot.com","message":"Ah, I wasn't aware of the exception for UI. Thanks for the clarification.","date":"2019-05-31T21:35:29.872Z"},{"_id":"633412d0-83e4-11e9-8f9e-75cbd2e1542a","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"7d824480-83d6-11e9-8f9e-75cbd2e1542a","authorEmailEncrypted":"dE/n06t5cmC8sdXYihi/zNxHomUuIdBPn1icGmPpigUkGfh41TxX0P18O7l+grRRz14yuDhMMYSm4Ok+jWvfhVG4U4S5Sibfc8ROpclSYi4cKCCHFdJmQLVc6Sw8zoGAcCtzMF0Godv+UCbP6tbaRljElDGgVAvDfzYJa5MRNZojiT3ue9+shxsfZps+bguprUrmam4Tff7A0cVqKMDpxskxRQMwdm7F2lAiWjY53tI2CcsXwUFOuJELeS1lvpBs74jTar+FMxMVEOq8ZSrV/U4MBHykj2YpODY72ruS/zVStDNcOLDTopLfcahAGosnKCXkOiP6toODkhP13K32aviIskAknxDvl0plr0QBlWJeO5VumgA+P2x0aWR8q8jTN46HMPxOdjLNbsyXhoFb2T3Clb3XEM3vbEecCqEZt4AwHJgSFlNCrm43bKGSxX/ep+g/WQvRsYOtKEhY2S+EMFqmmY4N4ADAEyQiX1Z90T5HhEwkM223+Jv7TNCoQdE6UjesfS08Y/H8bX9qFghKAx/sGbA4T1KwJmcKA9PAF5z1yiyIpunYjxBQUiZm4TiqDgF1EnCFbC888OIUgUILC+jY9sO9fL2PmmsfpMpSfT85yHt0PLRuPOpKoYKGtiIrZ9B3INZv8HfBRRBXum8+zL1WlMlooH3+dhx5fF1bvvU=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"No.\r\n\r\nThe guideline is \"avoid async void\" except for event handlers. `Button_Click` is an event handler, so it is purposely `async void`.","date":"2019-05-31T20:40:55.757Z"},{"_id":"7d824480-83d6-11e9-8f9e-75cbd2e1542a","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"bci4oLTk6aXINW/TvFYgsj6cW377EfZSJmbIEd32qJAvYu2p18LhthC+ZdUqW0wUXquVTgJugtItiuZNHNYgG4sBu/zxtB12DncxuAINc1/05/ttiCDafykaqZvwXs08hVEHNSAQjPu6CdBNrDxH1j1eRbTIvsZK2rVt8DG58IlXgFmn0ZG4bzm78v52Nqp8S2vYWoqRvWMoqJBb33l+XZ7YiulAKMLG47gW+V6rm3tfhhBgtUzK7Q3Wz4aYxGSapqD+X1YaHZ2wx3Fq5NPHnY2rr1m2UUIGyV4qH20PyYr/xJPU3lSHTLfUdOPb03FR25TTsHR0JD2Fs2BBT2jxljS2a9wCL1BnTZpDgpdN3nV1ZSOroUp2etJ0ka7vpjvM8dWAlzuxag/C7kIlYr46mNe4Ojjn0TRnSxPqcrybAbYnViw/BOU6ZoLjezZkts+GmbhhNpHAgfxknE3jJhyqVYXqJQyGnOcckUsYVDP4rehE1952ar2iEUXOXqaqiEcizZ9S/LrAYRoSrGK+sxh1Ptbu31Ehw9viDWhyt/b8zJqsXfFIWozVZ1HGxXrc1tXu54MPwkjnUY/iI0VixIHR1uwjvQaCJnA2oSvFYNtXe4Cs2i4sRaCbLAoQm+SanLnPDyIttaYmAPqeWwAAOjyqj8NKGOO3145yyz0RSOIKDWo=","authorEmailMD5":"924f058369af9b8d2b51d03470f9ea27","authorName":"Dave Black","authorUri":"https://dave-black.blogspot.com","message":"Just a nit, but I think a big one...\r\n\r\nShouldn't you have:\r\n<pre>private async <strong>Task</strong> Button_Click(object sender, RoutedEventArgs e)</pre>\r\n\r\ninstead of:\r\n<pre>private async void Button_Click(object sender, RoutedEventArgs e)</pre>\r\n\r\nI was under the impression that it is bad practice to have a 'void' return type with an async method. TIA","date":"2019-05-31T19:01:26.973Z"},{"_id":"645bd180-a152-11e9-b892-27c2eac73748","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"TED2TiEndVj0G9XyJ/yts/CM529v4+6mI17b5UJIMbGs3VlZv9fEnZPTT712KQYCcUKpTJ5gDob09J6Iq47vwxTOr6dfAT6U1CMsZVKMBcs2k1q7Y65aPsr+E7rlwXUslEAFIU4bLZvH0pcnfWj6xCX7NzyRJxvNSbxpkL5D6fdDEeInISaLosRUzO37F1eT0aRc+SkscYL14pOS4Qfti455WQsoUiYhAuj32ChJrL/WZx+MZHgUYj/1dtHnghrkCv6JeN2jg0Gi/o9gcR5TUsMl+nBPbh8oFjB++Hm6uPSFGcYHOHm2mpInlHQsxnmtVPWfwc9/o5Qb5Zq/08hXb27kDev5aGWbYd0FemHusHvOGHhVkaPBxQasP9NiG7wGbOrfzIWwU7MYmTvG7xHION0dymlxdOMB6orDNm57OFAmo560fqcgl9W6uv898jlqkZn4ZlBLvR24zSJZz+QQROuArcoMP4zi+KNvwgQqkJNDztl8jY+uGTB+loWDC3m8RtRuvRa3Ipdlo7x8rPFoOXbaH4hJHP3WDcJY9/Bl6KOi1MInqdB84F4dPTvtj717qGEoIq7uiUA/vmikTDulmUzknhxI4VqoS1brAF1qLPLJfPLBdrM8zXvttahu44512MC6Kl6d5suQOLu7vA6DacojKzfKL7bgVv54WnCRAGc=","authorEmailMD5":"3bc8b45d450d59282a0da5cced6d70c6","authorName":"cookie404","authorUri":"","message":"dear  Stephen , in this comments:\r\n> Imagine we have another async method in between UI or web api controller and the async IO operations. Who executes that code?\r\n\r\n>The code resumes on whatever context was captured at the point of the await. The built-in \"context\"s are generally the UI thread or a thread pool thread.“\r\n\r\n\r\nin this post,\r\nhttps://blog.stephencleary.com/2017/03/aspnetcore-synchronization-context.html\r\n\r\nwe know there is no synchronization-context in asp.net core  any more,\r\n\r\nso there  mast  be a  thread pool thread execute the code ?","date":"2019-07-08T07:31:25.871Z"},{"_id":"362a4250-a914-11e9-a14c-51fa5c639afb","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"645bd180-a152-11e9-b892-27c2eac73748","authorEmailEncrypted":"HTpOa3aRnEKNaFBJou5n3/CUE5zbS7OLyOUxnIIJN0DtfijRP4fK5gXtzDGoDdVB+8yW9pKzFaaogE+O9oPy5jNsdEz1zZbCVJ8COVEwKx+aaUXM/h+PzT6gqZoFhJKoHJ9ugokCOPJbVuSOij9EeKd3dYGD/nJxoJeySiG5S2R+Ey5Z0GJS+J1xrN3htVi7J7iiDuRcHdQOQzNPHv7abwXCxjwZ5iIOoNrjlGxQqJ6zkXKhyrUDJT32NYEwwU8wY+bQi82k7BBgRs1ugYggvqb/xr/VB6JUFNrvk85NMGrUDPsDSXk++tBnOE//cU0MgEirCZptySXFOkYPmaREdhhBrFqHczCd1+U1+E1UtgimMipweVoqOQu0wH8Igf7jdvSmMplyFdXtgAclk6J9pvs4dkRLu/Hp2ZaDwRpoyAmbYvmH+HjYRjAJI3SKMX+1wGqhg5N58oEM3qezSpIe4lNpdZcrYiX7sK9V1oTB82hWc2CSZFsJxlL3IBgrMqgw3u4eQAkSmR8Zn78F0xngdRSC7779R7OFm5gz0WQpwZ1b/5PMHQrRBieI1givAAYHYCkJip4s+S/zlq098zn8GMRudyf985O+ZrFXHjPg/QP8GohhlXUzq6pTT3K9ZdBKL4apldh8dC8ioQNwlq5WdpIMvnGGbUg23m3kF3oVSVM=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Correct. There is no context captured, so the thread resumes executing on any available thread pool thread.","date":"2019-07-18T04:26:28.817Z"},{"_id":"d6183a70-4107-11ea-ac15-038facef7728","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"0bd991e0-1b5c-11e9-ba78-3d3ffff9172b","authorEmailEncrypted":"RORESBi2AboT6qAxO2K9vQvLwt65hQLHCXxS6cO144wSKGSyNt3ue9YaE0hUuMff9czSf3ZlLDhcz8mS+RSFMXo60MiQ6RZSylUZcBhiM0sBzQRYAVufR40mLCN1qPdBaCl9ok6PD43tPYY45E7FSKtb+2JcdPbSKkCZRjpqIDhhFDL3SVgJzC+p05Bqy3MYWiXcjrU5iMWfmk0ldb2f2P5Qc0VS+1wE0xQzAuaGT20RuGiWNm3TdAHQ6pJYXTHq2Sdtglk6fK+hDb1jqbj0oN0jeSFAbtgFDDkZc8G3WRZ4E7HKE1vkeZX4PAcpbp1qN8qpsOSONMHA4/2DuesthQVexusVhpuvMg9XtxrqLCSfiKfdfEluGHi0iGnpBEERc31znifiL9HN7szyDi5Xhi84pJsbDbvZFROzKQ5nVPw8H1l5HlE85WbRQtik53DKWhYxkumii0E3AT8c4RKVuceP6+UcXkGwEXav4CUBjqZ/RSPKRPJHZeBU1lmQMte4g3WsNT8MDDiz/OyoY9qTAIRRQPLyF3WDItklpE3FFrJxirQnwATkillGdo26vlUi1AohSz70SCxDxLADgxN96tPe0qQ6LYuCV1tDc80HhG8ejQCblUP2eqStYQQf+rAXcMZBf6a7DQJYI5AfcRtRSRTsA3jrZuv2rePN6y3Q2oA=","authorEmailMD5":"8e49ab37de99f97ff270632bcbaee49d","authorName":"nowave7","authorUri":"","message":"Hey Stephen,\r\n\r\nFirst off, thanks for this post. It sure did clear up quite a few questions I had regarding this topic.\r\n\r\nBut, there are a few remarks I'd like to make and a few questions I'd like to ask.\r\n1. When you say that there is no thread firing the I/O request, that's not entirely true, since you have at least that original UI thread that initiated the I/O operation in the first place? Of course, your argument a bit further down the line, that there is no new thread being created that will block while executing the request is a whole different statement. Am I understanding this correctly? I think it is important to be as precise as possible here, exactly to avoid any kind of confusion.\r\n2. Now onto something that is still not clear to me.\r\nWhat exactly happens to the UI thread (or the application itself) during the propagation of the I/O request all the way down to the device itself (or to be more precise till the point when the BCL/library returns an incomplete task). I'm assuming it remains unresponsive? Even for no longer than (and I'm guessing here) 10ms?\r\n3. And finally, you say that the BCL has already registered a handle with the I/O Completion Port (IOCP), which will then, in turn, be used to create a background thread on the thread pool in order to serve the incoming APC. Which handle would it be exactly and when was this exactly done?\r\n\r\nThanks in advance!","date":"2020-01-27T13:20:50.633Z"},{"_id":"eb94abe0-4111-11ea-ac15-038facef7728","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"d6183a70-4107-11ea-ac15-038facef7728","authorEmailEncrypted":"OszHh5rBVryXfGaoSMQPtvzzS+7lxWMUfl5akViWVEBjVXeDA4bR8rtRfWaYAM4S+6sg20iGmMMYXbzJTA0Awo08bxOSnzap+tENe/1s1w8YDN2J+r6wmZVCOsNkxsN519Dt5J+aPCjbgtJ8ZIcN6wVS92Jrlf/Lq0A17YFVo9W4MdsBLd13KNX8jiYRs7N8z56cfda7ZrxWiRKfG3knL9OO3m/6imciMQVyEkXACHNxe2o7TkNkzh49yMyLuQKV2zCeUcpwTRuDgOKePkUu24U6J6KSvLcr3GOxNsLIto7zMORv94Ad1wef9mNeVcuVgD50LmKJ89vlEW/FT/AsoGV5CtUbwyFdzn+8FGuKFZlV7u/fCuY4jNYQLIzwLvvPBYNpTB47xwb1rTVzl4nyl5woJV+Bznb+SAXFjPXa/FGo+dYDHSiq578irGegWoPG914sMQfAXXpT+gjbRwaQMS0btnDTLPEElXMLdQmnHiheTnjeGSngqzlNU+WhBLvHOTtHS4XqvUHwu4Ic5VTs+wdQsGs8OOoLCSwBcjNNp10Yhc0pvILmo46N1ezRG9x/pH6Krhu+akrZdMWbGQI/5b+vEBz0Jl0Tn5sG2Xb9yFYUGyzRObzA00BInd3NuilRvwwavsFzdAZ+B6XFRAeZ3zZtZXBi/LOj2UUcKhvP1fI=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"1. Sorry for the confusion; I meant there is no thread \"doing the `await`\" or \"executing the I/O operation\". There is of course a thread that *starts* the I/O operation, which can be a UI thread. And there is at least one thread used to *complete* the I/O operation.\r\n2. All asynchronous code [starts executing synchronously](https://blog.stephencleary.com/2012/02/async-and-await.html). So the UI thread executes that code synchronously. I would *not* say that it is \"unresponsive\", however. Probably 2-3ms, which is not enough to qualify as \"unresponsive\", which as a general rule [is >50ms](https://blog.stephencleary.com/2013/04/ui-guidelines-for-async.html). In my experience, starting an I/O operation is actually faster than, say, creating and inserting a tree list node.\r\n3. The IOCP itself is created during the .NET runtime startup. In the particular example explored in this article (where the asynchronous operation is a file operation), the registering of the handle happens [as a part of opening the file](https://github.com/dotnet/runtime/blob/059b57ae1074b1e06e6afad17cd4d1c22eefb731/src/libraries/System.Private.CoreLib/src/System/IO/FileStream.Windows.cs#L92), and the handle being registered is the file handle itself.","date":"2020-01-27T14:33:01.604Z"},{"_id":"9217e020-4295-11ea-a8f2-f77e5be4e817","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"eb94abe0-4111-11ea-ac15-038facef7728","authorEmailEncrypted":"cZH+y5RVL7Dedfi5kT5nqdwYhh/v2nMtRq4aalqAKiETSC40KVTP9h8ykHbrV46XE96JrzxnKk4Y9nmaO0IPqrxyfmifEbYnkpeSwsSSR6EiVgZa1a/Ym54dJBvc4cPy4vfGycX67rQHSJIhsGprg3yjN/o1sWe8XOSuxCubMLVWvqajgSx/i6OEHJAQektexM40aqb/+Xaw06caG1cHPfSrPfWgKCCx+rMKA/Aa/lR42emCGc6lDS8OL0xXXRi9CrMJvhBP5pWDD2EPWpwweQel2ZIkxT80Yn+qcKHYfIlgVhlpC0Kxn9QDFki2Z2aB6TIqIo2Mgx6a0cHrRKHKkTa1G3OC3F0G6LIJ24B70FWJcj+wWqkBd58sD7ZvMKbsGVLzgAdYLOB/vg2BpqR/tRAUYmdwPrjxFxMYgRMhEPe0bYuhMIsPzyQOeXKguf8+IAxiM3aqQiXwF5ctG1gX3mwtiHVESyyIYeAm0HPyu3sPVHTU8BNooPNZKcT6puSY8D8CuC0kb5hzuKmoGgSzz77QahWTAuFM1xo5Xqed4nJATxGSYdx0TQuhBemwuDKCpWhOvLDLjPBp9KBX73S3pAtZors4VgENR2TanqPEt9F+ingjuCsj7dvsEV+FdC1SvvK+LSTglUm7icSHpHd1goD/szQEH0qtSGejeIFR6Mk=","authorEmailMD5":"8e49ab37de99f97ff270632bcbaee49d","authorName":"nowave7","authorUri":"","message":"Thank you very much for the answer Stephen. This really makes it much clearer!","date":"2020-01-29T12:47:56.663Z"},{"_id":"7bbdf930-8c88-11ea-9ef0-e95d7a14348e","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"daniel","authorUri":"","message":"Six years after and I keep referring back to this gem. Simple, concise, and to the point.\r\nthanks!","date":"2020-05-02T15:20:41.047Z"},{"_id":"2f9ccff0-92ea-11ea-9ec5-3955ad16e919","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Jonathan D","authorUri":"","message":"Thank you so much for the informative and clear explanations - your async guidance is all over the web and has been invaluable to me during my current 'flung into the deep end' development project. Much appreciated.","date":"2020-05-10T18:15:11.083Z"},{"_id":"ed049a90-939a-11ea-8c0e-09e6c6fdceaf","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"qvG6+Xk8gXBVWXPYmgrlb7YwZ0urcpwq+LQ4t2CrZoHnMqj52FDStfzzfh6VYeNndTJ+QBleTFR44yNDYanc1Lo390rRMpYqeqyHwu5XG+i9oLnutzcfRIODt1dcbJUu8WoK2J8EGtHVHCR6io27OVJ2Z2OzuCGDpAxDn+8GtG1cJOAWks1S/3odUm3pQ8uxdPFG6aBqsNAIW6QKX6ho/ili6ciKA0Mmj1s58kicrHZRJHX089qWqjBJkCGc9HDY7CZMXJHwG6WQnNPZIPtDCs/Kd+6UzzM8+SANlr3tP6H2kwd+8ltOCPard+ELOqtJneSF7nNsiyHM5pzxmdNzY5ZCiRQsPOQ7D89c0LFnLYEjYU2nexV5JgTZDt6QfwWo8oQdq7bO4KNV30eX0PfGoaL4HLCWQYqQSr0Ou3bYw7Oe33gh+sh4FfDCjpa7NNEVM0AaWgSQ7ecvr1GKZKiXNpoD506B+jRuEK1/xW7Xo+GimvTqdvR1ALwU91AU35nPjZt+eibUTN0GPwi3DtvZ7Q1QYDkSp9QAlR2DFX0Mu9JKqRcmy+zrEOO/t9r1a0eDJImhZRgviqAHsyycX0fQeiMNu5FxHeFaxK+bsp+D85VI9256h0kvnMvXlt0XMb/dVs+NeZXKapDLu+rx69+Xiu9KKC+Ia979hASFws2Zp9E=","authorEmailMD5":"0b6fe89aaf7f1c4e8ff2eed875839685","authorName":"Marcin","authorUri":"","message":"There is no spoon :)","date":"2020-05-11T15:20:20.310Z"},{"_id":"719cbf00-9d94-11ea-85aa-e50ced5b5726","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"OOkmht7QbvRgioMJP+zuwJldsbKdaiKSSYMr1lv2Uia1bfhGe8VaJe1kposps4kmNfwKZOv8RO75ayL016ma/yxfr2Q7KKXERK1m3giK0gnwsEz972JZowa51+sjyJPfYt5ZKt2m92Z1bhTDjgIrYP0APeyTN+ktK26hEXoifb8wjsTLOfcxl5Qca7CA6ttt4zqIiGZDzNa4CcKj7CyAZevQ+MHxqY49OelbvMH23smGzUfAAhERmbVsxJVlE1+mlszH1zDUHyWQNeo5nu/UfyryJGEMtDLo5grl4ZlrUyN3LfyjjB09DNDnzo+hHZPH14coYsssGNsWIFk82o+eYgO4H7PJ0k3odpqPVipTkFbftr3PoyhZuBaVgRa9B8gtyadshNN4PXF1aSk+0mAuJCl9Z93dloCbjgDFRLuI5fNl4Yw8cz4FtgyzDaogU6VUbHPPs500f6FgGN016z744GsdwxdVznCN5cI9pd3sQBUiiy+DJPtFwHV4IV7uCcf05QHEzr+ofGT1SSN4dZmJaHI+zUAIaz5msz1OiZAYH/NywD2DbGRHyOuE6+NKObB+MTSTs1Ikk7NaVLGaufBugdqIwoB2e9YhXu7/TjqBKY1sVnXI1X1H1b3eS4kqbtARk8x6r21PdNtVpcyMfun330UfqljYstgNuRppSfHJ26Y=","authorEmailMD5":"51e08d7ae4e4ff4f5f3c145acf8544bd","authorName":"Sunny Singh","authorUri":"","message":"Awesome explanation.Thanks for explaining it so clealy","date":"2020-05-24T07:59:07.775Z"},{"_id":"0a3d8640-d1ed-11ea-ad58-79193f5c10fc","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"f3a68040-d1e6-11ea-ad58-79193f5c10fc","authorEmailEncrypted":"QKb4It2Hl1Bl5KFxNPOhHyZYuBW+5z2rIoiFmO4PVjkFngm6YYSzCyWx6S0s0AjmvIMfqU1YKUJXNrh/n1J+4mbtxNA4bLmoLp6BQFmGng9snaCfiWH8Zein4BGf6HgH8BzGbEKdLJRqCOhMvGArC6Ee5yvrlTqtL7w4IDyuClTpLpCyLKI+OwW+Sw5h9PHc6D0ZhHONrkY6JO9DIQFnw9S4ZsjD2DEKbhrfELvwU4rePLne3iNQQlBPbTcqrGUHKYoomAy2eSOddYNL5UvnO3TRiKmh1sFMFYC7/skZfUpC/ofMVBnpYXPzhB4yM7GpJfIZkR0kd+OCoAnl5PM8itWIZIux0yMnO5Wq513v6jx8Cn3VcGraDvGCtP9Rj2E5yowj91gfYmwyl4GAcmF/7fm8+Wpm2vq4dKKyTg17ziAdjtaIl1bN+ubSrGbBs+8Fu+RWM0Mcg3eCaw3AVKwcop9L2eO1TjNF4B5sj0+jAXE8Ym/TDDIZ+tvkRlH/588IyxQIaTXhZyhgtszZYFpMxLW32ZqVrYanwOflRJCzLHjzd1loFYfAK3pcQBJHLVBhzUsmHPnY0VHPsDcVoSP4yBBSeQUfiSSk8CaJTxvn0wZV7nm0andqoaoaPC6SK1KGQVcLFV6EFIUT6+yJp6gMbhIRQX/FTM6dinfO2aGqor4=","authorEmailMD5":"38f94e31ac62e70238db3f90b034896d","authorName":"Moon Fisher","authorUri":"","message":"\"there is no thread waiting for the next chunk\"\r\n\r\nTrue.  But \"next chunk\" != \"the object I am deserializing\".\r\n\r\nSo the thread will have to wait to fully deserialize the model.  \r\n\r\nThe default behavior of HttpClient is good only when all needed bytes arrive in the first and only chunk.\r\n\r\nIf the result is large, I don't want to consume it until it arrives fully, I want to consume it as it arrives (streaming).\r\n\r\nConsider the case when I want to consume IEnumerable<T> from the response of HttpClient.\r\n\r\nI cannot hydrate an instance of T until all the bytes required to fully instantiate one instance of T have arrived.\r\nif number of bytes required to hydrate single instance of T are more than the chunk then the thread has to wait.","date":"2020-07-29T22:44:20.006Z"},{"_id":"8e3c8550-d1dd-11ea-95b9-71eb1bc5e14c","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"LS4bc1h4neyufsOIxFI9whkn8waYCTW6jxXantUxoC00CkaKsigGyUvy9xsFKb7hOOCruBR1Ot66ocYhrhdYQfkZga+4KyNME0OEfzdZmP3u38K2hXr7sKcoUzXsToUVRTh0cwXJOcUS6RJ4pecAQKra1qNLlCbkjaDLTFSGWmDmBZhSoX07AeAWp7NxpfSqodRE9xAS9g1MmaXqB+FfKP2Isfxmzz91IEjPGv3n5L/NQIrLLgK2/RxzwkgMGgk5+lkIl3ul2cSpN6WkOHtOt647OrxIi76ykeA6nZFx+fQXxPyjCxbVk61MEi1zH3NI++O3J2k1OF8eIi5AdWSk7CC9qXn7bUcpmA5sjfrgCrv8v1D9dRjAu11tPQOApQ178bDkYtvu5KxsRES5icJXdl4kU32XnK46jHxMXl9n1VYtDZ4PyLK21X9dgQR69GQ03835UVknb4pj2gosToyaggB3Nuk5/E5RbessEpAS4y3z/BUlHlKQSO3nu0YC1txg8ZJm9k3API7tt8HCPm45xTcjX3H/LObBOGR4qL71m3Ar+Fqhx5JKZkvk+Ahw3XlUvZAAeJ1JV559+gBpPBnhvECh+pSKCjD3CUTF7Cmv6y7DH8IzNrQyHEKWE3f5TsCcct+1Vh1dBqqJp94qhUDjVkAbIpt8U6R9tHutUFdL3Ok=","authorEmailMD5":"38f94e31ac62e70238db3f90b034896d","authorName":"Moon Fisher","authorUri":"","message":"I have read this article many times over years.  I kind of partially agree with this but mostly disagree.  The main reason is that the notion \"There is no thread\" creates a very good reason for many people to \"not think\".  \r\n\r\nConsider this simple code:\r\n\r\nvar result = await client.GetAsync(\"http://myapiendpoint\");\r\n\r\nUntil you get hold of the 'result' everything is async, and you are right, there is no thread involved.\r\n\r\nBut the problem here is that you get hold of 'result' as soon as the first drop of data arrives (in this case may be a 200 response from server).\r\n\r\nBut the reality is that to actually make use of the actual response and deserialize into your model there is no way anybody can guarantee that the thread will not wait, because the amount of data that is required to deserialize may arrive in multiple chucks.  Hence the waiting thread.","date":"2020-07-29T20:53:29.548Z"},{"_id":"f3a68040-d1e6-11ea-ad58-79193f5c10fc","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"8e3c8550-d1dd-11ea-95b9-71eb1bc5e14c","authorEmailEncrypted":"Uo6nJjJKaPvGWRag7YQ+HsJg+MnVa0RDVt4sZxedOvEkaucba7f02koi4ZvZew/V3A/XgsbaBI4T3L2tXnqEkdmrA4CzgP4AKVAZekJoq4GMAfysnkbG0+8GNtvqLZqvt+SUOkysxtNaRni8pX9wdWhJBRM8ik4FxNWsmUnn9KXz1RbjviuzslXXGWLZw43R7NoqMEFh6ddGuHxjXqnmC1sGG0Z0991yke6byvfpuPcjGpmnIi4JzJm1KiSKPH2pz0zfwzhs4d5rLeS0NczJv0cQSxRN1ruYjDkHCqPxK3H52oC5vjTUcoiAoKxTrNzx/5HSGtlmfeLsdidrS1S9jD/Qmu+rlWiZ44XUrVZWi+JvKIp10aRw6jR6xGsfHTSUJYv2MdcX8zLdk6ScBxi028jebNknWfL0BsVxaVdgDAZtfh20J4ICvtFUHethV7/nLGXWNMlprpUp5A0W64P9rAibryTFVAPAItjZ67+Cnz2lm9eCf+IorbhnvmCXJFFk7GMV/bD78yW/341Bja9zWFFK57CIvFwLJaUp6hfv4toTTPvh0wvFkSX/DJjntvEcLqEQCQHNaybdBQq9IVbj6BTma9mfaR+hRPBcn5vsmb+DpzTa7kxyGhjEvUnvMNHKCXIqfH1uosAmtmgrbHVBWR/UvXCjA3mk2o0cO4Vw3HU=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"The default behavior for `HttpClient` is to not return the result until the *entire* result has arrived. While you can instruct `HttpClient` to return a result only when the headers are read, you then have the option of asynchronously reading the response body. Either way, there is no thread waiting for the next chunk.","date":"2020-07-29T22:00:45.121Z"},{"_id":"6700be30-d3fd-11ea-9f94-3dc3516b29be","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"0a3d8640-d1ed-11ea-ad58-79193f5c10fc","authorEmailEncrypted":"QnPeBAdYKx4i782JtNdwWNdg6kNAXx8C2TbDlVxLAg0j/cgldRtINKk0yjQ5CBD0y8K+7GW4FMJgsl8//p8o5SgVRhnRNiS7wxweH+gFTOVV+Ose92TzzlZX9jgj1Ezg215z49H2lFwxy6ENqrSs9dR4ByKrou8g2EV3/oxkDIRjy+AUYYQ7gxmSc2hmRnolQ8p7iuqeRWuhg+l0MR2A8hVl8BV4ULlwtRV8+y52hLBfu87bByuzYW3ACrPyQ1PAmxRh+Epdgusmr6kcCo3o4i4v/wm5I+yYdG4qOYfqVFgT5amZdmiJ1T54jnqZH7n7K+tEY0uF7heLUjs3Uuqf7i+CF4NAN1TOF878IuJ9z0ywsEGmIOV070zmThILQZ28Y6caqWycn/Ph2GN2w10HK8kDSnxafaQs/2bGslZEak5ct4LvOmAb1qrIbg2RppCYVe17mv0QEaPBt5obScOkICBdO0qQwqYJ4oJqoFtxp7HJiAjJC7vjz7V3XiRtdYQQFBO8OG1tBH5w/XOXXXqkVN+ZOIGot9lPnTTvQhM36RGrZqxWHLloDqM6N3a7AKjCL20C4+fX78HMUDhLDuOFubEc/GWzX45c1NZ6o/yB7fJdx1oWzYNPj/oMiDm7HdW3d9ou77ms+7042/uBp1vyTFKOXYCGjj7+6Cof8qvkgIk=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"","message":"> So the thread will have to wait to fully deserialize the model. The default behavior of HttpClient is good only when all needed bytes arrive in the first and only chunk.\r\n\r\nThis is incorrect.\r\n\r\nIf you are using `HttpClient` to deserialize an object all at once, then your code will not resume until the *entire* response has been read and deserialized. The thread is not blocked during this time.\r\n\r\n> If the result is large, I don't want to consume it until it arrives fully, I want to consume it as it arrives (streaming).\r\n\r\nIn that case, you can use `HttpCompletionOption.ResponseHeadersRead` to complete the initial `GetAsync` operation when only the headers are read. Then you can get the response - as a stream - and read it asynchronously.\r\n\r\n> I cannot hydrate an instance of T until all the bytes required to fully instantiate one instance of T have arrived.\r\n\r\nYes; you would have to read the bytes from the stream into a buffer, and only hydrate the `T` instance when you have enough.\r\n\r\n> if number of bytes required to hydrate single instance of T are more than the chunk then the thread has to wait.\r\n\r\nNo, because each additional read from the stream can be asynchronous. So the thread will not be blocked.","date":"2020-08-01T13:46:29.865Z"},{"_id":"09e491f0-e3e2-11ea-adda-79bb21134a81","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"baa64620-e3e0-11ea-adda-79bb21134a81","authorEmailEncrypted":"GTfQ5njyknlhp1HhzA8JwJTwB/1xlT5fUR42SE7QuxRUyLCnBJgt9Yj5kp1mzMrz49/mAknOCbKmLHX+tBQdETjDfYhSGCPEZEfCH1rrXUgg4+qjXuOwfB6rBS225v4SC6XsHqI19yek0IZQn0uW923AkJzTlaBxeyXpwvR2A/KDRzbCFzHohsjByZ2pbPQTvmnHVaa/EG6xQxb5jGR+o/NIduglYSaZXVk68zaN2ELekvPpJgqxtF9D3lBpP/SCMs/KiPsku91VP7FI+DwKbFuy88LHzi4FQ9p6SpWJl1+twCeWDhJijz+NXZrioEzy8rB/ICL+7b60r1p6kRVMS94TT6dNBCYdJ6cHs3seskqlkubczbHjHFbCYeHeM1ZToFFrfiu8/KppNa9Lmt2xN838a/xObjPntbpQp1Awvzrjk1YkJw+XjHdSrBuX5OURjqsjlfRzfwb+DjG/OHGOy6MySZAEdaEdpom4fZuon81BHWBxz+4dDuSW6pCqR6LUQ7IXOWJrBF60vOjACw/9VAU/1qr/PEJaav46Pv9Iz12yFNgwtQLgJFsVu5qLsF1/DvrmlpBwdwH23ysoeklhx/fZ3+MRAvPuSHI8c9aZpI8NXp9z5KOR+Ps4C3lrgpoPpO+9xGlgwnkudkT+YyjhiZc0M18t58kDZF+W/eu9Roc=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I'm having a hard time putting together all your comments into a single complete question. Could you maybe post your complete question on a Q&A site like Stack Overflow?","date":"2020-08-21T19:10:55.835Z"},{"_id":"1688aed0-e3df-11ea-adda-79bb21134a81","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"6700be30-d3fd-11ea-9f94-3dc3516b29be","authorEmailEncrypted":"Yf0lcrElGdhXCP4YPO11uPzyPMxRAXbTLDMauBHf3eolJ1+IoBKVHBiTC7j4yLJsQ34nbeZiKOXrT36YNNQ2cZo/D6g3J5tXTisP6Lrpz8cn8Duhqh2VsbLcXG+/bSb2o2jtFae5H86vp98MQvykcRdGOVHMzLzJmaDEBq20B+J3rwmXezZACbFKSswMWjDQ7cp8+xzj6nArjzQSZbTNyn8evkW4jP1+9lwETs/LOAXS2O14QtO6wFMUO8VSCSfrDErzbTA3PYenIba3sgnhYepLzHeXtW4F95NSjVoPrhQMGq6fm2z5LTjC1/UA3bSeEPtnXxYbkBsCUnolIWLGK5V4vTBBnFtdiuWTRE0xF0rajznGguxOdduVqNeeHL47LvYSEtF0WMahIraomBKv2E6ve8wq4YcOD5MCXmxoZ1uMsB3r2NXj6LX2fwmpQzjJJpGPrrynRvAMI1x0NoVn5jkMzrLbyq+evo6W3HL2nspMp1je4yI1eamXjoIkXGByWH8z6hDv3wP94hH2yA0xLykP8WPxk2ahAIggR+4rGoqSMGdd3Ny5NobMYVXacb+AZCPb+dbe2o/1J7PmvYAEyC4JhjyYITpzoDCFo+1JN2p4cn3pmmed9aw3vQruWYX2EAvh89DCcf3n1w60cXgE6MAFXnpBmcSK6JuQlAW5Yk0=","authorEmailMD5":"38f94e31ac62e70238db3f90b034896d","authorName":"Moon Fisher","authorUri":"","message":"This does not make sense, if the method returns <code>IEnumerable<T></code> from the stream how can you yield <code>T</code> without waiting to fully hydrate the instance.  \r\n\r\nRemember when the client code gets hold of  <code>IEnumerable<T></code> after the initial <code>await</code> there is no awaits any more between each yield, so the thread that started enumerating  <code>IEnumerable<T></code> has to wait when buffers runs out and new data chunk hasn't arrived yet.","date":"2020-08-21T18:49:48.645Z"},{"_id":"4a446bd0-e3e7-11ea-adda-79bb21134a81","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"71f02c10-e3e6-11ea-adda-79bb21134a81","authorEmailEncrypted":"ZaS/xk6MaMKtRxn7RVPUjFPNDnx6t8KCr+XsgABU9exGkW5zJVjT7n1WUnLkD72IMJ3XHu/14tyu/A5lbXQzLGL+o8Rztu3O6lYu37f8HPCOjysHkWeJ0LcKxbKGb+WmrBIaxatNe5Ai9vsn9K+FGZ8ML/YfekeLCEp353jrA1ga1+ZzXnMEWqkHjpuDGWh0NY/gy08CwpJyUvq2SnmmcmOomnaTT0Vpmbjzq+0PeZDYNQbgysYHsI5Lx8Nw5LJoanKqBP/GeiYKLgZdYfXy+FFzQgvhACTrAd+B5oiPwBESOjamOr6qYUzaj1mfFxI9syYe3atXNh8NxBDBi4Dkv33/5p7VLXZrhWBohE2rf1IdgfrKGTR4SLXtWRSiCrsEoIMejkda1/FP3Lrwc3ZXL7SuE0mopwsSGSulLeKASz9FLLcaOfaDd8Y5yf2gICwiIbGcV9gjbGDHY/fbRLwLm5buww6uYoj/rYhiFyKUTyC1SN7Cc4HzvyRzDGKxKUlcfN05lKhT1Bs0hcbd5YANtoXZsz8PIi9Tzi9/rGTPJjTLhVv2zqP5EXG/8i3Q9iFrfvVMBePLDYdlIJiUiDj0c+i2VJcRG4gxajk8zP6Ocbbhgy5BNJg+c+DrybuFMCr3yZmxw8NO5QVn7h/TN5+14pUPhR8rHJjVVr9u3G3xels=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I've never been in a streaming scenario where I've had to consume `IEnumerable<T>`. *Of course* a thread would be blocked while consuming an `IEnumerable<T>` because it's a synchronous API; that does not invalidate the point of this post. `HttpClient` has no `IEnumerable<T>`-returning streaming methods AFAIK.\r\n\r\nFor streaming scenarios, I've normally used `Stream`, which does support asynchronous APIs and does not burn an unnecessary thread. I believe this is the normal approach for streaming HTTP responses.","date":"2020-08-21T19:48:31.289Z"},{"_id":"71f02c10-e3e6-11ea-adda-79bb21134a81","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"09e491f0-e3e2-11ea-adda-79bb21134a81","authorEmailEncrypted":"waS4uZL0fYpYS+5I4shwPyQsfHhfqrU9cSn8TosFpGtQJYLkaH0zZHZ0Lc7DQMUUvUKC+H3Z7Pw7uf3uoj2cGOnJbAHPdtqjwYDvhafZ+E/Rpl8xjI7U6u7kCRhrLYbCFS1j1F2AWMf6o/CY8WRjL0Q3kupNmaX6ydIYzYuIJwD0cAKIjQo4PVG2l7MB+DIzahZoHFoX1VKqEOnv9RSaVZAa5yeaQw3GgnjXfTEI7LVRDLI3LLMO0nO5M1EQ4JGnkLN0wZ8AajQfOsUHHBHyl7USakZEmK2isGu1IKWkXSE9tDXfUqoJd8G/A+3Fn2o6GzTrAdHAL3WIZtYoXB7C5WADahQ/l4MSUPbKYhw0gzmTPsYUvYMPdnDNyWJOkvVqU4tb+ikaZo15EycaNUD92qVVGqsbwxTF/Y8mYaCXFPtS39nGV6tJlL1/HVoMXo+SeTALl6xZ6Duf+27qW8nal6l7JuyofDevyKzfFYRzjbU4MJRXYvM3zmIVbmcprRTZfFRzl6j6T4aJ9I5hnM6PCRgU1Hm0f/v/X8dGyFsv9aNo1ggxi4IJplgdTIXkEBcXI7GA85yaSTyZE6ojaZvZZXIBtfbpyqA98Kh9VZ+giG5IVL30jxYA0fDkc2fHz/n666uKSgQu68tnnK8YxsuXwOJQlGWRdwgDlgKrl5i15jU=","authorEmailMD5":"38f94e31ac62e70238db3f90b034896d","authorName":"Moon Fisher","authorUri":"","message":"My point is very simple, and it is not a question so I don't need to post it on SO.\r\n\r\nIn a streaming scenario, where you have to consume an <code>IEnumerable<T></code> from an Http streaming response.  After the initial <code>await</code> when the thread starts enumerating, it has to wait every time when the buffer runs out and there is no more bytes available to fully instantiate next instance of <code>T</code>.\r\n\r\nTherefore the notion 'there is no thread that waits' is fundamentally wrong for this simple scenario.  By the way, this is a very common scenario.\r\n\r\nOne possible solution is to use <code>IAsyncEnumerable</code> to address this scenario, but that's something that came in C# 8, so your point was wrong until C#8.\r\n\r\nAlso even if you use <code>IAsyncEnumerable</code> there are only handful of deserializers currently available that return <code>IAsyncEnumerable</code> from a <code>Stream</code>.  Most of the deserializers return <code>IEnumerable<T></code>.  So you are left with the choice to implement your own and get into lower layer to read bytes, parse raw data (json, csv, xml, binary etc) and hydrate your instance of <code>T</code>.\r\n\r\nAt a high level your point makes sense and it may be true for the scenario when all the data arrives fully before <code>IEnumerable<T></code> is returned.  But this does not work for the streaming cases, which is a very common case. \r\n\r\nSo the thread has to wait for a very common streaming scenario that I explained above.","date":"2020-08-21T19:42:28.411Z"},{"_id":"7f83aed0-e3df-11ea-adda-79bb21134a81","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"1688aed0-e3df-11ea-adda-79bb21134a81","authorEmailEncrypted":"CFltVSnwG6mv5FAiHvETt8ppbv3nz//qgJn3hVTpEqejyrQaBEi9/TxIVtURZlOebUNYswSgcyi5Z6ukjGhn0VgHkNcUMaASOLVTFJ4geDVhXzMygqhat73CW/o/M4O0Bb6LYBF0bEgz+vGMCobMyR5/3ltyEU41BocAbXp7prTXKF4VLp0yrZDeCcdU8ckAO1qhyK4aWPE+Jgi8gEGHKoRn1ZRhB9D2vSisZKTqPm0KuevTVAiC14gZ+2LDqa8rFEIEUzMpto+QyKzf8AelZ5iWC/xsxuqmLboxg4pFFTx6dyC+JMVHj01Q1jfZuIfbwxXdecoNKPFdrDy2xe6h7SDzC2EOoOnLx6W9BrPoWXaPrRMnl/w2ZOcjytocnweJc/OugQtxsr8N39SaGeHW47R0Qv5Lwnv3mytrAA2OfZ6jw9zX+Asty39CQmrneMu0Hv0fDKR/Cgy783o7eUswP2Mym5UThouwiaopn7KJa9ogJFNX08QQIqNQe1qmxkLjwAcTF7xUNwMRz171krTCI2fLOBY5RZOIDqIZnQZ6KtHDWJAGfU0uOYLJHDv46VowzX8U48HWOsxkjFP867oE93jVrUixfUB5Qn95evEdVY8o08fD3X92JkKJo/PPsCaKDW2tru3Zve2qpRxm5WMkFJbndUbwNhlUJJkqcTY42qA=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"If you want to use `async` with `yield`, then return `IAsyncEnumerable<T>`.","date":"2020-08-21T18:52:44.645Z"},{"_id":"baa64620-e3e0-11ea-adda-79bb21134a81","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"7f83aed0-e3df-11ea-adda-79bb21134a81","authorEmailEncrypted":"PIsUppDZrRHvfsbd+R/+1AA7Cv52jqrv36WPxJ0I45UYubJZLPJlyfznDO7sx7Na33onw/ADMmFCiCIMOLvhZgbT6Qs1HpYglTuxiAu2FEntIAL/AQTxi0R37R5hKeVipoRf1aPCP4xKAm+7Jnal5rrYU3qkkKbu4xqLBGaSAIGLem6p6g2Jzur7K35cejDo+X9LcvUXYD+N3YGXddebiUf2HftOMjIUcPX13Nl+qYYqVba/kH34ZftoelDCskWLSIGbJVALVStQBQMnlSFDUqmyUDs+4LLRrkCnMd8k81vtsiC5kDJ1cd6u79WTxVWBSr8xebjw6gCdPKag/ApwNPCOnuwEIKBvwZcnFdmJqYrp6zgPrSnEfhyE7DxtAh+Y/cN85cuUlXbx1m2Xxg9K/zVtGfMcpGQv0civPrUR77VtXMT6iYONjHZszwewApD0gb6X4ItTfAycLkxY1eS6YcMQByxHl11klTsdqdwoCmwQARbkZRVSwxZW4iAjQUr9bUKlkwW3HmVvKYeX1ZJWt+mJaHvzxVand0rpk+6uahnRxrBB/fqEy0MN0xPxG4Eq8ZzXAmEhfjGhFirnOILb9no8QovYis+HCckZ/tWdRAwYrHv/Z+gW8LJRmE+KxabKq4whn1+0udtxwMhJbsAARaFIejJR+NKr5XPCQBJe5S8=","authorEmailMD5":"38f94e31ac62e70238db3f90b034896d","authorName":"Moon Fisher","authorUri":"","message":"<code>IAsyncEnumerable</code> came in C#8.  That means whatever you were saying was wrong for a simple scenario I explained.","date":"2020-08-21T19:01:33.395Z"},{"_id":"18ac7780-04c0-11eb-b16a-51173e8f1ad4","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"889e71e5-f786-3c7b-8328-390733e5e63f","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Orbstein","authorUri":"","message":"Just to clarify my understanding.\r\n\r\nWhen the IO/Threads calls GetQueuedCompletionStatus it receives the Overlapped structure and it contains a reference to an object that is the Task, marking it as completed and calling the continuation method that is the resumed state machine? Is there other variants of this flow?\r\n\r\nThanks.","date":"2020-10-02T15:01:07.021Z"},{"_id":"441cf700-04b6-11eb-90aa-13ace0dc86be","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"71f02c10-e3e6-11ea-adda-79bb21134a81","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Orbstein","authorUri":"","message":"Moon Fisher I am very curious to see a snippet (real C # code with Http Api) that you are talking about, you seem to be _so_ convinced about the api that you must have checked out the internal implementations and knows something we do not.","date":"2020-10-02T13:50:44.282Z"},{"_id":"1a85bd90-057f-11eb-a2e6-2905133aa567","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"18ac7780-04c0-11eb-b16a-51173e8f1ad4","authorEmailEncrypted":"jKno1n2caKHNRiAX3zFvM+LRYNBYaQ70hHZwjYgQsiFPWjIZZh7b9hFGBVUSGETNnhjrk4uSR1P7IhkA5dgQw2tjuTrmrjNwgUY7GdX4/4YHwUZDxOke4uoZzGVn1DIoV6u/09Im8ZROqFhZyYPZdkcUPBsuRrkfAOz8MELyaLFbtQGXAEyat+E229/Cx+VTu6TsBtaCtLMKrFiZ51YSdq92YXcGXyKmb2PbNOiN3IH+mlioBKWeQvm6MaABWjWj1QANMjwYPkuKRemU56DGqNNzbVOzeyfKM+L9As/0RKWLMFr01waHYoQTrXnRuD0giE/rT684TB39cX1IjhgR+L35g8Hw4i0dRgwuZelaF2mNBH1vvI7i5lAw6GATfUzVsfY3/kUN8Qbk5Jhb4SAyFQPC9kYzloE0jap2s7trnL2fIZLLemedKAuH1E+GDGc6DPj6FpMjrRJEQLyqMgKTcYQbJAxvHDb3BR2eFXAKM8pdvgfOKSczHdblRNvv6PLAK23RCScwLlYMZqDVKrWnsL1TtdnOUeowZ0HInhsW1+8LAUhKRanrntwzcthCquKhF3NE4sDQpENSgQkoCbjhdAzKzhgDr35zEFkgWMigjSaFGp6yMfPyMGwCRXxuX3v4Rizatzj70XmJdUSmQ7kH/L2WIAsy31NvhT3sTpscxpU=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Yes, the `OVERLAPPED` structure is passed to the I/O thread when it gets its work (e.g., `GetQueuedCompletionStatus`). The task is completed from there.\r\n\r\nThe only variant that I can think of is that the task is sometimes not completed synchronously by the I/O thread; instead, the I/O thread will queue a delegate to the thread pool, so a worker thread will do the actual completion of the task.","date":"2020-10-03T13:48:23.111Z"},{"_id":"4a418cd0-1493-11eb-86ee-7ff6dc1d07d7","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"bf45d4d0-1486-11eb-97f6-5775109d6623","authorEmailEncrypted":"CUEplcKTQqj/mph4me2djTzn6ayyqYVtyPjyKNgwpsq5TTs4qeZSFImCOE0fOq99qu82jJkGYy961xNag8hs7I97Hc9C37deEwJE2r/h5kVmXHmWL5KNeXy0TMCEuoKwJC0vfey5XeN9t5GNutVaaZVqkxQvqXfcAtbW6mVXiMFdxiUrDEe0dpA49rWzWBae5KBcXKfg+HxWsg1uS0f1UFOryxrvw+5NslHvvByB0PehCRxFm0f5xeTJNz5oL4wErspiaKZPuuJNyDMjFU2ze9dgEOWasBeRdQouQl9NCeqaXPoDVz7onT1oZEzWNJYLllslvr4KTb8B5A5dhhZszbYv7rzjPi+NuLK0GLwBdYRLqGGOBsgx8m2kYlGS23dj6KytM4EV9ciJkNoGwMCPE5XjerhSeu39K7VZ1ovQ4Rq/HooUqqvODHCVxO5cUQGde8hwltvq2j70KaBzYC7Y03ypHJpr7ymWQgbKxc860lg58R++jT04Zy6egsL8/8Rcut2+W4OoousdBOHd+zgLvEAKm5LTzXqsBvntPDwYwiPl6kFgp+dmymZeCfpO9rdvNf38nX+TGC7HTwKbe9Y3cFQMINiAOF3OhEF6yhMFVmk1sNheZrFuCkG0p/g9Srn4CUfLfdOYKqLoKAuOUYSk10rA7fjG1f9+VAc+hjsZgAQ=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"There's no contradiction. The multiple threads they're talking about are running the *continuations* of the asynchronous method, *after* the `SearchService` API call completes.\r\n\r\n(Side note: there's a mistake in the docs - `SearchService.Search` should be asynchronous, or else the continuations won't actually run in parallel or on different threads).","date":"2020-10-22T18:20:41.026Z"},{"_id":"bf45d4d0-1486-11eb-97f6-5775109d6623","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Sumit","authorUri":"https://docs.microsoft.com/en-us/aspnet/core/performance/performance-best-practices?view=aspnetcore-3.1#arlb","message":"Thanks for the explanation. It clear some aspect. but what happen , when you execute multiple task. for instance in below example (section : Do not access HttpContext from multiple threads), describing the multithreading scenario, by creating new task. It is not using Task.Run etc. Doesn't it contradict \"NO thread\" analogy here? .\r\nhttps://docs.microsoft.com/en-us/aspnet/core/performance/performance-best-practices?view=aspnetcore-3.1#arlb","date":"2020-10-22T16:50:53.498Z"},{"_id":"38daaf10-1878-11eb-b45e-83d58e3bae0e","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"","authorUri":"","message":"While reading this all my spoons disappeared - along with the notion of how a thread pool works.","date":"2020-10-27T17:16:59.694Z"},{"_id":"45d85970-187c-11eb-b45e-83d58e3bae0e","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"38daaf10-1878-11eb-b45e-83d58e3bae0e","authorEmailEncrypted":"sZfmzt7BvBrn+LW6Dcb+PI+WHTbNKl6w/Ogw4zFSZH3evGh2nrgzV4XtqLKyV86W1+VfAoHv3WSIMcHB2aOpR6wwgiTracp/bDA1mU5hKIRoSzeDHGCUuOJRqyOLAn8238LhefOy6OmrYvAcILMypkIkNB+WLQV+cVtEu4hUTzu/0Sd6iCpGp/ovU1l9YcUt/59jKCfKAUhCzXCi3GzoqlV+41+LPqWkBvcI2Wtqab3LX9+TuhrmowaTF1NzkK7c3hNQIb1rlO7zLc26tZvxVEwajPJKsWDF2YxZzJQGrPeiEotuUi/sXZN2++R5+jBgTfCRaBQk54OcLSXcmnnFYAqoLESzxtwG0pFJ8fL1uzfngB3WB70ROD10diG6kGzVPXl8o4i7fvRev3YqAM92D7T2uE8gzjnJSScchM3JVDL2NUvwAy4ddlGcuHBI2+xWyV2wWJuZNtXi6P2e1K7FVRbzOb7Iv1GHTH2paaS8MrSIlCuy0avAV3nWTAMHLspNBzC5XKvK42AsXcOvWC9hySBv62SFy+ES/itOgp/D7KGC15NrsH7mofyeyqCeKsRlgMwl+9yBVNJ0lcumgYb8Y5uyEZCqfiT3DEyCBINJ5M8xsC6/dbUc7hPOmtVwQxIO7X55AjyARO8Q4fip8koxFmlcgHgP8nMZTUXfEOdHSrc=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I didn't include all the details when writing this, because it's already Too Long.\r\n\r\nOne detail you may find useful is that the thread pool is actually composed of two different parts. The part I talk about in this article is the IOCP side, which has a number of \"I/O threads\" processing that IOCP. The part that *most* articles talk about is the worker side, which has a number of \"worker threads\" just doing whatever is queued to the thread pool. So all the work-stealing queues and things like that are all on the worker side of the thread pool.\r\n\r\nHopefully that clears it up. Those other articles aren't *wrong;* it's just that most people think about the worker thread pool when talking about \"the thread pool\", and this article deals with the *other* side of the thread pool - the I/O thread side.","date":"2020-10-27T17:45:59.493Z"},{"_id":"2ab9b5a0-d8eb-11eb-b968-d76a3395ed13","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"45d85970-187c-11eb-b45e-83d58e3bae0e","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"GoodMan","authorUri":"","message":"Can this \"IOCP thread pool\" be exhausted? And if yes - in which cases?","date":"2021-06-29T15:03:31.553Z"},{"_id":"82c27450-d8ee-11eb-b968-d76a3395ed13","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"2ab9b5a0-d8eb-11eb-b968-d76a3395ed13","authorEmailEncrypted":"MmqKNgsxbtiKfTCLFHlCwkUZjU6Kjvng1JtA9Gr91IowRMzV4dStGmK4Kd8i/19ICUX7/pWnusjk4rOB/BDa/OoxCAjZZgGt2X03Em54BG5w0ILXYII5coZFzamqm4GevW8NuWgBUcf2bpdfk5StXlOgeAsiM2OlIb13JhCvwYGkdZ5enausVjTUi4z8MG+MwOovdz5uA1LvElnahj54SQWrqGo4lCdTTi0wCUkfU8U3D0ZNXtdtL+ePRhOrd7Jn8dqd3m8xMWk5Ih2KWyi/ryCt304QCr5sKZOlxeDyzBX1YSr2hjphgZ1AeWL6WEjG/Ef/pUwvR30xnfAzxiubSrtsPACL2Z1WrQaaEEmq1FtlIXmBCfR2b9rwty+6CKvv7jbTP4RVscHSTCMguala+mWjbJDEGbDX96qUw6RJXEKqXdTmkQFkpAK4GbN2qeoT2Nrvhg2EiE0mRGWDi5RIrLzOYCoIS0HbgOu58rMLpYBLSX9K/etMfj2RORJs1lijQTOfaf45308wLA4UXjPDRJiw8hiCK8GSQMkZ1zO2ci/aFE6pGuy+yCjFEM8vxpmK5sN7qKhiBE8ecvd8RAN80MnElWa7NkdjgAZmD7GVsd5vwedbFkwNEJOcVzMXRpKJsBLRFq52M83cZhXeQPW4gJNoPxgUyG9J3Lw2T3qhXu4=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I suppose it's possible. I've never experienced it.","date":"2021-06-29T15:27:27.512Z"},{"_id":"e66d5820-d90d-11eb-99dc-835105134035","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"82c27450-d8ee-11eb-b968-d76a3395ed13","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"GoodMan","authorUri":"","message":"Stephen, sorry for the importunity, can I ask a few more questions? \r\nTalking about asp net core app, is it true that IO operation continuation will always be on IOCP thread, so we won't decrease responsiveness of whole web app? \r\nIs there any potential danger in using Task.WhenAll in asp net applications? For example if we run multiple IO operations (using WhenAll) on EVERY http request does it decrease overall app scalability?\r\nThank you for your answers!","date":"2021-06-29T19:12:09.251Z"},{"_id":"ed7fb7c0-d930-11eb-a9ff-3758b7ca93a8","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"e66d5820-d90d-11eb-99dc-835105134035","authorEmailEncrypted":"QPSHiTcwLQqfWy9zlfj7gfliKl0mKnUuF1WN2jNvRqz8fsfakQn3ents1aLUM5wnurr/FPEkeIHxnNy2UrXR4Uvs+KCH5gD6ecjgQzAljADSeCxO+SoL3k8R1SADzwXRTFmmevpyjpfqoik49sjJR48gZQu92gHkqOx/BwBXovr7DhsXjaIkcKMS+5Fymk0iaf4kYAFvCIMrqvsWXMPCJf379czRwlockgz+87iyj0ezHgyFw5lHyLM+bP1idVC8/TSGHw9aZXSlW8fBosJdgbKBOsTtgFXsGaE7kEFAZH/gt22iwKVxzwMY87HLRK1k7yY9v0bcBu6PuzuKBa12nw6lKEg8xZ6AsuXm+ci5Cqoh8lAjt0jtY2XOtS18ou70dChuNjAUlV6nMXGbO3HeGzMrUwAuw4thNSdnAZDW2xQFVrUs78C9Cot9ZCiJig/1QT5nx+N4Ci991L7m0fTt5O745E5FZwiomO7Hn2DMfA5nRUrNN7mRWHtDKLN5fp4SiteUilI0SFMJ3ctM3zZeCniabfl97gDOmGYSwVh6Eg8IcgXI6j21y8s1x9D4hc4x64vGFsU8JWDJhyui6pe6lK2bwUohlbw/8UVbFfSOjw1eSjmz5N7NMd7LZyBiqpNflfbuTuc6XdF8FonjSUX93Ko4Cg+yf52XWvJjWM0GM0s=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"IOCP threads are only used very briefly to complete asynchronous operations. Continuations of your own code almost always happen at a higher level, and are executed by regular worker threads.\r\n\r\nThere's nothing really wrong with `Task.WhenAll`. It would use a bit more memory to do multiple asynchronous operations at once, but that would almost certainly be more than compensated for by reducing how long requests are outstanding. So I would expect code using `Task.WhenAll` to be more scalable, generally speaking.","date":"2021-06-29T23:22:53.446Z"},{"_id":"f2d2fa50-0e9d-11ec-a66b-695abd059731","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"","authorUri":"","message":"Why is it bad to block thread in async operation? CPU has big amount of threads, so what is the problem, if u block x threads for y minutes?","date":"2021-09-05T23:06:49.032Z"},{"_id":"2047f8e0-0ff3-11ec-8300-835edbb2f5f9","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"738d5ff0-0ff2-11ec-8300-835edbb2f5f9","authorEmailEncrypted":"csnNCwiEafI8M2H8XdairlaZ4am3BwGRSxIQ834kKRXh+Wnw5Q31a5XoQdxAK8q8TDmH9lwVGnZwGCZZG1gPIiQZphoPER+cdLNkevX7gL4EuSO0gm5N0gk5prX/23Y4wGOZ6hqasEX5nzi1J6xwCRCe2oBwnWnFH3Ht3pNadJ31Aor6qrPTGKZcfU/Pp9vmLU5cSkaGRV9piLxv1U8nZKa9X/I08tcp45xcPLYawM0fnp41rjQAD4Gf467AO0EmBXl/5YComBcA+67ue1eocc35h765PqaJ03HA6SuU0gBL0uAkd7baG8r+xoYDZAwKS0La1m3sMaiKBgJqLL0aig+ABmQhWanwqd1qSaY5lbDO8/DOALEWbwiUW5Ubj9zi4kATifKsOj67MFy3gLtZVBIudd+X4DXn1m4wwTcUvuW+Gk5O5cc2EXuR9NWXcPbrx7ldlOK+DvemTb5kFsa6+ZtPhdzxYlcEGr6u1ozV0TK6k5L9cJcZ3Nbg0jB6s5POkYbpDnEw6lyjivM/adCe+M6PeKapODRtRKw9vkxyaE3cy2tVWafR/HFG1aTJA2KDjgoFupZtji1Ypl0TJTHNwm+Po/cSTt9V06LjlQEhR4KpyIUyBFek3PfvdDXITEVnkcMRjcrwAUNlI5sQ7UlVapF3P6yQH3p9FlusxHrxLlY=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"That example is synchronous. It doesn't make sense to \"asynchronously return a string\". It's still not clear what you mean by \"true async function\".","date":"2021-09-07T15:49:03.612Z"},{"_id":"2a57fd60-0ff0-11ec-8300-835edbb2f5f9","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"ae66e680-0fd6-11ec-a924-317c9875f3fd","authorEmailEncrypted":"hPZZuHMaJyNjya1ym56Nqo4vyM2rB9gYCsUWgYzbbAPl0Hc3n9/lka7N1mlGnvsuDgVdpI3Ho/e3fD7yA+bwxTuZpb+NXuxd5glp49VluQwMZtBcYvzNEx8sJ0qQfxsLDgxVbU8S13lLkRxtsJUcOKOc9oO5NZgGOJdMlam8hsp3RSWDl2CuR+6haqhgiGG8U7/2dYNhX0YBl0Mc+klcUuDhu28YfdehaUqHVdUXoihwyNVsXQcEaoFni2nGB6cGyzpp7AewVN1zMiAHyZwuxfaGru4JDiDqaGqFXxVVBOUraU5f5wN1DESk1/SWcKKuta+1juUBYH+E/+Lk8MoXssIKtxngp++/zKIs8ixacwU326qxPvFPxeEjhGPVaNiKCbS/LbK4S0LhqyGylgyoKMhisSqNvJO6HdlF1arXrmN6qJ/Vb+b3OrpX2joBSHfEgSOlp6GoJVsDt/PXvfEy2aEyhXFysUR72N3XhyIHnHqZ+1f/dEArciX7L30L+FlrTC0Fn5T5gzAHEw/yUGKTegfmBgJF3UNyCbVsRkkJlnGSxttnJ2uXiDkRJMNMa/DAyRqb3rnQbKz4eP39H43O42J7Qtuj9mwE4zIgOdk/Djj972uwjJlG6uO4awBbDOn3HMXhV911o7k8Pt+EJRb8HuzhqyuwlW53319uS1i+V5w=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I'm not sure what you're asking. True asynchronous methods do use ISRs to complete. ISRs are generally caused by external (to the CPU) devices, but there's also software ISRs, most notably timers.\r\n\r\nDo you have an example of what you actually want to do? I/O and timers are already done using ISRs; what else would you use them for?","date":"2021-09-07T15:27:52.052Z"},{"_id":"563e3d00-0f81-11ec-89e2-71c6940e3f6b","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"f2d2fa50-0e9d-11ec-a66b-695abd059731","authorEmailEncrypted":"q8r+/+YZsC0xgPAg9BTM7GygqrNZv85tPRsgRhmS4R4WVXhcwl/19MnaXx+YbknALH8jzwiV+xic7OoeXfEIKcrN3tBAP4xvG+lwmaCqF0fcsXrP6/qANJIsLgFJZQzcWUhkK63zszZgRM2hBsJLcQiEWxiVkiLyo6Ye1V01xH5muD1yRLJUkP8C/ctqkFfYCLHXwZn6AlYaNGMX59CVZIWLtcMEpDJ6CPb8Q1yW6+HGlUz8+2rmg+xBNhoRsuslKyrSuctOoOYKhAHKbxxM1j/ItMmRXZue6TfLVfsw2G7MASBYr8+H5eC8AsNCG26GfYQ5g+6Iqp7hGlcCdnM56R+2iiciYZuVt5+1XSJaQQDwAuAk7JNyspSXALaYj8PDD4EKrebcYzrWFNJ145F3IDalp9qMwpNYJn782EFR10/A27mCNPIK+VjUS+AnMgsL5zKY/rkCzP/pi6/aC5+bWIW3YcWyEk5y1xuWkUHyuSIfEZd5/3gsE0LlGh1a5F7Goug9eBE76A3vZvVYBpyMFBGluBoup5pkk2ci08FH2/raztdU4Yis+EZWjoB33c3m4lK9Ehw3hc85Gc6qvRl0W0E0L9WbDe9txdf+avDdZAB7w+Y2KBt+3tcS6/F+MtFCeIPzlbLMx+92vmNa39aeqahLuH5fAcCXr1yl1KVmaMA=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Blocking a single thread isn't a big deal at all. Blocking thousands of threads can cause problems.","date":"2021-09-07T02:14:31.520Z"},{"_id":"738d5ff0-0ff2-11ec-8300-835edbb2f5f9","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"2a57fd60-0ff0-11ec-8300-835edbb2f5f9","authorEmailEncrypted":"ZUSwC6KODQS1tyv87whVAfOFZvM4R1MXcy3ybeJ/wgOlPLVlPJX3a511pX2BfUByzg9uHR4r8ktfppqIJkYDMx1OjDI4yCQ9JicdElPZYZWLpSnfoCNlTWHsJA+FIp/zNUHJ28HCJv1Q9RU/gsXp1V0jwoVZwh/CmfyJbKu0Z9S62vrqOYVlKDWNIHCIb0CItGOobkeW2D6C3EQBrLcSQOwR9dRPqXZMhRTLkw91svzMpoIrixw4XdZu5gO39KMZ9odn1FxX+MpAmh0fxeUvIXs8FHf6bVTnUzhrtZKcnTqacg+6MQUYTvE951PKVmBaNWCXE7kOn+nquEzIegWZJFPy8lSX0BpAMw5Mpm74ip9xsCHpfhE11SfRAy+eY5PcsYDWlrmzjRI/e+MqUWeGr9J2RpMoD7MM7MWNynJ3ERgxLjwMQCKb8rcxiiGwGCgDmwyCy/tPXVy4DRP7HD6pUTJGbGDp78/Ngo9Wy73go9aWZuB3elFhhkc5Ry738L7Y68Xbm0uHJVkUVm5tkVWlREAIA9Y5caIWauWQXfRYNPUD8v9vq1hCCccetVXfbiHRWoJR6uok3BMxgttOnuiDcUz0kEUNGeTFOfrlmOAqlSe3QZphPVQs4lHfy/WSLTugxh2CF5wI77RaniSzKsroGoEVSPzBU+xKgn/PMZsdcTU=","authorEmailMD5":"d89d54c2ab59114cdcbab137cc8e8a6f","authorName":"Bartek","authorUri":"","message":"Stephen, i'm talking about possibility to create true async function in .NET. in example i want to do `string GetHelloWorld() => \"Hello world\"`. I don't want to use any thread, just want to handle it like external devices using interrupts to make true async communication. How to achieve it?","date":"2021-09-07T15:44:13.877Z"},{"_id":"ae66e680-0fd6-11ec-a924-317c9875f3fd","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"563e3d00-0f81-11ec-89e2-71c6940e3f6b","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"","authorUri":"","message":"sure, to be honest i don't want block anything. i have different question: why we can't use IPR signals/interrupts in OS? in example i want create easily true async function (with no real thread involved) to do something in OS, but i can't, because IPR signal can be only generated by external device like USB toaster (if i assume correctly?). why Microsoft doesn't allow to make interrupts? because of security (viruses)? it's shame that we can't easily create true async function. do u think it's doable in Linux or in some other OS?","date":"2021-09-07T12:25:26.722Z"},{"_id":"09102880-10bd-11ec-a397-cfa3a6921b26","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"2047f8e0-0ff3-11ec-8300-835edbb2f5f9","authorEmailEncrypted":"JsmoBWrg4xtDa/1aDjI6FJbV0t3xs0CwrPhVgMnfBBmLGR1QrWpjJG4bggNCGStNtYLAaqpBQBK2/AEsmeAsuqIRZ6jbqMxYlKwTns6H6kIKocQ75kRcTKrpFGSQOqHJMOweCf24Wa/CHghSbMpK41fLQfhKtlSzqnmo5t2nPeyjxb9JgOn1iw9o44F/FaZG9BmPmYAQPeMqKJsM4hjneHUce8m11tjzLeq7WEynHov0z/NSJZ50rrJ4tzYPHNxXiSZMfDzC8iCJtVM53bXO2RcOmaChRjWHPNqRb9SliQ2mCHWQw/zv5fA5a0zT3gZcc3FHD25CDmT+k5vP8ouSu2ToWsH6t8Xt64eOoxXS5OvgyE8vOy/mCNfmmAihztewqWfNOm3hbaIl+5SV7NItdxu42eEGNkkMs13Pj4emDrwyFTsmr8ASAvwV/EU0JKYwWfuzLIn9FOkOhpruVtMkT2DEe/KyxCw4i0onfQD2yrgm33YYDW1egPaa5GMICeGKIk31qWvXX1OK1jOrPhxvcvtFcwWQAbWE7fjVZ9BJ9SspV/oXtXTAwQmDK800+FC7hUkwM/h4CXnRPdOxSGf+Wxv0l3ngSsEQqSYKFkPSf2lhSatNFCrpdy+cWd5AMjkZygikAGmkQeR6ds+IygQixW6JqnEUB52rc0N/ODkodro=","authorEmailMD5":"d89d54c2ab59114cdcbab137cc8e8a6f","authorName":"Bartek","authorUri":"","message":"i mentioned that true async function is function, which doesn't block any thread except IO thread. how can u make function like that in .NET beside of blocking another thread (and i talk about making ur own async function, not using ready methods like `GetAsync()` from `HttpClient`). when i told u about mentioned `string`, i don't say it has sense to make returning of `string` asynchronous. i just provide it as example. when i'm doing `async Task<string> GetString() => await Task.FromResult(\"example string\");`, we block some thread and i don't use IO thread nor any interrupts, which is annoying, because i want to use these mentioned by ur post mechanisms. in shortcut: i don't want block thread, i want to make it truly async just for sake of example. i have impression that high level programming doesn't give option to use some low level mechanisms and we are limited by .NET possibilities","date":"2021-09-08T15:54:23.073Z"},{"_id":"7ed12870-10be-11ec-a397-cfa3a6921b26","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"2047f8e0-0ff3-11ec-8300-835edbb2f5f9","authorEmailEncrypted":"dpEoeDJKV5MQopOW9qvqDVsPi2WcwMJeT2KHoVJj2308+1Vs54SVCA+dv7D2p650iCN8UA+rcVx5pn24kXdX2k/IvzWJUXgllvbGSkWpH8xAnt8UZjKwVooo+vp0Tau7/JyUsRM82HBNjmKQRXbQsWGCQaFRFZTzARvCM2JhJ8L/2D5fq4rObowWO6/xULJ7529rVh1GpL1ycUZTeBcwpTeqXjmPXT7bxAmf4c82ZYxTWt1dcFyPUjQV//8d+G0yE1AN2RIKRoR9HBItUheQTzHejbBT5N37uYLDvmGII8L6eVgxBJJNvF7MIwDby5EWw221uNVWXeGkXZ3eLV5WQsY/GVzGNQLULpTGTRyPnQBVr79MsEv5ngPryEcaawnmu5bMTCqpT7Gsu27Xflelkc8I79e2tu9D1YT6jyV1hDeAhcx6XZCcNWvq0WQql6754n3RUQZSKsY2TgQ343MojL/elw+fcga2VXSHlQ1HW7xWzADtCDCcaTa7K7ZNVzDt3/uHan7RDPWbSLTUA5OrjfR/k2Z8MjvADZ1NLthv7h+ut+xn/5n8OQzMx1VV/FRsHHfgIA2jCXFx3UHKgHON4Gz5A5K07ZTaw4b3b5o79s4UChYseytla/RiVLz1mjvrMnIknT2yVogsYa3bQWqrjjNBmK5Fz8VF+qVaYB6gcAo=","authorEmailMD5":"d89d54c2ab59114cdcbab137cc8e8a6f","authorName":"Bartek","authorUri":"","message":"in example in WPF application u are limited to what people call offthreading: when u click button, GUI thread have to call another thread to just block this thread instead of using interrupt combined with IO thread. i think it's bad and after clicking the button no thread should be blocked.","date":"2021-09-08T16:04:50.056Z"},{"_id":"e5321540-10c1-11ec-a397-cfa3a6921b26","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"2047f8e0-0ff3-11ec-8300-835edbb2f5f9","authorEmailEncrypted":"i7F2X9lhvT2hictgyAU1DQ8RM37UX8TuG2kUSUY7cZ7p1wAKjVaiStYKa7f2viziXhkvLIiql+xtr+GvfDXtHOl/LOwDi9wveRZiXkTSpF3h1gGi+3h7GNdTOypKYY0Hd8CEsLhP4ZtkH1a278s/cfr4C3vKKAhE1RU6FWR6WCmS9pY7V9Vs5CjPi6j2x97J781mu3gm7h7qEHWxHjVulSkXDdvDKVHAR5EG4M07VqdxaIibAnGUhQhjdB4Qj/vdN+27YZEUJm6oobT7tgCHAIcqysJr9/scXBDnBiWjnk0OvYaucU0qK4URrVnB4UEM/mD1pJC9d9LVva2jmw/NC9QjBuTsJAWAl5QRQBhKXwssdv4dAd3IKYsheXWfyjmxACUc+ebaG/a2hjGN96K0NvLYJcKBRp8wcPBhljBhv03jcGygyMysF/vUkeKRXycZA3CNyfGq0mBldPsy4lZdoWDOs9Modan2t1Tvnbi49td8mOQZgKYW3B0ZkP1dQ7muj2/7Eegudb4xtcmHzOpwF1IyQDQdLFXD1FRBpj6bQw5HAhy8jJ+JnQ0afqudqLleCytlci+JQPyhg0yA8NvPLnOsIQ2jiVOP7wiDCaAIkBjJBL97D5dNeYkI5dy721rgtAXg+WwZhecxOtZ2dVno+KkWGCa/N3V+5DUHUJ3xNjM=","authorEmailMD5":"d89d54c2ab59114cdcbab137cc8e8a6f","authorName":"Bartek","authorUri":"","message":"https://stackoverflow.com/a/24954136/12262729 <- in this post someone explains, how he achieve, what i mentioned. what do u think about it?","date":"2021-09-08T16:29:10.296Z"},{"_id":"8a5ebfa0-18e7-11ec-88d7-435a48a028e8","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"DDDYLfiGlBSFzW80Tx1eTu+8MCo7yO3Xabf3/e2ysI00fc0WVq1Ep2+rhIwxbZoD1watxmqV7MO5+KDpzpKMnkA3IRc28EqDo1McQPHP5g9L+xxa5RepnP7BUJYKcNIW7i501XteNGLLMg1F/NMJyXYONvGg+PXbk3scl17Bw+CJm9OvU/vX7IOO7SrnjND5fKVY0fASPCPAXpk50MAVnN82cObLCUzmzKMOtTF19XfBbTHQHW9h+f7Slj5dE2KQImv87BnikRrYKYluK/kqN0ytVYXn6SeTBACeGbVCvteZDsFXGM/ymie7+7Rlh2DVCa6zFDZwf8ZjfAK7qmD44ZA6g8OOktiq3q1bRwx4DuZdYCwIlJQ+LPtuAXKZ45rdZPvlsjpXBhgt+/K1wzHx+j9eokQ5I3TdlxgP6bZ3U5Sz607oTa50ISUmHfdxWhzgYygoDVvSw0Jthvr5nnAGqjD3u3YnLlvzGpAsJnBptWQcMkO9EfsPOYB9nkjMpoVSaq9MwbkBr2Fr58/bz4ucFU3hUlL4P+xuVTRM5XIxC42yFSbVx5sJmS8aX0antCEXNbXZZ/npTLR6aCpxUIPqDkQ9a3A16fb2R1y939MmWHnSNgRTn0R1KjF2lr9H+O35tK3mcPn3RCSD1qPP0ANlBgZWzTPGirREYVrRyBw6Aw4=","authorEmailMD5":"d89d54c2ab59114cdcbab137cc8e8a6f","authorName":"Bartek","authorUri":"","message":"recently i asked u, how to make async function in Windows. i read about native overlapped structure and if u want make new async function, basically u have to create new kernel32.dll API method, which is using native overlapped argument. therefore it's impossible, if u are not working in Microsoft. in .NET we can only write wrappers to existing kernel32 methods. tbh Stephen i'm surprised that u didn't give me answer pointing to kernel32.dll IO api methods.","date":"2021-09-19T01:18:48.169Z"},{"_id":"616ae5d0-1e08-11ec-a9a9-d5ca1d3edabb","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"ffd87530-1dfd-11ec-bdf0-17da55d99b68","authorEmailEncrypted":"CdlXetY0hT5QJktcNxsHUXNKU4gFlmwB1OJxs2xGdbqyCg0DbTz3Rx0z3800M0JXteJ1+HLMT6AHoyZ3Nbytpje3XeFwAk6FwX2uZfRDSLN8lY/j7z06jDmu5y5OdSc2Jd1xEVO/1sCd3xgLQ9wLWTc5iH0NSHRzGBTZBMFKR8cZ9w5K23/DG7qkBbTsVXFw15mmdxZFY1twC47gW+VMEatEbrOAgXclRc8eYFCq+SYPGUKK6RECVejs+2/waa4rw24vRmOqlCmyf5PS3EKYkOCvevaM7NSlAQ1KXBSdgbz5TYf5TNRcANUrqMAfuwk1LqHpBji46w69u9KOBwOrQisNTSzuceJOFwqzenmr1s+aMB1rVMcwivxHCjO5UzJB0wL4FRkpsOoGFiz5tSagVFMfuOTWKC69EpU2vYLJtMkeRFQrwCeAKRoTy2JMZcGsiRsse7+RuojarT5jMOZiYMU+WzJNteUEK3ZYtsyHPK2Q9K1/7OrwMa/HRJVS4bDeMnrCDYlOuhKf68bLXMEev7YtAMmgvTUOT1X9g90OGwyAOoy20LULyPOl8ErUzNh+ipVsXGqDpMfCKBrJfIHLZvSZUpktuTpgWM4s18J8Z8f8ctrufValo87K+l9vq3lTGE0bK+HI4V2cUbkPdMhkKvWWSgAn8jQqeV4jQe0uASM=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"That video is a very good description of the state machine and how it works. He gets a few minor details wrong around the driver / thread pool / app interaction, but his understanding of the state machine is very good.\r\n\r\nThe main difference between the example in that video and my example is that my example has a UI thread with a UI `SynchronizationContext`. The video is using LINQPad, which is more like a console application: there is a main thread but there is no `SynchronizationContext`. `await` (by default) will capture the current context and resume the method on that context. In the case of the UI context (my example), the continuation is scheduled to the UI thread's message processing queue. In the case where there is no context (as in the video), the continuation is scheduled to the thread pool.","date":"2021-09-25T13:56:28.630Z"},{"_id":"ffd87530-1dfd-11ec-bdf0-17da55d99b68","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"n/kBdIKUGqWPcwK5TwFZ++BtBrvMgClHLyNQVNwZUG5oll0PzJQcoE3CaF0TpYiQA0qk2YbzMRMa7IjFJAumhCLJGbAIr4q3S6ehgOUgaib3Z4pYaZtBHf1qeDtsK+yTugG9McgImFuF9Sa/vC2/ujF18d0f3T73AOjs/GysK1H/isEcoXq4l6xIhYXqJi1bzzWMa9I680vkbIhsCSy+4V5KSGsnE/zGYOmbBxBBdtEi7PD3jCOg5wr4U27VWYVeVkYzn7cUEOL8Q5k2I7ZiUGB6zmVLaRDk6mEFKZ6icN3ALaUIYGhB6g35ScF0W+VPBs2V6FIqtvkZdcJBPffD2zQuEjVwZCj9ccXUe5AfvnjKh0a79/KBcqGBoIxCnERctuh9OIL10V1yj5zvlzQNwl2yBESgQw0xgKfKaODc4EcJdDuWWnavvVVKbfxJLm+Rc+X31hVgL6Yag6ZoXNY7FrjDEZ4n8Y3DbZG8DhJ3O4v0GvvLH9BPOGB+AGLLi84Ol1Mk+vZ2hTEhaedi4y3uH0i14uiiifLtk8b6HrhFC5ggKO2yV/iwsdMEdY28UpEwXgU9bc5uv50QIPE6W89caAv8O67nVdteuvYLvV577YvBELvRjzyudUgxL707ZUpUmI7oIHrPxxgq41IbaIB8j96gQyZzm5sYIPYBDD5xO8Q=","authorEmailMD5":"b4de5f8823782d9f4fed557ec73d0570","authorName":"Vincent","authorUri":"https://www.linkedin.com/in/vinh-tr%E1%BA%A7n-thanh-quang-85597a158/","message":"Hi Cleary, such a great article, however I do have a small question here.\r\n\r\n\"The task has captured the UI context, so it does not resume the async method directly on the thread pool thread. Instead, it queues the continuation of that method onto the UI context, and the UI thread will resume executing that method when it gets around to it.\"\r\n\r\nfor this bit, if I understand correctly what you said, does that mean that the UI thread (main thread) is the one that going to resume executing, but when I check others (e.g. https://youtu.be/il9gl8MH17s) I see that there are a new thread that resume at the await keyword, while the main thread is still stuck doing others thing. \r\n\r\nIn the example above (youtube) you can see his example with the boiling water function, I see the main thread is still busy itself with a loop, the Boiling Water function have already resumed and finish on another thread\r\n\r\nCan you help me verify this bit ? Thank you in advance","date":"2021-09-25T12:42:09.977Z"},{"_id":"eb72d940-1e67-11ec-9450-c35d41a02b84","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"616ae5d0-1e08-11ec-a9a9-d5ca1d3edabb","authorEmailEncrypted":"FXBRid/I2LlrLlb/i13LAaRq0HYyXAkg3EiZUyCBeQAeTb/xZTz6kfPCoPmC9mKiaFmHPO4s/Uq3ifBLg+rXn8/Uhr5ohzfNOhz4NNZOtxToxoKw0qRLY47d41j8E8r/UYe1XrOv5fGtVKvgbCw9hWfIsBqWvgyGLo1lpQOlJTHbeylHK0oGuY2TjOiJRTVPshz807p3rqbq8YMhLQiWfCnyRwgbiaoFNhiAXWrRftB5Q2hf2jri8j6xT2M/HcCiHo0TKY6tT4nK24HLqW6U7eC4uD+JsrrdgN2aMVzyOFwXII09nzwJ08yIvhfhXbteRHeQFIlvyjJgyFSVBWMvwtKrCMhxFlB5KjjbSumkRWp1XRbWepoQxF6cI6F/QMgwUA+Hw+gvuI/9SQdZwT7GqupD3RBPdzZZzrpTLGMCh+JQ5nkJG1stF1CfG0nBTYGj3gScPXkKIHXRoQc/WFXvwx6QXO1BqVsQJUrTKvZR4nZfONyg/zi393TG/OGSyk30f4kqgbNYLl5up2GmKXpOKCJUm0LxyZSe0UR9h72Ipyxk7JzJ2oTFWR/ASK2aAQP9GhiUEksW34b3kiJFkTCYYUgvR8QBrm4jyINJJoo4CKFZrmnUE7vGdPvgqpwzUxuikvso/OGNyLvWWLx+1otr6sjexUbCjGADzWa6Gbg+FT8=","authorEmailMD5":"b4de5f8823782d9f4fed557ec73d0570","authorName":"Vincent","authorUri":"https://www.linkedin.com/in/vinh-tr%E1%BA%A7n-thanh-quang-85597a158/","message":"Ah, I see. So the SyncContext is the one that make sure the which thread resume the continuation.\r\n\r\nBut pardon my ignorance, then how can I determined or know that when a SyncContext exists? For example, am working with server side app, Web API, and from what I can see, it doesn't have an UI, so does that meant it doesn't have a SyncContext as well, result in a default SyncContext(ThreadPool) for all of is async await operations? \r\n\r\nAlso for this bit \"the continuation is scheduled to the UI thread's message processing queue. \" as I checked the your blog on SyncContext (https://docs.microsoft.com/en-us/archive/msdn-magazine/2011/february/msdn-magazine-parallel-computing-it-s-all-about-the-synchronizationcontext#the-concept-of-synchronizationcontext) , I thought that the continuation is queued on the context itself not on the thread right? or what you meant is that SyncContext in your example (UI context) is only have a single UI thread, so they mean the same thing ?\r\n\r\nThank you in advance","date":"2021-09-26T01:20:22.461Z"},{"_id":"3293abf0-2094-11ec-b6de-0771f40ef796","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"eb72d940-1e67-11ec-9450-c35d41a02b84","authorEmailEncrypted":"itJ8zv2XrhYqmohpK4bREBmuldzQyPn1R4buDWQBLGqXGwlT5ojYxN3Q0Bm3HvuEYMrbHqPiGNyS2lGk4tYNv6ZoRuMAejwm6Juwlh75vbYRpwuIQH2sZowF2EXB0l1swo7LOs9BjdQy0FsFyEtzGdcxpYUi1k+QEoz1PDfXfWZ+/sgdc+WUhIA38XgE4/x3LK2b3tDkChC7ZHfzB36TSM+D9VeOmBLyzkFigItkE1teEr8I0zb3qsdxAqezHvz1Hn/NXfIlFfs1PJV7CN8zQY2y4f2kS4pGnzslBmrNlV35rEnaxV6DDLyHof41Z5lv3AGFuYB9xRdbPLmze3eZglD6ChSvPYVg9DGzrYfDD7ukOUoUBH61A1jWA1fWs3nhW8Mpu2WtOJcx/ZxputNTAgpEGqb83ChqJvIC5dTRNICBIOQQvjIQD66TTxIVkSFECZ7e/gXMDzmocFp+zRWGQzVRbh8mWRnvIjdQli4HQmuoJTl2yiqzpPtRTyYsBTlVMTeeF95Mf28Pw73g/uiRuI/a7ziJVrjdz9iWKu4LHth0IfK0mEBMrnBXYEKfh9xcgAbxZuTygOG0ikLu+PRmNy1FzXOXU6mJEWvPAslQgOAapkC0eWJ/wAIA5Wm1EWFWGwix2FL2OBzjuWuKquEzFgr8pKCh77hsdaz1GobsJiM=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"You can check whether a `SynchronizationContext` exists by checking `SynchronizationContext.Current`; it will be `null` if there is none. You can also check whether a `TaskScheduler` exists by checking `TaskScheduler.Current`; it will be the same as `TaskScheduler.Default` if there is none.\r\n\r\nIn UI apps, `SynchronizationContext` is used and queues to a specific UI thread (though there can be multiple `SynchronizationContext` instances that refer to the same UI thread). In ASP.NET pre-Core apps, `SynchronizationContext` is used as a sort of wrapper around the thread pool context; it queues to the thread pool but the context handles other things like ensuring `HttpContext.Current` is set correctly along with the current page culture. ASP.NET Core does not have a `SynchronizationContext`.\r\n\r\nThe `SynchronizationContext` is what is used to schedule the continuation. Contexts generally do not have a queue of their own, but rather queue things elsewhere (e.g., the UI thread queue or the thread pool queue).","date":"2021-09-28T19:42:21.897Z"},{"_id":"eedfb650-2094-11ec-b6de-0771f40ef796","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"8a5ebfa0-18e7-11ec-88d7-435a48a028e8","authorEmailEncrypted":"FMLC2OYNPr1OszrdYpHe07SjPT9IAA+OWC+naezfSfpcEOsK4go7C7CUtMkSgZ3cZao2G9Umb+62S+5tbHgKopbwQFQTIM9JyZG6my8OsRgD1DRVrtJLMV0TqDBx6CTkYxCZDqNVOYISClBbN6khvGdKWZh2QaOCV+dIgw92g6ZuA30NzhvL2JQmnL2pq3S62+qVU8dy7ZXK3FWUAggXnrajUSAMywHGC5gfzdd+IMxHwTjLqF6QOhD7tOpVl2gngUHYeBpjvzpp+r+qX/by3f1okdnCVrWh5Wb0llOkKcwJ8k/s+xJojNtdVWqtHqR9wLbhH5vfyExSXijXBLUJeB8r8Jf0AEUNkS/0AT3tRly2Z+7AbGysdKwA65N9RLLYZwcbGekrmfH/On/xIOqj1ft3PBZq5pkJ1E5ZvuX2xE1M6zhZNp8wDwSLg3UnYGoXkMAM8pdnO+DCszDk+yojH6r3m/POgmuA2/xgd5i3IY6q1vL+FGqTfPS904LTpmR28BIHIn2QVBEgLwpONgCb8dNcPHIxKSBdKUSfGn2je0Ehq/OwGJ/haxABDOvLbpDZ/uXjSxiSS9yzv/NI9IrhaynYTdMCFFJYla45BDTclkg2ecSQVQytzbiUfUMUN1MoB2glNO2pg24GVLpeSyyyjPZcfCA8Z7w9uX8N8Dqw3cI=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Your questions are still difficult to understand.\r\n\r\nIf you mean \"can I write an unmanaged dll that uses `OVERLAPPED`\", then *can* do that, but it would be very difficult. Alternatively, you can write a software device driver and communicate with that using file read/write and `DeviceIoControl` methods. You would then consume that in .NET using the IOCP built into the thread pool.\r\n\r\nIf you mean \"can I write an unmanaged dll that is truly async without `OVERLAPPED`\", then the answer is yes. You would normally implement the asynchrony using callbacks, and then consume that in .NET using `TaskCompletionSource<T>` .","date":"2021-09-28T19:47:37.852Z"},{"_id":"317e0d60-222d-11ec-920c-05162edb158a","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"7349a5e0-222a-11ec-920c-05162edb158a","authorEmailEncrypted":"SsntPWLvSaP2SPIeVoAlYAv81GXmRk7L0dp5tSiWyjO4dA72y07Zt3twY9ehAhZY1Fn+U0RNaHrGaOaQI5dNYJTVlfJCYdDCbLcthzgeg5U4xoBK3p7Mbv5BVN5PqdhYWgw5aA2EkO1evfNAM12YcEAGZ9vi1yJsfz9/Jxl2iJnK9VcmKb1s0hW4gMK4qIa9VVJTIcJwfwcriJB15Qg6Sj0NOK1fcJI3qFDNLFT995hBbJ+26CX/lf2pFRq/QIyLn21HRDL24/HMmMqfV9tjqRYz1JPPB4Ll7mWXhPuyYfmVWdJ+DgcOI4gaIxdOWiCIGD7BnPN0R4Hh7g9DWMwr37oTuAOmnSWLKpoaDyEHavhKatO2Gd0dGaJZVQ8JnEZN+9Od2QJdcG7PKFuQBk8KKfzBbpgF/nJWIwFJAxqZ/sEBcOeCymPNA1RHKbIlrTgEyHPB3cbfLrKbmgTweP9pjx5Qy9hNPJ80DrsC0bH9QnqS1alRPLwvDxXieY3/RfTV94CidpykVigcNFos8NxnZp4eun7vcJR+Hq+0NBQM4hzib3mjgPW9MUrG/nxHIiDQ6VyRPCQ69WRZqPbegfByMRWZK1DmGYoT17kFy9+oMDt+5fRFO0VqxbE5UqSVS5uIawaDPE9uVW4/d/l/igDiOLoeXG0SLtEQ8isEKGODgwU=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Why do you think it's not possible? I'm pretty sure it's possible, although I've never done it because I expect it would be about 10 times harder than using the callback approach.","date":"2021-09-30T20:30:04.300Z"},{"_id":"7349a5e0-222a-11ec-920c-05162edb158a","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"eedfb650-2094-11ec-b6de-0771f40ef796","authorEmailEncrypted":"VG8O76XCbPiKrp2KU2JS0jaAYTe0QbgBttDZJI4VEYaYtmI0Ke8fykpiJSdBM+vR8YPHKZ91+dZh+xVAf3+mEOuzsFKtsr3Ec0TMZDyAMrSVYVOaX2HeSVE+6BdFgUcf5w26ukj+mnyZWY53shL+tikKuTRXsbLSsTvQhMdUjIV/UIcw7YwO2j3p8P2oJluj2YHCR4q23d3mGeb7hbzuhqeW17RsaWNpGEsLUox9fCcFKOcRCrER1y0THtGo+YPzupM4ECk6dbl38nMcoXncfTRXCjj30Ly9WGxz7X+vgr2TI7cvqHlY1Kq85MQ/XD5Fh4BfT+ZNQKahxaMTPupAJdupiLAzLzsE2sBs9iVSOeJRcYr9Z35Moq/5R28y1C7QRmphP0awymdaiCWnpYoEyfsgK3qLoTnfQ3UeXSlNmk38MF2xmaIhZR9KHco8GL+lnYE32qRfUQVkIU/yYWfPt4aWSAb7beoEuktlvxuswG1LlfdONYv1fxokk45b8rpyJarLAdgmUALxybjqv9sUAF/Q2NTLr34Ex5kpRf1+IT0YB3WrrCVcMpPPEDzG0IA27cPQ7jfUZQiHgfDKAexQibTW8qiCyVnJZCYgekodrZsacjHYTbBvFvPRST56gvoj/uPJ3hCIqJxyNkE+V6I1iPtTnNgQAMDUiGEruKu6AqM=","authorEmailMD5":"d89d54c2ab59114cdcbab137cc8e8a6f","authorName":"Bartek","authorUri":"","message":"**If you mean \"can I write an unmanaged dll that uses OVERLAPPED\", then can do that, but it would be very difficult.** - why do u think it's possible on Windows?","date":"2021-09-30T20:10:26.156Z"},{"_id":"c1e39630-223d-11ec-a325-753414598e1d","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"317e0d60-222d-11ec-920c-05162edb158a","authorEmailEncrypted":"XRus6Nl+MevvEV6GaeHgl6/vAhZaqlGkY2DCGaNaWpbovH/6lBMIuis1DGPKdjBqr0gpJ5orUExTMJUIA/s06L8RrBD1pbeJ7tBQXnUi6xvKrtwtpGtMKb5BjNNG/LNgSH+IUMT7ET/rn6g0Lx1FcDuYAmnht79n6bIdpzd4yOokEYdFeTeSWCQlVAdtNsB11kKnTPPrnVPYEMjbYawJkWqN4pz65daHs4eIlupW66BYgS50wzAWF5toT1iB3apXi2vvzcUja9OC9pXHjLTvxS4hXfLZuMf4RNFpbcyxxMi5cFbEAhz09onE/Jcj3WJ5tXzsz6GvfYmU5Q079iLmg75GFa9t6p2TKxUDaY0vjAXmP5VzqfHSDOlv0th0oylgl9DhKs8lKS0iKoIw9SrA3CXkRGpwPCUEQD4AUwdl+vb7diDg4sz3ydiE0Miikpku0JvFDWp8HTRXasBwZyg3DYSI/qMgyVKJhFaWZSiSrUUC8FMOgG9uJYZteC1GtduMaiciPjE+bMf/1Dp/XHOL8j2FeNBTSHASgvfsJU7NFUp5kaBYlUG4ssouFfrlVhgN+gBGs4xmAuiwxUSQjV8SYVqJcgzFkZHExm4X2lxJCQj+59mAeMsMXjXvo6VXtnl7AEi9hxCJqXBEDpPC6kOyPQLYfjBlx3bF7y5ZxmOxHak=","authorEmailMD5":"d89d54c2ab59114cdcbab137cc8e8a6f","authorName":"Bartek","authorUri":"","message":"I guess it requires access to kernel of Windows and Microsoft doesn't allow it. I wanted to see code of methods in `kernel32.dll`, but it's not public. <br/>If u think it's possible, can u provide some idea/concept, how would u start to write unmanaged dll like that? Do u have idea, how body of this exemplary method looks? <br/>https://www.pinvoke.net/default.aspx/kernel32/WriteFile.html <br/>I'm just curious that if u want to gain this knowledge, is it necessary to work in Microsoft or is it necessary to look into open source Linux kernel for better understanding of topic.","date":"2021-09-30T22:28:38.487Z"},{"_id":"cfd2faf0-223e-11ec-a325-753414598e1d","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"c1e39630-223d-11ec-a325-753414598e1d","authorEmailEncrypted":"mo75BL9nlbm8SDjZ9L1jZXzXLACr6bK3wiEOwfQ49fnarLmCFGQQJ2PwJaCzZ08nCe7GYjtveNc/9TjIpPDxExJMg3lwsnAg0l/OOGF6DSbSUNqblfBV/uyjrh+OhoMcg8CM25AGyct4y0jL/5BVCBaW66mmxwRU2VndAfM3Uip/4z4L7aFpAVHWshUxkxFtpKSYHYiZ9qFpL5kkjBFE9dztNkxofhXe9ik2G9vYw+h70xnaiR404guQoXQ59u0IBknjbO75//wC0zkqkWvjHsGOBqo5Zm16LGxqP+nM9n14t08bDM0VHIsiYDRQBWtPgzeJfOF6gfDmoAF6LrTUVdOR4gPP3PciTstFeT2KGss6bv+7qcMgrbF12TWAsfHv21Zcz57unBloKoFCXKYJJC4XlB8Ps1iZgOCYUVAaLek2HNRlXRG4KjhpFm+M0eH5kRvRIhID3yjpDmsIHBPou6lMnnwJj2HRutP+ZizXprcpwzIWUeb/XlbE1OXV0EAUlro0JvQtU89RU/FoHWDrEJ8MeJ9DsYScoSqgRL7eWnPQOrU8e2wks1/trQwCyGsEZqeXsxwOmuh0gb108P6T7wfqWWXsfqkWlbrbsGfAUFQAFWd2wblNMAIBZwUfanVxjj1fy68dJr+qW5SZf9D4smxadDJHYvDaxA7vq/3qmSQ=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Well, a good familiarity with Windows Internals (the book) wouldn't hurt. :)\r\n\r\nOverlapped is tricky because there's different completion mechanisms. IIRC, the caller has the choice of either providing a manual reset event or a callback, and there may be a third option I don't recall.","date":"2021-09-30T22:36:11.318Z"},{"_id":"3849e070-2dbc-11ec-8a1a-b35861024157","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"3293abf0-2094-11ec-b6de-0771f40ef796","authorEmailEncrypted":"VUYF/a9Tejm5aZR5z1UrQmB92/9FNN7GO+mgw/BboQ02VrwaPOo5WnlyZcaQnNwY+Dd5CBWoHGJ/RFq8/49kPuRZdlnSqwYc2jWwUwKrgmiTcdwVfu0DtLMvT/YpYEj/HYy89hTmPJG4AkVuFQYdZu3A5AIJCInos4mBmAx4ZTHxZnyNZHDChEbDZf1YFYJrhkmvvsqnGBU4vCjmMJL8Z+3sYeyPJse82GUVrwIW391z1GutcOV0oQYNIrIt/y2nZoAxqKV7riPtG4pgOYPBs+LylmmKJS64j/WEgKFES16W2N77UG1Jd3dOtQ4adg16+HLyliHxDDSfAfXkkFpco1Z4TyicZrB5YsXw0ivuF2ptNTtfuNwsgFx7W+9mXWZDsSFT0Do76AV/ydjvhUzkgnMPbBuYijGl9VcOZ2liMatIl/6i3B2bNgr9StfqcokoRF1AMx+BH4qXW58V6ouIRKXCXc7EcmPaU3ix7bmz/XAQUGPxMNANdiVezAjfx493BZdpLDyRn7U2LmPWwL/jL4vHXt+epKBk4xe6BvuFeZL365zl9Cxsew8dR8dQmOvAURWBVk965zclWiAD6cs+IUW2/EC29sMezHFU6M1Z5j6MPbbTvwuIDa1p5z5tLiQ2mMsGHpzCBKSHAUNjSGhQXFD1dNW7xU+svMVAKBtyJtw=","authorEmailMD5":"b4de5f8823782d9f4fed557ec73d0570","authorName":"Vincent","authorUri":"https://www.linkedin.com/in/vinh-tr%E1%BA%A7n-thanh-quang-85597a158/","message":"Ah, so that's how `SynchronizationContext` work, tbh in the first place I started with ASP.Net ,everything I understand kind of surrounding it, so when you said UI app, I try to force in into how it work with ASP.NET, so I got more confused.\r\nBut this clear things up a lot for me now, thank you for the details explain.\r\n\r\nPs. am sorry for the late reply, got issues with covid thingy","date":"2021-10-15T13:31:36.547Z"},{"_id":"2e109900-31a4-11ec-81bf-f94d47a9e8e8","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"7b4d7de0-3155-11ec-8d1d-8b9b6af25e4e","authorEmailEncrypted":"E5HDXV0KUg0p45SrZsaW7MOH+Z1kWrgZA2frTW4NZviwz4NsXq5CuWwUm8CenJaKcOe3gd59El+9wEYTCuk59O3PM877BLzHRGhq7WOaduRIeEnNwiQMZAkeJFmIbn8sog+CqRSxFPvJBIK8PLeJnVhrMeISFevFwhSwr3hwR2QczfzDlEkGWwinF1T+IrUnUCManZhFxY5mBf+4+sN4rDwHcx5Pf8X6RTUR7OsAVUNA2qvwQmob9A4IWsDHCdDSs0caqv/Od16NFlquARmSshh0D9Sw4Lj6fKiPfi9LAQ+0CYsLHPWVuqbZn7L6FGESm4kirPeu9bVT0lHiwzbIW9CBEm5TekSvmPZDNan9XDH7UzTOePjMnfudxO863xBNZaqDjSzUfrZSFc76p3NQOfAMb5NS0DDvwv/lUSLOjPmtlOiEtzPJQRUj8Is8mqn30P3mV661LUxmx6Az92/bTBbHWk/+9ntmqj0RwU2KcU4eyffkCN2OTzvexrvpLbeyZhkT8JLDuR/F+ka13WxDwPciT+j4BJDiX9qSbdLOV7P4D9MdjnYXeOsNldij83sp5RHmTUSY8hNHBaOWIgPHudt6H6NaYi6dPsjgcq+jujhIs/JRZQRVOTO1272NbMjzEpAEKisVouxDGJ+osh1sesBVid6CJxfNIRnhvxw4Asg=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I'm not sure where you got that from. `async`/`await` *should* be used for I/O operations.","date":"2021-10-20T12:49:36.158Z"},{"_id":"7b4d7de0-3155-11ec-8d1d-8b9b6af25e4e","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"steve","authorUri":"","message":"So if Task.Run should not be used for IO Operations, and async await should be not used for IO operations, and startnew is terrible to use, The what is exactly used to start a thread on an io operation?","date":"2021-10-20T03:26:15.445Z"},{"_id":"dc804b80-3392-11ec-961e-bb79f6e0694f","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"EOYtaql4GzTYgoGszdpF/q8OCb7QfdClIXopovqS//ccwZ0YNv3Nf79PYv3ZcRjR5bfM/tmfTnQvoQ93dmhkfSpBPl7douXqndZqfPcGPKUj763GNEYIfIfSCYvmXICjTX7DaxSBobuYaMm2Sjn4CNakIvgJ1OOFBsR5esyGhsYt87xgmdEtKxINRgdS6EL7+452Bh5hRUHsBrEipEAsMvbvNDuowDzCrb19iEbyCjsxnEFAehQOKiU8axRPLK8805cQTmic1Ac7zrhk/iskMIFnRKaIAArSbO/zwDAXGtVCaQN7EByju3N7D2MtmpX8CmkTvQwVWIkz9/kyCL47UWyz5nji7dhnsBX3n5Nmr2E0JLji0PNZhrDBsIS/JzZ2K9XGbVvQR3rOmS6mrPdI8dgPvDL4mZn3+T/Sc7jmXtUootCkh69UJFigMy9ViB5zv5FwJmM6Nk777MLifBk6jlr2Ka7/Y3lbVBx8lQODVJOTD9Kjt1sjVg9CjCmURuWLN4aPONcwc+xQ+Wss7Gx30271JpGDSti5H9GcFyloT64DfuZsD8oooP+6aw9fuPxZYhWSlklkrYwheIPO7+26JLwv4Qnx5RcXD1kG94W+8phBPl5ChtZik26NBx+N+bA7lO3PfLC1rXp4zLiUGwJlL5w373Pyk9NqmaTuPkH4q70=","authorEmailMD5":"b2afb7e356d278742f347baacf6489a5","authorName":"James Kidd Smyth","authorUri":"","message":"I was just telling a coworker that this article set off light bulbs when i read it years ago.  Came up while mentioning that i had just received your concurrency cookbook.  So .... can i put this on a tshirt?\r\n\r\n\"Free your mind. Do not try to find this “async thread” — that’s impossible. Instead, only try to realize the truth:\r\n\r\nThere is no thread. -- Stephen Cleary\"","date":"2021-10-22T23:50:40.124Z"},{"_id":"e95f8be0-33ab-11ec-8dbb-05891920a8e5","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"dc804b80-3392-11ec-961e-bb79f6e0694f","authorEmailEncrypted":"nIQe1IpyRp5TS4C/4ylUV88Yczva9kCeHJo9GUlWoZMaS8i02QeUAq2LrGNQyrhkI8R0KzE8XABxb0zppP+ObrC93MzmCYgOoyJosVgpR+mvndg/RWFq2om/4IUhAWLwHd56kpx9ZiRtaCbSMwZ7Ytst4qOQaMNy2GE7N/pjq6uLa5pPb/WZjVHi0KF4GlNEt5+9i0CyYTHiArYqJomYFsPN0rToLHqCmGVQ5rM9/4Yaz3hydowpX+LLL5FpwFJYKjJAc06nZkObw7BVLULXLb/39kQE9vDHUspEZTW/o0MxM9A7mE8Km5YTnN2MjVr+PDxnJPPilwetqO4umfsI19z6viLGuzBG0aN93E7njitm5uzxp28lW0DkF8urSzRxwbySPHKXt8Yqj6BXPM/7L469Z9f+Yea5S2KiBkoTfbSJsYYIhzXYm+s6URgeqIjHptA+LujoKyXlgSV66AtP1JvOBypcbwOaOPNU6mr5rH467cag+3BWXRnqLcKNtKYT4QMSG6f0IeaO20Al4BkRDeK3CuF3Et+jU00fjxbQxQAsR4RG+cd9nRTMCUDD62bcqjVgxFKt4Ud2JzxXtjmzFu9lrfSs2UmvRPHRfZ1XOiCxG9cb2SkAAfnVRcD/J09pWwlV/5H2FSuBhffAGTdCqlsRTtJNBuZwua6tidmorcI=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Love that idea! Shoot me a pic of it if you do! :)","date":"2021-10-23T02:49:59.108Z"},{"_id":"562a3a80-35ba-11ec-a2a8-1b0002cf05c2","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Lars","authorUri":"","message":"This is a fantastic article and is the answer I was looking for when I first started asking about what it is async/await \"does\".\r\n\r\nI knew that .Result or .Wait() was bad because I could see its effects, but I never had any luck understanding _why_ it's bad or _what_ it does. You will find people asking about this around the web, but I've never found a good answer that wasn't a snarky \"if you don't know then you don't deserve to know\".\r\n\r\nThe epiphany comes when realizing how you need to make the stack async all the way down to the hardware device, which then allows the language to free up the thread by interfacing with the device handle. It also makes it clear why putting some blocking operation inside an async method won't achieve anything other than maybe allowing you to run it concurrently.","date":"2021-10-25T17:38:16.966Z"},{"_id":"22abbd40-3665-11ec-8f06-c183febfcf9c","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"bf8e50c0-3663-11ec-8f06-c183febfcf9c","authorEmailEncrypted":"scGLHTuKmbYpnMFQXlt7KlaIBEyyKuReKysLCFsk7RJHn9rQuqv5BZ143DCPbawNUuB0BdYKeUbH7fHOeMme6tyjPq1el+E6azvgQHGnMEg2vPfPuRfLTeWQO3FlnS894EhkxHICYkqITwHc8O7nXMm0b9SPcKkQ/6ZFSsiyOSGIU2DsdMQ8lCbEcjIO/hZR0+TK4y1QNGz9jyhPKeW3PygBTtEgaTB7iWHOY0X/FWZ7vNZ0SCW/YUTBxSA14Om3FZ8J4nsh1cjljwZIf1jpMFIq/EdJulCYzOroi5QVG/6cAG3HkyYRAYAQp5pUHWOY3GSlQLgKxnQgO6UaHtggxU8dDmzfYgBP6enjlBX/J50vqZnfjA+6KG9XAM0ritpCiCGNupCN7oDRAHKRw2S38zPt2wkWg9cK+IaUJeZk8Lr8HmuvAC034bWgR0lnWx/3Yq5gFKg08UcEdFpLUjAst8hRXTyiRciDzEElgfF6PyJtrd7/rUm/ps0zC++A3cAD+utlii5uCFlHJ9jknKGeY+Finm0Pd59h4BUSsLD8o7pFRTGGv/DTmAhMNeFi6xeMsULmm36YmYG4QKwVvM9SeH//3dAgd/DrWyxcP1YduEnQOjG8wP+euOeUsSgx+drMROOamqR0AGcdnmaW3HJwI063hlQAtq12lnYjkv3Cfsw=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"The sample code doesn't have anything to do with the topic of this blog post (explaining how async I/O is implemented at the lowest level).\r\n\r\nIt is true that modifying a variable from multiple threads without protection will result in pain, and that's true with or without `async`.","date":"2021-10-26T14:00:54.511Z"},{"_id":"913ebf70-3668-11ec-8f06-c183febfcf9c","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"e2f24dd0-3665-11ec-8f06-c183febfcf9c","authorEmailEncrypted":"ENzdbMnM0OcnDrLbR3Qmk/CMQgKnmgqkJ3EiAu28Pjf/W9hku9gud63gc5WfmXD950qUn3C85yUyuEc8J+WN8+KmcdWA7fmsmuVDNMottP0go6OOrbhW8+ZJZdAuh1LdmyJEU+dhtUvfnn7d4i5Ej5SS9bCn4O3W7da3C/PW/JDNPj4Kav/T8zT4jRbk0XDYbzJp1YIYDlNBBhJIy+rwKcETok9d/qbYkrOsgkrU0xae3l8F7yo31/P/uf2FBVsveojGzkMpbztiVDiM/STJCllFBWviMyd2HZX8phM94+nOWq9L0gi7++QyKa0r08esOgbIiiKgRyTVi8d6mPucf/6hup4WsCLCFtUhzGVy7A+HUBfRAm4IXa+ojpcEnT8RzxpIQClrvTMvQjlu/92ZYhMGI1BPrxJ2USSpAom7DfyLuX5DzsWhmSy/DmVRv+apbD/QWH+trW90ioAAuG5Ta2uwXeGfH8QoQa2tn2HS0CBERcrgGoafuSXoHr7nv0h+BzgEV1/h4AomqEYnzgz8JS9aEFz9ZGEX17HBuB0SZo0Ysn31cToZLUrNITrF4dq7gJWXnq/7UTf2GPm1Jmz0HWrF2s7MIlxO7RYSlSF0yRsrNtNIUDE2HrRBEnAQOmH6f2lQ/e3QfpAjlctz2g3Z6Yw07de8Cgg/W0Zxdt3VHQk=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Yes, the sample code is still using multiple threads since the `await` is resuming on a thread pool context.\r\n\r\nI'd recommend starting with [this blog post](https://blog.stephencleary.com/2012/02/async-and-await.html).","date":"2021-10-26T14:25:28.523Z"},{"_id":"bf8e50c0-3663-11ec-8f06-c183febfcf9c","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"uAyqhNfHM1PV9J+2zfJO1sJlXTLlxMFsgFRlJi3VLN/bUMFZyO3pf+HZaMie9bKbaQesNE947M5yzaJoSb0BZE7pP8zS6oVklFMH7h2r1tTFlLvhzUBD9R+tSWOXKRcrbVk7lErPlNuH0TTVROr+4A+yAcTHRo7iCTZDKy8SvoYu5DBa+1gtP3P3T3v7pO9kbtF1urst4MfaiAhPbkfEmwlxKyVxiZX3XmfMu80wKKwhLN/jRT95UBlxMkWHEoRW2xpvnwvMVzhKZPPj4sAmWRDoEe4G8J3kYfLyi+bhrJYwJB1+LpZhYeO57dg0kYzlBnfrJV7c1OxxxqZcdKDAuBfKSFR5NQHHQbCV+U5+utJYe6MaS9HMUSCw/9Wv80AE6H4yMC+Kze0nz48fbozQkMHUyks1YN5XwQrqBD/ITxof97Xv7LJp89CGCjaatMomaSNBgEaql+p8+uUSAUKpcQev+gtjGR55x33GU5ZcOFPmeUvKyBSIdfo4ZrgClYwuSpzCePeSRGEpd1XMXVmvIMXE2o5C8UHt/DZZ9CS2u+S8neODaUdIz0LykYWFE7W8gXch/j2BOsRU6bnbieMiy8uNAqON97ayS1q7QcPBjxo3rCQfkBHr/cxqw1YRvaZPsSHnjRHdJp1a0Oul3htZmyfJi/p8bPgXZfX5IQ+SHtk=","authorEmailMD5":"b1d76404987e50a7a9eacab2e248b877","authorName":"Tycho","authorUri":"","message":"Even if this is true, it is trivial to prove there are comodification issues as if there were threads used: https://imgur.com/4avJKtm","date":"2021-10-26T13:50:58.732Z"},{"_id":"e2f24dd0-3665-11ec-8f06-c183febfcf9c","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"bf8e50c0-3663-11ec-8f06-c183febfcf9c","authorEmailEncrypted":"q2xzRmwcObcGUJU8RpRhTJWCX4T5CK2ql8xlNFkrCcoYkRCC0X7W9skku/jfYClWlH/mYOSLb+OC+E4h+eU3VjRROoNTfu/5ZH0uM38aez3KMGv+8QpeMgx1do16etfohmurSr2P5d02dfW9F1rtES+kKkwRSkLNeZKIcBTq6jeNUw5KcM38T7N8zwfFCJfuNmfEE5WumO15B9xrVS4X1rxGKsG7piV/ZEvKBCcXJAQch0jdemw2OoMcE4hCdlQjHb9OT/lvIGbt2o4B/O3z7mm6y+0OUv0uqnfB1RV+BokoyUxRNSmJZfqk5W7Dwv316z8zEUALikALX7zD7clD8fx7B8mmi9FQULUH1keiQoMtl8hTltXZNjVRg2ZjZvIdLMGGVLQHKJsHrOyBKTq7qqKcDQRkpuTzXz2W5BgiKHVUZOoRjy/j/U3N7V6RABZzvyJgOSAPxe4kOnVJ3wqtLbrYl06buSYQTqYJEhMutQ5utZvfThxZvAs2osNO0rZZOE1FBJRPM3BZwSPk1gGHaAeHbH6IVMkGdqOLy9vYrb+SjvHFBa59LIKNzhvs7CnAdJMMDAXxeNNkDNUEvmgmZJkz1PlyCnfsEopS5xdtyDAn6V+g2HF6kYVgEKfAZTfsU6MGfPC8qLGgWQ2GvU5+Ba7fUEL+a9lZjbN/36xepW8=","authorEmailMD5":"b1d76404987e50a7a9eacab2e248b877","authorName":"Tycho","authorUri":"","message":"k that was just cause i have no clue how this stuff works, as i understand it on further reading though, this SHOULD complete, but it still suffers from either comodification issues, or not being async at all: https://imgur.com/Uig3iip","date":"2021-10-26T14:06:17.071Z"},{"_id":"2f776320-4246-11ec-8236-477423db843c","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Rob","authorUri":"","message":"Hey Stephen, thanks for this now very famous blog post. I am still a bit confused though. Based on my understanding, something eventually calls the GetQueuedCompletionStatus function, which, according to the documentation, is a blocking call. So what thread is being blocked when this method is being called? I am still confused about how execution goes from the OS and OS-level threads back to managed threads in the CLR. I understand that an IOCP thread is used to mark the task as complete and then the continuation runs on a thread pool thread (or the UI or ASP.NET synchronization context in .NET Framework)... but how does that thread get triggered and where/when does GetQueuedCompletionStatus come in to play?","date":"2021-11-10T16:49:35.538Z"},{"_id":"9991c9b0-47d4-11ec-984f-f134e62368ce","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"","authorUri":"","message":"Awesome post, thank you so much.\r\n\r\nNow I know that blocking/non-blocking calls are an implementation details of the user space, the kernel and device I/O operations are async!","date":"2021-11-17T18:31:37.940Z"},{"_id":"859e29e0-5188-11ec-9597-8bdebfbf6845","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"ae177350-5187-11ec-9597-8bdebfbf6845","authorEmailEncrypted":"nCSElf3OfI+cuaerwf1xby99UWd8FK5HtBK7Wwq4VMxkSMNi8m4oHn1/zFyVA/FKEGqyDSFk3h77PPfijPURXLMTjH1Ymau19I4L90L4pUK1Q/h8OquFrSIDxDjnLQlW4YaZ1+ybLfMmT6fffa2vOd0yPo6ZMZhyByhFBFlmtzCWzIF0VZUA3j8CB2puEwdC+QEqWYmIMLAQKwYI43cdgScph6XLDJ+TnwPHy+NM5c59aX/qJwLZ3NqHtsYLVjrKORq7don9NMfQ56kT0eSyrNvewjTUO4YGUUmlDT2Beu2uGUwiaixSUdZYyYdJ354cVcSk9ZNMqkvpJpfYnCPSjaPicxLtqeqG+/BteEFtk5Lksg1+Wr+s34TbcjV4KW8emxhz7Lt3xyqENzU3BEFuo6alLHPg0pmqKWiWNEVFA/T0XMvr2Ivf251X4NeKl7naTaJ4tafy9RX0acf6u1k1EZ9sxiUZ7TP7vAIGd8idwnsf3SxN30fJzfFMSyE+H+5nGWEW46cQm/iq5ZjERQ2hCHQHZTWsGwVemqN9ATmkygLCAQGslQlSuzV+NsXxwZ6VoWrGIViNNyPnXH/O3XGdvvqt6ciBFLRlwM2mge6aA8gDQfxNJ/t/2HWPPBo00C5TGuK2vBqOR38w5ymplKTCig4k/BdbMu5WOtLNOak6L1I=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"No, there's no crypto mining going on here. :D\r\n\r\nThis one blog post does have a performance problem due to my simplistic homemade comment system and how it loads the Google captchas too eagerly. I haven't had the time to fix it yet; sorry for the trouble!","date":"2021-11-30T02:52:14.216Z"},{"_id":"ae177350-5187-11ec-9597-8bdebfbf6845","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"","authorUri":"","message":"why do you blog take 100% of my cpu?\r\ndo you mine or something about crypto currency????\r\nbe careful about this blog or ban js running.","date":"2021-11-30T02:46:12.784Z"},{"_id":"a97b8460-5666-11ec-8d40-47a2bf18a987","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"Ad74YBnaEF6bkk2RHLARhtRIx0gPoHodsLXLC44wfyNjKmQr28AECkQraYdODui87CoZ9/0qg4G57j73mC5Kc8ua+LO76PZ3cpVUPLeiY1evBP678J/jHemmKG3E7vXlCeGksLBuO16QzxuwwREcq60vVtw3Zc7MDc/QTZcCO3SJ0xLKip+CyK7TMrxusMqV5hd4fycaHylbwWlLc75CLJ44j1A7Vivvl5xeCQTl+V38aNilSUqVToKW2JRFUP+v4W1ysjfczdMzTicljsXAQ63Oxp9RGoFau85TqbpCPNJRbl2JJlUJJkRAwSLQ72wwgG4HfbxOVqFs9Nsgu+gXb4jLNa3RiZoAYWTlDj0sVhEeyFV1Y7UzbD/jG6ozf8ZMWLy/q5/wXLqDZc5+CKDBmVYTwEfWq8CnwQYkvfKBIjGZnKXkxWhWZC0CWWuaJFm9lbup6DmdCKpCS90wMY7anoHxKEMPdGi59nC00V1iC9IqJzqZiSssFal9Sj8iDbipqmzyW62phWEd1G8hQLA/2lijrgVMOFYTYrxYa+0Bh1O3nPZKSWoxkZexsISFKGbZRMTwXS1T1UaRAb5S7YPPtd6PHSowbrPbHHO5XIMxvnJH8wYFblFiytUU/Eb8hUJ7wALwQQya+Blkiwa7rfP0J22haUMGx1OqDB7eE+91OGc=","authorEmailMD5":"9387c2a0bb7547112c4bea026222fb76","authorName":"Sasino","authorUri":"","message":"A great detailed explanation. But since I'm more of an algorithm writer than a hardware expert, I prefer to think about it as pausing my method, until a certain event happens (i.e. the async work is done).","date":"2021-12-06T07:32:27.480Z"},{"_id":"813754c0-66ba-11ec-8be4-49f74e847e2e","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"9991c9b0-47d4-11ec-984f-f134e62368ce","authorEmailEncrypted":"aVIHLBKScFaDbKqvgRJ1DzkErpys1ZX6gGcSmOcSGB4AOHr1rpGQ7kmDzYSF81h5UZ0Yw5N1f+uVZdzBCrk3mSn03hO477TAtyY8xTIG94QLsLatytfvioxWKt+7MiMPzVEhPIqUQp7o/444/T1tGSChILpbAkP84K4mGkx8CGQfDhDT1FsjJjZRFuLnBEBZLWMmKL/SrwwUHEtP8PohfRLG+15IYb1p71OB6VpIFv/GRIuFHBPc37w3rWLah3wN94eIZySApssdH5zgvEg+1mub2szZt9EfdvI01Bzc7zSCWtEU6jQW3D4ibrDFYCNo62d800ELWdxAb9sCLbuQrnx+A8vQvz/OLHKk5jec+mC8pHh9m6H0xU/bWSkPoNGPZhARtWCf7U3vMAuOTZ5YS+C4ryxIY4hctVSY0Ja2f2QjfmS9ESpD4xeyhUBTfLx6FPrBopUyhET5ocgRoamIVNqvsHKKLn0nXN3zka+ZmP7WuXYHL88BZyjUa5rIof3g2Ynt/iRu6eWFA6oteG+KufXs/g2PTivWRv6qC2MMeko35XZ5v9DTZ/84JsqDK8R4e9hPa/fb4oTxrSj0w11rfJ5FPM/UObicV0sWwZColgbSnbEurU3kDeXxRKh/aQ3r0kfcCU/mJEQ3xw6qcUweCEsLz/XautkFcjg45cIjDg0=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Glad it was helpful!","date":"2021-12-27T02:12:56.077Z"},{"_id":"d5de6eb0-66b9-11ec-8be4-49f74e847e2e","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"2f776320-4246-11ec-8236-477423db843c","authorEmailEncrypted":"OilpYhmPWMg/Bf2/b0RR9iKDkW13C/ITlfejBW8vhMGSiueQpLiJP5qUW0Oh7IO5A7TklMklCXKgNXyjeD4hRl0DZbzFbYmJrds63mnhyVZ05s3O8JHQTGtEeeGb/xmIIAyb5NY7/89Z6vdcGiBQlUTW6fqVrJulkOZU1l2UVzatNNfaMUp26cp+VEReYlaJxOstl8ekyweguzf2c7IS0bB7hL/Z80UeNgxwSvnQfw3chF8SK2hSobe2nhBE//at41QhcZRyZorETmCYrpt7/6+rYZRXtabx57vSRuLihQCa66tvsJknJ9Nkwm9wTk7sBSTMUBPpFIOrVSbfvbghUbId/onbt0wI2snOMrJocReut562N/Nmy8CRIKJfAHZW6FawMmqK9cOZL0r2requ0vHsQw11rUdGXWtvUUt35mA0s+fHeb4xMGF781kZ3Phn/RN0l6a/4tKmRUI8yZu3EiFD07Ym//MG+6bOSLO/sRy1iMftX6H5MkhvnZDsK6xNhlnlunN1oRJDfW3JhHqzb1S8B67EHI2bkIEswCasqpcIyFwg0HDSQgAhPPHl/PL0ylvhV0sx5Ovj4jIw7ouqWmBDQOneOtguBRtIm2hXRrMMD5FYOZZtvAHGS06kjU8MN41aUeIvISu/JQVVJK3LTMqUa3NRLAUWJ7OlKCupgY4=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Right, so the .NET thread pool actually has a few parts. There's a single IOCP and then there's *two* groups of threads (\"I/O threads\" and \"worker threads\"). The worker threads are what people usually think of when they think of the thread pool.\r\n\r\nThe I/O threads just listen for I/O completion packets and handle their callbacks. *Usually* (but not always), at some point in the completion callback, the .NET BCL code will queue further work to the worker threads. That way end-user code after an `await` runs on a worker thread (almost always). The idea is to keep the I/O threads pretty much just handling results and doing minimal work before they loop back around to call `GetQueuedCompletionStatus` again.\r\n\r\nThe .NET thread pool dynamically adds and removes threads from both thread pools (I/O and worker), but as a general rule of thumb you can bet there's always at least one I/O thread in the thread pool calling `GetQueuedCompletionStatus`.","date":"2021-12-27T02:08:08.612Z"},{"_id":"098cd130-6ad3-11ec-aa34-d993d35f2e36","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"","authorUri":"","message":"Great Post. But what about Task.Run(), it does use a new thread right? so when we await that task, it is technically running on a different thread ?","date":"2022-01-01T07:18:37.416Z"},{"_id":"ac3dee50-6b23-11ec-812c-b3e7f56339f9","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"098cd130-6ad3-11ec-aa34-d993d35f2e36","authorEmailEncrypted":"U1gtqTqjolCM+m3ByA+VsTQghRu/apw0cMFdtN4LmlJhbOdt/YzMsTlvdECo6Z2dgMMji4VEiao9d1SFv9uTQwH6GEkNKGdxmsdk23yVhMx+ji1Rj/jjCEIG/O9O9lNkLx7hzce1+QisGgwV+feaxgEFquXLqgowfAkv+3Sk7rz/FNTRaCcii4PckBFUggHlCeR+IEZsL8SvK88NO+KI1jHEChAUyZ7IGAWiAznK/4ncNu3Q3yn45deO0AAN7F+mh7YduBBladcOINQqYQUhcka5iWy8hZeuVS3ohAK2JOKvP7mHhEGQGP0gbUvwjlLJB9lnEN7biIsF30QMTpuareVFwo3qZyjqns0s3coj7eTqlzfQLZJIXxcudn4htg29/okQTI/rubazfWafmQ3nJBbjaHvhvRmgCNLkPLtyF9Ijxoqba6aQNDavu+An4G5qhznytTJDWiF+zMKP2Qn4WFa50HCsQf80ljJJI+IilAoOlVJ2v0EjLRuvHUmWMqwSGF/GkgfPlcFbV62CiLVdcEHgP0CzuZEidUDIl5JpFm/VO5bySVcSEXiLa/ZbKoxqG8Wf1jSnZ3eNIa35Cw7QMJItY/ObNWQ6CmndX8xhfOgUfK2G9MZx+JFYGBt79/vteukm8auxjKfCqRwfXSOmCdCuSj7i6Y1jrF9a/e+6Ji8=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Yes. This blog post is just about `async` and `await`. There are APIs which schedule work to the thread pool, such as `Task.Run`. In that case, as soon as the `Task.Run` is called, the work is scheduled to the thread pool and can start running on another thread. `Task.Run` returns a task that represents that work. `await` is then used to \"asynchronously wait\" for that work to complete. (where \"asynchronously wait\" means \"pause the current method but don't block the thread\").\r\n\r\n`Task.Run` is commonly used in some scenarios and should be avoided in others. It's only useful when pushing CPU-bound or blocking code to a thread pool thread instead of the current thread. Probably 99% of the time this is in GUI apps, where you don't want CPU-bound code to freeze your UI, or you have a blocking API that you can't/won't convert to async. On the other hand, `Task.Run` should be avoided in ASP.NET apps, since the code is already running on a thread pool thread, and pushing the code to *another* thread pool thread is just going to cause a thread context switch without providing any benefit.","date":"2022-01-01T16:55:50.124Z"},{"_id":"6f1d5980-70c7-11ec-8f56-a3211debdfc1","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"bd7072e0-7084-11ec-bdb0-c701d2a7f48b","authorEmailEncrypted":"LTphdWvVPuHqso0ee+OhgQrks6nEC77eAylzXTyvPMMseNJDummAsdcJjlbZLexwM6DE1/Elzy5ZI2IxjVRnpdGo7IUfOEh42sBInVPT/7GKwG/6VZ+gPp0OpZfa1W3ErqGycVgFyQDmHSkOdb3MR8liEoF0hmYc6FifXD/NlFgtNM1nhTkyhr1X54STELtwHBGiR2OVwCcCcT8a7q6ks/yHnsu8bq43HyHLB8hglaNnAkOwstYVBRGl/neXusoM4I286OTCkaCVY8w6vFI0vx4m8Ien7he3zYZS1JvaQyKEXWHtZM1BB+GVQiN2fOEbbf8KOCBBGGTzOo2yE39V/xh2B6+pokm4hzhTN2rHmRrqx51X9GCJQCfFafH89vjahJ61dggxJ9GYFS1gfBZ29OpLmvkfZCnok/Ha0raz1t3yTJaVcP0VFxAZlatO90XGYW0U4nguQVKm5dwPKjeth6JJCcRvK+IsZEWzVztNmH6ujoZbOQ7Iw+nII5RL8zx4vcEx/60llMtjjCK3cFDMaIl4dguhe5seC9EbHHz+gdgljsrgXc2V+zBqya+f++z6/or2J3CV6kVecu0PVg+K0a77SRIitRwsC08p5t4YVGlt5ByCg4eNiN03Jb2SAodZQG2x4CuTLksOxt72atOZWu5cOp9Pb3u2K9hqb+zdub4=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"1. Nope. It still works the same today.\r\n2. Hyper-threading and simultaneous threading are both forms of multithreading. From a programming perspective, they're practically the same thing; you have multiple threads and how exactly they're implemented doesn't matter (for the most part). Multithreading (and thus hyper-threading and simultaneous threading) aren't directly related to asynchronous programming; asynchronous programming is about using *fewer* threads by not blocking them.","date":"2022-01-08T21:10:40.905Z"},{"_id":"bd7072e0-7084-11ec-bdb0-c701d2a7f48b","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Philippe","authorUri":"","message":"Hi Stephen, thanks for the detailed explanation. \r\nI have two questions regarding the article. \r\n1. Is there some major changes do to new versions of C# that change the whole picture explained in your article?\r\n2. Is there a relation between hyper-threading or simultaneous threading and asynchronous programming?","date":"2022-01-08T13:13:16.107Z"},{"_id":"fbc46520-7484-11ec-9386-699986b116da","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Pecco","authorUri":"","message":"Hi!\r\n\r\nAs a complete noob with Async/Await I would have liked this article to have some context.\r\n\r\nAs a noob I'm asking to myself: \"Is async meant to enable easy parallel processing?\". You are claiming that there is no thread, but there still is parallel processing: the UI thread works in parallel with the hardrive. I don't care whether the harddrive requires a thread or not.\r\n\r\nIn the comments you clarify that not having a thread will multiply server throughput, because IO/Network operations won't block your precious CPU cores. From this perspective not having a thread is definitely relevant. Maybe you could add these to points of view to the end of your article?\r\n\r\nApart from that, it was a fascinating read, and I really liked your humoristic writing style :).","date":"2022-01-13T15:25:05.240Z"},{"_id":"d17df8f0-759a-11ec-a184-8be7ecbc8435","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"fbc46520-7484-11ec-9386-699986b116da","authorEmailEncrypted":"Xc2LxbWgizjpPSz3vrpfj7XO/8MqCU8Af1mRi3gjkCQ/B5frdF87QW80ivMZk+MFjPYloC07JOCfbF0tAwSvMi/ktCYBsLcswRn0fX3UV2jZCCkxupSmmzZxnAOEcQPx99K8QatQpSgSk7OBXqiMqjkVoB+eeRe8r2IQedt9G+D7toiqFwZMD39rZKn0uFLUDGoc+2o5fvTvGjWw7LsFtSBBaKL/f7lZZHS5vd/zmz/8AXdVHu1Il1tcVRkuK2is7peFhag8ZbC3MT4TIrj2qndttPjMMEz+fxAd2cWWYg8Eq669kG3QO0AchbvuVrRVP8TwtuhJezUqWxOr1R1f17QkhsOjAZPMDWFuzjiafGwBmMCfp4tIjyquYNtQ6+9IhvcRq973ofkCOOikgQMEtPRrfLbZ/AfxIGOlEnXnJSMtjZhC1LP45PhCCpdkpogEgN7BJ3vEzbPbuf8ef5zV6R8QDNmAdSIR1hTgEo6gUtnfp61gd1KL3lTQUFGNXLNwjpFNRkteveByBOjObKEnunUKRuhQ3HowyCyPWsdRUcEcdy49OLOu7VyWania7ak0INJpgS0HgmHDbYSjffAr5oKPC40uBseS1QFQM9o2tGjBedlMkLvXbOMsGvtQFdS0RrIWRnQBQj2xBczbNNC5SOmEVk+SfPJ7f+k9FJ2+IYY=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"That depends on what you are willing to call \"parallel\". For clarity, I always use the term \"parallel\" to mean multithreading. Otherwise (IMO) the term becomes too diluted to be useful.\r\n\r\nWith a broader definition of \"parallel\", you could say multithreading is parallel, and asynchrony is parallel, and CPUs are parallel with hard drives, and one computer is parallel with another computer across the Internet (in the case of an HTTP call). But I find the tighter definition much more useful.","date":"2022-01-15T00:33:54.362Z"},{"_id":"4e7a7490-8f4b-11ec-8294-63bde2a6b353","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"SEZNt6u73ECbM+4JGy/HicjeNejGRIPp9ucjO2jI+2A6vxfKwo+5MNgSerDI8AgZwGpjMVIRS/W6VkQAeprYPIAz3tSKDOOG+lxCdSvHs/n8i5Gqx7GARNCGRbqPdDBQwPZTJPtLh+g2+q6as+xVn1lSTAjCMuGJBIvqS5+gwqtcu1MG2d0BQ9mFWjy4eYxXplIQdFgMXUMNkXTEkyN6zptO7KMmRJ0F7097eiE9MO2iGx117Lc+BxeougOfQc7vCqHnxh/+QED4AIHl7JQO/rq8WOf5GMJo/Jd+cQgQ6xq0YU5ehwB2DnfV8pwVR9S6ppqElZcoJiwq/IQcvzVcqyWmy80zQYF26/GTI7dL1RzbJRLTrIKG/eKLBVs/MRGe77QdbqZTnebtcUAYiqhd617jGwke9ljh4JtTwIH2LNjG0/bgz0nywYFG2ukvU2x+DSFJVPiOY2RKLc2yP4gIArpM7K+mxioqqkaJ7l+quiuylFTKezOmMZgd3I1Yde362PeO14hCeNJ1wAXLL56MC6fUUc19QYUeJDxecdJAKUsYh1pskZPAMynqyek1ZeB1GSntvAyprSZ7GpiyvpYCaghv06xcQBr60+NTNu4HwcAgBV9bed3inPkFkc5qJDdRIn5B1hBjOwJhmIXvAlXEOpM8MPs/tHBTnJTkql88fJY=","authorEmailMD5":"31d868881b4c7c754d9f7b6d2038ce22","authorName":"Avinash Tauro","authorUri":"","message":"9 years later, and this post is still awesome. Thank You","date":"2022-02-16T17:10:14.656Z"},{"_id":"ed0dab60-a59c-11ec-802e-b58471770875","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"f5123730-a593-11ec-911a-df8dcc954f5e","authorEmailEncrypted":"UWDgpmVfD6Ke8FwqqlQzuXrncFDacXj3GezzgvMLg9XpDsgnqlzSZpEuoZ8jGrhFT3AGDR6wM6nCtrsYYgE90GRmOyuTsOhGL/qt+vejslLQBqvtetVqoInrjZQfzjpfodz71ffG3Fywa9R1HN1ChsjlDGDYW4wDdd5/XBU5I/vSRYEbXHq5sBQqJQLhbIWhvv8FDyKQxiBoQsR6x2iss3DWz3hB8j48fShUTp0qH25y85htu2h8CDwGIynYARINze7b7k6I3Gyfv/d9zQc/x8xoYa5muWL8RYQG8pAiGIoH8Wnp6zIheJOn93MAEoOGl4wPxqFnH3d3olFTeMDx7LUvouu/R/GKCVO29ZD9FaMdyxyNcvWQw+4UmqEVSEw86H9sSo9wynMPJBn+HA0vq2LAwOsxtVkCps6znJqu+ncSORruOlGewZh1GCijCcLPjqCQe6FsAU1cGEcViKdFl12pi2TqIF+ueg4WtHgG97iqR7dqb0vQWDeIO+gr1/S9b9m8xPYkrAUDGut9Bwp6ZMZWizxFjNKqqbUgKFvG4dH5YQUm58FSKo7Mg6UpuR4HoeqHYS3bxf08GvugD1ux6iIrOQgwNgf7DX1JsWJ/es74lxgkaszN9MYEoWpxgOc5g91Z5wo/P/DFSf6BRYvNZ5DnlFRp3aCByTI/q95l4lE=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"The core problem there is that `Parallel` doesn't understand `async` lambdas. Full stop; you'll need to find another solution.\r\n\r\nIf you have asynchronous work to do and you want to limit the concurrency, then you can either use `Task.WhenAll` (for asynchronous concurrency) combined with `SemaphoreSlim` (for the limit); or you can use something like TPL Dataflow which has concurrency and limits built-in as options.","date":"2022-03-17T02:49:55.423Z"},{"_id":"f5123730-a593-11ec-911a-df8dcc954f5e","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"Jo6ZjScBFk2KiFaXBsrOoGcjn2wOiW6za50mNBA8oJcLD2qwD1n7mDQJfE80dCfQDiK2pUUQhrkiyMOGhwCNAUmXFiQj+X73ddesd6XrZHkq30rnqHOi9dywlaN8ukFX6ARVQjqNAcjplKZghq26L30HjmdMNdGrV/heiFnbkAU4XteqI4qa0t8as+a7ci6N8IhuXhikKRGgo1VCsmWdl0eQzWeCvfmpFtWjvoTjJBGJ8qybincOXNKiirX+g1rL1hWBX5EhVH+6TM3/q/oWu69qFAr/AJXIE77okwKPqyW7eKptjV7LVqT19id9XWzNMOJwkc0wgmUPHTxXT1+7LspU4XE4HbquJkhDnEgEGYi0FDyl06kYQ5jA3z7o/t0Kpt2U0gEZfdYL5E8j0f3C4ziR9k8ZH496TaEshfndq2c4//KCuM/ldSduGY6dUkeYeIDlp7yONxb9x2eJcMaEEPR5ogXyqBg7Dp+BXZCnSuv7ouXl5lRBpuRbgBNDztvdZih7MBPUjK+18q4JzbU4zeFxvdbzSNPGnkdIvDkAZatLr9wJ4TlFyMMFx2o96QjcZTue2mSRC5RFDLXEdOXElkXAMXmFm3wwdXrYxIpFmTiKjrNU4SBk86mgVZsouYCA0RxUM+vkM+eUrpdIRuylWj41EcdCXgx2bqJGIxrafMs=","authorEmailMD5":"2f08a8b49638d5c3ef6ce7c5ccc8f0a4","authorName":"James Smyth (SHP)","authorUri":"","message":"I'm going to guess that this is pretty well-known issue, but quick googling is not helping .... I've been playing around with doing Parallel.ForEach(blah, async() => { await somethingAync();} and it is pretty clear that the MaxDegreeOfParallelism is not honored.  I'm guessing that the return of threads to the thread pool is \"confusing\" it.  Which begs the question of how to see how many things are being awaited on in Visual Studio for example; it doesn't seem to show them as threads (which makes some sense). \r\n\r\n(ps. \"confusing\" it in quotes, b/c i'm guessing these patterns are as fundamentally incompatible as some other thing i've seen you write about, eg BackgroundWorkerThread and async/await)\r\n\r\n(pps.  Yes, I was starting from an older app and trying to add async calls into it)","date":"2022-03-17T01:45:43.387Z"},{"_id":"38452ef0-a6f1-11ec-9d02-0f6d6fea1882","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"6562f900-a6d6-11ec-b30a-e369b2514221","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"James Smyth (SHP)","authorUri":"","message":"Actually, after looking at the prototypical use of TaskWhenAll and the SemaphoreSlim to limit the count, this doesn't cause the problem i was imaging.","date":"2022-03-18T19:25:50.444Z"},{"_id":"6562f900-a6d6-11ec-b30a-e369b2514221","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"ed0dab60-a59c-11ec-802e-b58471770875","authorEmailEncrypted":"BpXgEWiEJXR4ESvDzLkKhN06m72pvQXyK63x90CVKYcUxJ/FHwDqQUgblT4f8vMZK/RxqiSwpiEvwo0kiuZp3byjhoS6cjnpLL93mqsx6klQWeeXxhkL6HDMbpjgUJLU6VwyprpxwhdplK/kTosCgEIkZyM9ZWzFgmdOSTK6dm6xCDgTJ5hu9F2z5pPL2SU5/5FkmVLhZd4CuPMMQ7y5e2kUInV4NZpqS7QY+nbKy5DSWzU+Bv3ZxJCrR65+ihi0BheVWHRUKIkWQy6xCh7j4Bt6Lj+ozplmqFoaWPMP/SalYb6U6JvBw/1WKJ2GRAEihGZz4LdJwj1kNBWixcpqfnECm9vSOooyM61LkA+R8u5L1Xf/eS4ZLzWmzRiV3r1fZdLnDTTzYhnpamUWSSmGwyFMhGzC+XEkRUgnsbAq8JTG8kmq+finASfHhUdUZ3Zf6CQGAV+ORjcG1UAg2XgeSnVCACyE9ce3utcGbHgMTm4P2E0ngogFIY+5SglBE1DbWmq7h6fpMdIUxHYhD+y06ZQFpvFAY4k5rysTMlSy8LhagW63RDJRti7utFF4Mua5ly8/BiKmUbPIt6QwaDLEQShIrl2P4rQC8sDB/E7ufxID3Kqe/OFRk0CoWrLX33vsmhZL31zTa3awxjwzgA8tnZFmFQH/wUm/dv6eRYQjLi8=","authorEmailMD5":"2f08a8b49638d5c3ef6ce7c5ccc8f0a4","authorName":"James Smyth (SHP)","authorUri":"","message":"\"If you have asynchronous work to do and you want to limit the concurrency, then you can either use Task.WhenAll (for asynchronous concurrency) combined with SemaphoreSlim (for the limit)\"\r\n\r\nI often have on the order of 10e7 tasks to process :)","date":"2022-03-18T16:13:49.774Z"},{"_id":"ac39c9b0-aa1b-11ec-b52a-eb0d8ec9ea52","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"38452ef0-a6f1-11ec-9d02-0f6d6fea1882","authorEmailEncrypted":"LMjf7Zhaswl90zKGe00kVJKf1LT4LUYanFBXyLLRuz4aOFww1zioGXExdVwsLkV39Q5q+SrV1Dbb1cZOhA0pogh9Cc0SHel707MBaWTG6CPY8dY2ezjWqcituizvbUTj+PSvpn944FG8uRWocyvBkHcBe/MMt5QpMN03BIzo+ON/BPQ8BIhsuXnEXXYy/Rln39ASh4f1egZgf9QW+5TY+Fb/JZL88G/mpv3RvFPWGkpHdvv5qykU/qo2bH7atrDEroZu/DOpoIXPU5+II4V3g3cF+Sx3pWzKOkzbO8aznZULDFS1kU31i+yJOLlptVu6wlKAFibUwNkOPhYk5xGmNHqY26T0pgG/zhZ/20O2BsEjXRq5M3BncgdT5Rxvloq7UUQgw3X91Fay9IkJiuiZczGUrugNv52zkH7sdw6Y+pZAMjSm6nXDJCub6jo7IENEGhH4B2vzVnL/As2SgEen7xc+Jb4FQVSLH2nsHlQPAJ4Qp5tCoJtBzMCkPDEeRdoMN1NgFBH0x9wJWxWx4KwXk3elUDE+tRyi0myABB6ddTOqwmEIyd2MwUN1HxwVlOkW6TVAygL+Lu97GgRXSS7AFPXuv54QrAzKNoDKwn/0yHf/tAnWYS7R1lQsfLfRnp/+D+DCDu/ETcZr8tT9xnz2yTfo7ERwKX1qSxAwse7WA/k=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Both `Task.WhenAll` and `SemaphoreSlim` will scale quite well. I have had very large numbers of concurrent tasks. Really, at that point, they're just in-memory state machines that are in a list waiting for the semaphore.\r\n\r\nThat said, 10e7 of them can cause some memory pressure, and you may want to throttle the *creation* of the tasks as well as the *execution* of those tasks. TPL Dataflow may help if you have a more complex pipeline.","date":"2022-03-22T20:07:17.345Z"},{"_id":"c5a002a0-dab0-11ec-be9b-05a3b5a266a5","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"","authorUri":"","message":"Great! This really cleared up a lot of confusion I had. \r\n\r\nI'm not familiar with how \"devices\" work. When you say \"Some time after the write request started, the device finishes writing. It notifies the CPU via an interrupt.\", there are threads in the processor of the device itself executing the write request right? So \"there is no thread\" means there is no thread in the computer which is running the async code, but there are threads in the I/O devices servicing these requests?","date":"2022-05-23T15:55:31.194Z"},{"_id":"635138c0-f532-11ec-a9a7-b1f18237358b","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"VH2+unWsy7HjWafVnGb8DKByoDepGrN99aHuTyz5baqTP6yaD0Ey/9gF4i5M9WeX1aM3EnSLRwPjBiSPtzLvKsO8lATHHzroyR5GC7FiqAVti9/J0/W7rTi+d8d9bjxz0NLkqXn2alggq2MW0whkzFCo1W2wfsYfXtO6H1n9HsvqvE1HE0wz1Mki1aaCEqiYKAmB/8kDW2RM7tsNJAQ5wj9EkIExsBrOD6f6eFRYTcXt4rcM9txXcMomRfC7gKOWvuem9Vr2o+UlTnzalKyWUm21+2IwVIcNR/I3/UrP9kzzK6v8DBfwg3XjM2IWwBSEhv+LFuhhAsOEOa3qwDS4oo6l5mabDZiuDZUOVPN0c8AUafPgYX9f7JAar5tNgpetSV4+lLzW+37MjWFKNBX9zQAoveXqPY4qbJ4IiKJjQ8rWh4QAz30QpuU5hcxnxhbT20wIkMFTt1a2wuEhS5haQ/dTBjbA2z/XUStwhc3h8edgikOUpNBxc0MJ6B3jRwXcV+lUfbySf58/6QEPbMP4tUpsqeM1O+stZ8g6rvluxcCeaXvXq5OMmsfY2JU6N7RJRiEfcPkHBQkVR148bHaVfdnuF/7dy8SN65NyWfBtVT6/8bZxwq0/y4bC2tHTsuqXkktgPPAQRKkvUgv22zV4Vije1kAV+Vm7IbuC0QJ+k3I=","authorEmailMD5":"2353fd8530110a4929fd4c1cad003363","authorName":"Gopal","authorUri":"","message":"Hi Stephen.... I believe what confuses most people is the difference between a thread being suspended and a thread being blocked!...can you elaborate more on this statement....\r\n\r\n\"which returns an incomplete task to the button click event handler, which suspends the async method, and the UI thread continues executing.\"\r\n\r\nA- isn't the event handler being executed within the UI thread?\r\nB- how can the UI thread \"continue executing\" while the event handler is waiting for the task to complete (await)\r\n\r\nanother question \r\n\r\nisn't it true that regardless if the event handler await the task or try to access Task.Result (which block) , the event handle wont return a result back to the browser until the entire handler call run, and in that regards, what exactly is the value of async await?","date":"2022-06-26T09:28:50.646Z"},{"_id":"13118270-ffb9-11ec-8278-c132177ae00a","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"635138c0-f532-11ec-a9a7-b1f18237358b","authorEmailEncrypted":"V9Wvp3pyXJqgzvhnq81bWMH1zKIDrzRAvkurYqy2a/f+6CZmWv2ZHImYvmkgKZDkPU8sGNeEFEIDPdTfoab+Hb7+e3Llg4aKZUuIsTwFMbcYbg19TcDbSsp+roYap+zFa6RIijtYR1xEM7FyaCE7HULLkQ2x5YScghmmQe/d6eirdKqXDNz+yrV2TWaPZt/zuZzMRiDrYorya0Hwujb0OTjG/Pd9dcaEFXKt2pwge7HPv5PaawsyCdFhssf5tpC+IyWwlTrSldZbqYzUNEaSbVLrOdh1hjCobV2vtwC+BW9sq9DTI29nmHU9Qnesjv3qmSJqEVgISV6UNC7A+CLYrzZIuJhwLMrMsgVy7J+9m//XZbEPpZzYcLkfauYJQFCvFDMyJMDvKSIiZz1AZzjhTFyRbPjl068xoSxUMGtI11fGSFnnVZVzW0fcQZGzCChRSgN5HYdiacNyIspi+q+dZmu0FsOYNSzo65ZfNILczSwdjFqcbJqOSMSDbEwvAYgmjNntpIEz+6HAE3n/1Ej0LlS1s73JP4/CX6tic9izNWmHoaMMakY5Dqc9eJmO3dxKhmZXY3tGfBrLZaXtLQ/ApvbZvLuDN5X+rARyIIC66R2NC4ONOHltko/dEVtIPeJerEjuhEmzZbhuM+PsGM6WI4JCcmpuQ/RRHKong3gExkg=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"When `await` suspends a method, it does not suspend (or block) the thread. That's the whole point. So, the event handler is paused (but not the thread) and returns to the UI main loop. The event handler is being executed within the UI thread, but the UI thread does not have to wait for it to complete; when the event handler is paused, the UI main loop regains control of the UI thread, and may execute other event handlers. Later, when the event handler is ready to continue executing (i.e., its `await`ed task has completed), it queues a message to the UI main loop that causes it to resume executing the event handler at the point it was previously paused.\r\n\r\nOr, you can think of it this way: each `async` method is split into multiple smaller methods; these \"break\" points are wherever there is an `await`. Only these smaller methods are executed atomically.\r\n\r\n> isn't it true that regardless if the event handler await the task or try to access Task.Result (which block) , the event handle wont return a result back to the browser until the entire handler call run, and in that regards, what exactly is the value of async await?\r\n\r\nSo, this is a completely different scenario. There's no UI thread or main loop in ASP.NET. It is true that ASP.NET will not return the result back to the browser until the HTTP handler completes. In that case, the value of `async`/`await` is increased scalability: the web server can handle far more requests with far fewer threads.\r\n\r\nI recommend reading this for more detail on `async`: https://blog.stephencleary.com/2012/02/async-and-await.html","date":"2022-07-09T18:58:09.691Z"},{"_id":"46a86870-ffb8-11ec-8278-c132177ae00a","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"c5a002a0-dab0-11ec-be9b-05a3b5a266a5","authorEmailEncrypted":"WAtYo/swtjCrEfJ6awog3/jQh5Gkc8ruVLUcSsQan/s5KvgvPbq0RElahOY5tzCPxywl3vHoWn0QpV57DLwLTqTbyFZHTEPfsAeV5XcCu3ZqvotWAhuNHCkX6rF4E+L3iWiRqGMnVN2dkSw4dyzLGQWocWGnfeQZsOhRKcc75DgeZ2k6m8j9D/YSXJimwTupiwpsNRP/G1I4x/AdDkXUgKcS957xIM8CXuuS+lCTm+XOKrVrPZrT+m3nRi4FCt2DR3A2urBVmO1uwVFJasY/KPAYlGITUs72GqwKSolq27feZ1Pmz70EeCP1Gwrl2oA68+hOXzmgB0lgq7jbgv6qw56R2BissvMEsjJpvfldwWCSUCn8mRYz53a7RxIaP55SJ/QsSP2v7vWeeT4XpcCEkj32W7J0SbpSxl1KvNrN2icz+pTkrRo3TGoCuJud+69tnvHp8H18s+sMXMO2QksDnLb1x12qDjs7P6aLxIxCnCGh8d7SieJbFHjbzapv+Bhc4exzifmsXvxT3fM3I7btXnuncqSmxun8SWji4VQUaT28tIwJd2L5qdwuRRvrqAVwA38zUGJoBUOSOHTNg0lG4gne02EpYd1kDtWjqLXOcVeb8fXz8Qw5EMU6hcACAcDLtiQsu7MCwcw2+KpRMAqlXqXbkF+jP3E60q02BUDlADA=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"That's one possibility. To consider this disk example, that would be correct: there's a separate processing unit inside the disk controller that performs the actual write. It's not really a \"thread\", but it is an independent processing unit.\r\n\r\n`async` in general can also perform higher-order work. For example, when you `await` an `HttpClient` method, that task won't complete until the information is written to the network and then some time later a response is received from the remote machine. So in general, `async` can react to any kind of \"event\", even when there are no local devices involved at all.","date":"2022-07-09T18:52:26.750Z"},{"_id":"5fcd1fa0-4606-11ed-acc0-01720b00662c","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"vx2iWzJ+gu1NyxsbnxlbmMWDCJAVCy7QozYjVxy/ehuObbgUXAUvP2AEVKVUqgVmI55GZHOelMwaWd6Cf0452Ks8TEvsiA0CBqyh5IQLWz7/jcHqondw8G7ljhJTXdCZ/rloSPjTmah2JZKCload0zoFS0nS2nIWsfc2gsYXWQlQQ4ZJsIXvIYeHmUuX2y4HvrzHGqsNvjtb/sEsBrTNzPolloGgGhGjkxTorfdA0ggy0XGdCXyxYM0YniA4jwzrRdiy8L4jil/Jr4rucG2r5It7KQLM/RW+cvmW2Wm9kZ0PlgJQcBLpxOH/9DUC6czccZqUYwLuMg19+GFtLyPK3JId1ewYFWX38cIvxh0/Cr/m9HEtQkpQdph8woBAebdv7fJIDZOkNtsIePaPZoPHYi4ei6qZS63SEc39FoZv1eXz/mhKUjEYgPpxayYQozvPVFPJGlzLCvCjy9ietD9/m3FYnYe15FJk/qGqa3jVc1NvGoHKH3kvxYAGTndg1P+e1yXcLcZU2uBSVDnkuY3yZEGZgEyigvtUzIYh8qNwoou/AV0QmophfrQtCSmLkE/Mjjm2AS07CS6+hDBs74GGdmEZhf9Q4ZnkA3JLnbut1OcWEtGrSAktqCUGS/eAsAN92a4OCi5VbWn/P8GftyddE7qsyq41DlyInUhTae5E+BA=","authorEmailMD5":"5e815157b7fddf0ff70c258cf584cacf","authorName":"Albert","authorUri":"","message":"Mind. Blown.","date":"2022-10-07T06:07:51.132Z"},{"_id":"56d945a0-48df-11ed-99b1-256270d1c948","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Santosh Vaza","authorUri":"","message":"Thanks, Stephen for the clarification, I got it now why do the c# docs suggest using async/await for I/O bound tasks and Tasks.New for CPU-intensive tasks,\r\nHowever, I feel this knowledge must be part of official docs","date":"2022-10-10T21:05:59.197Z"},{"_id":"07779630-603e-11ed-85f9-b7c1a134faf8","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"5c81db90-6039-11ed-a5d4-497fae41f5f7","authorEmailEncrypted":"Iqlocc+sb9X2YWqzEuqsy6ulowo5Qkw/WMTW4hPkLk7Uie4ARhFeBBoUfiMe3gRbuxy6/3zNywuVcDbGQ4ROrCIi+UsDLEeFQF+0CX4hEMe7LJGozAu4StmI5qRE4tvKBq2p2ksEApCUZgIrfXroiRG/WhjDkryI591reAJDEbF1MjGznB7QBNLLtek+5d91ZV3/5HaSzU2spuoCkLOTj+nuZmlkakv/r/kpmC5tGYNPniIafSy1Rw0PoNGKb7mhwiG6NLSs6znr+8y9PC5PhkpwpwSK+pVJfH9J5F/C0eqaiZm2PXFJV07/M3VhReF6UBJsGEkjXdOi8nAFgSeL+0xgH+cDGZwm2BnkHlaZuF5EKsiKCsjz/6HDtkyP9hjNZSJPkTuRJwvx06Oz1w9S7dh3IYZeC3oOjdiUkzoTAPMCcY7vKYQgT3qYMaQu8KjZ9XstLDxYKqiWugvCW3n89Dt8wpTLlwWMlWK3YTToxiWWhj0hvxSucet3M6eddoeud6RnjRf6CJveJk3qAwnTSt/V/6UA/i1abB1h4T79zZ1L6gp9RjzOXFUxs5nzYOxh1S9sKypUmPtSNbcdruEydl4Nl7iSmB2EUxHAoICnn+I5ZfTFnF8e5Ll72Zi3ff3Os0qZ7ZSxfO3Txcca14DJSsdvtkaJ2z0MEHhUB988uXA=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Yes, the title is a bit provocative. It's because so many developers assume \"asynchronous\" means \"run by another thread\", and the point of this article is to point out that is not the case. I don't mean to imply that threads don't exist, or that they aren't necessary to execute code.","date":"2022-11-09T14:51:44.962Z"},{"_id":"5c81db90-6039-11ed-a5d4-497fae41f5f7","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"","authorUri":"","message":"Interesting that you proved that threads are involved considering the title. \"No thread blocking\" != \"No thread\"","date":"2022-11-09T14:18:20.256Z"},{"_id":"2148dfeb-cc2e-4ba3-b6da-fbe5c90d1c9b","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"d5de6eb0-66b9-11ec-8be4-49f74e847e2e","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Rob","authorUri":"","message":"Thank you!","date":"2023-03-17T21:20:16.8679305Z"},{"_id":"ff385fbe-41d3-4ded-8119-7ec9ec2e02ba","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Florian Voß","authorUri":"","message":"This is probably due to me missunderstanding something but I see a huge contradiction here in this article, hopefully someone can clear it out.\nIt starts with the premisse that there is no Thread blocked and waiting for the Task to finish executing, no Threadpool Thread, no OS thread, no nothing. First of all I don't see a difference between a threadpool thread and an OS thread, maybe there is and I don't know, but to me a Threadpool is just a collection of OS threads. However lets ignore that for now.\nLater you say that \"An I/O thread pool thread is borrowed briefly to execute the APC, which notifies the Task that its complete\", from my understanding this means there IS A blocked thread, some threadpool thread / OS thread is blocked and waiting to execute the APC and to set the Task to complete, and to pass the Continuations of the Task to the UI context.\nSo there is actually a thread or possibly multiple threads (depends on TaskScheduler) being blocked, just the calling thread doesn't get blocked.\nIt could be one Threadpool thread / OS thread that gets blocked by 1000 tasks due to the optimizations of TaskScheduler but even then we still have a blocked thread waiting for the task to finish executing","date":"2023-08-10T12:39:58.8350310Z"},{"_id":"54424181-fd38-46da-ba83-cf32b7cb81d4","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"","authorUri":"","message":"What happens if I call an async function from synchronous code without awaiting? Do I get these benefits still? What happens if I just use a synchronous method then?","date":"2023-08-13T21:17:46.3393640Z"},{"_id":"4ff5f7c6-de90-4c6e-901d-c4df87ecb128","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"54424181-fd38-46da-ba83-cf32b7cb81d4","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"","authorUri":"","message":"when you don't await an async method then it is not running asynchronously but synchronously. Does that answer your question? The magic comes from the await keyword, when you don't await it blocks the calling thread","date":"2023-08-14T10:04:29.8694022Z"},{"_id":"5cda813e-083d-4c5d-a3d6-a74850785401","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"ff385fbe-41d3-4ded-8119-7ec9ec2e02ba","authorEmailEncrypted":"f9yefh9HWiTiFUN8QMo1tHGmAKtiE5WjCzMfb+5VYKpsyiN8RofBLDqhWKhP4yDFW+7bflTMzJqsxOuRBVO+qmNgTeuZZpkt0e3WEmz+drU2HBD9GDp1fnR/6bWBMKxoEgwW3hFQMNv7RaUZaBOJZ847J+EFjYaFB1WvM4hs/PTamZDTbLhbfya9kvG874pkcizRrRzfnh0cOHRPVKGJJmt9vovkXIntoifWIh8bskvMwjVL4oTK5BHyTpE/lIiffpd+SxVeOtkdwfAZAjeJ7BW0JvZscQ6zJSoptrS1J+ozysX9jQY5TjrOh2n2WEbmTohkM7owsV82+gBzQwzm33za4X54dDjqwGgTVeR8f9YSkNS9SHnuJajQOTPfii48Bzzabd8p15Cwbpuyte6wfFlKzMzIuiJzV2vm+6rAPliEhFMfi5Cmta9dwLL6RoMTYUAL5oqLtmASJBh02CDFyooIP+viH7h2iaKw7HbQIkCm2Kkh3RKl0KwArM5vNrfMTfCsNGwUSKnZmYb4Jr+DvuJbXfxv8CHwNyE/zEfOKXdWf4/a/INgeLwwQlELsSxzdXr/PZScQK1kqqZDXWnhokPVBdO0lC/l0F5tYaFjUuHd6YTFiIZgTJpgqdHesB3dVXbsQsD+GJGKlPd954WmvTGeYhjSymJnVNpAya/UA4o=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"> to me a Threadpool is just a collection of OS threads.\n\nYes. A thread pool is an application-level collection of threads. The OS has its own threads, too, which are not owned by any application. What I meant by that was that there is no thread *at all* blocked waiting for that operation to complete.\n\n> this means there IS A blocked thread, some threadpool thread / OS thread is blocked and waiting to execute the APC and to set the Task to complete, and to pass the Continuations of the Task to the UI context. So there is actually a thread or possibly multiple threads (depends on TaskScheduler) being blocked, just the calling thread doesn't get blocked. It could be one Threadpool thread / OS thread that gets blocked by 1000 tasks due to the optimizations of TaskScheduler but even then we still have a blocked thread waiting for the task to finish executing\n\nTechnically, you could say that, yes. The thread pool (which exists in every .NET process) contains thread which are blocked, waiting for work to do. As I point out in the article, various threads are borrowed to *complete* the operation, and that is what happens here: one of the free (i.e., blocked) thread pool threads is what actually completes the task.\n\nBut those thread pool threads exist - and are blocked - in every .NET process. `async` avoids adding a thread blocked *on just that one operation* rather than using the existing thread pool which contains threads blocked on \"any work to do in the entire application\".","date":"2023-08-15T01:38:47.3536915Z"},{"_id":"c8e47222-4e8a-4ecc-b78d-8ec5f0f21a62","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"54424181-fd38-46da-ba83-cf32b7cb81d4","authorEmailEncrypted":"ZPtoCMsYvGVBgSjxGAXIxtvytyb5erWH0DNQCk4Wj+mKjE910stlZe9oKGCBDwug64jzuFAp2fLthU3udG8IKcqgarVDlCPymVcskXOcU5Qrxq6TENVTAocUuAF446aYRUoGvpE9064wn5ddBnnrQu4q1k24vTvw/Qk3DD0ksYW3Qm+uudpBdLYDG4bzj+D0u2rZge3Gdvjcgsy6D7eypsIZcJVjCZWYS+ly9j/oJzXcL0QnVAZ8lPr1OpxFIEY+VKKAepXEQvmIGgcpEpy8Eknm2s7sqdVjKkv824aQ2tAEcPYiJ5x36ipkpb/lzNbPgSEaRkdCk9HBgwbHlbtECqta0rOlQvDQXlBGra3fEc80S3PFN32a+1viAKLFTHoVYHf03/vEhBySrTtj79DN6n1D+Z2CUpUMGrrc9+EwSzDYkF23ZuuJH1t7W2kjriXmsMcxcOe5J4TmGk44eczj1AnFWqellYQOoegLcAA/P9EQfQhNsKsG4Vtgrsdft5GiNn59LR/hx/fuIbRdIW30BZKTnF29Sb0UlouTJl5wyzJkNasjDS8at+MjySf1QWv3p6bFhD9mBVUB825EIuyy+dqxjR1mV20ik0Xb4zxwOvtrv5qMXANb/o0wN0Ry1pQg3nxPgSposgG7aE5vUTNl1ERGN/CYiecS0PbK20APxS4=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"It's dangerous to call an asynchronous method and not `await` it. The method will run asynchronously, but your code will never know if it succeeded or not. Or whether it completed (i.e., if it's safe to shut down / exit).\n\nIt's possible to write code that does this kind of \"fire and forget\", but it's almost always a bad idea.","date":"2023-08-15T01:30:33.8787633Z"},{"_id":"37bf188c-5b24-4689-bd89-68993d651225","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"7cdadc02-9ab7-4797-8c28-56d09b028066","authorEmailEncrypted":"M2/q68/U2BevUq5hRTt9tBOwYqmg1CzF1x0tuGX5vvW0t3spkuXwsxSOHsDMxxL/mObeCHIw07qdFWu9hpAwpePDMaMmb/IFe8FR8iQqF+GoeFanDZK7l2y1Pf8cp7L/NrDNjdWuXUOYAttsOElm37YK72m4hlfUnMGSlqx4Lp6VnEVetp1aTI4DlWmiZqJTdQN/heeNngilYSaQWANupp7++T8DkRRqzt0aDE+7GEkFDjCG0pocYgAp/yJDPP7qs5OTPecAasftiTas9WsZWDYVCj0GvDZ0ab6RWOad8wF9mWBCYXeV5foADA5qFKtV2WlTYnzBZ+cPItp2oa0bwlXDY9/XL+F15fjzd+zvVP7bV4yi3Tkc+ES6ZUyVuTUg4K7FUkLqQsm6i3pxbjNZSCsSUiS0ny/Gb+kWt1Tl6LakY+1dNR9XlR1yUyXoatAVjTV6ZTx/1jzPPgjYZDo7QSNV2Qx2tkLso5RbceLv796sBlKC6mXqPXWvjbO4v2S71qCsc4/nMM43fxD4idbwr6ZLLTNXXoIqRo2rvKDtO7XThVXHrcsUixCwtY5RkA37qYXrrVSLw3ynp5Hw7vyj0kLCS8Q8YuwbF+8f1X4ptVL2zmBr3gXYnw+DDecZBPm/O0McO1R1zNXbUzPdQhmEo29ilxsK5Qua3xup78SWx0w=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"It's a *callback*. In the case of networking, the network card will notify when it's done sending data (or when data is available to be read) by triggering an IRQ. This interrupts the CPU, letting it know that something has changed.","date":"2023-11-05T13:49:01.7171831Z"},{"_id":"7cdadc02-9ab7-4797-8c28-56d09b028066","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"2f309c8f-c1b5-364a-862c-980332c3d6a7","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"George","authorUri":"","message":"> The key behind truly asynchronous methods is that there is no \"work\" to do. Thus, no need for a thread. If you, e.g., asynchronously read from a socket, then there is no thread that has to periodically say \"is there data yet?\" Instead, the task acts like an event callback; the networking layer will tell your app when there's data.\n\nNo matter how many articles I read I still can't wrap my head around this. Especially the part: \n> there is no thread that has to periodically say \"is there data yet?\"  ...  the networking layer will tell your app when there's data.\n\nHow is this happening? If no thread is used to \"listen\" to that notification from the networking layer, where is that happening and how? I get that such an operation does not need to block a thread in order to be performed (because it is happening in the tiny CPU of the network driver, if I understand correctly from what you said in another reply) but what is \"listening\" for the notification that the operation has completed so that the result can be picked up by some thread? Something has to be checking whether an operation has completed or not, right? Otherwise how can something get the notification that the operation completed? ","date":"2023-11-05T13:09:50.0696592Z"},{"_id":"a628b223-be50-4f59-8b7b-3f7294ea8035","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"","authorUri":"","message":"The Thread is a lie 🎂","date":"2023-11-14T19:30:18.6605107Z"},{"_id":"416c95c3-6bcc-49d1-9ff7-2a70eb5057dc","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"","authorUri":"","message":"Hi Stephen,\n\nThanks for the great post. It really helped me a lot, understanding the true nature of asynchronous programming. \n\nI did some tests myself and there is one thing that confuses me. Consider following win forms code:\n      \n        private async void AsyncIOButton_Click(object sender, EventArgs e)\n        {\n            await Task.WhenAll(Enumerable.Range(0, 100).Select(AsyncIO));\n        }\n\n        public async Task AsyncIO(int index)\n        {\n            await Task.Delay(20000);\n        }\n\nAt the same time, I'm monitoring the total number of threads by calling:\n\n        Process.GetCurrentProcess().Threads.Count\n\n\nAs expected, while the AsyncIO's are \"in-flight\", there are no additional threads started.\n\nAt the end of the click method though, when all the AsyncIOs are \"resuming\", i see a signifikant increase of thread count. From ~10 to ~30.  After doing nothing for a while, the thread count drops back to ~10 and there never seems to be more than 30 threads, even if I hit the click button multiple times or do some other async I/O stuff at the same time.  I'm also monitoring the Thread Pool Threads (worker and I/O) and they are 0/0 the whole time, so I'm pretty sure these are no TP threads. Any idea where these threads are coming from and what they are used for?\n\nThanks MJ","date":"2024-01-24T11:51:44.9811474Z"},{"_id":"669678a8-04ec-40c9-ba4a-c672ed067490","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"416c95c3-6bcc-49d1-9ff7-2a70eb5057dc","authorEmailEncrypted":"rTkJjW6LHX7753fQHHfroKzfdilWZVoKh4Ph5beb+Xl+3wLFzxs15JNh6Z8ZiAunoS5aa73ILr6oR+n9tKtWA1HoBhPZdF6j6PbDKBvugdSBE/Q0YgYflgsc5NIFjUpUFb8PRqGvTsP06gAWjqXP9NYlEoj9amEp8FgJlh5Q6dGZwjnL6G/AYe1E5kYqjHBw4omXJWjeHBuoCKdwnFj+Z6MS3W/wyaGDoNsOApgzRbpDkCn1gspPfPrh2GMY/zJgoFKrkLNAMwt+5ImdxMC0mjOFGRMa4nPE8n9NHmSkUvott8k22tL0rdANuPpHcM0c/ZFgZ9dlN5tEQacsHf9Tssf2LIzbHyPrCyilefFHFj1WQwRvLwmTdBy7o9dFH36FT3exGMITmbx+gOKZfVKNbKsybAuNCNjKp3ujMrj1syEqLVwH5WYmohsabmHd70k2ZfJFL6p7csIJYVyfxQsEvrvrvlCM9kQgYphOLOZ5AusgvpC7GESQ1iwU3SIGFXBy7qbpgvJAvF89DgS3ccCd1gfO/kg5JotvMt2LOOPAccw9fRDfDtzlHIlF2vdlOhNPVgpF/MYC0ppVuPGTzw71kvqqIOLJ+aOqScAMEAXDCXowgJZ5F9xYebrutndGlwTJejmEiCj3GQsdz+VDqaDwQFonacHMz7xq2QZvD8wLE2k=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"The first thing that stand out to me is that the thread pool count _cannot_ be zero. The .NET runtime for WinForms always has thread pool threads, just as a matter of course.\n\nI'm not surprised there's a spike if a bunch of I/O completes all at the same time; these are I/O thread pool threads (not worker thread pool threads), and there's no problem with having a lot of them.","date":"2024-01-27T14:07:00.8140664Z"},{"_id":"2f4f00b0-4b21-4707-b819-c48c71105ea7","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"fhx4dIg6np8ujgiAJb0GnY80Ats2rLBI0CAFWh99z/Vwh08fwXr7ompzz+6lZ2rruobMfkLYbCN7A3vXSavCM9c+5ZXHOlVqXBu/X8MezLp+7KAgR82FHN0ozbfRse5i25XMy3Pztv/8HIvhwTPQxlHdfbif01gaonfee6biT7LywUeWPXlqM2CQmMlWabO/fngfBRhGjHpbFDAxJ8NcdyjL7vLfxuoDQay6tPXwhbWotQa5nzyZOhPVjMAkRdeFz7ZqXZQU64XYxbbcuF+3y/5Flf+6fGe2j78cb0VjRvzqrj9d1U3tfoBcucIL1i1l5g/dYz5vD/b9YjeB6lzYeZfkSVHBf/a/xcvRKe1YXLudkg63ahbCDBYmIgFKt0dGg0ZlYjx0mYuiap+polGeTc1B+XxoBSSl2xvq1AKUl/QaBmbsD1J1wyxWjzYkfJYvlkD1Wo1aZiheB4jMJN19eJjVe9v3zOSGbh76xkxGc5p3NG8bTYJcgwj+wBXf6OmhEqUQSHD6/ibDQNtuyqDWrQPU/kcL+7D7cZ4/r4ylcw+iKXK96QMIYMlHKJW/Qs3eimLOLpEW6eTINGPyc0BUdvg05tVsAm+IwfuFXv9SJgX8tu+uMFhMfU0+vxnkqDpd0XKp0eup4YEcPG85ra3g2Q9oHUC7hV2EcdYU8xqFhRA=","authorEmailMD5":"6cae7683ff5e265431fbdf63c6faf896","authorName":"Mihai","authorUri":"","message":"Stephen, this is an awesome post! While trying to understand how the UI thread message queue executes the final state of the async automata (*method resume*), it is apparent that IOCP (kernel mode object, responsible with the receiving of IO completion notification and owner of `OVERLLAPED` structure) pose this UI message queue entry while borrowing an IO thread pool thread, which executes APC doing the invoke of the *method resume*. How this IOCP relates to DPC was unclear to me: does DPC (also marking the IRP complete) initiate the IOCP registration and checking of completion status by the virtue of SW drivers following standard P/Invoke overlapped IO pattern? What initiates ACP queue with the Task structure and when does this happen? Thank you!","date":"2024-02-09T09:30:37.2016386Z"},{"_id":"25c5218f-68a3-4565-9160-3686cedcb053","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"","authorUri":"","message":"This article is not about 'async/await' AT ALL, it's about the 'myDevice.WriteAsync()' function that doesn't create a new thread. Yes, 'await' itself doesn't create a new thread. You can create a small test to see that. What's the point of this article? To provide an explanation how the interruption system works? Thank you very much.","date":"2024-03-15T16:09:19.7644288Z"},{"_id":"a51ddf40-4bc0-47b4-af22-0be83f311ef9","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"bDyJJm3Xgd8z0VZ+JGnDR32J4yMeRJsecfLYuCcxZKE8pxKyxicQ5pVyTAxlibBiDcDJhy32JkORdtE5/aK+uomEYFsaDiXZbSqfD152LZEe8zfr/m9CIXKsCKd1ZpxGzzwLGwVrmGwReFzO/FVl20ekrqeNB4tI7I8xy+u5p/alfZawbZSMYnP3UJDTkGDj6nIEKZo5Ha2MAmdkR/gNhEgHqTU2HG5cVU7r88G6qjWLZVH8bots26fKJdX3U7IK0vbgXQ2tmEFkcEq47F19aqk7F2uGS92hBhmwezuxNZqEORUf8rOOgB9xInPvcEy5DU5vrjtFYxKfgsqRXXHE7h1YBFLFStMxtIMOGyclPqDeBB7Iifr0Jt4alDN/ZHXSq9cKDXzDhVUzMjbjfV7eP5D1b8olZ73hQ0TcrBc1iFFqRcs6K2gUVrUfiZhV98T02p/G5AAH+reBGdgdtEl09/G4WT9aDmrMEC+ylcPV7GhsCPbFq0+QrgK06i7DWVoawDgEUvB7epM28sVzFdGfSBLIHSwhoSNEs7FaCIKUzvTrbpITVm+jKydoYMA5EjnqktrhoaeIJzBNReMoqyNeGLqSq1N34WBxVY0ElA+edfhQ+2ExqvQOKuv5RjCJQz/gEi9pMxz4Ia+dtYKkA7sCbCR7McPtVSRHra74pqvZJKM=","authorEmailMD5":"c9bc5b6207645a58255a76dc42288022","authorName":"Debashish Saha","authorUri":"","message":"Hi @Stephen it would be great if you can look at this question once and probably clear my doubt forever :) . thanks in adv\nhttps://stackoverflow.com/q/78172932/9298362","date":"2024-03-16T19:13:39.5179779Z"},{"_id":"218e3f98-9494-48e3-b108-34acbdec69d3","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"2f4f00b0-4b21-4707-b819-c48c71105ea7","authorEmailEncrypted":"mLD85yJ7WXnSmzZ8VZSRUMsu7Xl2tuTvM9kQYjPfGwptaxjU2kq3ALTZUZwd+ZwhjN3w3LIoSrD0zdFhQe9JCLPtZxFkfpU7qVv9No9axKHxRHzLVogOnAV/kQ4X43Xs/wPD9e5bfkrJUuggSJHxQunA6SZWoRxepaLz+800uUNZRXV+zts8MoRZk87PIvmmTYj+NlwD7QqPy8Uta0N6+liA1MxAsDd2z62zF526EkivT9ECK6i7V6B8cCdMA5Ic8hdQwQ9wa13oV6lqQh0hpQyNkJzpJV1fR0HDNJe3Ah1DPSyxJvujKLrssqtBtaujgdYAjNZT+TSWBzpXx7sJEFjCaAaDhcDklxmvmt2WZyUmOr/ebLXKJ2hkohyv69TvICBkI1Npb0o/yx/x+b2znhwnWQGYny/duJL5qtaV0UkyD8oPOwq7nhMXe0N6OwyCDmDHf9zZf2OYAGOK/iFPhH8nAwo6YZ4Pm6XfbNvimcJhSpBsoK1us2P5A93PtmN8J1ZkMogyUxTS64M4h62MPTyMcnIm5Yv5qgOs5zvSSykE7GRRnxEPKQ+IHq4vM1Kaa7Lw01GbPntRjVvpqUk+cH248WhlKXA+7dw19yhsHEW4x9ByV8jXulR4gfAjpvPuVeQ4Gn6CuuSgqCFQPdPFkG/PPTngELQtPBfcmFiBaEQ=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"If you want the specific details, I recommend reading [Windows Internals](https://amzn.to/4aavUC0), which goes into depth on how all this works.\n\nAs far as the managed side goes, the APC usually does not invoke the method continuation directly. I have observed that behavior in the past, but it's usually avoided because the APC runs on an I/O thread pool thread (part of the IOCP), and user code should be run on a worker thread pool thread. So usually there's a pass-off from the APC to the worker thread pool before your code is actually invoked.\n\nThe DPC communicates to the IOCP *by* completing the IRP. That IRP is associated with the IOCP, and by completing the IRP, the DPC has done all it needs to do.","date":"2024-03-22T12:17:53.1721260Z"},{"_id":"780fb9b7-4a67-4a79-abd1-a727131c6fc9","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"25c5218f-68a3-4565-9160-3686cedcb053","authorEmailEncrypted":"MUbhp/XeC5URfTrTW7t324NYfn/XlfLMkb9GS2jY2Ix2A10O+0oDpeIc9KBhtrqn3lnFuHnGIcamRvTpIKJh1sXl/LTvA1vCNA4gXZO1Y96uWHt8iT09vIvcP345JvtdH1lufk9AynCtVjecosWiF2FSBdjCcs8lR2LfqSRyYCqc7/oNqVzK4LRUWsIZrd4qSzUqZdfcE1Ma/rt2vIbWTie40LpmkhGBqKVO6UM7IvjEQAix433TsV624osnEaT3EWmSm3tbaycPwizSBQ8SPBfN5BcJNb0aNH6Xl3uDV50yEr09JT0GNlDJJ4lKPkTa/ONxAWeE9hIbN13eJ40T2ZZON8BHQSdm5GN84Tjnyiy/EaeG05RpQ27dUEH4jJUjCd7EbQ+HU7Vfpnf00yTYxSF2FTGtrXBEOgUNgE/kjH4Oh2Vyfy8AbyWEaz8+HgMx6hmCVoECM7+eA3mNFyU3oE5W/51EtgpS//hU0qkP90UA+S8oQEYVaVff+MWtJAD/C1tJsz+zDWJhLV2QllDKcDU3bJbOSwaVxXGH7TD8qpXKrMdzEZoEN1v8O2McUwl1bUd9lH0MbbhgZ4qJy4WRxZsp3hCj/VarUtUHNY5WhRqTqY49h5AtKrx42iZHG2Nxb9Wdp80CP0SgfFBwTYE7QByuwmxYlEZM+mIERolFxSQ=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"This post addresses a common misunderstanding with async/await: that one or the other creates a new thread.\n\nThis misunderstanding is so prevalent that it was addressed in the original async FAQ put out by Microsoft around 2012. I've included it in all my async intro discussions. And yet I have lost count how many times I've been asked this question - several hundred times, at least. The most recent time was a couple weeks ago.\n\nWhen people are told that async/await does *not* create threads, then their next question is usually \"how does it work, then?\" (i.e., how does actual work get done without threads). And answering that is the point of this post.\n\nSo, while you are correct in that this post is not strictly about the async/await keywords per se, it does address a common (still common!) point of confusion about how asynchronous code actually works.","date":"2024-03-22T12:06:52.6948011Z"},{"_id":"c70b3add-b881-4e3c-969e-7cde8c533337","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Milan","authorUri":"","message":"Very nice post. There's one inaccuracy re APC. APC approach is **not** the same as IOCP one. With APC, the I/O completion callback is executed within the *same* thread that launched asynchronous I/O operation and only if that thread is _alertable_ state (see Microsoft documentation for more details). With IOCP approach, which is used by C# thread pool, the thread that runs continuation after I/O is completed has nothing to do with the thread that started the asynchronous operation.","date":"2024-08-19T23:34:49.0732195Z"},{"_id":"cf8db813-c99f-4cb8-a162-f15b35e7a367","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"c70b3add-b881-4e3c-969e-7cde8c533337","authorEmailEncrypted":"l948iOb6nw7Ibpc3+M+RozHXMiQTLrxcT2zMR13YaGdpq3AIPE0tj5l5i/difowifol5joieMIvkboLWIYIId5aJOSfqKNgbg9cHh0gA7+4RJZZhyYIFj2FAbcMDGZIldL9Cim2LzJQQxsSx6MgR8RDGBDKU9EqkY853Kn0fLLi/tfTtsoXXhx4WJ8VlGlS8+KQthew4LnOmBu1ryRM+/MSc6ZZNuPi6wssdj8NMqHO8YJnbmkKrnCqMD1B8e6aEa5WIefrM+tDJrkuMh0tvpf8/WAX667PtJz5nOAS8A9AbgvQGYRmX0ZBpJfnB2mD1Ge9XcGRU3C9gNDWyKlVQUxIZBFFqq4YygszknnvzlQvag57zN/A+YmEt/aVha43WyN5BpVL/q/uLepHQKpUYS3Om4iNCGBPe5a8s8bqpIDdVo4vjR4BcFFFPExa6dGrtKCgjUSZYjGyf5FJBgKvEdkCRFgiy0IybxDFMj6tcrr9fL8R6eXDGu00Ul1M0R7HNagRyaIDD1n2iwGo2MPByQNuoiytskrACoV3U2e9CVLQp7++JOz/m5ICB2bboAQ34Rv0mX55mNcZ86sAx3OLqqu92hSsbT7RtnVIzvavxYWIh3JiiEmDApcJtmwqwmJF54Po/w2WWedlyfBdAy9gQkA9sQy2T3OpqiYByrRaew0w=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"The APC mentioned in this post is a special kernel mode APC, not a regular APC. Windows Internals has more information on this: [Volume 1](https://www.amazon.com/Windows-Internals-Part-architecture-management/dp/0735684189?crid=P5779NHTBKQT&dib=eyJ2IjoiMSJ9.p9cBb_-Q8GjuK0z0kDLKG6xoExPM_2QWt_jn0PlqVBSWYNyqRp2Cd7MHXFeQ4EiRACaX_Y_9xzECC0YpECzSl5kCBD3u1KUPduAgmnO732ERW-HLpOGuzyzeeoxsCqtVp6ZfmAWX0X8x4g9FnaJfousrREogBtDyZYVK3_1BFBPS_Pn7aPT1yHHh45ghPj9lVvuobEk3hZEnArbh6pJdApE4lkvjr5Ydsu5DtJV0Zbo.CwMBFxIChWp1nfUJBhfs1VfJRKx_3P3ekBxX2rQEeuY&dib_tag=se&keywords=windows+internals&qid=1725114604&sprefix=windows+internals%2Caps%2C116&sr=8-1&linkCode=ll1&tag=stepheclearys-20&linkId=34056b667e5e563491d05ccff787cf3a&language=en_US&ref_=as_li_ss_tl), [Volume 2](https://www.amazon.com/Windows-Internals-Part-2-7th/dp/0135462401?crid=P5779NHTBKQT&dib=eyJ2IjoiMSJ9.p9cBb_-Q8GjuK0z0kDLKG6xoExPM_2QWt_jn0PlqVBSWYNyqRp2Cd7MHXFeQ4EiRACaX_Y_9xzECC0YpECzSl5kCBD3u1KUPduAgmnO732ERW-HLpOGuzyzeeoxsCqtVp6ZfmAWX0X8x4g9FnaJfousrREogBtDyZYVK3_1BFBPS_Pn7aPT1yHHh45ghPj9lVvuobEk3hZEnArbh6pJdApE4lkvjr5Ydsu5DtJV0Zbo.CwMBFxIChWp1nfUJBhfs1VfJRKx_3P3ekBxX2rQEeuY&dib_tag=se&keywords=windows+internals&qid=1725114604&sprefix=windows+internals%2Caps%2C116&sr=8-4&linkCode=ll1&tag=stepheclearys-20&linkId=76f83b32c6206e6c1aa481de18618afb&language=en_US&ref_=as_li_ss_tl).\n","date":"2024-08-31T14:32:12.3336807Z"},{"_id":"097d5a17-54e4-4f09-886f-1bab0d956ec4","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"UrXHqvn/Li8hJMCJbI66YWnkGHmOBJzsNuh82fg8i3AcLKGn7RjAql5n6hwBoZB287LM8S0eyb2IzOhCe82swzFoFhEVLoEKL72gx6gjJtD5IuaOT6g6nFrINHWLCJz7RJUH5ju111OWWi/6GPb8cHS1lD3BHzuxEMaNpgFVsXK1Ztb2a+ZfB4H38Vh5GlT7GP/tOWllIDOXNxg0pWGbl/RcRNzatzXgxjjtI9NKdImjoEHzsHKPDzLlctGQ1Tpc+iAqyyZDPrG/ptfELX/fQF+UEZX1l/47uTFCjklH4IRiqGlE8vHM6UK9USH0Jj6R2UlJpRVLlxxVJ0kgV+5DgjqMLmuLbGkk+/s4141DwlC4/mQ0IX2IIE5aY4kK85IWat4j43rCKDQedrLNkM1JV+AzEuda6vX5GEdOXr8kP5EDQ4ctMAW41jgtF0XNNshaKZrqwMtXHLnSQVzF1EbW0gUlSOZrRrlg1yOaNqmR9p0IZ3TraIdTzlQBK0Iz+6C9BSfdIZ3DtFrwGeZx4znkywg6MT8gV+4oyuAZtuCGeRlWwLnN5bgr1dZlrH/KnjR156MtD7M6U3FAQGvBSypK9qtq12ew+MJlGbdpOm+yUExn2lSVuwqJ8tNo6XP3TENHYfmYD4thX6Aa4LyrlGWMwLHPM3X0ClE+oIrkp6trEs8=","authorEmailMD5":"a0bf0e3b85927b20b5c03efb74612051","authorName":"Ken","authorUri":"","message":"**Thanks a lot for sharing!** \n\nIt took me quite a long time to understand one thing: The blocking behavior of `read()`/`write()` system calls is just a illusion that OS provides. The **\"REAL\"** I/O operations, just like you mentioned, are always not blocking.\n\nI think these questions also help with understanding:\n- If I have a thread currently being blocked/sleeping at `read()`, what would happen next?  \n*The OS would wake it up when the IO completes.*\n\n- Then how does the OS know when the IO completes?   \n*CPU receives interrupt from device controller and the OS code handles it.*\n\nSo my conclusion is even if you have created unlimited number of threads, the OS still relies on the **async IO interrupt** to schedule them. i.e. When to wake up who.","date":"2024-10-02T09:21:11.0724777Z"},{"_id":"87d97ba7-754d-47a1-b442-c320c72c820a","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"097d5a17-54e4-4f09-886f-1bab0d956ec4","authorEmailEncrypted":"lX7nNAFpc9PN3BM5M4uH7sbzOrVZRfbiuF29p3pm7iV80Is6bTYfrECF+9mR83FErnm06Xae2PHn0BkPAO2ATuspiXxMEtZXaCT9toX4ITaGVdIl57DcKKcGEeDgPcID04rJT8ZW23u8wOHtaoZGRlrnP9QkrN0J79eFNKl/yEzvL7X5PwqwNop8H9YxxLhUodg7b0PMmLtdscWCUICeKuIhYTliuAytRdQyA8fKAEgjJLjSTc1dpNXXVrhJt4fI52AdNoI+EmZvUKgSVk3oZYM191UKLVraU01e+GDAQw++VsyoRHYpZCkUc8L7ESV3ccRULLLU/t1LBgt5XGlOhLe2ovKYrxbQEVctQ2pGBUgGPe6lZuqs+PtcIfAeiUbSPTZ7nKH3qYsi7/s6zHz47//K9QCXUCZQRVswmZ25c/uSuFDldUOQtS4WfrSitOrG+Wb/bxra188MnPOUGBkiySssKQrFJaBwudeZ2V40dEY1d7bUgXaxgRZ4L6W5TSo5+sToPohXlZJWdl/eLWovFvHG2j0wYvoGcqRcwz4bfDo7hf7a8HqCeFPCcTAHs73w8glkcGG/XU40TQGYU48PzeVt9GdqrMVYn7w/XMqiwCMr09w3jO9YOI4EdWhVaFb79+fbJc052Pa7nbxYA6Qengshle2czTqIdGxDtLuxIiI=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Yes!\n\nBear in mind that my post was written with Windows in mind, and on Windows every I/O operation is asynchronous (it's not possible to write a synchronous device driver). On Linux, however, device drivers may actually be synchronous. I'm less familiar with the Linux I/O stack, but I assume that if it has a synchronous device driver, then the OS may actually end up blocking a thread even if the user-mode code is asynchronous.\n\nBut on Windows every device driver is forced to be asynchronous.","date":"2024-10-03T06:08:22.4413851Z"}]