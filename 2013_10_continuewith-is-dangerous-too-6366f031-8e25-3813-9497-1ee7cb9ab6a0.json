[{"_id":"adfe3917-cb58-3146-9137-1c35117a59f9","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The best shorthand for \"ContinueWith\" is \"await\".","postId":"2013_10_continuewith-is-dangerous-too-6366f031-8e25-3813-9497-1ee7cb9ab6a0","replyTo":"","date":"2013-10-04T01:17:54Z","timestamp":1380849474},{"_id":"d87e391c-226f-35dd-8adc-10e828561518","authorName":"Sriram Sakthivel","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/14791805082342292214","authorUserId":"","authorFallbackAvatar":"","message":"That's unfortunate. Is there any shorthand for Task.ContinueWith like we have Task.Run for Task.StartNew..?","postId":"2013_10_continuewith-is-dangerous-too-6366f031-8e25-3813-9497-1ee7cb9ab6a0","replyTo":"","date":"2013-10-04T01:09:30Z","timestamp":1380848970},{"_id":"4cba3b0a-71b4-3613-a77d-f2f7daf26f32","authorName":"Admirador de Damas","authorEmailEncrypted":"GyuAOJcfx+RvxZgc3C7ZDvc0RmqB98mmOSGgWGiM8W7JIAcz3BV93fl0vZ1zmcyP1XKZez377GsVTcEpii8s0aiG8KyOrFyIa5Oxdec9j0fXt9n5joao23rrSqjUB575N7dzFIC0ysieXiyaeXR+Di7lV0SVMdK+HlBtwGBpALjnTGw8HZTpPvaknQF9MN36gFgw1XiNHT7xrn0jgNjV+uzXcL3pxWbZyoIiOdmRa3d81qh4zbZQ2KSQpssXoLLkewnb20Ua9phJKCR80VmquJEY2KT666pPgdHeuksLdGMUVZImgrS/fQ/3MYoP9l0/HheTsUg8PFaWXCuory9wwpeoKts054W3yB5CnxvRIkrDmKJIg0dgI7yerAcjeflakz/4xWHia7p81JoUPoZkjXWv/2UpKcbqI+Wtky1lb+33R6uV+rjfi+CiGfB3UDBTm2pL4U8Msb2kGpv4X2csuUyZbHfO650+C6WG8Uz+ceZ91tRVRkVi8HLMmYwqI7fzdj3rpEvQJO34KiKlNLRzvX1ewlfDI3UXaSnE45vo0MoUOX1g3djvK7MHCEv9WI4Uv3ILTgNWiZj+m1cr90kyTPTnBw8yOLIQupsAo3OUPtMNV6Qj90yHhpD/ej7M0WCC0jQRZum+zImcfFufIrlTivHC9nVhuGi5T/eLN0kt/70=","authorEmailMD5":"873dbd5fe8982d6380307a3d52e59b5d","authorUri":"","authorUserId":"disqus:admiradordedamas","authorFallbackAvatar":"https://disqus.com/api/users/avatars/admiradordedamas.jpg","message":"Suggestions to Microsoft MSDN, a Little prayer: Source code best samples using best patterns and practices ?","postId":"2013_10_continuewith-is-dangerous-too-6366f031-8e25-3813-9497-1ee7cb9ab6a0","replyTo":"","date":"2017-04-25T08:15:18Z","timestamp":1493108118},{"_id":"4acb62b0-1a8f-11ea-9eca-ebd14bdc5874","postId":"2013_10_continuewith-is-dangerous-too-6366f031-8e25-3813-9497-1ee7cb9ab6a0","postUri":"https://blog.stephencleary.com/2013/10/continuewith-is-dangerous-too.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Karlo","authorUri":"","message":"Are you saying that passing TaskScheduler.Default is safe?","date":"2019-12-09T14:22:12.913Z"},{"_id":"ac2ed9a0-1ad1-11ea-9eca-ebd14bdc5874","postId":"2013_10_continuewith-is-dangerous-too-6366f031-8e25-3813-9497-1ee7cb9ab6a0","postUri":"https://blog.stephencleary.com/2013/10/continuewith-is-dangerous-too.html","replyTo":"4acb62b0-1a8f-11ea-9eca-ebd14bdc5874","authorEmailEncrypted":"O40ulCBLuY77eUxmp+8xyAEsLNsx8XR7GcaYXG8Qg3g3D1SEfmLnTJB3lkJgcUzVWizAE0UljdNT4rf0Ejee9n+Z5RXW1+NQbtEBHnb/gElHiT7rVkg4hhX8bXAHIvwDPmjtWHvlcOE7l1/Wx9tZxCqeldrxiUuz0knN3NrpJVNwjcPuhZdxgO4ymjFPYyVMlWuOMdOivfknIyi8dUuStKLiftd2kGxjAVufe2bzpmWbXLxfOWmkr+lymd/QfngamNP1mPufGfBpoNUqri7KeJRTjr4Yg6iRPRiODWlcmHWd6ADfdrv4o9UN1MrPHIIya+g+wjemLUYFJ0wrIrr6v1PE4UbCnJ5O+WVB0Zkm7sxXg2NCZRWAJMP63CUqRRzrZijR5QiB1mAx11g2wqhQWObYX+Aszo4OktL9X47lyknCPFJnLstQl4XI6yW11NY9efbK8l1BnhWOdTjqWjL5k2NbXHUairq0+PGMza8hSUCA3LFLMKOZUwMUPRAsVAkYrzPMTYUv/1fbahhpdEk3o9lp3JMxBCXsX6oSYdMAap+QK7Gv4w6oONjABqqKs5FmVvGUBrhx8uP/lNt1Izdd3UoPNYDerq73Z/fdT3WyCt9kbtZdYNg1g9KQ7il/a/DaeulreZbZWVCaej9wk3aZpS+GBNGwzMXcF2xDPA8P5rw=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"The `TaskScheduler` is one way in which `StartNew` and `ContinueWith` are unsafe. They also do not understand `async` delegates and have non-ideal default option values. But if you always pass a scheduler (e.g., `TaskScheduler.Default`) and specify the options you want (e.g., `DenyChildAttach`) and properly handle `async` delegates (e.g., `Unwrap` when necessary), then you can use `StartNew` and `ContinueWith` correctly.\r\n\r\nBut why would you want to? You'd be adding a lot of code just to do what `Task.Run` already does for you.","date":"2019-12-09T22:17:23.117Z"},{"_id":"168f03fb-64ca-43a7-8249-460adcc5bafc","postId":"2013_10_continuewith-is-dangerous-too-6366f031-8e25-3813-9497-1ee7cb9ab6a0","postUri":"https://blog.stephencleary.com/2013/10/continuewith-is-dangerous-too.html","replyTo":"c10383f7-cc45-475a-8994-24aa40afa3bb","authorEmailEncrypted":"fg8d6fGOKaSAKj6o9xtnK2WuSrjGCH+QzLzzu1r7SBJNlVD5BFGY7ETlHgwYb/NYkqAZDesvO8fJJGfHyjgdd6H9/wQKitq244OFIHWYxqaf5L0Nbw9LfE3l8WbORzxHlwPGhVtp+L8SNoZRx6P7fAeDhDf1xOqyBtTvmNdoPzficIox+uE9TEpVYs+WRtfMCJOCL7r8/1WGnptJlf1XbSV1CY7Xtia9TkSaFSNiHtAjsY0FBY7R7ocVTMGocPOuCxR9uTZYpakSf3HVqYvob1ahtIoxDgKRIYmYEBbBoYdG/wowNMLeFxbFxG1EBZGVs2kogIKs2wR1mfScPMnVVBZOz3jSN/oS47Tk9WOgYQyf1WnZOeTa4I002OZ3ukz3+3iOZXsuHzDor3FsBEW6PCY6DDGYDYVfhei1dkbGH8o2y/5llpc9FuwPGP/tsuNbgPxwl3aarDi/nIwPvlz2VELNPCgj2ABvIv2PJD82LDzE6O6yJ6vCvqkqiTd3BKz+ths2W88oDXyJAu04EjbXhKEqy8OQGxnU83f2QcOmkM3epjyG/ftYsVOFmAdJfKzg6d/ObO8UpBlJVt1adwCazWu/UZk3nFVIW4O1qTp+XL0vuQCdDBIn8SzrbQGMvcDflJphcUN0WQGiz5SlvLK5/B23GouA9wMVE6DrxeIhHx0=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"> Task.Run will always use the default scheduler so following it up with a ContinueWith will also use the default scheduler.\n\nNo; this isn't correct. `Task.Run` always runs on the thread pool (with the default scheduler). However, `ContinueWith` is called immediately (likely before the `Task.Run` delegate completes), and `ContinueWith` uses the current scheduler of the currently executing code (i.e., the code calling `Task.Run`, not the code within `Task.Run`). So, code like this: `Task.Run(...).ContinueWith(...)` may not use the default scheduler; it would use the current scheduler. It definitely doesn't inherit a scheduler in any way from `Task.Run`.\n\n> If you were continuing on a task, wouldn't it be expected to use the same TaskScheduler you started the whole chain with? Imagine how more dangerous it could be if it defaulted\n\nIf you're writing old-school Task Parallel Library-style parallelism complete with `TaskScheduler` usage, then \"the current `TaskScheduler`\" is expected behavior. That's how this API was designed. If you're writing modern Task-based Asynchronous Pattern code, then `TaskScheduler` as a whole have surprising behavior, and \"the current `TaskScheduler`\" is part of that surprising behavior.","date":"2023-03-09T18:29:31.3636165Z"},{"_id":"c10383f7-cc45-475a-8994-24aa40afa3bb","postId":"2013_10_continuewith-is-dangerous-too-6366f031-8e25-3813-9497-1ee7cb9ab6a0","postUri":"https://blog.stephencleary.com/2013/10/continuewith-is-dangerous-too.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"","authorUri":"","message":"According to MSDN, Task.Run will always use the default scheduler so following it up with a ContinueWith will also use the default scheduler. If you were continuing on a task, wouldn't it be expected to use the same TaskScheduler you started the whole chain with? Imagine how more dangerous it could be if it defaulted","date":"2023-03-09T18:00:47.2675967Z"},{"_id":"baca2c42-709e-4c3c-be11-62758ca281b3","postId":"2013_10_continuewith-is-dangerous-too-6366f031-8e25-3813-9497-1ee7cb9ab6a0","postUri":"https://blog.stephencleary.com/2013/10/continuewith-is-dangerous-too.html","replyTo":"","authorEmailEncrypted":"lNFSxmE0Hm95jpZDVfSt8jNFHxJlmCasZqcTlf7R22OZwfZ13GcxVeoffxOus2uVe2Xs7HDc6xZy4IxfgA6KzLPgo3AVKqI8LJlFIYbQNY3k8XsfSxKbwL02A0MnFB1EcOYQ9UDimu8eUFXsZ0H1A/W7nu33+ZBDBUvgivjuPwHDYaSPLckgBg7rKa5QvuyNJZaSun+wzPmH2dG7bLwpCkYxNaTSwrx412OT88zboqjDC7lmZTedAynk2c+LvnWHAqu/rKkrQtqaRjRgK6OBoXlm9OSGcDSFtoG7zgaauXkZgw6rJ0DlPhKW0DC5Y9zJ+HfaDeWIZh3CYzZWZlgOXFm6LDmeAUJFxYC8k3YKxko8uuKOlJAIZnimWThww4TTT6TWuWn7FJe8kN+32DQQDnW6Uunq/CNrlLFz7B5ym8SbTR2UKdjwhXdmBEV3oe3H51HkFbAySMS/Z61sxXDCmkyM/DtnjF2r56kc7kfDGC/BbtvcngUUqrDdR0cYuWo+HALh8CkHIR9tk+jpRhZ+22YMI7HDuhphPjq/IuBs0Ek8VNj9+NDYr01VVtwrrZO2c5cv+9pXwL7boStKKFPPijKz6ilPVmjkTM/aR9/2HVya9dhVLdpF1YaC1+tDV8qKCXoo0xJBlizlDfBMqdV+VPYSit5P8PwNMTfGxND+kdU=","authorEmailMD5":"13b7c89b1959c82b46e2b249b8358d63","authorName":"Yves","authorUri":"https://ygoe.de","message":"So you recommend using `await task` instead of `task.Continuewith()` for understandable reasons. But this changes the flow completely. The following code is now \"blocked\" until the task is completed.\n\nIn my case, I need the method to continue (actually, return) and have something executed whenever (if ever) the task completes. How can I do this in a safe way? I don't want to use `Task.Run` with an `await` inside because it will be there forever if the task never completes. Keeping an additional cancellation token seems overkill.\n\nThe background is, I have a method that's called when my client connected to the server. Then it still needs to wait for the handshake to be completed before using the connection. If the handshake fails, the rest will never run.","date":"2024-01-02T22:29:39.5967467Z"},{"_id":"56bdffd6-935e-4673-ad36-4181461c680f","postId":"2013_10_continuewith-is-dangerous-too-6366f031-8e25-3813-9497-1ee7cb9ab6a0","postUri":"https://blog.stephencleary.com/2013/10/continuewith-is-dangerous-too.html","replyTo":"7571c810-5606-4acc-8e8f-e5706d19cb7f","authorEmailEncrypted":"XjobMjN9JgvLQlnvkp6oQviODUMwVQll38PZQQeQTafd2iaKMGZt6evOoXiqpmxPLaWR3tvcsT03M+SF13MIVwD9JpMkPh4TymugIVPgL2/dazh4p3fCcqK7dYl6bR64J1xDQ1P5xbo8YMxWLYnXvmDBP6sKb1G5tlyBHaVvGA2EIuwRLBDVeybcUz39vbGzj571T6II8PGSHpiZWKJOf3fT+JIr/pXkZ7tVW/snNxa8olHIZIE0u9SrnAXn2HP/7P4r24A8MDXlrwaP6Ac2gCL5e6Ov4DV42DPbpwvIkCHe0045zmT0Vom6qF8lB97CtdQfb0S4AA3xsEMAPortgMmy/gDWSiePBIi69mx3JzkP4X/2T8Rv30Ov+H0vDIvZ6FFeTkhbh423hHX6ryPfz/Hzycve0PG6KkDH01E5VhxWers4G7UqfjF4Im4NiFJZWU/0JbzbK6gTr7lo6JsqEA49eqEK2UKr1dIcCQx+8kJF2AdVEiN+Nul3L/rPgr+/s/MoBTsG87D1m/tdXPesoY/CVORG3LuGMwVlwO4aKkq1HG6OhWud6ZgGQHvJo4gXM636eks01FkCAwLjM5NNjL55lZTRFQOVXGz9ykNXwc2GIZ6FaGlfo9QSlwS5gTVZbx4CR8vdFd9dZ+yef1dvl9wy4qL8olYYlg2hxrrwNq0=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I strongly recommend storing the task; without doing that, there's no way to do a clean shutdown.\n\nBut if you've thought it through and you're sure you're OK with the ramifications, the caller can just... _not_ store the task. ;)","date":"2024-01-03T21:50:12.9739104Z"},{"_id":"7571c810-5606-4acc-8e8f-e5706d19cb7f","postId":"2013_10_continuewith-is-dangerous-too-6366f031-8e25-3813-9497-1ee7cb9ab6a0","postUri":"https://blog.stephencleary.com/2013/10/continuewith-is-dangerous-too.html","replyTo":"7e1cbe62-7c79-4ee7-b46e-a4476dd5d98e","authorEmailEncrypted":"t/McOFjTLQZI5pemYxMOVC9WnJxzjz+kNo+Iuh47enIaYQO/FVdl3LH1rDU5wROZ+/xGl8MihhOijTfPiqJnJ2tKD4yN37k/S7Ii2doiHcaoY3959RxFa1pRS9XnrOyVSgM1gbFe/5YcqXlMTq79sNTsg2QbeNKLk+h+WOo0yixTT75xGEJfSAe1DLaH5rxQHxryLIxsybTM4fKEuHRvyzqVjI5CDMWbfKMP24WEhCOCS5TufqASwRmI40cRYs9qMCkkcGyGBq2ma5Hy94ABa1cejh8mJJAxsMoBz4pUqGXH3brTv88AA2LntZz1TKJGu+nZyrTfOpZHpasP2Cx+SW6HSlQNWsJzWfZKFGo/hcF1L14W1gXM9aqlUdRgFnQJ8n2KTFN8Ak4BlWpZ8lK6wdLXT33BPy6XVm9tY2/Fp3ePQx9C8PXNqgg0AyqRspL2sw2XLLa9udm/UzfKY98VnKWFYPLjgvmRrtnkUKyScC6kGrtaZUlt1dd/2UmyutKzxXNraitQXlD0IGrzIH0vMNFfr2wTn+1IDLMEAKUVC3rajhsJGX88CH/w2CXVYh2zlqfwJfBj191mEcQamvDZr3TV+JOA4ysi/k3sVf1cCpR+AGXi717ux+KOLGgB7nhTS0W5SOGN2uA2EQzlslMNtd9sCK2VDlBYUDxrPoCt6uQ=","authorEmailMD5":"13b7c89b1959c82b46e2b249b8358d63","authorName":"Yves","authorUri":"https://ygoe.de","message":"Thank you for the response. I wasn't totally aware that it does return and the caller can choose not to await, too. Still I'd have to store the task somewhere which I wanted to avoid. And the caller might not know whether it's a good idea to await or not here.\n\nI could now rewrite the code to have a dedicated callback running when the handshake is complete, so I don't have to await the task that indicates it. (After all, the task is also completed from somewhere with the `TaskCompletionSource`.)","date":"2024-01-03T21:38:19.6231936Z"},{"_id":"7e1cbe62-7c79-4ee7-b46e-a4476dd5d98e","postId":"2013_10_continuewith-is-dangerous-too-6366f031-8e25-3813-9497-1ee7cb9ab6a0","postUri":"https://blog.stephencleary.com/2013/10/continuewith-is-dangerous-too.html","replyTo":"baca2c42-709e-4c3c-be11-62758ca281b3","authorEmailEncrypted":"GzRM5bU4xAVP3rWc+qxJ0zUB63fKoheVJ1tmAo1Vjz3q5ykRqKXSQsdmB2KdWZCHYL8wwgLd5kaZLcUG03AlAE1TD5NO7bqhrF2xg8+vMS81G+TAK8PaiKP0UUBssLL5/FY/ISl7GcaKi4sT1Hw/v1HhsmTwxmNkg09xA5StqFOFT6Z7c4m2UdspsPBfFkK6sv/ba+Ipohv9QIzjyLTvlTDeFK+bXObg8iKDj0cQE72+XlSjdmEFiATkovEienxKSURZSQQGnKDM29wCsjfqYsEKzxNxr1Mlkvy055b/RAdPqlG5t5T3fZGpBPV/lkspOIqZB7uBKoW85i6mFPFcbepR/i7keQcPXoTf0E8P5Hp2KEUQDDsg3tMlYfBw6FP1Wxrcht7Eg/MRiIpvNatrpZ3P/2Yk31isKQOogosuETjrQPwVXj9ZJnCfOhRGkmKeIPQLujdNBtmpsWKvc9jbQqyd3vOQqZyj5TsIuMV29qkpuFCXDi/r23Bquju3HtLkoBRWABaJpev4Az0tqUGgoOR1Gsd1rzUmT0b25r8vlz+th8iOkw5RFazcEURvV97BoCHWeQf+/HYPnYyQKAkaf1fqISqstJNjbenJCYsEhA0JPYr9fCX8pcniXZN5Cn5nMDqDqqMsUrGod7tLh0JgQuFd5TCA51lcBTZADCpPsrY=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I'm a bit confused. Your first paragraph correctly states that `await` only runs the following code until the task completes, and you don't want this. But then later you say you have something to be executed whenever the task completes. _Which is exactly what `await` gives you_. So I'm not sure what's wrong with `await` here; it seems to be exactly what you want.\n\nThe method containing the `await` will return as soon as it `await`s some task that is not yet complete. It will return an incomplete task. If the _calling_ method doesn't want to `await` that task right away, that's fine; it doesn't have to.\n\nIt sounds like you may be writing your own TCP/IP server. It's pretty common for those to have a list of connections; you can just store the task in the client connection object.","date":"2024-01-03T03:49:31.4894251Z"}]