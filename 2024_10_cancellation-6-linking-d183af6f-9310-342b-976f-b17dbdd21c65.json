[{"_id":"51ccb468-7bcb-4c36-8d24-d156bebbd1cf","postId":"2024_10_cancellation-6-linking-d183af6f-9310-342b-976f-b17dbdd21c65","postUri":"https://blog.stephencleary.com/2024/10/cancellation-6-linking.html","replyTo":"","authorEmailEncrypted":"O2I/MU0uZ90ZaCGW/+mWvmjr2L0CpbIaa4OFx/ZsROOW/Q331WwiSWRw2t79hOyAVGrwzKGcSV2bqpI9Xvb1Zi1vq2S21tbudhDjeEoW81HQHGmQlQC/lZcwyIjK6Z7EQe+kcWkLhBW3YEEr9aJUe+CDXeWrZAzp0mI1ZEKBWY2J1rEdMEx2TR28QtMKNU510/GQLsWbkwDmeiALjeXg8RuwXgLQnvC/aimO/pCH2adN+noySQjgQ67MM8T6fsbwOSeFE6BDCB15sT4g6qxy9tvxR9toWR1fUIE+OvHEfRg8iY62uyMaTvMW3pI0OYu5gEY3Bh1hruNSd2or8saJbdoVWssJ4bdjwiNHdNQTggSnC8OAuzJaaOQ+mL6f6jAsXT9iariO/ubjLKVMEUP7OxoKiSfQr+fIL44lmM8H+oE/n7Eti0TTB+ociKUHMihUCo0Nmp+EsUYuSIw56bzskUPpu2icQD9/Wx4r+HpPY41KeC+VueLbROt6RLD+anoVEPTf7pjY5ld6Sxi4zvayv/ZOxYGvCi9xjxOuC7jbNw6eFmlrEhtWWYWZfkxU+SW+l4dHTftoKEbU9RHf1hPw71knOO2eUzNWmIFKddmUVMoqbjQdqk9XRv50wpwdGhkIGaYKeZSGDJGCql7rB4Mx/1enp2f47JbQpRuQtdmY4yY=","authorEmailMD5":"7bcbf5cbd8c19ed27fbc04388a1a2f48","authorName":"Sebastian Schumann","authorUri":"","message":"Once again, this is a wonderful article.\n\nYou mentioned the pitfall of monitoring the wrong cancelation token. For exactly this reason, we have specified that every cancellation token must be called `cancellationToken`. Nothing else.\n\nIf you create a new `CancellationToken` with a linked-cts, the original cancallation token has to be overwritten:\n\nYour first sample would look like:\n```csharp\nasync Task DoSomethingAsync(CancellationToken cancellationToken)\n{\n    using var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);\n    cancellationToken = cts.Token;  // Prevent the wrong cancelation token from being monitored.\n\n    var task = DoSomethingElseAsync(cancellationToken);\n    ... // Do something while operation is in progress, possibly calling `cts.Cancel()`\n    await task;\n}\n```\n\nThe same procedure is applied if a delegate is used which is passed a `CancellationToken`:\n```csharp\nasync Task ExecuteWithTimeoutAsync(CancellationToken cancellationToken)\n{\n    ResiliencePipeline pipeline = new ResiliencePipelineBuilder()\n        .AddTimeout(TimeSpan.FromSeconds(10))\n        .Build();\n\n    // ReSharper disable once VariableHidesOuterVariable\n    await pipeline.ExecuteAsync(async cancellationToken =>\n    {\n        /* Your custom logic goes here */\n    }, cancellationToken);\n}\n```\n\nWe have to suppress the warning, however, which is not a problem for us to prevent the wrong token from being monitored by mistake.","date":"2024-10-31T06:58:21.8903489Z"},{"_id":"2dfee15f-2aee-42fc-a725-df6075ea8a70","postId":"2024_10_cancellation-6-linking-d183af6f-9310-342b-976f-b17dbdd21c65","postUri":"https://blog.stephencleary.com/2024/10/cancellation-6-linking.html","replyTo":"","authorEmailEncrypted":"GQ5+/5Edu88eJGqwDDqxGL/AEYRRgzL1QQRqwyfO8J8QoYe+1DuCnybcRMZyvugDcGTfZ1An1PiDbT+9zjjBNTy2QyAuy/jK8Q8pE68bgV9N/Sm5zgStezsLAFPXk2L5lil6e3wnsI49Bu+Y2fOZ6oZ0AWygxSBq369bB/fhu/5LS/RH7C8lnFT6cPngf0u9Jnan5aYr5+nDa2HmHSafVlykzPUbviQTmSKqKyZcn7AXCuPdLIktPPpQHx06MmcshcoN8NDxegq43vFz2AFJCItn9WlpAjOuVumeoGhr5Gh/U5WgKFKaeiRlFfM0Rb3OPBJ6VwE6jp/7S2cc7zYcEiygOA2WNMOs768JkJ7Id/YB2LNl6n1IB/uKzvwng2Xsm6yJbTKCmswJiEJqEZca1wB+L4e0nXqAxBNBNrQn5N5Bx3JdBrVZKA/BdjJhuf+7z9YP/+7v42zETQKn6c+hPaMBTgL3LzayCRISdbWNhBYzxgTwp4zreUnMb9twDmkSvfbRivVrNiAxlV7rfqmT2Ozx1wu9uT7BvEfXnFkpbb2X95OnZgLDWFMm/t1IMwgA2ajw70GlvlRmkH2OepT9tyMQdXWYAXNU1JmxOrxLKMw/phnTNcGxOm1ZF2TkuNR2CNi498DW5iqoVUzlkCQjUqOt0Nl29ah8+J5sW2SBL/s=","authorEmailMD5":"e381c8fa1f86ff42adeb23116541dd8e","authorName":"Shripathi Kamath ","authorUri":"","message":"Can you comment on one other use I have found for a linked token?\n\nAt the highest level of my application,  I have a CancellationTokenSource with the same lifetime as the application.  If I pass the token from it to various functions in my application, it makes it easy to abort operations fast and gracefully if I need to shut down the application. \n\nBut that token over a long time accretes references which keep increasing until the LOH grows irreversibly.\n\nTherefore,  I use an inner token (linked) which is disposed more frequently. \n\nDoes this seem reasonable?\n\n","date":"2025-01-26T03:35:38.0492260Z"},{"_id":"2cb821d9-64dd-4162-8064-3f53af185a9a","postId":"2024_10_cancellation-6-linking-d183af6f-9310-342b-976f-b17dbdd21c65","postUri":"https://blog.stephencleary.com/2024/10/cancellation-6-linking.html","replyTo":"","authorEmailEncrypted":"WfAoWl8WP1o5a6WGgnod3+rKmNSSnvWwnVXLBO0uiDflPG2jkzKK6Rs7BgkA9d/6HtlXibN+CI7hHKQ2sXNZQiSYiSEkfdN/hFK5tabHKGIn6IXcLQ6kfhvCQpwgRxy/JaHo2j/LELoYdoh6tgQQausHQjZATZ3mQ3Q+qOJOajQywywlKWvYCcEabhBIccJ6/WNyIl6Y9a0J6xuGbCZvuDq+JEJjZsZMSrGNBqpe1ssBTXjbtmj7wu0q6r+NRPnpyPqiZXi+sulGhOK08IqlWNsP3gZztErM7eNBse37xHjYVbSYaoKr9ob/EzBjghJTtKLfNS5QjuFDYQeoUTAZaYCklx7l92uTUlQ0LOpR0zGwhqc6md7dTj+RaVU+aRCNdtDCs+zeb3YnIB3QL/WqKFPoVbE8MeNFrr7fDunKq75baHtYwSaofIJVl2cvAwMGJ7F/U71Trn4eB0sD2K/ZOetunWoXhL493hAgzEYxMYIXbb7qb0vrHfFgEHxt8kl6m+7EHYtraW2284zxvZOR3BEVS9PBMTnEapReHfhwYvS/sOC23MzAtREcU1yXZj7jG4nB7Sp9UEpTa/zishrASPOqxG5OxWnp1rH2ySN1070uERZVMhawEd31FRuLY9AL28ce+Y49MHenG0V7HsQTcuHWWRu2/3ownHdzzTVdhs0=","authorEmailMD5":"30cec367a10f6f6e5412401a65972bf8","authorName":"Denis Bredikhin","authorUri":"","message":"Dear Stephen, first, thanks for a wonderful article.\nAt the beginning of your article, you say that \"Microsoft documentation is quite good\".\nBut I don't think this is the case...\nThey have quite many examples where they silently swallow cancellation, they nowhere explicitly say that doing this is an antipattern. In general, it is much less clear than your article. \nDo you know what can be the reason, and how can we influence them to improve it?\nSometimes it is useful to have an \"official Microsoft recommendation\".","date":"2025-03-20T08:26:14.7657317Z"},{"_id":"b4bd0f86-c643-482e-8b0e-43f10db6d568","postId":"2024_10_cancellation-6-linking-d183af6f-9310-342b-976f-b17dbdd21c65","postUri":"https://blog.stephencleary.com/2024/10/cancellation-6-linking.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Daniil K.","authorUri":"","message":"I want to highlight something about the last example:\n```csharp\nasync Task DoSomethingAsync(CancellationToken cancellationToken)\n{\n    using var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);\n    cts.CancelAfter(TimeSpan.FromSeconds(10));\n\n    try\n    {\n        await DoSomethingElseAsync(cts.Token);\n    }\n    catch (OperationCanceledException ex) when (cts.IsCancellationRequested)\n    {\n        ... // Do some recovery specific to the timeout.\n        throw;\n    }\n}\n```\n\nThe `when (cts.IsCancellationRequested)` filter in the `catch` block doesn't let you reliably distinguish whether the cancellation was due to the local `cts.CancelAfter(...)` or the parent `cancellationToken`. \n\nSince `cts` is a linked token source, it will be canceled if **either** the timeout triggers **or** the parent `cancellationToken` is canceled. Therefore, if you want to know whether the timeout specifically caused the cancellation, you need to explicitly check that the **parent token was _not_ canceled**, like this:\n\n```csharp\ncatch (OperationCanceledException ex) when (!cancellationToken.IsCancellationRequested)\n{\n    // This was likely a timeout triggered by CancelAfter.\n}\n```\nPlease, correct me if I'm wrong.","date":"2025-06-28T00:04:05.2178359Z"},{"_id":"4c2a94a6-5b31-416a-a9a1-6236b4229e1f","postId":"2024_10_cancellation-6-linking-d183af6f-9310-342b-976f-b17dbdd21c65","postUri":"https://blog.stephencleary.com/2024/10/cancellation-6-linking.html","replyTo":"2cb821d9-64dd-4162-8064-3f53af185a9a","authorEmailEncrypted":"wovCM3h4UedI3UGEBSYqzNg9I//9Ab81ohnbmDsbmPV/em6gF4yFczW3osM3vAfAttZJjzgiXYvSBb7Pz0Cb13pmRJAp1dADaE65g7Wj9apzfppwqOr8PCk14urnip6Afl2bFcGAW9DLyc9ObTnglRDgBY6hA0rteKcpeWinVWJGNYj4fwLVu8nFpOV8Lr+irtbA9OVsbyK6rTnWJrEwGg0l+yGYRUzB8+K/cUGlo4fjJaswDoNxybvQ7lxWf/XAJVOfJ/0YBshIuUX941T5/Gr8fNF0+SzI/g47c4Lhjrw/flCG8ozqrtX8NCWgsC7GYLLH+FzWoW1+5Dhq4iUH4y4ZFpI8iTy0QBuewxUBeXI9KGuWz3I2IzKyYl2kpxZRg235CY0ozmdX+jwSXNabD8+mVCDxs3pHOqvH06oAl0N49oOYjI/sUrXBqBhzKxGRdlNUuITuRh9VFsBnKrJfJdFpPcIDYApR+RvlUWbQAPhKclDte5zaZ1w27kldFKJ/Ld4Z2SuEMnfQT0sy3+fMt8jvrZg9lSv4VxAth0UnzYv+9j+amESZeXo4IPhwz4cZQub1U+5JPyyVbOYWdmVA1Ga91jAi4d+Fad88v6o7yW6eNHUWm+LbY8WJ2p1S4Z4yfESXy3il5lcc9yQuDqkO7KGnzfQjfsNAYo8GBh9F+ZY=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"When I said the MS docs on cancellation are quite good, I was mainly referring to the [Cancellation in Managed Threads](https://learn.microsoft.com/dotnet/standard/threading/cancellation-in-managed-threads?WT.mc_id=DT-MVP-5000058) topic which has provided good information since the very beginning of cancellation in .NET (4.0 IIRC?).\n\nBut what you say is correct regarding examples in general; example code is not always the best quality. Many times Microsoft example code is actually an example of \"how to call this API\" and not an example of \"how you should structure your code\". I don't know if that's a deliberate decision or more of an oversight.\n\nMost (all?) MS .NET docs are open-source these days. You can suggest changes whenever you want!  MS encourages contributions; you can get started on most pages by opening the three-dot dropdown on the upper-right of most articles, and selecting Edit. That'll drop you into GitHub, where you can fork and create a PR.","date":"2025-07-18T15:00:49.0857100Z"},{"_id":"810d2717-925c-4baf-af73-232068b15a39","postId":"2024_10_cancellation-6-linking-d183af6f-9310-342b-976f-b17dbdd21c65","postUri":"https://blog.stephencleary.com/2024/10/cancellation-6-linking.html","replyTo":"b4bd0f86-c643-482e-8b0e-43f10db6d568","authorEmailEncrypted":"m+xrQpCElb7B5s1WyfZu3+3YkMtfHl6aQ0EY/+0FFvWnxk0Z9e9UZ/h+brlJP3gHtdD/DZtyc/N5Q3L5HK6yaumduI0X/XMGUlwUEDT7KVL+oUYjfPIccwOiQwIVQ/bsUjoz/1Q6Q2uBIA/EQMEbvFYM1/37b0fXDKmfey+8snHFDgawdf1JaJdEnHqrShn81qtDcVp0fCWst9lONmCJe23ezFDgOXyuqBZS0uZ7dF2xrY9BCvE4GTHclOK6Omu7Z+TGEfN+D6LkcxxYQfEBGXPIFOPsMh3RfkwTCfJJav/bEWUX1GYll6mjsaouNNB6WXLaEupeOJTPc6FG6X2MZz2B5JsZuiHA4HSd3FwPViXa6JtpDJfzNCKp+JyIMN4rCl5Q9CG3Uua5rW6+Uv2kScx1qfLlPQA0qParLH1OonCCG9WybZVmhR5DRtubwWEQ6qrdYcS+IDSHYHl5ox7tegvjmClA6B05bUMHWMAL84J4cdDiz6bLX6SGnB3zHUOwGxdUrMFHpb953v9WTkP8gpiGHcd9j4Y9sVepyFuDz89W10wqaG/N6KHQlJ9O4Tl7Bna+7PVOl8Fe0MbgxZLK2A9qe8fQNOvWQo91b7p001OI0Z+4Jj4wTeAtKRve9NzvH6+fUvr0IbnrL+S5JeqfSNDWMVFVUimo68dqO0ET9JM=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"You're right! My code was wrong. I'll fix it when I get a chance.","date":"2025-07-18T15:03:53.4701510Z"},{"_id":"88566808-0b20-4804-91ff-f0f7ca5f384a","postId":"2024_10_cancellation-6-linking-d183af6f-9310-342b-976f-b17dbdd21c65","postUri":"https://blog.stephencleary.com/2024/10/cancellation-6-linking.html","replyTo":"51ccb468-7bcb-4c36-8d24-d156bebbd1cf","authorEmailEncrypted":"ef7j2qR3MJgUSzch321ehuIdIRPYPbgR9otYkuVqK3NMtpDXwHdaIF+3LXeuO9LzYNJSk8U95VMHSyBpQVm3lAEAQGQTFjzsb1WBlaFSPiBP5LKbvs2LK6J4ZDZtdXxMSra5if9ompDzmBKoxuaE5KZZzcw91mpqIodPEYFppmekpBwzQLavTHXFzge5l9rz7Jq0os7oZse1BerOmGL2SNpAH1AwkQvslxrdw0ki/ghViZqQJPJgKMZ3ptNkGxKirvyzlp/REKo26T6yxduIDBMnXET4ObNnjqgDR8+5z2cWCbt4vcfNimfKSWvj9PDcOVvqKxP6Mj4FU6xTjsL6qgC2J4cu8YKg18fejwm/7C6My1uM7ET/loZm9WuvNgNGce3UknUwOx2BLjsCeyhDo4T8LsQKHzma4Yulq7ZNcLolSkIcnc73Q+Fzao+d3mtUBWfnUkY6/ivs8qrwZToUl3vAJNRQQ8Mdqcjt/07BoA7p/Sbpb0piWdxpCFjW5sOxHPRwmIgoYXbxW5varqotPdh77fhnWydAU0TI3fRMN/v3gO7Xxkih1MplHijD10mQ1o/X7v72fUhp7OW54aZRpMk5rvldvFOTl44zoXEfz8wUvaabOePHN60EzSjzZOjvp/HED1vYqDj9UwpSFrYJJkTz0LIzQvIqBGmOjksTM84=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I like this idea!","date":"2025-07-18T14:49:23.8585467Z"},{"_id":"cc5f29cc-4c5a-4d26-948b-224d26112309","postId":"2024_10_cancellation-6-linking-d183af6f-9310-342b-976f-b17dbdd21c65","postUri":"https://blog.stephencleary.com/2024/10/cancellation-6-linking.html","replyTo":"2dfee15f-2aee-42fc-a725-df6075ea8a70","authorEmailEncrypted":"dURjv9ob/N+az8MaCmUhzTy3ajdUljY4qKK9yqcYkaG+c98kfJZeabqiDA35Bc6WKijTlIQ33VlUqDgEAFF4FdGn1vMRwbWc6woc5DFVh8xUFqcozWsR2W2M4e0Wavkffbf1zkvap09guLSJQ6ZfFl3Ev4JyqfBVkLQUkEcJerb71yCV4kPO9t0iY0ToMGSTbWUR1pXw3CrOME1pQp0e5rW8R5qgQ2bksrgcOprun0Ot3ATrbry4PWFAR04K5ak5+kpnBiyJKXmGMLTRnyrnUXkGf3AKVJl7dduowCsz2/YDtT59lszuxDem5l4okEImyKZ7wGVNmKe/FUpyNAQOws/oekAA+qlAAhZNSxXIJQt59FuEG9Oe4YzIWeQKEsrC25vazsgyQAMiDisJQH+qgxy6XfeNBg4cqQh3YYst8Ko0D2GWHvwW00ovBxFsxt65Cgk7Y9EGut0NYwSWsv7HWcB3s4OuQkrNuWrs7QC/O2/1Z3xYMuntNkCxflRidqWaVn9mVlasFFvm5zsCBqooqO6KPjoU5ajk+oWh4+yt75IRMQhuFLAJlZrYzbT45gzD4lT/lIwFF7/f+XcVfWqHZgAuStbo9gHs4TbtSoznwoYkSbFqAcNWhKvrkjj7nnzO4+GxiODLcoM+nTmUWjWhDYYkeQBoJbTnyh1DT+AOZdk=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"It sounds like your consuming code isn't cleaning up properly. In particular, any `Register` calls should dispose the callback registration if it isn't needed anymore.\n\nLong-lived CTSs don't leak on their own. E.g., the ASP.NET lifetime has a CTS that is scoped to the lifetime of the application, similar to what you're doing (`ApplicationLifetime.ApplicationStopping` and `ApplicationLifetime.ApplicationStopped`).\n\nI suppose if you don't have the time to fix the code properly, using shorter-lived linked CTSs would work. Sometimes that's a natural approach anyway, e.g., ASP.NET has request-scoped CTSs as well.","date":"2025-07-18T14:53:37.0299106Z"}]