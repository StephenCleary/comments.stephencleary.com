[{"_id":"09c108d2-2c44-3870-bbcf-c107d173178e","authorName":"svick","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/17579249405158039163","authorUserId":"","authorFallbackAvatar":"","message":"*If someone is working on A, they have to be very careful which invariants they violate while holding their lock, because B is depending on some subset of those invariants.*  \r\n\r\nBut that's not really about re-entrant locks, no? With your proposed refactoring into C_UnderLock(), the dependency is still there, the person who is working on A still has to know how that method behaves.","postId":"2013_04_recursive-re-entrant-locks-2b4ba4bb-380b-3fca-9765-9a08c2b8bda1","replyTo":"","date":"2013-04-26T04:10:59Z","timestamp":1366949459},{"_id":"f169adba-692c-38ac-9cb4-625e59c829b1","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Excellent point. I'll update the post.","postId":"2013_04_recursive-re-entrant-locks-2b4ba4bb-380b-3fca-9765-9a08c2b8bda1","replyTo":"","date":"2013-05-07T03:48:05Z","timestamp":1367898485},{"_id":"6edeba94-2240-33d8-bbbf-9bfec091329c","authorName":"Alex Yursha","authorEmailEncrypted":"lZbF0yhAv5Focl7G/X0RmGD/FqK57Hqjv/W285RQQWKG8Z/FPhWQPKsxSRI+WZ3oHf+h9Lcr54SFFuUen0LbO9d1bPFbMx/CXn6ROl9vWRbwNMIucqb/Gt/c+JfebD+WIiI4fIpZ+XpaK9aNe2AqqMFWk2zq7y3EaFnsqdyGdR7+0e1N63KHCsV9hhX6ZjUZNYaLstTjfBosqbzB5bR8t9xsAwPSWBUNXteiyMfpsFi6YZhGTCexv9vbwCN0EKpNq0ibXzGVgNcWuHll+J0lkB5XrOf43qlqT6gZMQ+TR0mXj+E6HxB9j4/BGwziyEsJ1NTgVOUtuX+sOz57KH+rfwsWkdUGj2jtCyxKMAWX5THMO7+tferdj2IeT97VliyBayE5j9Q2RenH+i0cCFeDEE2owkFK/2ZvDdk1I0+++Fsf6mp+JwJ+rjKmCa39reU9Pp7cUboKtky9MWPlXWZ8iS0K0ibQCJMUrH1CodHv9RndfUViLWaemakXUguI1d0JAEfRgIlK13S3dLvikr3fB4I3PPPnmdbybEArBDobMXEiLhXtkBR+ZO7TDZJmYZzf0j1lqrAeroNhDZfa1y5hUZ/a8nEUd8fCfXaoA5On08vLbXtHW0OpmfQNeOFyOlBqmU9xtWNpESUGdiovtAfTZjCbZgAYIT+UE7+wm0tSCr8=","authorEmailMD5":"2dcebb212df339cbcd221755478a6ba8","authorUri":"","authorUserId":"disqus:alex_yursha","authorFallbackAvatar":"https://disqus.com/api/users/avatars/alex_yursha.jpg","message":"Wonderful post. Still useful today!","postId":"2013_04_recursive-re-entrant-locks-2b4ba4bb-380b-3fca-9765-9a08c2b8bda1","replyTo":"","date":"2017-05-19T21:44:39Z","timestamp":1495230279},{"_id":"214a77c0-70c8-11ea-9a0b-219d79660d8b","postId":"2013_04_recursive-re-entrant-locks-2b4ba4bb-380b-3fca-9765-9a08c2b8bda1","postUri":"https://blog.stephencleary.com/2013/04/recursive-re-entrant-locks.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"xylent","authorUri":"","message":">> When method C needs to change, itâ€™s a simple matter to verify that all its callers are still correct. With recursive locking, whenever any method changes, you have to verify all methods it calls (and all the methods they call, etc), as well as all methods that call it (and all the methods that call them, etc).\r\n\r\nHow can you assume that the method ```C_UnderLock``` in this case is *always directly called from a method that acquires the lock*, though? It may very well be called from a method that does not itself acquire the lock but is called from another method that acquires the lock, i.e. ```A => B_UnderLock => C_UnderLock```. Now, when you need to change the implementation of ```C_UnderLock```, you not only need to review ```B_UnderLock```, but also ```A``` and anything that ```A``` or ```B_UnderLock``` calls before the call reaches ```C_UnderLock```, and anything they call, and so on. In addition, since now you are changing the implementation of ```C_UnderLock```, you will also need to review anything ```A``` or ```B_UnderLock``` does *after* calling ```C_UnderLock```, since the invariants may have changed. So the problem at hand is *hardly* any smaller.\r\n\r\nI get your point though and agree that the mentioned problems are in fact there (great article pointing to them clearly), but using non-reentrant locks is useful only in making the mentioned problems more visible (which is still a good gain), not in magically getting rid of them.","date":"2020-03-28T07:45:44.497Z"},{"_id":"25da6f10-70e7-11ea-882a-0b6f14800880","postId":"2013_04_recursive-re-entrant-locks-2b4ba4bb-380b-3fca-9765-9a08c2b8bda1","postUri":"https://blog.stephencleary.com/2013/04/recursive-re-entrant-locks.html","replyTo":"214a77c0-70c8-11ea-9a0b-219d79660d8b","authorEmailEncrypted":"ZZipjW6bnnR1UwDcW4fxUKPqehYk2Ps0QSuhpr2MdRvNjJlUQX0b7klpzyASkL/9I/s7JAswuK6OIJJbvHb/96Phi4A8lu0rum6QXvTcI/pSXWUV5GP6aqgeSo3+xFktrPFGOhhvePJtSf1Wf6HGyEemRuHe3mD0fB36t0/wwaBH9ZBpjU9x1OZIHCb6Y9uNtJ+I6HqcirgFGoTdNozRGZjMgWXlNNDSoDYE5VLZ0/FvHnRD7ZDfTYjJHsaeYLxBOoRLsHi6a8wp3/ceoHlaA3Kr5biJ2vKWLIWx4W045pkdkUE/jMLR67AJVEzphXNbtGV4V0H+poY5PnWSozVJbroLsNUdG/vp7HEN13mLxZ3HYE16e75INLK++9+PjnKMtSZkG/qm3+akXh5ztIGHEFp/zMWsr5ptD9AjQSFNlD32DRO/61FoyOxqUUBa7WocO1rDs+v4VKcc+W6RSq3DrpuLcCrwZr/hbrpkrLbshOig85Ooggbk5h6XhDjBZ/R194gPTGT3ZzaEQjlbyHYnF3QDoNhtCoO7BrfWuDk5Rk9Y2Eu6tO2J2/HU2Dhn8l8Y9an2lN3BMx467dTmAjFLxvFeYNCMXGDEC4Yt5EBhE0Iy6nIzQFsRagbOH65tuKzv+HpLIKernp2HA0R8w08XQ2yoV51eSwIIzseXrqEcDxQ=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"For the specific problem of inconsistent invariants, yes. Non-reentrant locks (and the naming convention) only make the inconsistent invariant problem more visible, and thus the code is more maintainable. It does not make the inconsistent invariant problem magically disappear.","date":"2020-03-28T11:27:46.575Z"},{"_id":"6a7a0780-0673-11eb-bf85-850fa784bdc9","postId":"2013_04_recursive-re-entrant-locks-2b4ba4bb-380b-3fca-9765-9a08c2b8bda1","postUri":"https://blog.stephencleary.com/2013/04/recursive-re-entrant-locks.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"","authorUri":"","message":"IMHO, non recursive locks result in more code a maintainer has to handle and in addition to that, they have to understand the implicit rules laid out to avoid multiple locking from within the same thread. Lets take the collection example. A new method has to be added, say.. `removeIf(predicate)`. Then the maintainer adding this function has to at least find similar methods and mimic what they do (check if lock already held or something) and get that right. Just as many opportunities to mess up.","date":"2020-10-04T18:57:14.661Z"},{"_id":"b54e12c0-0721-11eb-8283-ad0ae3d0eae5","postId":"2013_04_recursive-re-entrant-locks-2b4ba4bb-380b-3fca-9765-9a08c2b8bda1","postUri":"https://blog.stephencleary.com/2013/04/recursive-re-entrant-locks.html","replyTo":"6a7a0780-0673-11eb-bf85-850fa784bdc9","authorEmailEncrypted":"WQHtgnaHsis1ZWPsetn7pU+vLJI5GsH3CgrKCS3dnw1z/5cLIrGK/60TYaxpxJRnVUnSefCWpFOt5szuJQUHxUFJgKD9gf9aJibeDux5fzRk3NBCJN+euv43thP9qzAIibcVppBH6Jptu4gsR6MHugWog+GPs5XNMDjVuWWNJwV2p4ssTxHvwGQj68PFqb6WmhkyvRL7jS1+s4T2lO9Kn2OI3dy9f+VgQr9M6Br101UN3XZLd1dljbyHSEUpCuudCYQq0pK9N2D6oP7DpLpFRT+L3S0173u1TRyaPWULS75eKU++XHsAYGH0kOfNO/n6d7vg3rdRu013rRL0QQ9NOejDoazaMHZi1VirCWRMUqQyDS+NdlIamn5GIXIRhP0coIq2igdEVaY7Gke5ojHME5/jwMOVBgvzManyP6DhFtUdISyZD4aw0gdjCoVbK9yqsqIi3nnUoS1iBnvuqce+rM17NiiawVGn1ZWOI7kCRYI8Eis+Q0tYLLFCW8qJivDgpS8ITpwxdALQGYgMus6eD62Phu2dyuA8YTAIRZVejeGYWXeQyDKh0XqLW4bfCLpSg+7dqIWmKGfsIIzAQW4/I6roxsWRyKEz4eTh9WoP5EyvxvXPNFrPdD6qRgp5EO4hzfybKQ85dIjAuv4e/qL/PWtlTZFk2VlnGX6BkeRDMms=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I disagree. Non-recursive locks do have (a little) more code, but there's no duplication and more importantly: each method only does one thing. With recursive locks, you have methods that change how they behave depending on how they're called, and in my experience that always results in maintenance problems.","date":"2020-10-05T15:44:52.391Z"},{"_id":"67a44850-23c2-11ec-b10d-157b4bab5ab3","postId":"2013_04_recursive-re-entrant-locks-2b4ba4bb-380b-3fca-9765-9a08c2b8bda1","postUri":"https://blog.stephencleary.com/2013/04/recursive-re-entrant-locks.html","replyTo":"7b983f10-234a-11ec-ab6d-053298adc8e9","authorEmailEncrypted":"dIWTGIv62QgeMzep1VKSrO4pJxXukceAT2nZZUwRa0YeI0Cz08TCp/NEJP6v5m/cANgV5oC6+/2AFmzcjCGAEYCTUUApCkBRPxKK1rG8OElDXNOPrQ68k8fYIJiuSPCX1xnTZgplWUPogOOR79dm8PSDeU2LvgJbJW80tHjGF3YvTKPNqXDt9LXwCQzO6A7jcE3swGPjfoG7DalJuh2swyeffRzq1yKDNwJqOudVVbj/Xo1ouNcV5RArPIRfpSxesJQ7XRtkQYnxoewx/TJkjZnoIk6y+Qcw/j7nYqKS2NDuPkefcQ0kHRmgOhBJy9dsZSNJtq1mc+BGSjVg/pU/YtIaiONioDmAvqTijyWU6yn6NFwUB6cLlmVkdre94sZQR6SzCRIYipl+H4MZRGvzQNEdvIgKMl+6BxUUlfxQyLCtvctLHV1+LrDnObfA3Qjhn1HDx/v/2AjFVlwBwQStNHrUNNiXC0Qwkjog9Lz5UqBWTqCcY/jG5ZPRYE8dczrh6D2BsfxIXg3lHpOMePMmwcsWPNGONamAlLENiaXQU3oubm9gsRFs9qkToKZxyIMCTQUiLxmzEUzST46eN9yP4Wo4Q5zymIJGLWCg2vETB7wszUCbUzcm4mO9tIyLJhESf9VIBkZxRVOourwr0TFMtMQzdq3GYFNZkv/Wgm4Al/A=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I do not have a blog post about asynchronous recursive locks, but I did write an implementation, untested and unsupported: https://github.com/StephenCleary/AsyncEx/blob/v4/Source/Unit%20Tests/AdvancedExamples/RecursiveAsyncLockExample.cs\r\n\r\nIt uses `AsyncLocal` to keep a set of locks that the current code scope \"owns\" (i.e., has locked) along with their lock counts. I can't recommend it's usage, but if you have a broken existing asynchronous recursive lock implementation, you may not have a choice.","date":"2021-10-02T20:50:41.315Z"},{"_id":"7b983f10-234a-11ec-ab6d-053298adc8e9","postId":"2013_04_recursive-re-entrant-locks-2b4ba4bb-380b-3fca-9765-9a08c2b8bda1","postUri":"https://blog.stephencleary.com/2013/04/recursive-re-entrant-locks.html","replyTo":"","authorEmailEncrypted":"NXdHBq55oQYKFQSSGZaSLfo9J8ECN4M18UQ18J6kA8mZyZOyEmw3HOK5rs0jY0I/LpGzeV266sAG1NMvYV9OIlU3cXOsxcMWk/UPupiK7O/qdDpbFzrz077qjcrWphY3O7XRKV50mTmJwgJOdEOQyFj2DMIw27AsvGfVGR9WYc/ip8K9qPzufl/dnwS1wCEg3a5xt7k3xrhbKKpHWDRLS2KOxx7sht56YQqT56gXeKMlXcG2wGTd5HFZAStnltDmDWUujd3+jzby51XwVJsXiAvEk48pIAYzlHWpS1QEx3g3HP6s47eBeA2OZhmbzbNOtKrb3sm+4b5WLc8ZlITDTeK1v9yTUsm9b6pl7sJ4UW4FCLfHbQrpD+/4NIs7cNNG135aPpfhdoAAIkpPM8kIOTwppqv4b3hcNdZcbDrCP1jtFUjomCu3Y98LCU3IUZn+duclhZ1K00soRv0v51/lfmI0Xa8lyfKdHPfyIiKuYyso8Z6G1whgOLz2WBicSpWF3dlYqqNmej8DsZicBc6J5bOt1kn3Vg515a//PnXh4aiIBpDLqj2obpdermBsciP11eKoTP/kpyzkO3QB3xWBgs9KREyu8dfdGgzBKdbGyawIlRpm2XdykDPBK/XLR3yeQsmeoN16Yv+0ehOZLijZdBAtPEBIUh/Do27t9u0iiAY=","authorEmailMD5":"c11d34cec748e365c7fe4e9394637216","authorName":"Max","authorUri":"","message":"Thanks for the article, Stephen!\r\n\r\nI wonder if you have a follow-up article on the asynchronous recursive locks, that you have mentioned in the conclusion? :)\r\n\r\nI have inherited a codebase with an asynchronous recursive lock implementation that I need to fix, preferably without rewriting every class that uses this lock. But the more I think about asynchronous recursive locks the less sure I am that it is a sane concept, even not considering the arguments you have made in this article.\r\n\r\nInitially, I thought such a lock could work by tying it to the `ExecutionContext`, using an `AsyncLocal` value to identify the associated \"async context\". But since `AsyncLocal` values would flow up the _syncronous_ call stack and down _any_ call stack, I could end up with multiple threads acquiring the lock simultaneously. And in fact, in some circumstances that is exactly what I would want, since I could end up on a completely different thread after an `await` in some method down the call stack and I would want to allow lock reentry there.\r\n\r\nThis seems schizophrenic on a whole another level -- I simultaneously _want and don't want_ to allow _multiple threads_ to be able to _enter the lock_. Do you have any comments? :)","date":"2021-10-02T06:32:15.261Z"},{"_id":"30acc960-244b-11ec-8078-c55cda96390f","postId":"2013_04_recursive-re-entrant-locks-2b4ba4bb-380b-3fca-9765-9a08c2b8bda1","postUri":"https://blog.stephencleary.com/2013/04/recursive-re-entrant-locks.html","replyTo":"8d221580-2444-11ec-8078-c55cda96390f","authorEmailEncrypted":"Ucr1LwbCsXwyY0WesVLIehPFhSEcajySAL/IZPB3N0QGuevxM+fh9NsMwOP5hiCSoMYcBTc1YCUtgwt5r+zw5/STVGkcpG11tQd+d7hUaSGM3+/24mgOuAmXGJzdDIQIhoRvDtu036viEJcUTgW19na2vbr91hISP+VQ5zxTq/878xspfL4wIScqJy8Ujl7wGwYqVzJ3tgk83bD0HTsh9YE8NaVd5PpsHh7bPgrhdaHjSw10P/P8ZfowbyHSkg5oigJAdTmuZ8Ys3jvNd6i0jgmc/nLFq5E775cJL8J9KrsBefg66OoWSlJCLlBYc2Q/hd6yzDdX381AXnZAzXpZEdDOIFH+pG2pYefCHENtfLmWfyj1uZ8DHFrRN43D6tlHqLO6RLKxh2jfE8YNIkC9G0PkvVDOdE6N6A0hyafThwu5nEo6VUqQzIpYfwSZLbdrbCSx5ZCAzhBSg7NYTt9w4RDMth5jo5PCF4CnZ3MQuZeYZP7kS0M86LTcRnwm/YDri/FYxhJzPAwtSVTQqodYd1iyh/qRCG6HlVLyu+wY6Vrg/4jlrl/L7axUaEspOTWStkoHbXOecj836RjIeJozamEyk6z+W2Ciezv2oFtpYidOHAvON0mSSnk0C578lHXHJBhSEM9LFRXW6HE9Cm466JGudUvZOAlhrMXI0doYiEw=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I see what you're saying. The problem is that AsyncLocal is establishing a scope, which is inherited by child threads. If you create *two* threads and lock from one of them and then try to acquire from the other, then you'll see it block. Your examples are establishing a scope at the level of the test method itself, and the child threads inherit that scope, and thus already \"own\" the lock. The key takeaway is that the child threads are not independent from the parent thread.\r\n\r\nIf you want to prevent the child threads from inheriting the scope that owns the lock, you can suppress it by wrapping that code with `using (ExecutionContext.SuppressFlow())`. I haven't tried this, but it should work.","date":"2021-10-03T13:09:50.129Z"},{"_id":"8d221580-2444-11ec-8078-c55cda96390f","postId":"2013_04_recursive-re-entrant-locks-2b4ba4bb-380b-3fca-9765-9a08c2b8bda1","postUri":"https://blog.stephencleary.com/2013/04/recursive-re-entrant-locks.html","replyTo":"67a44850-23c2-11ec-b10d-157b4bab5ab3","authorEmailEncrypted":"Z68hOz2oRhXiIwU5Hq3QS8vnOaBNlXaLWyYApOmBJ4Gtu8sjpaflnWvwdrFiR4HTU8CbY2Jfy89nuFuTMahDGj8xzrFPS1BwbjzzK7AN4qAOIRqNlMeKH8KaGzwHmxyhQ7mWr22aCALMcH7s94294WKYc/mxTN0NusjeY9RCvAN1z5naxvzsesySmhmz6fEIaXJpVMQ++VdxrTsh7an6axV/pREJMmyAtdUTIhCX8Hjm54Ri7HjA/O8ru5Cw4Xo6iXMPU9v46Jhqd3zOhUwyYVg1mGi2zOflaE3wwlxM79M9BgWwk4PlTf1Rq6uZul7oUNev9rlQ3mnGY+2mrlCyLFvC+I5+G0jIBQwABBNldoHOhdMTw9Rd3RIp9Kor+gQaM/lJQ3bjz8LGtAvsSsqfMXYddwrGAeZHiGLA8H3nLVGbM6LpClUNi274DP/ks7qFafDchmD0KcdIgnv2TVx2Cz70jmEjpFnAnmoPAKaqVKuqVDVRWLyFnxdmoha+hCMGbDrwJT33N2ez9nQLXnVceiJ1IIdgxJmeVhyvo2z2Jli/t4nrYn7/v+jjeq/uDNpmDYeaadBavHB4NVv0BtvXHPpXeZIfBx7JuEEbOXpFy36dw9xZeEYhds1C9G4LitZ116r26WkfBZmWVOBJmvHVfrtX5xAVSKOk8u0140bQnRI=","authorEmailMD5":"c11d34cec748e365c7fe4e9394637216","authorName":"Max","authorUri":"","message":"Thanks for the link, Stephen :)\r\n\r\nThe main point of my previous comment was that asynchronous recursive lock is not a valid concept at all (at least in .NET). I might have been unclear, so I added a couple of tests to your implementation to better illustrate the point (not real tests, just a quick and dirty demo):\r\nhttps://github.com/maximcus/AsyncEx/commit/201c48c5bdf22f7631761f5da98f43b1630e8ecb\r\n\r\nIf you disagree with my conclusions about the theoretical viability of asynchronous recursive lock as a concept, please point out my mistakes.","date":"2021-10-03T12:22:18.816Z"},{"_id":"dad085d0-618b-11ec-9503-d14966ab9845","postId":"2013_04_recursive-re-entrant-locks-2b4ba4bb-380b-3fca-9765-9a08c2b8bda1","postUri":"https://blog.stephencleary.com/2013/04/recursive-re-entrant-locks.html","replyTo":"7b983f10-234a-11ec-ab6d-053298adc8e9","authorEmailEncrypted":"VDNJqcsEwb+jBYkPdL6jwkNUnWCWM7OGdApl8wlnFdalzaxAKeqiM8Lf58ysG980v8DvigRTSuOWUeObp7zmirCfKtkYHKxk9hN3/CmWcl82+nzKiA+h2iJNAPXpUNY7ojuPnRVysrOq77p5NZocYanJQhvDIoYo3ca+EJY/ncArsc32h+OS9mMCffPLevspDVj5fcm31+YYNWh5VKGsh16Ug/cYiR2jIf/bjhqJFEZXJfzdJuMSyQt1PirxzJ+9Vtsj4svmqhtWfaJlWoD3PXG0LiggDpN3/DpOU7WFWT/TdY4hwNdTPA46J9H1wKX+3egpj5nOEwQ9sWgiRWoojKfCS5vVZLP/goMbvsF26VeBgts4xunyFXEwMiYT3prbRJkrrD0mUL0enGqhFi2h4X8kVkn7J4XuaeXYTBALziCWVkTHUuyTmBTs/fU09iqTfdFDyQWlIrAUKR8rub/aQcZfBneBwdNTndWorROTcz9JThsoQyce0vgX8BiOXc4MR5eEp5nNiK2cLpbKU6dZMyz6t5PcdKVbaAWtv2kxTyBFkUvdxJWCOO2dAmlaepbmjg5bEZKqfK6owLGF+fTXO2ySvWbULlW/7SpKh0HivNrmsUsYkmyO2MzoTht8zPYTJpHTT5A61BmgkWx7XRhIMgqlzN0dBQEVHNpqq4hEoQI=","authorEmailMD5":"c11d34cec748e365c7fe4e9394637216","authorName":"Max","authorUri":"","message":"I wrote an article to expand on this comment, so I'll leave it here for anybody interested to explore this topic further: [Reentrant (Recursive) Async Lock is Impossible in C#](https://maximcus.medium.com/reentrant-recursive-async-lock-is-impossible-in-c-e9593f4aa38a)","date":"2021-12-20T11:56:24.442Z"},{"_id":"e19a97de-cf97-418b-8b1d-a8aba3081d5b","postId":"2013_04_recursive-re-entrant-locks-2b4ba4bb-380b-3fca-9765-9a08c2b8bda1","postUri":"https://blog.stephencleary.com/2013/04/recursive-re-entrant-locks.html","replyTo":"","authorEmailEncrypted":"N8QgksYdDEzyO+7Y/fFFNNfp5BkZUHRLlKO8IEL82ZAMe2IU1o8DdbqwZMVApoOhZhpqO7t83cpIyWHP3oo/cKgsC+3f+AaiNiEVtFZ+myae2sUtocFIFCGRl58zBk9MkxExS+CKgcMEFHKuGKa4jLq29+I5NM1UYPu7bhz2qPhxq87a8qInBw57ZunIlQNijj2U8fZcyna/YIF6Y926Z3thhqw9mYOm/B/c8XpY/d1o3VLx7YOgzJy9SqbTOKciCyNT3BqO/EhTzbncpVCIC9RvCkuWzoryt1QGZH2aLc3tgwMcV1QcLhFuSm0L76G8LlJTWjuF41WbvNX7oI8WSqiyoitt9a/DfAb5AZRHZZZuP9X/5CVh0s6KGhZCHcNYckuVRF35WUmgkDkLEZJrOpdJLWWtIQlph32Cfr86orYJ6MXrFSqeTLuOdUNohMa9tU/vGIogiE/iD03mhcM/UeIV6+90hZ6Ecrjnmuq5NYSz0fVduapKNp0Imo23wE0cWcnzNt5rpt+kFnz4S3dLQg1dYIyZywzLZlngG5ndMHR+HsXOPLdwTpSzwkcT3TbsugW3ybRAPDlqaH2JEUE4I507u+zxMzHs5b2LQcTfFc1hJdYHMuMyw0+HFcOff5FLwOjh8AG9rWBYxi7zNIjud6zzp3tqHbd8XIH5x5x1Im4=","authorEmailMD5":"f4fa2effb77c48bf460210baa762cb4b","authorName":"Kevin","authorUri":"","message":"I did use a pattern that is a counter-example to that rule that I'm curious to throw it out there.\n\n```csharp\nTask operation;\nlock (_runningOperationLock)\n{\n    if (_runningOperation == null)\n    {\n        operation = StartOperationAsync();\n        _runningOperation = operation;\n    } \n    else \n    {\n        operation = _runningOperation;\n    }\n\n    async Task StartOperationAsync()\n    { \n        await GetLatestValueAsync();\n        \n        lock (_runningOperationLock)\n        {\n            _runningOperation = null;\n        }\n    }\n}\n\nreturn await operation;\n```\n\nIf \"DoStuffAsync\" happens to run synchroneously, the recursive property of the lock is necessary. Not knowing if we will hold the lock or not at that point is a consequence of the async/await system...\n\nI'm definitely not saying this is a common pattern, but it seems like a legitimate case for recursive mutexes in a traditional application.\n\nThanks,\nKevin","date":"2023-03-24T19:48:49.8179150Z"},{"_id":"a3b140f9-5883-40e2-8740-a1c54f47ef20","postId":"2013_04_recursive-re-entrant-locks-2b4ba4bb-380b-3fca-9765-9a08c2b8bda1","postUri":"https://blog.stephencleary.com/2013/04/recursive-re-entrant-locks.html","replyTo":"e19a97de-cf97-418b-8b1d-a8aba3081d5b","authorEmailEncrypted":"kGeERhbNzwP4a5CBO0lbtW/Pu/XjKC/nELLWlRA8LmjBZGUHg1+CoPHuiWQk+U+QAhM8xRRlWcNvvbzCsmjQ/roJzsLS8Cuw608wOOfB6bnGUohkjxgGH8WAjTI1/a+hZcb7/N/bPOcM8j50D1VAfwg22BHd5CzgPuf8xwtDdco+l4Goz2uu9MQI6uUS9NGGCciXqv7gqrkGri97pn648/1rbOfpS/xLQod7TkRuigeqo+XHaugOlXjz1Ri3iqdnWlJkKariqhugU0uwg1ZUVusC2YiP4fprSaysSFLGvhD7FYEr/ohpJvo0I5QiNmDTSebdR67cn8KaQJSFq9qP0bayuzai30M3t1sTpHY4ROKKyofUDiPNqnabbe+Tft97FlALnaGOI0JdIUv2TOKiT3uXEDJHfuU1APJOdBBl7LjhppS3RJdMXK6u6pDpV+bURvxEb+7Tk4O7VYAlXaPAqdQctJnobYYmDnlKlrxTIp/AcHkez/zUOS09adlKKptGnqW+UA6QNBBbRB2AlZpjuRyFP0ViNJZLe2jto33iRWYQBFp8pNNeanOWoJAEMiBxy6G4IxNc/XBTztcQCI851maQ7iKBrDO7uVpoj0bcJZNNV/lf1oxvvSnHV+ZATHrT2dH377vDacyeMwAiXSpJTaQ50U170yWY2mfHdHBTGmw=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"That's an interesting application! What you've done is essentially an `AsyncLazy<T>` that always resets itself whenever it completes.\n\nI have not been in a situation where I've needed this kind of behavior, but I can see where it would be useful. And the recursive lock does make the code elegant. Of course, there are no other methods that would use the same lock in this case, so the drawbacks of recursive locks wouldn't apply. Interesting!","date":"2024-01-28T03:02:45.6531732Z"}]