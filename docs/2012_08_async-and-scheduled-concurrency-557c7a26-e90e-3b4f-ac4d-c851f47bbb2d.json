[{"_id":"b3fd46ff-a68f-3a59-ad90-2727a6e70311","authorName":"Svick","authorEmailEncrypted":"","authorEmailMD5":"","message":"I think it's important to understand one crucial difference between the async synchronization primitives and CESP: When you await inside CESP, you implicitly release the lock, but if you use one of the async primitives, you still have the lock.  \r\n\r\nThis means CESP is not suitable in some cases (but that's why there are other choices).","postId":"2012_08_async-and-scheduled-concurrency-557c7a26-e90e-3b4f-ac4d-c851f47bbb2d","replyTo":"","date":"2012-08-26T03:54:34Z","timestamp":1345953274,"authorUserId":""},{"_id":"92994677-1c07-32d3-8089-e806fc7f6771","authorName":"Stephen Cleary","authorEmailEncrypted":"XokHdzhkmXmUc8+4/hX7HKiFAFKL4BOP44wQsSnPhTLaQOV+aN+TI5X1f40rKv3XqUy81bfTcsov77puf/5Q3kxpXZHwt+P2U8Aegjkz5fnPJuSCXNz1zhCHw/a/9+Xi0WWM7LW5Wz3v/BeveG4LAg0uHMGCVXfMk2AyAfZxngL0cATXg6AurJxZDsyR+q4RLllKZpIDGxOEdipbZmANcoO7LeUxahGIQKc2j3Rth1VVeUgRRy6zwxiwXClgCBtuyoAVgi/DLWtHp26/6idW5660yNTiX1ZTpOILlSIb1V2Ztf59W0yfDJ+Wu97Cw4nEbTZUDQDK546trcaincaPrZzbh0iikUXlUh3DaxnZhDFwdn42ND1DPsnKi4Vj1hyDSDPBmr6y3jipK7XYbDxTqN3ui7Vd72cOzaAJwZZoP8Qco5myhzDvk/G3aIL0MlvQN0/WZ768jotk75SSagppaMPu6nnrCEXvbtVRtOZBfJVTavVA/9ltIX1zvijHDFHNuGLSNPc5eXhuAbP/zP5UxKCdd4BsiDc4ZLn9BiSyexWfxfAoQwjmcewIxEBPbaO8Ula8sJL/S1NcTUjNSHuVgs1EpWQMM2aJCE2snJ1RCNolXh8VT8dsSIJgn3AW+mEjtyo2c9KGHFMFrTzSEmvmf6RgR8L2QXcuNKoZhLjoOE0=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"An excellent point, Svick! I'll update the article to make this more clear.","postId":"2012_08_async-and-scheduled-concurrency-557c7a26-e90e-3b4f-ac4d-c851f47bbb2d","replyTo":"","date":"2012-08-29T23:29:46Z","timestamp":1346282986,"authorUserId":""},{"_id":"20d6784a-081c-307b-b61a-721315371b47","authorName":"Stephen Cleary","authorEmailEncrypted":"h/mq8Jx/Achitbc4jek6ZplsUVu7DewYvgPj1jI5qMCWiMZ2djqj1tUzt6DLetdEYREeqjiuiN4XR8nhGFbvxzoSxBXxAe6IKRe8cmo/wK8ZVr9t/JMdbI6kHPXbO6LZuI8mwTpeo7pdy2coNj4ICVQEeZuIh5ivS1DovVCoGdiEpv0yi8f6wZiNjxSvRAMFqmBoCCNiTP+pXxC04pGT61zDueiE1AoBOJz6S5xg5Ue1MN6yvSahtgwC0p6Lcu6r4FAWrnsfQ3AfIrJmKVQVzeK6QBPY8tjFCbWDTlCfQrSCpkpYrSIQ8Wyn4qLri7EMOl8sAF+KPg2RrJE2g3nftdVZfFsptQ7xxI7l6Qu2w2kTBhhBjfUFgnlrDTZv/WEn1NlyA9GjYAUYC0g4O0iuEIZ/eX5NeDF0FdiR11dRhuBvTEx/VET4R5fqaA2HFeHK4yuHPrL7+JN4bBfIqEhzS2Eg7w9s/seSJ4mU5tQ2BuXtkJSoVNMYa1JtSD4lTogk7Pv19p0OxAKCF/T3VV2M3kwSJVJnNRGkuOYIHFiF6HQOsmpdaqMbFOR0+BquWV88h4SjUvnQCTnGMstgnoe8fZDRFXl4T9wVuifqfkCLEF8A1WoLT8UlvtQ7r6ZA48KPck//i9g+0gu+CIHWR1ciXguw3vLX2hWktjSJMhjIajE=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"The resumption of *that* async method does always use the thread pool. When that async method finishes, its task completes. If another async method is awaiting on that task, then *that* async method has its own context captured (or not).\r\n\r\nSo, the resuming context decision is made only for that await. If a higher-level method does not use ConfigureAwait(false) - i.e., it wants to resume in its context - then it doesn't matter whether a lower-level method uses ConfigureAwait(false) or not.","postId":"2012_08_async-and-scheduled-concurrency-557c7a26-e90e-3b4f-ac4d-c851f47bbb2d","replyTo":"c7acec81-bd9a-3d42-9094-80e9978a62f1","date":"2014-09-04T19:20:27Z","timestamp":1409858427,"authorUserId":"disqus:stephen_cleary"},{"_id":"c7acec81-bd9a-3d42-9094-80e9978a62f1","authorName":"Wojtek","authorEmailEncrypted":"YjaGGKAsJYWSxCTDSexcZo1B3c4bfsTN/2hi96pP6mebP2WW09itz2hpaNk1G8/9ZTkqw1CZ7SJTgs1OXWKKpsPVr8t00pua2nZ8eMcxW5l9D78nUZ/RT+VzYYCbgasx589TOJJrSbtRw8+YT9w0nBye8TsjZS0BbIz93II9cgRihFxmPHC/4/ujiuQEPwbUSXuBzodNi/owDJPEjo9EFPu85QgEsmDGA0SbA2QMHLZiwu52w0LriZgL4qJRXLnHJNmyS6OXLkrhG6X72iMfcaozF2bllK+WTBkuJjmy6O/+UeJeb9jyo+Tzj2Afaa5fcE1303msQYGCpvFWbUfdRsEzVAhi49RXNFtMCaPcFBE7o6oQh+sPE/ozL9m+Nu6xLifuwyCkyQ7+YgXD8fff3hPcKhO1DYP4WnNtyq+1Q48xlR0iDaZ0E1LDoAFm8uyzu08n98ORQcZBT1avrdYYK5C7ZoSvoIkngGtV39hY3InJaYSt0r/ygksUtG/sFogj/mTOZsWdLMfQyvhOd7YW7m64+6F2gH1b8EHXGOuV7t/cxyn5aTmRr03nqt5ZsIgm4bEkSzahTyTo3g6NpemZOzJ0ycwMIoKDG81k9YfQua5TlDp1mSeuVsqUE+6xFgEQk4u9vSD7MIRY2q2xwEy9q9vOpP39prgzWSj6Vxhm6d0=","authorEmailMD5":"ce6c5aab81a98d0c4d3c5f3ab7633ab5","message":"Hi.  \r\nIn your blog posts you advise to invoke ConfigureAwait(false) on awaitables wherever it is possible within asynchronous methods placed in domain layer libraries, for performance and deadlock-avoiding reasons. I have a question. If we invoke ConfigureAwait(false), does the resumption of asynchronouse method is made always in TaskScheduler.Default (thread pool) context, or is it done in the context of our custom scheduler provided when creating a high-level async task? Then, what is the context of async methods invoked during resumption. Do we irretrievably lose our custom context (custom Task Scheduler) on entire call-stack tree in case of ConfigureAwait(false) was invoked.\r\n\r\nThank you for your useful posts.  \r\nBest regards,  \r\nWojtek","postId":"2012_08_async-and-scheduled-concurrency-557c7a26-e90e-3b4f-ac4d-c851f47bbb2d","replyTo":"","date":"2014-09-04T19:11:34Z","timestamp":1409857894,"authorUserId":""},{"_id":"5c460e43-f88a-31d6-8450-539d08e4309c","authorName":"Dan Gershony","authorEmailEncrypted":"tB14uETa/LMXhRTl1ctkhhcQBVnkvVvYXxjZbTkBXEy0pyZz002SaVtbd6Y6rQuu8PB/17sCMIvDYX4SL65GMewNVmh3riFcuLP7XwVivTh4AXfd9WZAAAuaWrwB/+RenrhW/iquE+e9AqI7YvFhz7sLUb/0s/plJpvSBThPe3CB1iw7Y+kG/v4ubBMswiZVmrskQ7cctbePWHKZZxiVdK4nGfQdgxfnP59YJt/UbUFbzvEx3KgHBNrTM3m9utuKtNTqcEaxWkQHaZ2IOGl2u+g8dB9nnw7k1enNr2KjzansmAjTAcrl9bYkJSjyy1LrsUCOZbps7CcoR9J2iiYplTUZgEDiVeqlczCMUNBXZVVMzCYCNgu3KHuPLV13vDsy589HAZGow8bt0Pm/grQ/V0FOYlfPTEh4pW6G9CmluKOhIoqSJ82hbjxu7cP/kSCyg/VeaiAIhikAElI44ukcsjJBrBs6iw1v5YwpYRV3OEzzQwxmXBdxtPPccSEK3XtZ5T1jmdNyEK0R4tAksEQSJYCOKLfs/bjO+iRP6Ryttpi6UQKmMdtbpKUgxCWv8F7XoU5aPMdT3yUXhDNrRJJV/wz9pEGwOQHM5rW2OiVKAc+HAvzLhz5x3LR7RKLKSYhdstoylH/5Km0e6iJlkJnjH2ksGzl6cSw7ncZM7G6E0uM=","authorEmailMD5":"71adc1449fa9b5644d69a5d25db9ecd8","message":"What an interesting idea.  \r\nAnything changed in the last two years in the scheduled concurrency approach?","postId":"2012_08_async-and-scheduled-concurrency-557c7a26-e90e-3b4f-ac4d-c851f47bbb2d","replyTo":"","date":"2017-01-13T17:13:25Z","timestamp":1484327605,"authorUserId":"disqus:disqus_Mq904YACXH"},{"_id":"152e5833-cc7d-336e-b070-3fe9360f9f5f","authorName":"Stephen Cleary","authorEmailEncrypted":"TLSx2wNQZB091XpDBwzzTOFLXPwexttYpjStGVRE+EoWl5kimB79DiKUmjX8iA5N53imxDu04ZsmCa5GH1OjBxEZnZhnlNHeC+XKJp2xepQDq5EnaiU6lpO8BNBeAHHVYznXaZ5fI3GenKtxZvF6LvqMuRJxS+j3Oi6hQcwqKIXupgSyr+C3JXxwL3dEau+ExdphxN9tt529aeX0olwpQSWvyigj4hPp9fgQAvkOmlanyUtMOJ2ksThjNhKSS+hQOwNx6u1BIUTCOD43exH9mxSqeV8cQ2BhL/tlI3XiGEa6xNF9gV68CLPpXVXHW4Z1qdYGfJcRQlTpv1LYh4aMXb0i6xOvGl8LqOGYSsm5Xt842EwRIbQTMl8ig6mdz2b9tiQPSSarrSr0jbWPOPcMUEhgRujLLMObgMoMg7CaugcA1bHC4SUOllh0mA5gQ/SxnvWG3OzqmZx65u23m0aPSlHI+Ujj9DY8PwGFWs73EvgwOi2SZ1qgdDBfb6Oe7WbgHlCg6DBzyaUWrHYzdeSrD0iR8dFylP9OGaSMuFalk0MIpk+ND2FGlyBi8pGSHL0ZdZ8Qpjr8npvojOTVHGj62rpUK6Mlpndmlvqq4DTZcMlqvw92BVD/E3ZdlBVFJ1bUbnWTcegFJ0JBx5iCbtiXxX5aEQ4WYpMV+H+xKVSv9pA=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"Not really. It didn't take off like I thought it would - I think it's a bit too complex to reason about, particularly with asynchronous code. With scheduled concurrency, asynchronous code is first broken up in to synchronous pieces and *then* scheduled, so the granularity doesn't match what people expect. Most people have ended up using my AsyncEx library (or rolling their own) instead.","postId":"2012_08_async-and-scheduled-concurrency-557c7a26-e90e-3b4f-ac4d-c851f47bbb2d","replyTo":"5c460e43-f88a-31d6-8450-539d08e4309c","date":"2017-01-14T14:50:42Z","timestamp":1484405442,"authorUserId":"disqus:stephen_cleary"},{"_id":"34ee4c05-3e69-30e7-a606-d6a4b8724bb9","authorName":"Dan Gershony","authorEmailEncrypted":"gg1nIkXgc/sNbISABjUMQlNPxoJuqpAcHOpOaTLAYAvSrF+eCyQZ+uSWhgkkvjsou+SEIumLykaoBAz2X6y4m+68Zk0KKuZNqggAZB2g7WbYEoUPN7uJCMDKqGcwQ99J2Vxukgo9gQ3Qv0s1Hk8xRngpsiHrcjgHLot9M/on4nlpDBFzKq3qiRh+VJhq54uq2A7irmIsKyW8amV5R+xlbFha+U9ASCPP/0o5VgqSYPCA8FoiqK+3O1WpBNvIszLDGpzlHnqhEa5DKTzCWzPn50UNCa9dXzLulA24axOk24lAaCQqm/G8TDZKNsxxKUGZksRCTvq12ae87mI60zc1omq9M7AV7+EWWAlg/QFgmTKMYQVPnNiU9TiLtBoRtz1XqY7d+vTbVA1W3i7WFdPXC8hvtz+NsveXLJR/N6hjJqJL6ieaRzrGf6aYL3WTfUtaAXgx8eq2c0Ga3yb+Zd6b64pcMGgSwO8bOXS4e3HU3OoPWBd76MqevpwtuUq61S4W3PK7xzIEulGOOpFj9HTfYXRN7fHlCwmC1DMkvOHlDGoBrxqYt43nPgyWj3ZbVktbvfcOaSCCOsM051d/ictBvlIIRzhcLrcnniw4meWmBso6PTrhpuu56H1ncUjCZiSgs3yBf12jOsxX1tI1vF2jA3veaNrcNMlffRJFy8l1g7U=","authorEmailMD5":"71adc1449fa9b5644d69a5d25db9ecd8","message":"Thanks for getting back to me. it is indeed complex but writing none locking code is truly useful.   \r\nMy team is doing something really interesting in the Blockchain space, we are porting the Bitcoin c++ core node to C#. [https://github.com/stratisp...](https://github.com/stratisproject/StratisBitcoinFullNode \"https://github.com/stratisproject/StratisBitcoinFullNode\")  \r\nI do consider using the scheduled concurrency approach to avoid thread locks when doing read/write operation on a Dictionary (instead of using ConcurrentDictionary or Reader/Writer lock).   \r\nThis raises some questions, in some cases we have a limitation where a db operation can only happen on the same thread it was created, does the ConcurrentExclusiveScheculerPair.ExclusiveScheduler reuse the thread or discards when no more work is waiting (is it configurable).","postId":"2012_08_async-and-scheduled-concurrency-557c7a26-e90e-3b4f-ac4d-c851f47bbb2d","replyTo":"152e5833-cc7d-336e-b070-3fe9360f9f5f","date":"2017-01-16T16:30:41Z","timestamp":1484584241,"authorUserId":"disqus:disqus_Mq904YACXH"},{"_id":"319978d1-11ad-3c14-969b-65c1ca4e9fec","authorName":"Dan Gershony","authorEmailEncrypted":"MP9L8+16diMtHd1Y9fK7T7/3lGGYNxqtGy5ZI61g4az5UCnX7hIl/w+DawIbExKUqqT03Z6FpSjmUPRZ1dzS69ZyPq5ejQDX4jwaPMh7KqV3d8lLADdJTC6qemGgJ0X+wohPKVrYNROQ3FLnEF9xqrr8ryC5ecvo5aFtGSvVLiQaPFQhPljtAvtVAZnQUfLDvPpO/bdtxg/IDN364ITlkDWE0OnhZVIbIVy4A3JC++9QXh/tKsK2VeywF5CPPR4lXg3vAZuNaY0B5pJiuYQimMG+S1+MiZBUMEzd/fSTjs0GOljBdSTXgTkYI1FZOjiMmTdCB9jwDbMk5QQBAx03M3mtpF0H/l5onfH8T2NJQ0fO7W8A71QKKxhIDG5H1449mUzobSMuo6yeoW6PYWjU5JjbVzw++jXgyqcR4F13yEDLIR615sJa9rQjyDoMJL4TsxWx7Nc3L8GQrFbzNAh0qgwhxgFcRfsMp/m9gEsgtKJO4zI7JqATbO8xPAXb0oUiHV4NOFo56sRF/x9iw/EjxM4uMG0K4jNpJv47gfsvVjrkbORiHIWUyCSEsJUqUh47zyNqqQMfdQAXz5+E6bF73Nfy3+tQqOSNWJ0bBUhGUBfsNzyLAc07UOgUc9yYQCFHgp/nKoN26Ph09BP6mwBwmcTGD4KeEHgrtUlrQPj1I+M=","authorEmailMD5":"71adc1449fa9b5644d69a5d25db9ecd8","message":"Thanks for the answer, it is complex indeed but the thought of writing code with no locks is very interesting.  \r\nI am considering an approach where i'd use a Dictionary (instead of ConcurrentDictionary or a ReaderWriterLockSlim) to store data then using the ConcurrentExclusiveSchedulerPair to schedule tasks that read/write with the Concurrent/Exclusive schedulers.  \r\nThe rational is to write code that never blocks (I am aware the ConcurrentExclusiveSchedulerPair does hold a lock internally but that's only to insert tasks to a queue).","postId":"2012_08_async-and-scheduled-concurrency-557c7a26-e90e-3b4f-ac4d-c851f47bbb2d","replyTo":"152e5833-cc7d-336e-b070-3fe9360f9f5f","date":"2017-01-19T14:36:41Z","timestamp":1484836601,"authorUserId":"disqus:disqus_Mq904YACXH"},{"_id":"800e4bcd-ab2d-34b7-b8ec-4fdfdaaa820f","authorName":"Ohad Schneider","authorEmailEncrypted":"n7EXCfRSMUduDkSgzcNqiis7iaxpD6uMdXq0kM6Wk+W0wp8j5WiHeOr5Z7zx/GKNh+zX2vFiKKu/3UicLr4r68oMAeI/YzleS9J7fQh9XrpPuR8B4B//sFaxzROinXACiAAcPBPJqXz1pY3DSK4gOWN4uDqb+mGSG2FvC4mwF5lNWPISn1dk8k5fTr3gGDYsx+8QwmcwX0YOFiucCcFksjW4sT2H6o3H9iHTkiFOJm1MnhSalH9zohkLCkzcW3Kh9XU8zieh8OysQIu33XCoEy9ej3xg7twri9PTSvscGTOdxEuPliewpMvau1FH01NflIH/8DrKTJGkcjmcOUbpcuTLocpb58UJKQlYOo1eIVB/PxPjGkyI9IwXsxVDjQo9WzwrjyRqEguHhI2TWziTQNylAWg21PCHrdWyF5OV3u5LvvGdOdMXNP3m4EHTI/pGL5+q89GSq0mQxm+bMEovOFpUKEwlPEBBolqlERDznrKzuo1Q977AcwnkXn1EzS3rFvJZBMM9oojK87XNZ7nYSoHhUzdMAwXyNHn/W/5Gm6Vgc9EDJ7McnHva7N4JAD5T7n/b6RfZlau9/DbmCbO5tjAZxl6b8mIQlnpZg6l0D486yN3B0lLDsDdjDqgzqiZkxfiNIvBTzYhD257HmPT96k/3WN/PvZw/DNVdIJbgZIw=","authorEmailMD5":"cacacd08cdb74729cd4a964ced03f62a","message":"\"If the method later resumes on the same thread (e.g., a UI context), and the “other code” attempts to take the lock, then you have a deadlock\" I don't think this is a good example, because vanilla locks (Monitor.Enter) are re-entrant. So the other code (running on the same thread) will succeed in taking the lock. A better example might be the UI thread launching and waiting on a threadpool thread that is trying to take the same lock.","postId":"2012_08_async-and-scheduled-concurrency-557c7a26-e90e-3b4f-ac4d-c851f47bbb2d","replyTo":"","date":"2017-09-30T12:26:25Z","timestamp":1506774385,"authorUserId":"disqus:ohadschneider"},{"_id":"914c7bec-29d2-323d-9fbf-bbb496bab434","authorName":"Stephen Cleary","authorEmailEncrypted":"EboOF49L6EeLTRJ1m5AzpScsf+57MhT5ajoRWltXnKnRLXFeXSZflw62H1RCyD+yZQnVhuxpWmaZRbF4U/e04NrFDP9cNXeD0D8EaIshKciiSieBh/l0dlBBLcBC7m65qKMTk/W/+GhvzJdM32t9zgH+4ORU8ctGHLOmr8nxzijrkfYbWfJZezwNrggzNbGWrkKe6VR+z46/scjY5dqLt9XUuxOCLijz+56aeaUuel2DufSPyHQGU8ve6rZkcfOj5EEQnhAdYJp71mZzYVe2gi86vlb22VFxmskN54LYjC6Gibw2s7S37RkLytmeHsbVQEjR21+pGIWTcxEHEdZXdU8XcBK8Msxe0LdScAMJiYkGh6Bs9lt8NP469tq38cjkJKb7ABQPeFlffPj0SonJ9cNA75FAHgjxaTOPi/png6Kkg9oGlVtH2pHh0Q9mXQWzi3+CR1g+rWixKPdxehfBJQ097gtfSTSF4ui1VegHn4ib5zgcxDUEt2fnwUESTfvt7iV8wsP4TE+fFXyfjKyQamvKYhIBXnReLLMHF+8E3dRHaFlR0RBrrDlzL/kETMgJWMrWp705936NXG4awQfdCn+TvnujPupO6EQWiOU+WeawKMwpCTdMGkBE6/whWpBGEqYXr9MgQolfzoHqsG4hQ2OOEbcKqACI9jqPy1ApLd8=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"Good point. That phrasing is confusing in my post.","postId":"2012_08_async-and-scheduled-concurrency-557c7a26-e90e-3b4f-ac4d-c851f47bbb2d","replyTo":"800e4bcd-ab2d-34b7-b8ec-4fdfdaaa820f","date":"2017-10-03T17:47:04Z","timestamp":1507052824,"authorUserId":"disqus:stephen_cleary"},{"_id":"1eb41f8c-a342-34a5-bdc1-e220121c7b38","authorName":"Michał Dudak","authorEmailEncrypted":"SMpE0WZYEhQAl18TZGFHP+1m//bOlf3+zGz3kyn0d08t9CS0q9lAEmuTWNoajvh43BConMC3vRDB0mlvYTsllHwVmYLDZbwPh5XvkU/UqSzi8lP36bhyMRMHyyszdvLXo7XBQd5gyof3Aag8j68ME++nPnvaxY5DbdWAExakfk+N7icjDb5li2Q9sWY9DVqeBrug5Io1jlYN6C2zmr9dzyisczn9uqvQyGK1UUFkvVA+/pON0V2hAwvvkUQot6ZYpfkZzorlzz2rwpwI3FHNcDayPbLtXvPDxpl9F9nrCNqIyhnqbZXb4ZM/Gn5W4NsC7okmHNie9195aAyUwmzGfku3Dnq7qk1rdwo/Ugyyinb0eLYRiIEg1icFRPbIfLZnzSRCpFVEQqA33OYB15z5BAZLGL/8XqC+3N38d4ClIpci6WY//HjBqwtqE/fLwSXmldeeB8j55FEwbVM5eJRxStotSep2WOCyPZGSXMVISA+TYEIAh9mRneULzEZU6q/nw4HJEOBu4+uhoaa264huw3fNtHhC2dbHiifR7YzJjVwson1aIcf7tb342OCJS6ZzqkDEQ5g8EECb3QrUUYjkvBLxp4rvZIe+V+bQZp2PA9wLIgW+k5IWXcNcCoB/IIBVl9hgJtBD64IJJi3+AusvbZzGEDdKjfn/An7LpF9cW8c=","authorEmailMD5":"1b2234d7d08acb31f90a97ef4bab1176","message":"Hi Stephen, thanks for such a great post! I do have several questions, though. I posted them on Stack Overflow for more visibility ([https://stackoverflow.com/q...](https://stackoverflow.com/questions/48346489/using-concurrentexclusiveschedulerpair-as-an-async-readerwriterlock-equivalent) \"https://stackoverflow.com/questions/48346489/using-concurrentexclusiveschedulerpair-as-an-async-readerwriterlock-equivalent)\") and I'd be grateful if you could take a look if you find some time. Thanks!","postId":"2012_08_async-and-scheduled-concurrency-557c7a26-e90e-3b4f-ac4d-c851f47bbb2d","replyTo":"","date":"2018-01-19T22:38:34Z","timestamp":1516401514,"authorUserId":"disqus:michaldudak"}]