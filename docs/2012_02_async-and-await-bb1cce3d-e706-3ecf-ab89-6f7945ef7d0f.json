[{"_id":"241aa794-324e-3b4f-99ff-3b59fac27ff4","authorName":"H. Dolder","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.hdolder.com/CutBSK6fN.htm","authorUserId":"","authorFallbackAvatar":"","message":"VERY GOOD ! THANKS !  \r\nhdolder  \r\n[[www.hdolder.com/CutBSK6fN.htm](http://www.hdolder.com/CutBSK6fN.htm)]","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2012-02-26T04:25:44Z","timestamp":1330230344},{"_id":"35dbdbdc-e035-32ae-96cb-a17d60571d56","authorName":"Stefan Forster","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://sourceforge.net/projects/asyncwcflib","authorUserId":"","authorFallbackAvatar":"","message":"Many thanks for this excellent blog!  \r\nI'm only questioning your statement [Most of the time, you don't need to sync back to the \"main\" context]. Don't you think most programmers will forget about locks needed when accessing shared data from several threads? This is especially dangerous, when programming asynchronous operations in a 'synchronous style'.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2012-03-31T02:10:10Z","timestamp":1333159810},{"_id":"480e1c6e-311f-3102-805a-7768805466d1","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Absolutely Amazingly described!!! I read so many places but this is the best.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2012-04-12T21:27:51Z","timestamp":1334266071},{"_id":"493e49b0-b123-3314-b13b-47c41316b89f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Each async method is processed serially. This is true even if ConfigureAwait(false) is used; the async method will continue on a thread pool thread, but each part of the async method is still dependent on the previous part of the async method.  \r\n\r\nThe only case where locks would be needed is when you actually have multiple threads running at the same time (e.g., starting several Task.Run tasks and then awaiting Task.WhenAll). In that case, Stephen Toub has done some very interesting work with await-friendly synchronization primitives (on the MSDN parallel team blog).","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2012-04-14T02:19:55Z","timestamp":1334369995},{"_id":"0de218b1-1c60-3ff7-8865-47a21b787806","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Stefan: I'm not saying that async code doesn't *ever* need locks.  \r\n\r\nRather, I'm saying that async code is naturally functional (side-effect free). Async code really doesn't mix well with state at all (whether object state or global state, such as is in your example). Usually, the only shared variables will be local variables, which will not require locks.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2012-04-27T03:28:33Z","timestamp":1335497313},{"_id":"48152830-b308-3a4a-9c40-337e4f809cf7","authorName":"Stefan Forster","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://sourceforge.net/projects/asyncwcflib/","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen,  \r\nThanks for your answer!  \r\nTo stress my point I made a small console application.  \r\nOne run generates about 5-15 race conditions on my laptop.  \r\nMy recommendation is to always use a SychronizationContext unless you really have to optimize the performance.  \r\n/ Stefan.  \r\n\r\n static void Main( string [] args ){  \r\n for( int i=0; i < 100000; i++ ){  \r\n TestThreadSafety();  \r\n }  \r\n Console.WriteLine( \"done.\" );  \r\n Console.Read();  \r\n }  \r\n\r\n static int m_counter;  \r\n\r\n static async void TestThreadSafety(){  \r\n await Task.Delay( 10 );  \r\n\r\n int n = m_counter + 1;  \r\n m_counter++;  \r\n if( n != m_counter ){  \r\n Console.WriteLine( \"Error: counter=\" + m_counter + \", n=\" + n );  \r\n }  \r\n }","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2012-04-27T01:40:01Z","timestamp":1335490801},{"_id":"6906ebed-73d3-316a-b07b-ab7d341dba91","authorName":"Stefan Forster","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://sourceforge.net/projects/asyncwcflib/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, its really about some higher level design that has to be defined before deciding such points. I have an actor based model in mind while your's is a functional programming model. I will have a deeper look at functional programming. So far I have no clue on how to model the 'reality' when I'm not allowed to change the models state. I actually could generate new versions of the model for every modification - but then I would have several threads working on different versions of the model - how this could work out is currently beyond my imagination...  \r\nThanks for the discussion.  \r\n/Stefan","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2012-04-29T01:10:24Z","timestamp":1335661824},{"_id":"fbe3074c-cca6-338b-a83e-39062611a7ab","authorName":"tiru","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"amazing.. great !! easy to understand..!!","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2012-05-22T09:16:12Z","timestamp":1337678172},{"_id":"de6fe969-9c82-3131-8b3f-b0cf882a2764","authorName":"tarnschaf","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thanks for the introduction!  \r\n\r\nDid your forget ConfigureAwait in the WinForms example code!","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2012-06-28T16:38:44Z","timestamp":1340901524},{"_id":"78ae12b3-ca00-36d7-8d9b-41a8c7dd4946","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"No, the DownloadFileButton_Click does not call ConfigureAwait on purpose. It has to resume on the UI thread because it modifies a UI object after its await.  \r\n\r\nThis pattern is rather common: library async methods do use ConfigureAwait, and UI async methods do not use ConfigureAwait.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2012-06-29T22:51:19Z","timestamp":1341010279},{"_id":"9804e6f2-4d2c-3527-b12d-1376c7039c99","authorName":"Bhavik Barot","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/14025767250306196409","authorUserId":"","authorFallbackAvatar":"","message":"Thanks for the gr8 article. I got stuck at this statement,   \r\n\"By using parallel composition (Task.WhenAll or Task.WhenAny), you can perform simple parallel operations. However, this is not a substitute for the Task Parallel Library - any advanced CPU-intensive parallel operations should probably be done with the TPL.\" By using Tasks we are already using TPL, so how it is different if we use - await Task.WhenAll(tasks). Please elaborate. ","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2012-10-09T16:02:51Z","timestamp":1349798571},{"_id":"8a3240fa-c256-3d04-9509-677cfc43831d","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Technically, the Task type is a part of the Task Parallel Library. When the async team needed a \"future\" object, they chose to (re)use Task rather than create one themselves.  \r\n\r\nSo, when I'm talking about using TPL for CPU-intensive parallel operations, I mean the Parallel class, AsParallel, and other TPL constructs that are not normally used in async code.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2012-10-19T00:31:04Z","timestamp":1350606664},{"_id":"1cfbb834-9756-319e-9069-a7e91667f54f","authorName":"Elliot","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"\"It does not run this method on a thread pool thread\" .. ah thanks, people should say this more often. I had associated tasks with multithreading too much...which was very confusing.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2012-12-11T14:45:49Z","timestamp":1355237149},{"_id":"2da5dbd9-b8cf-33d0-9737-32605a6b4422","authorName":"Nate","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I'm a little confused though, if a method returns a task but the methods definition is on the UI thread and its execution does not run in a new thread then how can that returned task be awaited on without blocking the UI thread?  \r\n\r\nDon't all async defined methods run from a new thread in the pool?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2012-12-14T06:37:00Z","timestamp":1355467020},{"_id":"39cbfb9c-f1ab-393f-b80e-cbcfe384190f","authorName":"Nate","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/12041379981386387382","authorUserId":"","authorFallbackAvatar":"","message":"So if you await a task returned by a method that has no async implementations defined within it, the task being awaited on will lock up the thread it was returned from e.g UI thread?  \r\n\r\nCheers.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2012-12-14T07:17:22Z","timestamp":1355469442},{"_id":"61980ab2-d0ea-34a8-8e28-22d339601364","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"No, async methods do not run from a new thread in the pool.  \r\n\r\nWhen you await an incomplete task, you are suspending the current method. After the task completes, the method resumes execution.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2012-12-14T06:56:39Z","timestamp":1355468199},{"_id":"96685a5f-92ce-3437-b15b-d30020f6c966","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"If you await an incomplete task, then the current method is suspended.  \r\n\r\nIf you call a method that does not await, then that method runs synchronously. This is true regardless of the return type of the method or whether or not it is marked \"async\".","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2012-12-14T09:00:33Z","timestamp":1355475633},{"_id":"1fca1808-7554-379c-a266-4bb7fa34fe16","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"It is crazy how that well that bible verse in the header (55:11) lines up with async/await. I'm not religious at all, but that is pretty cool. I'll be sure to say that to my code with the best booming voice I can come up with. ","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2013-03-12T18:43:11Z","timestamp":1363113791},{"_id":"955c8ef2-99d3-3ca7-8b76-14b1eaa9806b","authorName":"Chris Marisic","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/08904925342941324684","authorUserId":"","authorFallbackAvatar":"","message":"Great job at a very very easy to understand article! ","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2013-04-18T21:49:56Z","timestamp":1366321796},{"_id":"a612efc1-fb42-3fbb-9e22-24b666c4a7d2","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thanks for your well written explanation. But I am curious whether a task can be awaited by two different tasks. In case of a program in which two tasks need to execute after a task T, can they both await T? How will T's continuation will be set in such a case?  \r\nThanks in advance.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2013-05-05T16:24:39Z","timestamp":1367771079},{"_id":"01d91132-8da1-3b5f-8fcc-33e19277f2a8","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, a single task can be await'ed by any number of async methods. \"Await\" will first check the task to see if it has completed; if it is already completed, then there is no continuation at all. If the task is not already completed, then it will *add* a continuation to the task. Each task can have any number of continuations.  \r\n\r\nOne common use case for this is (shared) resources that require asynchronous initialization. You can declare the resource as such:  \r\n\r\n class MyClass  \r\n {  \r\n private readonly Task resource;  \r\n public MyClass()  \r\n {  \r\n resource = LoadMyResourceAsync(); // Note: no \"await\"  \r\n }  \r\n }  \r\n\r\nand then multiple methods can await that resource:  \r\n\r\n public async Task MethodA()  \r\n {  \r\n var res = await resource;  \r\n ...  \r\n }  \r\n\r\n public async Task MethodB()  \r\n {  \r\n var res = await resource;  \r\n ...  \r\n }  \r\n\r\nKeep in mind that when the resource is done loading, it will continue all async methods that have already await'ed it, and any new async methods that await it will continue running synchronously (since it is already loaded, there's nothing to wait for).  \r\n\r\nIf you want to *lazy*-load an asynchronous resource (very similar to this but delaying the loading of the resource until it's actually needed), I have another blog post for that: [http://blog.stephencleary.com/2012/08/asynchronous-lazy-initialization.html](http://blog.stephencleary.com/2012/08/asynchronous-lazy-initialization.html)","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2013-05-07T01:31:34Z","timestamp":1367890294},{"_id":"d22e4396-cbbd-3156-9d43-f460174afc55","authorName":"Kiran Kilari","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/17924946581743598588","authorUserId":"","authorFallbackAvatar":"","message":"Nice Article, Thank You Cleary.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2013-05-12T11:41:03Z","timestamp":1368358863},{"_id":"e26d89ba-2655-33eb-aca1-a1444f4fc957","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thank you, it is really helpful.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2013-05-13T17:03:51Z","timestamp":1368464631},{"_id":"336b7c5d-2870-3444-8c68-5b5fb6616fc1","authorName":"ByteBlast","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/01103643419505369391","authorUserId":"","authorFallbackAvatar":"","message":"Great article. Thanks. ","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2013-07-06T18:26:55Z","timestamp":1373135215},{"_id":"bbf339d4-d084-325c-9ef3-24e77a83f657","authorName":"Ruchira","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://ruchirac.blogspot.com/","authorUserId":"","authorFallbackAvatar":"","message":"Excellent article. One of the best in internet which explains the purpose of async and await keywords!","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2013-07-24T12:22:22Z","timestamp":1374668542},{"_id":"08c4c3a2-9e66-3016-a402-41a64cde20be","authorName":"Peter Klein","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/16736940424719033643","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen,  \r\n\r\nThis is the kind of explanation I had been looking for. But still, I can't figure out how to get things geared up. Please take a look at my simple code (VB.NET)  \r\n\r\nPublic Class Form1  \r\n\r\n Private Async Sub Button1_Click(sender As Object, e As EventArgs) Handles Button1.Click  \r\n TextBox1.Text += vbCrLf + \"No connection yet\"  \r\n TextBox1.Text += vbCrLf + Await DoAsync()  \r\n TextBox1.Text += vbCrLf + \"Done\"  \r\n End Sub  \r\n\r\n Private Async Function DoAsync() As Task(Of String)  \r\n Return Await DoJobAsync()  \r\n End Function  \r\n\r\n Private Async Function DoJobAsync() As Task(Of String)  \r\n Threading.Thread.Sleep(2000)  \r\n Return \"Connection made\"  \r\n End Function  \r\n\r\nEnd Class  \r\n\r\nThis works allright, but on the UI everything waits for 2 seconds. When I use a bigger amount of milliseconds, then everything waits that much longer. That is not the behaviour I would expect from asynchronism. But where do I miss the point?  \r\n\r\nHope to hear from you!  \r\nBest regards,  \r\nPeter","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2013-07-30T11:59:58Z","timestamp":1375185598},{"_id":"905333d3-542e-3bf7-a42d-38b630345704","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Don't ignore the compiler warnings. In this case, the compiler notifies you that DoJobAsync does not contain any await statements and will therefore run synchronously.  \r\n\r\nAs I said in this blog post, when an async method starts, it runs synchronously until it hits its first await. Since there is no await in DoJobAsync, then the entire method runs synchronously.  \r\n\r\nThe problem is in Thread.Sleep, which blocks the current (UI) thread. You want to avoid long blocking like this in async code. To fix this, you can replace Thread.Sleep with Await Task.Delay, which will asynchronously wait for the specified amount of time.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2013-07-30T17:23:10Z","timestamp":1375204990},{"_id":"052ea9cf-ceea-3b3d-a3a9-59e9557e247f","authorName":"marin.ru","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/15218065101069685358","authorUserId":"","authorFallbackAvatar":"","message":"Thanks a lot! You really have a talent to explain difficult topics in an easy-to-understand manner.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2013-08-04T11:34:26Z","timestamp":1375616066},{"_id":"98fd8b6d-0cd5-3c62-837b-ff4912b026de","authorName":"Joe Enos","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/17203532207216246426","authorUserId":"","authorFallbackAvatar":"","message":"Great article.  \r\n\r\nJust wanted to clarify something to make sure I understand - I haven't used ConfigureAwait before, so I want to make sure I don't screw this up. Suppose I have MVC (regular or WebAPI) as my entry point, which calls code in my business layer, which in turn calls out to another API somewhere, and I want that all asynchronous. Assuming I want my controller to never lose its MVC context, I would be safe using ConfigureAwait(false) everywhere except the very first call from the controller to my business layer, right? For example:  \r\n\r\n// In MVC  \r\npublic class MyController : Controller {  \r\n public async Task<ActionResult> Go() {  \r\n Foo something = await _businessLayer.GetSomething();  \r\n return View(something);  \r\n }  \r\n}  \r\n\r\n// In my business library - a separate library which knows nothing about MVC or ASP.NET  \r\npublic class BusinessLayer {  \r\n public async Task<Foo> GetSomething() {  \r\n return await _myApiWrapper.GetSomething<Foo>(someUrl).ConfigureAwait(false);  \r\n }  \r\n}  \r\n\r\npublic class ApiWrapper {  \r\n public async Task<T> GetSomething(string url) {  \r\n var httpClient = new HttpClient();  \r\n var httpResult = await httpClient.GetAsync(url).ConfigureAwait(false);  \r\n var content = await httpResult.Content.ReadAsAsync<T>().ConfigureAwait(false);  \r\n return content;  \r\n }  \r\n}","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2013-10-08T00:28:22Z","timestamp":1381192102},{"_id":"9358ceee-b47d-3acb-a1fe-f3580aed159b","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, that is both correct and the *proper* way to do it. This works because every await captures its *own* context. So the ApiWrapper.GetSomething and BusinessLayer.GetSomething will complete on a thread pool thread (discarding the context), but MyController.Go will complete on the original ASP.NET context.  \r\n\r\n(There are various optimizations in place so that what actually happens is that when the last await completes in ApiWrapper.GetSomething, it will run on a thread pool thread which also finishes BusinessLayer.GetSomething and then enters the ASP.NET request context and finishes MyController.Go all on the same thread - but this is just an optimization detail).  \r\n\r\nI have an MSDN article online ([http://msdn.microsoft.com/en-us/magazine/jj991977.aspx](http://msdn.microsoft.com/en-us/magazine/jj991977.aspx)) that goes into more detail around the best practices, but to summarize the guideline is to use ConfigureAwait(false) unless you know that you *do* need the context. Your example code is exactly correct.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2013-10-10T21:44:43Z","timestamp":1381441483},{"_id":"002516fd-478e-3fe1-bdf4-a7a06415c45f","authorName":"Joe Enos","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/17203532207216246426","authorUserId":"","authorFallbackAvatar":"","message":"Awesome, thanks. I appreciate the clear explanation. ","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2013-10-11T06:44:10Z","timestamp":1381473850},{"_id":"dee375e7-de68-355e-bd73-f8b854c8afce","authorName":"pollaris","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://wrton.com/","authorUserId":"","authorFallbackAvatar":"","message":"Clear definition of the keywords.   \r\n Clearest I have found  \r\nthus far drowning on the internet.   \r\n Got this bookmarked  \r\nfor reference now. Thanks!","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2013-10-12T01:23:33Z","timestamp":1381541013},{"_id":"dec8294d-dd24-3abd-87f0-4f66c849ad68","authorName":"Andrey Yemelyanov","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/13990243468584152589","authorUserId":"","authorFallbackAvatar":"","message":"Hi Steve! Just wanted to thank you for a fantastically lucid explanation of ASYNC/AWAIT. I found MSDN docs not so useful in this case.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2013-10-31T11:17:36Z","timestamp":1383218256},{"_id":"fefa9dae-c1e9-3f33-9135-bd3fd817b761","authorName":"Robert Gammon","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/17513433596088822474","authorUserId":"","authorFallbackAvatar":"","message":"Thanks, took me a while to find a clear and concise explanation of this syntax.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2014-01-06T22:14:19Z","timestamp":1389046459},{"_id":"862c0b9a-fe31-32d2-a689-f8279fa3a8c9","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Please look at the point where you say \" // At this point, all three tasks are running in parallel.\"... since it is still running in the same thread then it would take the same total time as if you wrote DoOperation0(); DoOperation1(); DoOperation2();   \r\nIs that correct?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2014-03-08T06:14:57Z","timestamp":1394259297},{"_id":"d8ab6f31-0582-3cfb-912a-8e5e7aabaa26","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"My use of \"parallel\" there is confusing. If the operations are CPU-bound and there is a single-thread context, then yes, it would take the same total time.  \r\n\r\nHowever, if the operations are naturally asynchronous, then they can all run concurrently on the same thread.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2014-03-08T08:14:35Z","timestamp":1394266475},{"_id":"9505c2ba-b269-395a-afe0-8ce41eec38ff","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thanks, I understand this part now. So for loading from HDD operations (loading images and extracting thumbnails), does it make sense to use Task Factory or use just task/await?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2014-03-09T23:53:23Z","timestamp":1394409203},{"_id":"12b773a8-7a57-386e-8b42-a48fe26da30e","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"For loading data from disk, use async. If you're doing image manipulation, ideally you would use parallel or background tasks. However, the built-in image manipulation (BitmapImage etc) is mostly tied to the UI thread so that's not possible.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2014-03-10T07:42:54Z","timestamp":1394437374},{"_id":"132f8d6c-08c2-383c-9a2e-28690d3d4831","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thanks Stephen! This was very helpful! ","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2014-03-10T18:14:51Z","timestamp":1394475291},{"_id":"efe36ae2-b848-321a-bcb3-171930e1ce70","authorName":"Damian Powell","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/17133278233421943645","authorUserId":"","authorFallbackAvatar":"","message":"I'm reading this two years too late! Thanks for the great articles, Stephen.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2014-03-11T22:49:51Z","timestamp":1394578191},{"_id":"74a91d96-912f-3258-9ddc-081288f2bce2","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"You can choose whatever arguments you want for your async methods.  \r\n\r\nSince you're getting a cross-thread error, I assume you're using something like Task.Run. You can just copy the value to a local variable and then pass it to the method, as such:  \r\n string value = comboBox.Text;  \r\n await Task.Run(() => MyMethodAsync(value));  \r\n\r\nIf this isn't clear, please post a question on Stack Overflow.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2014-04-13T04:54:42Z","timestamp":1397364882},{"_id":"eae5a750-b4e3-39d6-b575-a63c7d10c4a7","authorName":"Emmanuel Abia","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/15843086437756521342","authorUserId":"","authorFallbackAvatar":"","message":"Is there a way to pass values like (ComboBox.Text) from the UI to an Async Method. I tried but i get cross thread error. BackgroundWorker has the e argument parameter can you advise me on hoe to achieve this without getting the error.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2014-04-13T02:24:23Z","timestamp":1397355863},{"_id":"e715a605-1302-330c-b168-82cd705d3aec","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"No, you don't need them. In that case, you can remove the async/await on the outer \"Get\" method.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2014-04-22T19:46:16Z","timestamp":1398195976},{"_id":"f8936150-272b-3ed5-bfb3-8c503c577c9b","authorName":"Yaniv Yancovich","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/15517691077072323439","authorUserId":"","authorFallbackAvatar":"","message":"Stephen,  \r\nQuick question:  \r\nI have the following code:  \r\npublic async Task Get()  \r\n{  \r\n return await ExecuteRequestAsync(\"GET\", command, null);  \r\n}  \r\n\r\nprivate async Task ExecuteRequestAsync(string method, string command, string jsonData)  \r\n {  \r\n try  \r\n {  \r\n await SomeCode()  \r\n // continue after it  \r\n }  \r\n}  \r\n\r\nThe questions is if I need to put async before \"public async Task Get()\" and await on the result, if the only line in this function is just return?  \r\nYaniv","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2014-04-22T19:35:45Z","timestamp":1398195345},{"_id":"2d3a2fe7-49b7-3dc0-ac47-e71bc8b2242c","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I don't see that in that article, but that is correct. If your example was doing something that could possibly throw:  \r\n\r\npublic async Task Get()  \r\n{  \r\n var data = SomeMethodThatCanThrow();  \r\n return await ExecuteRequestAsync(data);  \r\n}  \r\n\r\nThen in that case you would probably want to keep the async/await. The reason is that if you keep them, then any exceptions from SomeMethodThatCanThrow will be placed on the returned task, which is what the caller expects for an asynchronous method. If you remove the async/await in this case, then any exceptions from SomeMethodThatCanThrow will be raised directly to the caller.  \r\n\r\nThe exceptions are not ignored; it's just a question of where they go. A method with an asynchronous signature should place its exceptions on the returned Task, not raise them directly.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2014-04-23T17:15:50Z","timestamp":1398273350},{"_id":"65e1a5e5-4ce0-32a5-9a6a-330743011f78","authorName":"Yaniv Yancovich","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/15517691077072323439","authorUserId":"","authorFallbackAvatar":"","message":"Thanks for the reply. I read in another article that when not writing await, we may miss exception\\error handling.  \r\n[http://compiledexperience.com/blog/posts/async-golden-rules](http://compiledexperience.com/blog/posts/async-golden-rules)  \r\n\r\nIs that true in my case?  ","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2014-04-23T11:00:38Z","timestamp":1398250838},{"_id":"736b91e9-9b0d-31a4-8002-3af9fa8b9e2d","authorName":"Dave Black","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/11787334586939943513","authorUserId":"","authorFallbackAvatar":"","message":"Thanks for the good article :)  \r\n\r\nOne question I have is when should you use Task.FromResult vs. await? I've seen it done both ways and not quite sure what the difference is and when to correctly use each one.  \r\n\r\nThanks for your time!","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2014-04-23T02:01:16Z","timestamp":1398218476},{"_id":"ef80f387-5ed7-3e66-ad79-1ac67f7c5b1d","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"If you have some asynchronous operation that your method should (asynchronously) wait for (like calling an Async method), then use await.  \r\n\r\nTask.FromResult creates an already-completed task, so it's not actually asynchronous. It's useful in a few scenarios, like if you look up the result in an in-memory cache, so there's no asynchronous work to do. Or if you have an asynchronous (Task-returning) method in an interface or base class and need to override it with a synchronous implementation, like a test stub.  \r\n\r\nIn production code, await is used a lot more often than Task.FromResult.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2014-04-23T04:30:59Z","timestamp":1398227459},{"_id":"6621c875-f1fe-3057-a7f2-923f7f87fa00","authorName":"Jamie","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/14915898789982949517","authorUserId":"","authorFallbackAvatar":"","message":"Had to read it a few times, but got there in the end. Thanks. Helpful article.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2014-05-13T00:21:49Z","timestamp":1399940509},{"_id":"6e65948e-a18c-305f-8f02-b8f770eb6e1a","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, there's actually a fair amount of information that has to all fit together before you really get it. Glad it helped!","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2014-05-13T03:45:56Z","timestamp":1399952756},{"_id":"98945bda-9c9b-30bd-b5b4-5fa90416fec2","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen, thanks for the best intro to async/await.  \r\n\r\nIs it legitimate to use the following instead of await Task.WhenAll(tasks)  \r\n\r\nSystem.Runtime.CompilerServices.ConfiguredTaskAwaitable consumer = WriteTradesAsync(target, cancellationToken).ConfigureAwait(false);  \r\n\r\nSystem.Runtime.CompilerServices.ConfiguredTaskAwaitable producer = ReadTradeWrapperAsync(target, cancellationToken).ConfigureAwait(false);  \r\n\r\nawait consumer;  \r\nawait producer;  \r\n\r\n?  \r\n\r\nWhy this scenario also work? Shouldn't it wait for consumer to complete and only then begin to run and wait for the producer?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2014-05-17T12:29:46Z","timestamp":1400329786},{"_id":"f03a6e36-cca1-3533-acfa-2202eba15e31","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"It's because the tasks *start* when you call the \"*Async\" methods. So by the time you await the consumer, the producer has already started. Await only (asynchronously) waits for the task to *complete*; it doesn't *start* anything.  \r\n\r\nUsing separate awaits is also an option, and some people do prefer that method. Personally, I prefer Task.WhenAll because IMO the intent of the code is clearer. (It's also slightly faster, but that usually doesn't matter in the async world because it would be dwarfed by whatever actual asynchronous work is being done).","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2014-05-17T16:14:43Z","timestamp":1400343283},{"_id":"68129bf8-b3f4-3239-b81a-43328cc68927","authorName":"Jon Stelly","authorEmailEncrypted":"Eb1niksY7c1EkJfeOH586sSt5dxzlIRsBPFvwxB7IKVyPAt+wje9MMU1mwAPiV+BxwjNUpDYenHwyASWJ7lHDs2PkLeyqBRXwlooMe8k1jJqDpqOZYUCFVepHSAcUppnoF8QlsSrbYmrQPXtYGnpsUNekXzu9XCh76NH3RvJmXFl51ZD+n0dB0OEVriPqGIPlamjktsajK7nu14gFkrLiWKZldWCNOCs5LbpaWahDBZMwrlhXiNeSEE/+WrEFadyXBbA35acYQdlMsC+w4NAvL6xHlxIN7rO6JbMmdroOUCqufjnxAVa+CoYO/kd/02vVaQN/80Ew/lvOoLhB1Q672zFS0hhasPp1rPsMnXpKcxiBL6CQJAFjx2bo6L1AcN5mU8iSiP3yEob5q4R/eIpcNg7aZLWFixYvtb5yJdslPf9ELOocJaDSbe4M6WBiLkpM/3catMwRfHDCzsp749bqUR4+g/MKhTe4Cl8hr7wKb5xxPO4pXXLWpXntWVX/31JOcrXmc5Ml0E+5grtcR4IMWdTqgKTpmF9sTpOId7w4og8pY3wo07qAjxjjOvn9TowdEbxJ2k8nJM/v+sQpxQ5EsE7qbT5LoKQdBfx1BFwDElWunwtIKxJ1WdexTBrnOke95OYmaulK+QWpWIABNbPfiNiUpvSnLNvq9hzKh7QLpM=","authorEmailMD5":"407095fe6d28bc154fb98cb0b23f9510","authorUri":"","authorUserId":"disqus:jonstelly","authorFallbackAvatar":"","message":"Agreed, this comprehensively but plainly explains all the moving parts. Good job at making a somewhat complex subject simple and understandable.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"bbf339d4-d084-325c-9ef3-24e77a83f657","date":"2014-08-25T14:18:17Z","timestamp":1408976297},{"_id":"de3e6f46-bd5a-31a8-83d1-0ec27b02bcbb","authorName":"Ba3","authorEmailEncrypted":"b/W6pzDrg49ogXL1zewT+gr9dj11b+tk3FFDI6tXH9g6r9Bqdl/dBMt9mdw/GBIgD7X1c/X3SI6noMvL4Ez3vLlSJfS1uCQD0ux3nIjr/Sj3sGqh1eZwvSYP+4uEyMkZZTXdjEI7QeWXNQF25MxSTI44RsCvnw3yRoDxCx0myaB1Pjr3/a1vjTu3+xdtcGMXf+kVijKLgOR0yRf40j3DWnkH2RJjL/sjG55iOyqmE2fECDY4ejoiUp7a7yXgXmOIZmXZ2PREzQSzDYL3K4ovoaXQtHivEWEIJTsCCSfkxpHZwka2L4wVOo7owpGBTvJ08CD8oDfTdlINYs11WpyerddVRtl4y5ER1dXgG0s8qkOA0OsLs5CVGmK3pSGeDxR2gDmHQDPoM4CzIdoH0NwaZl6p0jdUJrpoQ2ccgfTlYv3yPV4kdDehg4MwGltGH/YxMRmPTYkXIWXfNA90GBacsa3LrDFEwPKDcv9iDP82AebvN5WtQ2sDyh821U9LeeBAApcTKLM1ac0RUkS/JR+stVUwghK9xuRSpShx9p5bL+0eOVt9FuLuK3Dm2zxYIZpP18gSDfG0HbUmnwp0+MQLq05+rU8tHlWE7mwZK1eTadWPh1KOQHznRJawOKyLXeL+8hOESXsz0GnJmAELObTgPNhuoJjOW2BIY5/UKgDgMMY=","authorEmailMD5":"13ef06566ea6077e1a13d36e57e0c9ea","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"¡Excelente explicación!  \r\nSe agradece el aporte.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2014-09-15T02:37:40Z","timestamp":1410748660},{"_id":"ac6c9ed0-4fde-35dc-90ab-dc7c7daa65cb","authorName":"ML.GB","authorEmailEncrypted":"EbIUm8YqQf4AupTQnbKOk6/sCz7KydsksVWCxnXDJYjXBCw8Je07KQ5xTY/uJ+n7K/CHDRMMJoHX6LunI1pR+XEXTlQ8ERauu41WP3Z+ZyLoOJ/ePunGjEyX0z7n/AmIxJNLIldx5sxlIVEQ2Mvo6Oiwb4kN0cgUOBGBXJE4N1/M43vfPSigwYrq9S6zoOwseheRNxrNSFQhN40hH2yXBDZ5RIczVUE/FNQpICUvV6HJNIzYn5rSm2+kpOVs39sK+vOXkxIY3fSl79ua15LUw493HOusD/EsleBihqY9OnWaJV4yszRRpyT3Lva7t7IrTQ2He3j3lE9bSRdQgISvw6UmbVhxB7r+Ir/KngKTt5M2+XT+GRIAassbVrqS4La4d7O8/KaT4BK9d362ttpnF1U9aS0LJbMEsGplkvXcOUEjwR6PAAQoF25XhIZX+J8QT25FyVhyPDmNRdfZlsobs2U35kb/LjjQb5udO4sh3ere+OSn9zk0WgJPKQL60pkRsGTl/WmLy15q3GHLg6kwpRnoc+oYSUVea8aC8Zz9P/vVJTr5AeOFZt0HyOnP3qPhwTWq8E1ZcWgLI/WBQscub/dbUBG2oFh+9mAcfxkcI9f1TjlV0M3JpjYF4T9N4q4xpicXYw7x8Jx5wXrkyUC8Ro4HwrOochm0trPJYvHLYX0=","authorEmailMD5":"a871cb7bf100a22d8ecbf78befa9a008","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Excellent article plus all your answers on stack overflow relating to async are always just what I'm looking for. Quick question, altering your example to show what I mean, is there a reason you should / should not do the following?\r\n\r\npublic Task DoOperationsConcurrentlyAsync()  \r\n{  \r\n Task[] tasks = new Task[3];  \r\n tasks[0] = DoOperation0Async();  \r\n tasks[1] = DoOperation1Async();  \r\n tasks[2] = DoOperation2Async();\r\n\r\n // At this point, all three tasks are running at the same time.\r\n\r\n return Task.WhenAll(tasks);  \r\n}\r\n\r\npublic async Task SomeOtherOperation()  \r\n{  \r\n //some stuff  \r\n await DoOperationsConcurrentlyAsync();  \r\n //more stuff  \r\n}\r\n\r\nSo I guess my question is should I always be using async and awaiting in the method and is there drawbacks of doing so or not doing so?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2014-11-27T12:56:05Z","timestamp":1417092965},{"_id":"3cfaa914-3262-3a81-b26a-aac5ea843fa1","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I'm not entirely sure what your code is intended to mean. In the general case, you should always await a Task sooner or later. There are very rare situations where this isn't necessary, but you have to be sure that exceptions are properly handled.\r\n\r\nNote that async does \"grow\" through the code base, because 99.9% of the time you should be using await. This growth is perfectly natural.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"ac6c9ed0-4fde-35dc-90ab-dc7c7daa65cb","date":"2014-11-28T13:22:25Z","timestamp":1417180945},{"_id":"53f90833-325a-3b29-a8d9-3bba3710b6a3","authorName":"David Logan","authorEmailEncrypted":"ZaXSCBMGO2kvE0Zv5L4CuavhVsn46bJdOkpq9IsqISq3gaz17t75ys94eyh/RmbBA4zsZEhJ/DL+jgExouVWOZH4YfqroPaBnFJTRMFtPA+t6jnB9O927FymTuQQuMDJ7/ogL9PHhjo7Cos5OoiE9YGe86hlDpOXOs2VS3fVHMwUVsX5V934/JNS4z26XEUcpsUyGv9Qa/F9s14a7mXCS5QRB8Z93gKQDX08MS50RhZ9tMD5fAYyc8QMtH6xsWnRWm0+hvUcoO1HE4z6nR3KnMNmMV649uMqXvvvGATtXzDMfyrS6bb5Q+9N15dHT3NpPe2EJvQDxS2t5w+Zc/3MU86XyKvjBNRwavMBV6x3s0qvETpKOhF6Jlid+lAE69QgTJHaaEbow+2lgJq0B8OXy/mbcozbCJUGmLqHADeABOCImrw+fz2zq4OwpOr0VsvtMjWizT7FVf1h3Z94N9X/zw165FY2vv4FdAbsjLDg+NgAyB490fkvVyVGgQn9ar30wOd28AKBRIbF2taJGAs3McP5ggmZ2RGfzQRsDcsuMcdv+9bgm7lqvv6SW19ii9GiN0D++lFXsVaCm0Q9qcgSN+8cCoFUqfpREfKicYsVRINFmzdvH/HqpMP4hbF5waVHRJpGMNY2gNlMzZxtpepjlUaLY0cNG4vAXJSl+QZ/tJ8=","authorEmailMD5":"aed4764d9bb88513922e3ca3a13e49f1","authorUri":"","authorUserId":"disqus:disqus_X3JcV4mu1m","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_X3JcV4mu1m.jpg","message":"Stephen, can you point me to any examples of tutorials for writing a WinForms application that does a bunch of file processing, not read/write but directory and filename searches. I want something that uses classes to do the searching ... instead of a BackgroundWorker this keeps bloat out of the ui and is testable. But I can't find ways to do something like Application.DoEvents so that the UI stays responsive. I also need to fire events back to the UI to update current search path and separately any anomalies found. I thought Task.Yield might but the documentation specifically says \" do not rely on await Task.Yield(); to keep a UI responsive.\"","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2014-12-12T02:32:29Z","timestamp":1418351549},{"_id":"e3faac25-5489-3845-b0e8-29cddfeec678","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I don't know of any that deal with that specific problem. I can tell you that the directory APIs do not all have async equivalents, so I would suggest writing a class that just does the work synchronously (using IProgress<t> for progress/anomaly updates), and then calling it from the UI via Task.Run.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"53f90833-325a-3b29-a8d9-3bba3710b6a3","date":"2014-12-12T14:25:18Z","timestamp":1418394318},{"_id":"1f0c5c2c-bc2c-3f52-bf84-f97b1d65ab9d","authorName":"Grateful","authorEmailEncrypted":"H8l5B5oemX1lfGkc7XuUB7x3NOCV1oVymsESQrtyksE9DJcYA6W6KOE0S2A/phPsVEcDy5NiFVNFGxftq7GR/Ls7oTvuBEVJYm0qtuq1FWZjFkZ7gFtFq0fhYs/M2vBV8P6Ig5Jpeg46thmdvpHdq5favLr99tUcS/bduRllRCyvD2XJDTYbUnMx3EMY2DXMjLn/D8ZsxMpajkiLjMAgQONA7dHDrybz3Y3wpylTpqgsxMmENbAQjLx/LgvaH4CGXiGhjSUm0p57UffuayxUXrOG4ZbEG1DVhBKL/aa/2k+1D3Py7h49fXHUuz6TWRFDVD6h4YCllqGRS8s57/L/XGMgsyQap1Zx0y9QgBent5j9+EHTdUoXep1yd+qow9ZJs8ysS7/4v+NJk/3LDIEmYIpBNZriCrTH/VkmSSQ7dDB1cQaTpkRdfzHE6nDCIP7hu9cKEySqO8gfPOwvLQUIYMPaH4/1f5lFnPZT5qtZ7nUNfefFNkQ34/K+mdhQireDU7oCRcCyNGLPD8SYbdAhZmyRiyCG+ILde6iy+AhqVOW68NrYIr1yJSnWDkLMZ/Jg6X3XUB17d9tz8A12aF0Qg3JeJdLJh+/nl2JBUbdMW1/cTAnaA7vuaYRmosygWwJZ3UrLuSgqpHaAElJinKU8EV37oDHXt1h9A7HxqMXhKBc=","authorEmailMD5":"0c2887c19932ba204e4abe9336971ade","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thanks for the response Stephen. I think I'm finally grokking this stuff after banging on it all last night. i.e., It seems that my original statement \"So, for existing codebases where you have some long-running operations whose implementations you have to or want to leave alone (instead of changing them to async implementations or adding an async implementation of it), you can't just easily \"wrap\" async around them.\" is actually true. As you point out, the bottom line is that it doesn't even really make any sense to try to do what I was trying to do (because all I essentially accomplished in my 2nd solution was just moving the blocking call to a thread pool thread). IOW, it really is the case that to have an overall architecture in which asynchronicity is being sensibly utilized, the participating units of work, so to speak, need to be operations with async implementations. So starting at the beginning again, what I would really want to do is to supply an async implementation of the clsSlowOperation, instead of trying to \"wrap\" it up somehow. I hope that all sounds correct.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"d7570814-2c26-30db-92bd-9b1ee4c9d8f4","date":"2015-01-04T22:38:38Z","timestamp":1420411118},{"_id":"2f24ce7d-b8ac-34a7-afbc-60c1467b0f61","authorName":"Grateful","authorEmailEncrypted":"NIzkgtwf78g4fAFAdbid2406Fy5L5/e8uM1VcH4iBNiqpPzgTjk5HjTEINysgZ0u38kavP7Rk9nag1hzl0s1bVZL5GnEqDHrFrrLCEQBuZgGOmY3e8C37ZRtUybq3Xtgj4q7Ol+bJHjUhMTIf6rhH7ctdH32D66/0smfHePM9mgwPhnQf7R76WETk28fRRjCTk3XFh7LYOGf3KPHNQ+WUB3pyAUgk0eyeHjfv82szOXNMd3YD6T/G/2z3X2MJNMsIafxkO8zKqsZO2eKLi1wJuRZv9UW8XeJ/n+9fLJsqacRRkT4dmKW5r8iDKVzzKjSo1Ec2P6chiEA6/HbA6cE94BRSn+W08GBsDCqmOALME7YqoaeP+JKPefSm8Y6wXcl5nUKb5NsVzXViVpDvk1P/OU41psppoFMHgtN5DO4zhHIVdLgx3ADR6zsUvAqmmMy0vCHOZ6zpruirfORvytcCZsO7wkimAJo0LZxHoeqKdvjViTI95rgQmSrQ9+0yNcUibAGbpVB/9WzUJnCTt7zlOmnihAZLl6qLJoP45EJA+qXjpSCbf2wQ1SXCbxgY1D9N0+uZKYdZJw9obvTzwd4O+j1Y9fEQFqoq70X9z4KsN83vR0xqaaLOQQMAW65YXCNPLGdzbY98CgQfdSY4BQIPE9vzuQ0IuTrSfrSfgqwtL0=","authorEmailMD5":"0c2887c19932ba204e4abe9336971ade","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Trying to wrap my head around this stuff. I hope you get what I'm driving at with the following example. So I start with one regular (no async stuff involved in it) method A which calls another method B. Inside method B there is an instantiation of a web service which returns an int returnCode value. The web service takes a long time (up to 30 seconds) to execute. So hearing about this spiffy new async stuff in C# I thought, great. I can leave the web service completely alone (i.e., not touch its implementation), and just \"wrap\" the call to method B inside a method C, where method C is an async method. Only, this is evidently not possible because WHATEVER operation you put the \"await\" keyword in front of (in this example the call to the web service's method), HAS TO ALREADY HAVE AN ASYNC IMPLEMENTATION. So, for existing codebases where you have some long-running operations whose implementations you have to or want to leave alone (instead of changing them to async implementations or adding an async implementation of it), you can't just easily \"wrap\" async around them. Or am I missing something? Here is the actual code of my console app:\r\n\r\nnamespace AsyncWrapperMethodTest  \r\n{  \r\n public class Program  \r\n {  \r\n static void Main(string[] args)  \r\n {  \r\n clsMainlineStuff objMainLineStuff = new clsMainlineStuff();  \r\n objMainLineStuff.Operations();  \r\n }\r\n\r\n public class clsMainLineStuff  \r\n {  \r\n public void Operations()  \r\n {  \r\n clsLongRunningServiceAsync objLongRunningServiceAsync = new clsLongRunningServiceAsync();  \r\n var task = objLongRunningServiceAsync.RunAsync();\r\n\r\n // more code in Operations() that I don't want blocked...   \r\n }  \r\n }\r\n\r\n public class clsLongRunningServiceAsync  \r\n {  \r\n // This is the new method I added as a wrapper around pre-existing class clsLongRunningService.  \r\n public async Task<int> RunAsync()  \r\n {  \r\n clsLongRunningService objLongRunningService = new clsLongRunningService();  \r\n await objLongRunningService.DoLongRunningStuff(); // build error - Cannot await 'int'  \r\n return 0;  \r\n }  \r\n }\r\n\r\n public class clsLongRunningService  \r\n {  \r\n public int DoLongRunningStuff()  \r\n {  \r\n System.Threading.Thread.Sleep(30000); // here is where the web service call was being made  \r\n return 0; // say we got an int return code value back from the web service call, and are returning that value here  \r\n }  \r\n }\r\n\r\n }  \r\n}\r\n\r\nThe clsLongRunningService was the pre-existing class that inside its DoLongRunningStuff() method, a call to a pre-existing web service was being made, whose execution took a long time. Originally, the clsLongRunningService.DoLongRunningStuff() method was being called right from inside the clsMainLineStuff.Operations() method. So I just thought I could write a new class, clsLongRunningServiceAsync, \"wrapped\" around the clsLongRunningService.DoLongRunningStuff() invocation to prevent the blocking in clsMainLineStuff.Operations() from occurring. But as you can see, since the pre-existing clsLongRunningService.DoLongRunning() method returns an int, I get a \"Cannot await int\" build error on the l.o.c. in the clsLongRunningServiceAsync.RunAsync() method where I say \"await objLongRunningService.DoLongRunningStuff();\"\r\n\r\nIs there a way to get around this snafu that I'm not seeing, or is there just no way to accomplish what I am trying to accomplish? (And that, in other words, the new async/await/task stuff is great and all, but ultimately whatever operation you want to put an await keyword in front of, HAS to already return an object of type Task or you need to write a new implementation of it that does.)\r\n\r\nThanks for indulging me in my long-ish example :)","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2015-01-04T04:39:51Z","timestamp":1420346391},{"_id":"d7570814-2c26-30db-92bd-9b1ee4c9d8f4","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Task.Run should be a last resort; what you're actually doing is just moving the blocking call to a thread pool thread.\r\n\r\nIf this is a WCF service, you should be able to have Visual Studio auto-generate a proxy for you that has Task-returning methods.\r\n\r\nIf that isn't possible, then if the API you're using has any asynchronous capability (e.g., Begin/End methods, or an Async method with a Completed event, or even just custom callbacks), then you can wrap it into a Task-returning API (e.g., TaskFactory.FromAsync or TaskCompletionSource<t>).\r\n\r\nIf all you have is a synchronous API, then async/await isn't going to magically make it asynchronous for you. You can implement a workaround like Task.Run, but the ideal solution would be to augment the API so it supports asynchrony natively.\r\n\r\nRegarding return types, both await and Task.Run will work just fine with return values. E.g., if Execute() returns an int, then you can do \"int result = await Task.Run(() => objSlowOperation.Execute());\"\r\n\r\nIf any of this isn't clear, feel free to post a question on Stack Overflow. Source code examples in particular are formatted much nicer on that site than in my blog comments. :)","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"fac3e235-8c1d-3abc-af64-0e271c3d5d61","date":"2015-01-04T20:32:39Z","timestamp":1420403559},{"_id":"fac3e235-8c1d-3abc-af64-0e271c3d5d61","authorName":"Grateful","authorEmailEncrypted":"KnYUJoNB669za2jIjtxdvBEFlDue5pLtbVRyyMv3/yi9bLDj3RN20oJZ+yR0X9l0dZhINVjjf92rmUiM02Vw49iw7LBPkUVs/jZ8JmWB64SgEGsedrJ4pzk8IYc87sCdHAI59q+TBRVhrMnP76kaWfID3nfnxHyK8eHIgw55kdQ9xnHFayOGcrWHYY1F1OSzJr3AtMjMuATTfYdXxyBSdKtRw+OhMaUOCn296jWhrRSiwaGasaAeydcZeCvo1Bkvq1jXcuYVPyhIhwpjSViKgzdpYq0GFvSt6ekeqJ4xFsRiOsooS8cBQQyTZ7uF266d1jlgRNBNADW5DjXKQSh2bj+0cl9374iy5PV+xGQmBkX294mK5tDuRsW4QKtkqJPQiaa00533IcgO+Bv0EX7wx7LI93Hlwlh+ceoMbEB+OSsshAGFTIsk52Os4VnVGpcBIHHEU8MldYD8s7onugiNlCtK5tsDsaht5CtlT4Et6/hyC7527cGn+3xrvzDDOkn38usupK0ofRNNUiLuYb6KFM7K2YW5qfclmz2o2BG5jQn6KXJx0AW9C39kFoE07E5N6+43Qvpidt4REkmpAAQ8E2lKi8BS6lWl8ZcQ+rerETpeXxRQwOtcfZEn6By+7CSg890b8L5UA6UIZJgc6hQDzy61nYWTN0swTzKPW8D4CUc=","authorEmailMD5":"0c2887c19932ba204e4abe9336971ade","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I think I figured it out (mostly). I simplified the console app code, and I made the method to be executed be of void return type. This is because I initially had it returning an int, but it turns out that if you try to refer to the Task.Result int variable value even in the next line of code after invoking the task, the task will execute synchronously. Simply by not referring to the Task.Result int variable value, the task executes asynchronously. It seems to make sense that it would work that way, but at the same time it would seem to make the usefulness of async/await/task stuff limited to executing operations that have void return type. In other research I have just done, it seems like there are more beneficial use cases of async/await/task within the context of ASP.NET MVC apps and other scenarios in which UIs are involved. But here is the code that I came up with to (kinda) do what I was wanting to do within a simple console app:\r\n\r\nusing System;  \r\nusing System.Collections.Generic;  \r\nusing System.Linq;  \r\nusing System.Text;  \r\nusing System.Threading.Tasks;  \r\nnamespace ConsoleApplication8  \r\n{  \r\n public class Program  \r\n {  \r\n static void Main(string[] args)  \r\n {  \r\n Console.WriteLine(\"In Main, right before calling clsSlowOperationInvoker.InvokeOperationAsync()...\");  \r\n clsSlowOperationInvoker objSlowOperationInvoker = new clsSlowOperationInvoker();  \r\n Task aTask = objSlowOperationInvoker.InvokeOperationAsync();  \r\n Console.WriteLine(\"Code to execute after the clsSlowOperationInvoker.InvokeOperationAsync() invocation...\");  \r\n Console.ReadLine(); // This is just here so the console window doesn't vanish!  \r\n }\r\n\r\n public class clsSlowOperationInvoker  \r\n {  \r\n public async Task InvokeOperationAsync()  \r\n {  \r\n Console.WriteLine(\"In clsSlowOperationInvoker, at beginning of InvokeOperationAsync() method...\");  \r\n clsSlowOperation objSlowOperation = new clsSlowOperation();  \r\n await Task.Run(() => objSlowOperation.Execute());  \r\n }  \r\n }\r\n\r\n public class clsSlowOperation  \r\n {  \r\n public void Execute()  \r\n {  \r\n Console.WriteLine(\"In clsSlowOperation, at beginning of Execute() method...\");  \r\n System.Threading.Thread.Sleep(10000); // say this executes a database stored procedure that takes 10 secs  \r\n Console.WriteLine(\"In clsSlowOperation, at end of Execute() method...\");  \r\n }  \r\n }  \r\n }  \r\n}\r\n\r\n// Output of program:  \r\n//  \r\n// In Main, right before calling clsSlowOperationInvoker.InvokeOperationAsync()...  \r\n// In clsSlowOperationInvoker, at beginning of InvokeOperationAsync() method...  \r\n// Code to execute after the clsSlowOperationInvoker.InvokeOperationAsync() invocation...  \r\n// In clsSlowOperation, at beginning of Execute() method...  \r\n// < not part of output - a 10-second delay occurs here >  \r\n// In clsSlowOperation, at end of Execute() method...","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"2f24ce7d-b8ac-34a7-afbc-60c1467b0f61","date":"2015-01-04T08:55:40Z","timestamp":1420361740},{"_id":"6978574f-14fa-3de0-a4e5-590781467708","authorName":"Grateful","authorEmailEncrypted":"Kf0dAQYdNCMYPVHQsEQfUPnIKD2YsBccfrfzFxnfxOYduXMfi4v0MvACklAQhdmJm5MhkTlDBWpZmaAYI1Y6kWIQOHuGDhNKzhuj8qAXxU+PcLSE5/ZMYkK97woL0sGa8cHcQh50XIbpJ17FEJDmhPc0bulhojwkdiNHWcqk4qdB7q9uzOv3ch0QEZPWGQJFWPHdv1O6ZF//cZ4e1h+B6gkf6dx9O4MFc831jNJ8lpnuUiHwd6cxIK0wpNv0/bbvRHimUld1uW9usPgzodvc5XbC+pOicGxl86lIa7t46XAXg6x8NXBZ5FV7IF8YaTCX7VpwaCeWqT6U/D6rQYhoBSZPkBJ9b+9XfbKqa7ct5riZCzlBc/RvOHMdEizk94456t13PctRWjzchbIhbKUQojlQgwpziXxNVlliRSN9pjualgbaIrSi+n84iu9iVKcGrzGlYsNSjRxxDw5XYthz3R03g8mn9QPK7bg66oGLreWrbRnqth2D9pTN9MhWYB9umAfvZ7A9kgV5OYkUQlBYaXR8b58MzYkCedoP8Yrg5+W5U9frb3yaICh7UzNMN05lIPNYpauCjed3bY2VaV821IXbEXAkMGnV0QrWTCDyVgP5XTDkjLI4zf3icu6mNB4s/vyw6+ZsszSgGUfV8rTyQGLwKvEk2g4EdrmV/3Z6+4Q=","authorEmailMD5":"0c2887c19932ba204e4abe9336971ade","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Perfect. This weekend was very productive for me because between your articles and a couple of nice ones by Andras Nemes, I think I've got the basics of this stuff now! Thank you so much :)","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"7f82c88b-30f9-301a-9c6c-693606e562e9","date":"2015-01-05T02:39:07Z","timestamp":1420425547},{"_id":"7f82c88b-30f9-301a-9c6c-693606e562e9","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, that sounds correct. If you have an existing code base, I usually recommend starting at the \"leaves\". Whatever code does the I/O at the lowest level should be made async first.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"1f0c5c2c-bc2c-3f52-bf84-f97b1d65ab9d","date":"2015-01-05T02:11:07Z","timestamp":1420423867},{"_id":"0e0812f2-3762-308b-97cf-4e9cd359fbc2","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I expect the Response instance itself would still be there, whether or not we resumed on the ASP.NET context. However, many (most?) ASP.NET types *assume* they're running within the ASP.NET context, and they can fail in really weird ways if they're not in the ASP.NET context. As a general rule, I only use ASP.NET types from an ASP.NET context.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"c2597ce7-2835-34d2-9fd2-87f58104b724","date":"2015-01-15T18:32:55Z","timestamp":1421346775},{"_id":"9f257894-6bab-3f08-8bac-27fa5fa24ed2","authorName":"Craig","authorEmailEncrypted":"QGVKGoujXeV9Dde3xDAhXCcfQWnlYtLW41zX4uzRFucXXHWoO457YMQ3rCSm8MmKQq2znvB3GH9/CZr0oEHr7JVkJuBLBtk8U/lVSitvmbXuD3y+obZPuthK9sGsew4SfqL2q5EgmA70YR2NP0axlcuWEYOdjAcOjrblkrIXC3L4dykzfEA1ssXYtY0IM07gppzf4fAvC9nFRMM+QxC1NpUW/diuPVGNkZqWxxKI3vndJucqlLL9Q8b9+pviNcZUQ9f8sZfQv7LspGh312gYmxAdrO5iLwlYQbvCPq439T20jq3reciNvhDGnF8HnSW+Oeqtu4fDblz9EfZyYD6RCRHs29NyUN4HF/dlPhWeYftCH7//93frnQDADZUFbK3emkaKCqNJtXZq1eiHIIHy5QRdX5gdgyCMBgX9nYXj+vxL77UDCdT4qr9101d8YO/jGNOME3+QzuszAAmIrbnPi4ZuAGzp3tGVe6exwUlB93RzU0/lFUrkPWoCpqtOeNcS+Q1Zl9XZSz41eUBNMBOIVeKPHP/4Jge8yGxS3574R5ddxyGi2DaDGffDAvdy0RiZ34ghfKocaWkXZ80okTLmKTrPCg9jItHFm2Z/RWRUJjMrreGgxhpkHwuH2296/gEGGwpB31ytnksTeVcXdvmplDvFoLuCXIBTJZ26HEQ7GsM=","authorEmailMD5":"cb1b0d8c4d62a5931bc889131c1747fa","authorUri":"","authorUserId":"disqus:disqus_T4mhSyf8nL","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_T4mhSyf8nL.jpg","message":"By dropping the \"context\" we are running in an environment which contains only the locally defined (or referenced) variables, right? It's like your method has just become a free-standing method rather than a member of an object?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2015-01-15T12:57:32Z","timestamp":1421326652},{"_id":"a34a6131-5cca-323f-a364-d05070abda76","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Not really. The context doesn't affect the scope of the method at all, so you can still use \"this\" and everything else you would normally use.\r\n\r\nHowever, asynchronous programming in general will encourage a more functional design. It's just cleaner to return values rather than set values as side effects. This is true whether or not you keep the context.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"9f257894-6bab-3f08-8bac-27fa5fa24ed2","date":"2015-01-15T15:18:04Z","timestamp":1421335084},{"_id":"c2597ce7-2835-34d2-9fd2-87f58104b724","authorName":"Craig","authorEmailEncrypted":"O5uHBVcFmvE4JLOUZWxrtzZgnjZ16/617428mktLFP/oiOAz+ClMPFs4h1FjFOS8wSwDdYYAwzgdiyU7pTA7TpkF9LAWJuO5KyZq5/7H3JYHB660Ouw0LJSZRE6aFqOP/3sXk/1h+GSjkLycTT8KsTEA4gb+gEH3S5ufg7/HI6mlxQeBc1361L57QDjS5AvXMee/RqwJf+tbVpL3EQooRI8e/69M1X3DadOGPSLmTAUlynmkG/pobH7saPlcQJqCnW7OkjAyS4onWVhMGBNmolmKLIpescpJrjUROdytLWyTmVJ9N6gsqx1VqNgXfxy5WNM1xkKp7/mZiEfXV1T+G182iXLLrs8K1hU9h+MjwyRanpIZrGt5xU5doFBJHqF4uEmhP3OBiCvPLaqPGeZFprVPC2H0zoCqs8yb4lXT4pqilqlTBKjMywojrK8dgPZvBMsGvy4Ii0OIj7aiIfUTXUUxJdPb7MELOt9O0WDuBAw5rBnlhA4bbxOoTUaihoCjvN1ahptwHM2D/Crqsd+r+AIDy8R3wlK9KBO8Q2DWjuue21LtBqj8LRMYJoBcEItA7Fo7tgvluRvHMshBBnkriuti8/jmCDYeBuI9BGRp/OuJdLRY9MXUFSO0Mn0p5jql7HU/5ueJiQnDXGqbe7ZexdE4iaDGaLIIuEBsBNfaQ8I=","authorEmailMD5":"cb1b0d8c4d62a5931bc889131c1747fa","authorUri":"","authorUserId":"disqus:disqus_T4mhSyf8nL","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_T4mhSyf8nL.jpg","message":"Yes, certainly. Ok - I'd got it in my head that something else was going on. In your ASP.Net Context example, you access Response but a comment implies that you can only do that because you kept the context. Why is that? What would this.Response be, then, if we hadn't have kept the context? Or is the point that the this.Response getter there is, really, getting the response from the Context - so that should be restored in order to ensure we don't end up dealing with some other (or perhaps a completely absent) Response?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"a34a6131-5cca-323f-a364-d05070abda76","date":"2015-01-15T16:05:57Z","timestamp":1421337957},{"_id":"ec5da41e-3640-3024-97ed-94ddf9105a8c","authorName":"Chouaib","authorEmailEncrypted":"CdCDBAk7YbaOQwpd4jsCNr2ah5yHUqNx5S7I7Up75woLP9Gz1606rZ3G6S7HfrC6gBbU9baN0knjVUjuhOXlvxiyIOe/IWfmpjoUUMiaHTF0tfkuksvuvEUxV0QUzkFDkp5g20LBNhyZynO23TZZA3s3dpCICn6cbg35KS6KT/xDShii3JteZygFo6anEin4bq3sDx8zu8KpK4p+gN0ew4F49bLAAF+nofUUPumz7R85CNl80jD2daZ02lgsPHkB/aJHXXnSvdxQ9sIgl2gBpc3yqam4wqa2+3eksL8HkC9y6fUMRJt7+ZE+AYUt7ktzmhrwNUTZLF82hncW94SKFk0XlguMIr73XCjCdV6RmvYZWT8f5X7LqktXTzj6Kr5cXKXSeCviBoF483LTokfT7nSuVtTtEgKF6hLAXhMHcBKsgZI5EHPSRfzX4oFaM68xqwdWigJ7AbL73fFzMedTBsXriAYFi7FCG6re/5TyE9/nDFu9nfYdLAHwz7MQlO21DcxfkYeM9pAAJkh6NJaaDnTwjMLPr9n1vR6ADspJhzZfXgU+0e8+y00WKvV8LUiTe0ibUgR/8gMV2Idyu9nDHs07Bu43y9e88I/vH7GZ3A2OrBikFfO+TYH8ctLc647NK8WKfdkxyi5EIP6NBkp1nfRWzocMi5BVtX/w2BCH0+4=","authorEmailMD5":"4a3cfbc6ba8ee2d285f8cde0aa6ed84c","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"great job Stephen, I wanted to see more about the use of TaskCompletionSource in async method","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2015-02-12T01:56:01Z","timestamp":1423706161},{"_id":"6e0a3be3-54ea-3ccd-880b-b3f1b1ea431f","authorName":"Adrien","authorEmailEncrypted":"jpwStTccxQbwqmALO/VjeQFEM+XrX5c6slshOugcpg+y44D3JjW1qbVEk/6Sf/E8NiI/S0Db5+AuoRcaauZ5fs7lwRckqjr8ijHp3kOkniSCYQc6kcOkKBgJdVbQiErKW+t8sRCHzTdEnnrgh3N5DPYpPd7Xo86ln4R0FAtz8c78hu3Ju2rREucIswxsePt4ChzQqWbuD0mXuknCuQUCxThf5prDMmalrodWg+agMr7ui5H1yp67ZMJ5H+r3BOrz7js2vRo49BWr/I/YZM5M29GEzwK47Q++5EZXir9oM6x3OBA6NExWKSFBPMBsCOjfYCMnrVToDbjnK7mkEF+6u64NzPccEymZQG6DvEmAVv2uJQerfgXZncZCLMBZpX8bkS5JOA17xR+0nLIEv2FQDX2d3ufhFM/LUGU1/qGCT25nzRhUXNvraQXijUlakS/93iisCk3VcT/ZsQQ1sI6umXwgI605Nac5ZfaQIwLD8f1AdAThKJOq4k3pifRzu7kJpBRZFCIoOFpI/326DGEPz58RYwqDrvOz4Q0XKpPcfxVTxCyjvYA/uxF3cdm9vycL3qE9mHyJUUAPnRMcxfJXbmdr8NN05T6G/Zaz/Muw6xHLOMn/t+CLJPFlfCau66u0U6OwIqStE+KJk+iNh5iTSMaSaduE4tv652Azq4Y7Dak=","authorEmailMD5":"08845ad889bcaf135e57b44366d51968","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I have to admit that all your articles helped me a lot in my understanding of the subject. So many thanks.  \r\nBut I feel I'm still missing something each time I read you suggesting to use ConfigureAwait(false) whenever it's possible.   \r\nYou say that the continuation don't resume on the original context and runs on the thread pool context. This is something I clearly understand when calling a CPU-bound operation asynchronously but not when operation is I/O-bound.  \r\nUnless I misunderstood your point in your article \"There is no thread\", how can the thread pool context be requested if no other threads except the UI thread are involved in the process? What will be the behavior of ConfigureAwait(false) in that case?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2015-02-26T19:20:28Z","timestamp":1424978428},{"_id":"9a9bec5d-4987-3e23-8552-ee0ccdc0d0c5","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"In the general case, ConfigureAwait(false) will force continuations onto a thread pool thread. In the case of an I/O operation, when the operation completes, it briefly \"borrows\" threads as that completion signal works its way up the stack. When this completion signal reaches the IOCP, it borrows one of the IOCP threads to complete the operation's task (and schedule its continuations). Depending on which operation this is, the BCL may switch to a regular thread pool thread before the task is completed and the continuations are run.\r\n\r\nSo, if an I/O operation uses the IOCP (as most of them do), its completion will come in on either an IOCP thread or a regular thread pool thread. (The .NET thread pool manages both IOCP threads and regular threads). So ConfigureAwait(false) will just continue using the notifying thread in that case. Actually, if the notification comes in on an IOCP thread, ConfigureAwait(false) *might* switch from an IOCP thread to a regular thread pool thread, I don't know off the top of my head.\r\n\r\nWhile it's true that an application may only be concerned with a single UI thread, the thread pool is always there and is utilized by I/O and other parts of the BCL.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"6e0a3be3-54ea-3ccd-880b-b3f1b1ea431f","date":"2015-02-26T19:50:15Z","timestamp":1424980215},{"_id":"698d2205-e64a-3066-bdbb-d6e943bc26dd","authorName":"Adrien","authorEmailEncrypted":"FY1uuJBmRAAnrXh6pfgtWNgHyHld6bDouHsB2jse+olivPhh8BKqAUUjStnxKwwCmRLPg3M7GUdtSmp7Xvs0lt5XZJBmpwevXUmaN/xWWaVj7+slDPpQko+A9eBCww4XbG+S44t0KYhabz8XWnfvXE8jB4n9wlh7aty7v+mGn2PAtIIeX9fzzTfmEiTig4kCNKr2Iv94e4nzyHdb2n+YPiO0CnkcAc3g3ZMXz3WLi2LtaCb0BnpuqEjoIQGphBBcpGsVQSRpTY560nCBu+F/z0aCzxTEqcih96APIHKDxHepQ09sgU4UrNuvToo/fVOaTBdmQK0KAGK3S3SP0W8sepyWjA5IK4sBP7b2GQCiwKyarOCSxXbZCZuYq3yk4EVI+0WfNYDL/fsArY/M2M4f+DkbfIg9ri+7sXBqCiX+bqgp4TUf4YT3kFI81qi1f09h+8uJELMo0lYrEf+sWSiBQ9GTBnRSUfyhQ2kIt/DR0+gdPxT0Z3gUqvKnSuWZxM48I5i7xGYj5sTKd7TihfT73bcNmRdLkiAFkrq9kPsc0dCGMGkUAV4S2ZeReqNBa2YchXWy1BvBtVcl72nTHJoewJ6MuFIAUtF+sEKU0YsDWBhCGfTcKr729dKtGlzI6i4X4NUMjiW1/jNFOUakrFVI/qkwVwP3ihgunDr7gGXRIT4=","authorEmailMD5":"08845ad889bcaf135e57b44366d51968","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thanks for your prompt response.  \r\nOk. It explains well why the use of ConfigureAwait(false) is interesting, whatever the asynchronous operation is CPU-bound or I/O-bound.  \r\nI now recall a comment from your article \"There is no thread\" which, along with your explanation above, leads me to understand the statement \"there is no thread\" as \"there is no thread being blocked while (pure/natural) asynchronous operation is running\". As you said, the completion notification is so brief that the thread requested cannot be considered as blocked.  \r\nIf we assume that continuations will be quick operations as well, the statement still stay true.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"9a9bec5d-4987-3e23-8552-ee0ccdc0d0c5","date":"2015-02-27T10:39:17Z","timestamp":1425033557},{"_id":"91e1b78d-ead5-30d7-b4e5-9628229d86d2","authorName":"Nick Greco","authorEmailEncrypted":"IHszELZW2KuAkzqr9s5hMo5d9nhbnd0ce2GNDs+yIuLhE7cRHtWq+lS8+FP3MsnPbzXqioNTn1DGFPWpRPtLrQs+HSGCwCUwRPa4u1LqL/4r41jq/jqcYTIvfa6OFeR77hCgNGw8LA/WLutEWTAxxKH+3UdIagKSvIIhZ4lK2CmBzXrKW6FrFOuSkbef4Urv8cNbhGa4BJ8XVKIWEXgl9aoszIUq/JWhRdZmQun/F5Rwfh0MozgMQrvNvZp/wD0QCyNCtvLKoSjCcoN1F37M6a4HWWvhrwckClhgocIYpQ+noV1VOah4LREUnu/UQ7c+3NBhdFBiq3QsHNA0itdfaEHlb4G3WlUwjf00dU65uzi9cn+nXmamTnoCuz9up9S4ys61UNFGuQF1TjXGwPk4efaE2QKKnAEoLrSIucAubUkzEjBDfsK6G57hahNxUy48COA4rrIxFZWirQBFyaCqYAmbBCzUzx73wd5dRuYTgpFHNyJDGFoz/PXGduRxGn1XzEwvJIulHhR6rK7YAxitxt0p/X+WNpfmJTWiee1SGnK9nGgMH+uo1Vttpaoz00YrHPmlpwfL8kM4JEl89GXDXwND0Q8V6pZ2XY4gZwaNGQCDP/VE2HxiXgkHRLVZXRKUYMJiEXNEUwg99Q0qLH85u5RiWBuyXN3h0JzlKst5n2o=","authorEmailMD5":"1fd4bef65acc0771468748a7e9586fce","authorUri":"","authorUserId":"disqus:disqus_8Zvk2qQuLO","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_8Zvk2qQuLO.jpg","message":"Great explantation. I've been trying to understand Async Await for some time now and this article made everything click for me. Thanks!","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2015-03-05T16:00:33Z","timestamp":1425571233},{"_id":"a6f4a6a5-a4ce-30be-ac57-3e14e51a986b","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I agree, but it's a bit late now. :)\r\n\r\nHaving ConfigureAwait(true) as the default does lower the bar to entry a bit (ConfigureAwait(false) is really just an optimization), and makes for more impressive demos.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"c9cdce9f-d132-3fbe-a1d3-dd719a34b54b","date":"2015-03-15T19:35:25Z","timestamp":1426448125},{"_id":"c9cdce9f-d132-3fbe-a1d3-dd719a34b54b","authorName":"Dan Pantry","authorEmailEncrypted":"LSUe2zHUfpuc0ouuQ97FXLv4/wAqnQoqxf7/fEoNort+hDAm/hjFEwxt+E0umQWtkKPWOZMiXchlih/yF+kxAg1NyTcwwYXI6NJN12ESxD5VmmgoqZjq0GMPTv+qv+uOBrzq4/z7XIw4d8zZPY45kkS3aL9P+GEq0gHjfxD3ZHdT+VshEllBXiPa49nMPvWkXL3hoBdNU2Y6TbNE0hmw9cybk9k0qZRIBIVV95D4aY5CldZ9bEYFar+WpqYvN/WgkGK/wHWjhChZ5HMXySvzwc6j7Rs3Pfp+S1ymRUlCuW73/vDUkWzLQM3Q80yRG5mcXDJon9RIpNYTP5f7AOd3fvsD7pgsA8uWWiLDa5cEwi1T4tEiDDCAeRY2dYA35RjPRu1opHq+HzltIb2NMzzNIspYOleprSCXDbiCto7pvz/IRwT0OwGnfxXGu1/SkHM6vTF8yYyl5Cyeo8FEX5hFF0VnQ937EFGO97upIBcaSCrHcdFdiqqyrVFcAgnHe0xbX6Dtw2taDkI/PrUSGH3fSeQFaSfTBQy+oZw0ZF1dly5Ptju/iq94JHpUwJlgT1VNXxw4pjW61DtHSzuBayeh6aO2vOwCRPMc92QNUyZRA8A7ZKmMGXeJaazQSIPTPaJJOykBvDIhXnf1q5ivmiUC9tXa/HE6DU0LYK6hCDjUXSI=","authorEmailMD5":"617aee74fe5e8d2c5a9baab9691876be","authorUri":"http://www.aredherring.net","authorUserId":"disqus:danpantry","authorFallbackAvatar":"https://disqus.com/api/users/avatars/danpantry.jpg","message":"if ConfigureAwait should be used in most cases, would it not make more sense to push to make it the default and an opt-out? it seems like a lot of noise appending ConfigureAwait to everything.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2015-03-15T12:32:32Z","timestamp":1426422752},{"_id":"1f1bcbbe-e098-3193-b632-9c5130183b98","authorName":"dustmouse","authorEmailEncrypted":"cO59vKONOvroy9c8Kb7cxf1L6CkoQpfrPStHAG6tlMKLcIIT6RdOR0WcWPwnLzyON4uInEDtAkWR+AAMfYMPyWIhKsFKe5d+SK43v8WBwTkaeIbCThWbEWlZg1ahT6o0RSVSx79IhqQrWBttNrEOJxkNPCk235B8qMne51paFIEYXxO8bE1sTWbrjSEFGRcdNJzxB8OmVkn8p7toxiNtbVjYWkrvFYrgHyD87Zy+1Tly43AyhVKWhOqdTXfVKfC6PSaCxU03ni2Kq8UyxvCo2Ntmwl6iKAbQeNFj79lxOrnIMZexs+9zffqgixequOWYS5yCwocckrJ/KiDgMSs2Pikxv2OVmiLA8an6hgWJHlgc0SF/B4NgS0wKU637zjZfV2nCOpPC7oVoYy+aitYlCRCuMSCuIzZIx5ci8ngBg3xlZVCbVdZh0SwshlXTCr+vJQ0xk8VpHRhroIgZ2T5VpZo6AM2XNujQTcUWeT6cIcMXQI2QARYCoNuBFj86g/UUKMP4Buf6Wb/wvZ+qPQo5r9XZOYHr90GeJvmagesX2nPGY3MRw9D+mXC3kHdEN3BqxH1eTc3ThizT7BItmPem/fX/QCztk455JVclolwDtQeapHrdtuYWCoqRMIbvGbTsUIeI1VN44P+eS2j5upPvPDdEEllnSTEXIhrqW5WcMGk=","authorEmailMD5":"d99122ce07a79f353edaa0cd14ee06ad","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Very clear explanation of async/await. I have enjoyed the blog posts of yours that I have read so far. Thanks.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2015-04-06T17:21:06Z","timestamp":1428340866},{"_id":"abaa6e63-b399-38a2-8e1a-5d36c15c000d","authorName":"Veverke","authorEmailEncrypted":"FHAhr7mczHoNfCg9BjTTtwyNzC35Umh1OzOQJHgcFznWBMpIfq8ebvNgduxyUjfxgvvG3yFPrBGheJX6PW9ibayDRmVqJRLDlwjGOPIK4yIylue4niAxXEYBdWbPPdXVA2mYAvLMAdxDdxurfQktCU8HQxVNuZZXuIVV2jl2a5GXkFcfLyjz6yL/l2P2SGKe2AI3jImK/8sElSmHfD6enx+Nph/8tZoF2GgcP7NQpPCtFBBuNaYSQE1o0ghkWLwNi9T/Zv7LxHTg0ZEMwn55inuAJsS5A11I334M/hi+6zUwHGD0HxL64aAu6WuthF7G7za3lDdoDs3WhXBWeOPAIFmOKODLkRcjQS7U0e2L+V+NfqgqajAHwzjn5jOXc13yJ8l78tX2XgFXudTUvA4+Yh2GfgVu4zZlM/LPSW6QGRKwAQig8iIr/JfhDJjNazogpCWBa/oQQLi0OlghvlDBtFfLISxU8JQSnO7s4IfO2Tj/y7TS9QFvQ5Czorq0Z1BdxZKv3VhBeJnDR+JFuKuVHZ95Z7RoQE8X5wCjvuZVsI11rdFiYbM+jneHWSe+Q8+t4nFqRdadqwHFMLdxbbrH2NCHHat2CMJYkETyo3MVYED8kuIXQcqstbzoz6QuGsuXvk2sx0fo6AalS041PckucG3zMMX3dthrRXibce0iAvU=","authorEmailMD5":"fded734fdc8e94cb19a184c528a0d9ae","authorUri":"http://devrecipeshb.blogspot.com/","authorUserId":"disqus:veverke","authorFallbackAvatar":"https://disqus.com/api/users/avatars/veverke.jpg","message":"Very instructive once again.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2015-06-30T14:45:22Z","timestamp":1435675522},{"_id":"2527cc42-78c1-350b-ac24-6cb3a00c785e","authorName":"Martin Mews","authorEmailEncrypted":"swDh1qp+t8LVkoiIZirbcX9SEOQQg0Hve0BEgEqQzmbMZuRAPWz2gUekNCs3LUt/na5jSKhb511LS1/EmFE75kp2GKC7SFCZuli71BdQbUbsgBgw4tOVug2xao2RqEZdslTu1jdxr7IMrd1reg7+ZSQGn4qYprxZPRpZzc4yZvZfixsWCeMSXCUNyDPk2oH+qwcqsvGtt3mqk6H01JkZIgLYkiJxD0Sr1TDtkwueUfpwWb+2zI9RWA6rg94zGDYtZg01L9wPO59e64hdKuyE+DPd/zZyMAoVEJ8JPBX229NjbkpedKct0AYWQW/lHCnXyKvmVhzR1p5FCnyRjrT/NMzh8NjRp0IeCSOvr0oV0CuYjW7MwOwHA0r2RyWO/0MtNO0AQ7ntNYhVyJPD4d+vYNZi9LYBC0Y6uTU6iGe4rXx1Eg8INjPdswcKLeThR5YasUVN4CKJNZr1jaymZv0zMAOOPP17zVoDJ4FDquwjSOEs1+maIJ/S8EYiUxglWTGOUAbOQ8MitIzSbp5iH+wscK1gl7pzTxiN68WnT+mvF9a0wkRLTtlx8LlR4PzB2xyCcpED1TUG3tISHCwpg9FipcRb5GJ+xA/OVv4BVZcFTzaNxaHWhpHN7CZlPFy4qPifX/i28cgSUS5yBwtA0o1xsPVF+IYoVA25uMZPWUX58Js=","authorEmailMD5":"6148688f57d27e6d5eb4f5561c82d9ba","authorUri":"","authorUserId":"disqus:martinmews","authorFallbackAvatar":"https://disqus.com/api/users/avatars/martinmews.jpg","message":"Re:Avoiding Context - Whats the point of the second example? It does not ConfigureAwait(false)? Shouldn't this do so and then the example becomes that it throws because we've switched context. i.e. in contrast to the previous example in Context where the context remains the UI thread.\r\n\r\nRe: Async Composition why is the second example returning await firstTask? Shouldn't it be returning firstTask.Result? As we already have the task returned via the WhenAny and with two awaits in that method the compiler has to rewrite the method twice right?\r\n\r\nthx","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2015-08-20T08:27:25Z","timestamp":1440059245},{"_id":"3f352586-68c4-3dfe-b4fb-d467b3820cf8","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Re Avoiding Context: Those aren't two examples; it's two methods in one example. The second method shows how to call the first method, and illustrates the fact that context capture is per-method. In other words, the button click handler resumes on the UI thread even though the method it calls leaves the context. This is in contrast to the example in Context, in which neither method ever leaves the context.\r\n\r\nRe Async Composition: I prefer to await the tasks, for a couple of reasons. 1) Result will wrap exceptions in an AggregateException, which means catch blocks become much more convoluted; you can avoid this by calling task.GetAwaiter().GetResult() instead of task.Result. 2) if the code is refactored later in a way that the task is no longer (indirectly) awaited earlier in the method, then the await will still properly behave asynchronously, while a Result (or GetAwaiter().GetResult()) call would now block.\r\n\r\nThere's no additional method rewriting necessary for multiple awaits. The method is only rewritten once, triggered by the async keyword.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"2527cc42-78c1-350b-ac24-6cb3a00c785e","date":"2015-08-21T14:20:50Z","timestamp":1440166850},{"_id":"8b76af92-1e95-3df2-8019-1faa1d35e0db","authorName":"Varun","authorEmailEncrypted":"XvMMBHfINbcXK5+CdPoVCfb3o/o57g6Og3skJ+OiC2bLa2xjhiEd0Ffi9eYsH2zdxMTBgFJ1ykEg6z0Yfz1fX3NC0qwFyocZ2tQEGmfIrbIVURiFV/xh4fkg3uIMJYJ0vbS2JPTVL8LJwqJGELg16/BLqymlPQb3bXKc7H261QwzxcS1EM5Qag9XWRg7pw1qZAJ8JzspU45nm+55juU+a6UJTx3wjasfum5RYVeM0OmzD0+Ky4h+62Z/PB/gEQD+pbl3jlAIyNlWdpyUBPS8uP+cfgsC8UAIt984QvPs9LVXq1ZsgogPpkvYeLVnAec4VpwBdSp+F7BmRmxpaJf1hfD4gVp1B5kujXgh9dCY6NDKhHwBoxWB4zJ4Q5JD4jCJ8aIcbD073lyW/3y8KaLLrdjaBHDcBOGcn4MpHw9aGDVXbnpQMoN7SMYxrpsITrsEh98U9RCBEqURiZ2ZCikwiOUBVj9FJK6c/XPy3gR3epK5lWTEn/laikXiqag08ayvjbp3nUpnmOEMzEoDwu3vfkSrUH0rS0RtHbeZjk1hiQSxlFLkQySl8cnsrcAVFJeLmJ5y7YAjqZIJREQ9AyszKESzNVboucuWAEPcy4maZxRaFM0YMq3usv3eVXcTFD9ASdnLTyfduCklGKHFCVYp3qCMq9MhJbjAD45cQ8qlggQ=","authorEmailMD5":"72bc0f61aa977594b000207e747601cc","authorUri":"","authorUserId":"disqus:disqus_weoHk4DDGw","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_weoHk4DDGw.jpg","message":"Hi Stephen,\r\n\r\nI have around 50 operations that needs to get the results appended. Each call takes time to complete around 1/2 sec and then aggregate time actually hurts performance. the example is in phone application context.\r\n\r\nI had implemented using   \r\nvar resultList=new List<resultmodel>();  \r\ntasklist.Add(httpclient.GetAsync(url));\r\n\r\nvar result =await Task.WhenAll(tasklist);  \r\nresultList.AddRange(result)  \r\nHope you got the situation.   \r\n1. To understand configureawait better way, Its a mechanism to avoid UI threads to be resumed from the async context (waiting to the await to complete). So this means that if you have .configureawait(false) the control is returned back to threadpool and the rest of the code after the await call is executed on UI thread.   \r\nIs there any better way to execute this scenario.  \r\nRegards  \r\nVarun","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2015-08-24T09:48:44Z","timestamp":1440409724},{"_id":"be46ecb9-444d-3f4d-bfdf-7fc1876436ab","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The code looks fine - it's 1/2 second per call, but it's done asynchronously so it shouldn't be blocking the UI.\r\n\r\nOne thing to check is that the connection limit (ServicePointManager.DefaultConnectionLimit) is set higher than the default (which is 2).","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"8b76af92-1e95-3df2-8019-1faa1d35e0db","date":"2015-08-24T10:59:14Z","timestamp":1440413954},{"_id":"c7173ce1-03f9-3540-bf56-7b892d122294","authorName":"Martin Mews","authorEmailEncrypted":"SrPz9wVFerUQ3lDgXMMSGM/S0ssHLkPytPJz1a8Zl2qZAh9Sbvpmpm6urNzSPuQ81mtXIIhf5H4qQ3hohVyhSg1Cr+4HHFJD8DsXONxM4YboNQJFhQOIdtSa6vgT7WObkuWOAxmYvLNB2ev1GuCD5b3ncqnvGBXIYcKAEG1VwPMs9S/TSC0oJbtzPNMeuGUMqDandTbKKdcN+pNTiKjF/Z2ATK6uCenH+y9fBAvUuWKDnpqfnTdgCpNAHYtrmOJ0Tw++YVmDGXzOVOevquyI0DW06pJrfTLewGdxyVASzpof/NEReTbLBJE6IH1NS6Zs0bT9gLfHkAVzhGaYnpO8vvO8dPxPR8+gnP3L8B8231zF2uBw3OlyZ7KfSA3HG3Jn+Ev5VfMbyFqvPxdhR1P2KJuKSc8cSeVqn6D8D+DQsEfWwu+lle3VubZ+ckKsUtu+JW/1+uq7fiX/sBBgISMfb5kTwL2C/ZFAR0FC4rm2eHPJxBrhQpOPS/JLdXUHp0vvjhFwmJeSUUMS7eAUfCY5L82Jvm0kF183HZE7tCE9o/cu3MXQ6RZiIt8SjJLmrVIadKFKO/EXZ3Z4+DM5EdMveCQFAni6mPfck5p2HxzAikq7Y18iL0l4GilZe/e8PxPYd0uGFdG0y+TvhCIVA2zaCnZOOYn9jf/II92+SpvKlaQ=","authorEmailMD5":"6148688f57d27e6d5eb4f5561c82d9ba","authorUri":"","authorUserId":"disqus:martinmews","authorFallbackAvatar":"https://disqus.com/api/users/avatars/martinmews.jpg","message":"Re Avoiding Context: Hmm not even sure how that confused me 4 days ago. So obvious now.\r\n\r\nRe Async Composition: ok great have done additional reading since about async and exceptions and understand what you mean. Also read about the state machine that the compiler creates which further reinforced this.\r\n\r\nThanks for your time.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"3f352586-68c4-3dfe-b4fb-d467b3820cf8","date":"2015-08-24T08:43:43Z","timestamp":1440405823},{"_id":"2ffa8910-da16-3d84-a4ac-a725d24936a6","authorName":"Siarhei A Arlou","authorEmailEncrypted":"sJI3mr2wKOtVzmbPEN8K8DkYMo9Xyl3SIkdjhyINW1s1rDt43X98Bvo+TSf3Xm3+Er9+1xTK7pBGdt0qqgwKCWLjgaM6DDN5aIsSG2CACKhmoDppnRUp+SUEVDSfzTiXfEHw+2CKNJdm25Wga4oUNmyLs4AgPpbu9mMjVEyPGGsW2F5j5+97LeudfF4IaicEedXQwk7F+oG7AIPcj1nqoyTVUQMsvNVFmGZOdV46RuGSlw2lGGz178pVaCVJZhcEmvChk8UHNz7iAgbq+J7JYY7D/+ivwvKfFQyQEXEav+r6+8VqTGX0tWFf5r01VKPun0knsnCtMF/Ox7/Ek/xODMsU1btfLxHasqP5ag3sV8er7adg1Jo2lT/6MbhCE8GUno7AGsADyxhpiLmdkLpT1/GsPsvro6INRg3r/PEW+4xnHhB3MtxSg0ImTAGOQKbsQWTaLdux+BZ1fJ8s/XO9rm7vBdgc8yS213scUhzvG3CzvEgddA3NcR7wdf5LexdElWZRvyYpJvKn9XODrA/XYfo90wfBVHsyfjwtCFjvboU7suT+he8Ik8Je8QUxpb/0seuWSS12UCOVHCSLJ/wiGUpWKAGsxLYKqgc1I6sXp8QlDJoAR3TJUewZojH38cGfSmZYteJLMZwah9t1nx1dMYy7ExSzxzQuoGECYP6OPjE=","authorEmailMD5":"e423bbf32dcde86520834bbb6e0f96cd","authorUri":"","authorUserId":"disqus:siarheiaarlou","authorFallbackAvatar":"https://disqus.com/api/users/avatars/siarheiaarlou.jpg","message":"Please add to code blocks   \r\n// In the Real World, we would actually do something...  \r\n // For this example, we're just going to (asynchronously) wait 100ms.  \r\n await Task.Delay(100);\r\n\r\n// In the Real World for NON UI operations, we would actually do something...","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2015-11-02T20:53:38Z","timestamp":1446497618},{"_id":"4df7ad72-811e-3223-8bb9-99c0f1ab772a","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I'm not sure what you mean by \"NON UI operations\".","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"2ffa8910-da16-3d84-a4ac-a725d24936a6","date":"2015-11-03T13:20:45Z","timestamp":1446556845},{"_id":"5b668fad-2f85-3c73-aef1-761200c92595","authorName":"Siarhei A Arlou","authorEmailEncrypted":"Y1FLNWiSntOVby806+Iq8SxIrJMdsVug7ipQAcFjk2R+ImIjPiRTP5hKnhCGdRWXPeDVwW7MPZieZl+W2+FMUiJwFF+t/nmn7KY5hARqjGWM8DiOseqDhnRrVALU+rJZreKhYPJ5d71J/6iKb0uVmLbSABO+M2DvEaVMbsmTMIcgmVQMKQYYQ+yEXOsD5lH08FlpnURv0ic56VNKaZPM+lnSmkpy7OLz+SvKct5bqJiXQfc0QRowbCw6m93MdUQ1/sEaZ0GPwiHw17czrApSjwWPwZ9wL30VBjq4Z23d6T8eQH6MYKPpxPsZZOF8FEE+yh7l2P0eInljvxYLkA74ewy8pNXEX/RNI8f3ZAjyV7u9favBP96FT35Lz25kF0gx2qXsMFw8AZnrIqjksZ4IislNYXmm7aXFakcPOFpUwT711A3PlZpplZGLemzcG5afBFUjQWmeJ2J1pDc5XGzN2n7NuCl90hHqQsVk8Y5IC3m7y1pRquI5dWzKHv0Kx6+M8qmWdm+uBu6FME419bo9zj9jXQtsf66NfudjiRtx6H+jph+WjKswxyzKj+s6wS2VJijWgLIqqKfaXOicfqNzvghWAfWlToiiDlV6smdfn6y5WwKSFBeZ8J8W3ER7WQfgyRjumav7tjsS4TSiS+0eD9zOgUy3RqQnnahzQaeTRIg=","authorEmailMD5":"e423bbf32dcde86520834bbb6e0f96cd","authorUri":"","authorUserId":"disqus:siarheiaarlou","authorFallbackAvatar":"https://disqus.com/api/users/avatars/siarheiaarlou.jpg","message":"There are a lot of programmers who tries write code in context\r\n\r\nawait Task.Factory.StartNew(() => button.Content = \"...\"); or\r\n\r\nawait Task.Factory.StartNew(() => MessageBox.Show(...));","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"4df7ad72-811e-3223-8bb9-99c0f1ab772a","date":"2015-11-03T18:30:53Z","timestamp":1446575453},{"_id":"1d565047-2ea1-371a-826a-e3efedaecced","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, there are a lot of programmers who make that mistake. But they wouldn't get that idea from this post (or this entire blog at all). The problem lies with StartNew, not async or await.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"5b668fad-2f85-3c73-aef1-761200c92595","date":"2015-11-04T13:41:39Z","timestamp":1446644499},{"_id":"5319d582-e0bb-3fb9-8dd2-3b56bc159d61","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I'm pretty sure that there's no deadlock there. Personally, I would still write it using await instead of Wait, but as far as I can tell the blocking in this code would not cause a deadlock.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"af5986d7-0f04-3bcb-beb4-66c320063c3a","date":"2015-11-06T14:25:38Z","timestamp":1446819938},{"_id":"af5986d7-0f04-3bcb-beb4-66c320063c3a","authorName":"Kal Sze","authorEmailEncrypted":"e/p4wJcVzdhCKkgcDuBUULQBX4pTeYX0AlO6rxsSYHfNwdfF9q85Pz8nY2cy8yOfpX1oTy7UDKWa/y6cPtS5KfrouN4ALZ/UZGr7i0+TCvDUn44J0VMwt1y4f7kkY80tu4BwBRMb0Z/bnTeUdjC0dlvBfTzFCk6UpJ9GoVgkPXVH0o32EzZOA1uN9oLaJZ8+eQkRI2O9qk7N5o45yxGud+11ZC6Urn8HZxaVPr189ViOlonq9x/H0CfmSfQL5R5MQT6PT8LBD2QsH/Z/9o3k++br12o7mNfh8/923HWRnAPu4RRlt0vc5TzRLrxJ7yIDdMk4ccbbiSmEShA5+wLqWsLLFmOplgh/lI9Zka5Abmcf/uwteFLJ7tLiRp3gKzX4Zq32fVVxu7vXgspBcCUqO8a+WaCwawPPw+8HTpLkU9nh3q1ckUszmUmT3DjkUWSGVj5B9fYTqRvUnan4HuTpbq1/mfdYTc2xT9GdWeuOwAnfQivAOZVQxrZgZtXsjCtX1q5N13vyfFqURX4PVpXoD5+Pq56bB0t+WPwGjSaugNIV6PEpoI35POPn7NHwU7HqHjhruh+xNH+KovaJ++UWXeq1PNjLjJUVWPbi52csqKmZzwfYPLm73VuPVIkyq9j0TfGYq85jlN+AYYT6XT2/6cncTdxa3NjcNnIbU2K71+0=","authorEmailMD5":"b227c6c2c91f7248998801b23712314a","authorUri":"http://kalunite.net/","authorUserId":"disqus:kalsze","authorFallbackAvatar":"https://disqus.com/api/users/avatars/kalsze.jpg","message":"Thanks for the great explanations.\r\n\r\nI would still like some clarifications and help with an issue that I'm having.\r\n\r\nI am developing a WPF application. It has method that does basically something like this:\r\n\r\n``\r\n\r\nThis method is passed to a ThreadStart, which is used by the UI thread to spawn a Thread, so it's not the UI thread. If I inspect the Thread in Visual Studio, I see that the Thread is not a background thread and not a thread-pool thread.\r\n\r\nOn *very* rare occasions, the thread stalls for well over an hour, after which point I have a DispatcerTimer that would purposefully crash the application if this thread has not made certain progress, which it can't make while it's stalled. My gut feeling is that it's stalling at the async_write.Wait(). But I haven't been able to reproduce the problem in a debug session yet, so I can't be sure. I'm betting my money that this has to do with the fact that I'm writing over the network (SMB 3).\r\n\r\nMy question is: can I be pretty much certain that it's not a deadlock in the async/await/Wait() sense? For two reasons:\r\n\r\n1. Because I'm not on the UI thread, SynchronizationContext.Current is null;  \r\n2. I'm not nesting async/await/Wait();","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2015-11-06T09:59:28Z","timestamp":1446803968},{"_id":"06d3330a-068d-379a-b398-45921bebe1b4","authorName":"DrAbe","authorEmailEncrypted":"DNODfUlPSFNB3x99D2DhjzetnCCrl8SNaHmC56QYFj3nPwcE4Dw6oqUJhkiC3pdjxi09AF/zmv75iuigr1wQlND5Rr2wmpd98CfqXcqwTuBIOT0gCa6e1dp/zpVJr+4BWkOzJ5mAe4fzyftO7Ig4o6a3BaqhATmpzmTqeEvviN2hDgMm+CGD2andqu1yAILcQwWnNnhnKOnIKQmeFTXQZBS9kdJjrkR3hOBFy5DPiDjd+81sBGxBGo7HrHA3uFOxsOadVULrs3ndbwEkrV7cwsDoU5hDlhRf2bVPTNiuECZV3e31DZrI99EBWNxs9C7vyYD6ljD7e6nnQ4hSMWmHwjUORyb69P/DGf1huDGxTDc3ySMUcwBbAkQa/oRLTuoOP2D3jKr1fV9WIGG941MQAqpKJoSyiZ7AvZccVpU/28oIfcEhg3ZuPk4GW11G2PWB+KXjFH1vvtm7QPal+wEw1IWEDxOaM3eA9iW8hE9uMD6sw3oicPa+brtCJvhwuKv1jAFdQUw9BMyUox5HMSG/nM8tzYqLv80bDINlK2r4Oyt17wR8ZaMjlfO9bIiaxxapdAjYFzr7+m83ftT11NNdFkYMgd/hkYZDroCZTnBWdDGUSV3+59rkF0wdpgJjs4dgso3Iv8hp0yv9xAdMreGIVFch18e6n0i1rTbYbibdAls=","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I looked around and couldn't see an example of the caller processing the return task object. If the method returns an int, the caller gets Task<int>? But then they have to await the returned Task to actually get the int?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2015-11-08T01:36:35Z","timestamp":1446946595},{"_id":"6d181a68-e543-361a-87c0-d1cf52ea0e59","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, that is exactly correct. As far as types go, you can think of async as wrapping the return type in a Task<t>, and await unwraps it.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"06d3330a-068d-379a-b398-45921bebe1b4","date":"2015-11-08T03:40:44Z","timestamp":1446954044},{"_id":"74c75536-e09f-38dd-916b-0aec1b7866e4","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The context is captured by the async/await state machine (not the task).\r\n\r\nIf the code uses ConfigureAwait(false), then await does not capture the context. This means that the method can resume executing anywhere - it doesn't care. Usually this means it will resume on a thread pool thread.\r\n\r\nYes, I recommend using ConfigureAwait(false) anytime you do not need the context. Business classes that do not use the UI are a prime example where ConfigureAwait(false) should be used.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"83aa3745-27fc-38a3-b814-38efc8f88723","date":"2015-11-11T13:15:43Z","timestamp":1447247743},{"_id":"83aa3745-27fc-38a3-b814-38efc8f88723","authorName":"Rubberduck Chris","authorEmailEncrypted":"U7dVDvk1cHL4kFaEL3AZ3GzyyN/lmd7JOQlFQzhqWugS8XkFBgObv44/u42j/7DOasED7GDlVHZdW/ot3W/TewV7ixjiJpmVnq1gxBvJVWJm7vVfra/KIS4CGfYL1dzg/vTFyKyQ3Vwb8jWT8fiw1iwmf7zxwmlA8DDBo6ZckiJo3QUhLq8s1bZ/6W2NQpSQtqY/3d8FewwgJ8EalYwEfStvQOcytduXQFb2qMKxJ4APr+xmfTdI/TXEugMbRuyZPZ6rmrCjEyyAI+Mbx7pMGMDwWqs2wPRFPoLOL7HXT7f4ZWLLw1w/Jz3hecfZWKky8w0boVUqXAkHY0P+vvmdUd5Y7+Uot5aGh12MIzbpW3IAjuUNn0Sn+49uQyBsbN6tYw5sfNS1YlqPKILJEhWRa+98CVh2+3mauJKgzPbh/rsa83rax55OJAvxIr9l0GteRwPSHB3hUhFBcazEY492zOknIzQV2es+Kvig8+seZdDl9nS+01ulR2Selvm8dAWi+ooE6y0JqoZkCKq5GaNhVBXM/hvPftg+AFjo6U/yVz+6Gur8fMVZHGU/WuBpLqB00eiJdE+0BjRpIfzy/8i78s0/TOxpGvoR+mI5k/uN3qDZoM7t5a2Z87ZKCPTM8TXpDI21QRV9Qyq7Qzyx36fLr2fn1D59U1mm4e6LepLqXWA=","authorEmailMD5":"9f15e8747613f8d532cb3b9044786c0b","authorUri":"","authorUserId":"disqus:disqus_6K8VK1yvuN","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_6K8VK1yvuN.jpg","message":"Thanks a lot, Stephen.. I have read your article and it's really helpful for me.\r\n\r\nLooks like I'm really late to the party.. may I ask you something in ConfigureAwait(false) ?  \r\nI understand \"to not capture the current context\" by calling ConfigureAwait(false), but in this case what actually does the completed task with ConfigureAwait(false) remember for the current context?\r\n\r\nIf I have controller/business components and do not have any views(UI), in this case is it suggested to call ConfigureAwait(false) everywhere, because I don't need to remember UI context ?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2015-11-11T05:58:44Z","timestamp":1447221524},{"_id":"530a32d4-dae0-3495-bac5-b846deed7b2d","authorName":"Rubberduck Chris","authorEmailEncrypted":"HKTZfziI259GrXjfpWY8E2xNDH9XSIkWInupFthrQmNzdv+Wj0S1wk0bwXpqUdj9lGw7BwdVZh6BZFYpSG+eES4fpRsQPOb6Vv5t+hzJhqX3383l0nJRVnaN2fvRBDdvKNK2v8rrq4Wl/Te8+plcAMK9O8EqUoNQpYYTsHnHK1nrs8HAYIoOZSoaBzhSo6ZU5ZcoJGuXNA2FnwLYlLlYl3ysOnq1HALjQBtdhVh66cXN45ZqTU5wXHnSqgKdPvezeMMut9DDwtsqQMZJbPzsPqudIGDpXWpiu/NidhuKy0rnQ2+yMk7NWrgVsyCQyH0+JvDL896sNqkIWpsDpBNX5/Ty1FIn1v53Ro9219I8CqWS9Ypaj+6rIWfuDkpJbpUPrQeg9uMSHirRi+HbUVqQ0usC7uPS4MsSfdXgRL6CHKt82grSGUAaAA6OAKK/Bx2mFPy27K6ufh8mcUxq7B2lQ2Ayky2q5neoa3zDu6Cs6ef/OuVx7jYBJ/S4pWlEVUnsGD7B7lYL9nqQ3CvVz7/6itUZ/+8LzrLtUZc2G3/aMxm1XN22yy6EJ+67AjpSGbhS01QqFoqBWPMJ5hT4s1r5fszfIn6DAmoXmpfYaw/URrGNvvy2/u4jmLTXQdwKVI4hH3kAI7wpFJh3Jtb69VCPbHsly/Ix/UQbL3t7jw2PhRY=","authorEmailMD5":"9f15e8747613f8d532cb3b9044786c0b","authorUri":"","authorUserId":"disqus:disqus_6K8VK1yvuN","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_6K8VK1yvuN.jpg","message":"Thanks a lot, Stephen.. now I understand it :D  \r\nHope all is well with you !","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"74c75536-e09f-38dd-916b-0aec1b7866e4","date":"2015-11-12T01:23:17Z","timestamp":1447291397},{"_id":"c5051e73-3edb-3aaa-996b-d3f260f00157","authorName":"Ram","authorEmailEncrypted":"M/h9HcWfO+uVwThvic2VeunpNmq2mUoiQGoMjwqRGIt0ZayjTP/FzQUY2O38MpoPEhikjOQ77R1Bekq5WJIWHjEu4dOBUgrMFEZKGWH5Y25EqV1A5hqB2a94sBcN61pvOiPeesmITtlEFu+0Ay6HEaDkdP4a8D7JjjSzJLjnkU8VprZ7f7OlO/LjnCeX3xngXLZkkqpxcImca4JWn8EP4N8Jqj+BA/hWX0BDQ0En5rRLiOcrFpysUhE5X0l91gSriYW3J2szXUkxY0miHk9jtvKNqv922K/wfccVadElG7DmXQZ/Z7gT5lxOnnBU5RBRbLJsN9svvw7cYQHHkLP5CtsH6YbPmqUf70EkSss6ntvLBepfP0B2LP01os332IqatFzwn9I90ilWywZyIcQM2mhIvbECEGWVTAvfxjBn9YXOdIxLDa/0Bd3Q8XTjP4/wF5gH1QaxD3+5CNJf1ygmpf+HHcZx5t/V2iqb9L0DJsCvB89L267mmA90TrQFYHQRIbLFSy/CQFknoD4MPO3Y8GZlw9RgAE8rIjMWBnxHKaW067KRxaLoh+bOMGxw7u9DKRE2HhbP0jk4eodZD8XZMN1Ed/SH0kC6x3xAFoDLm3g6UKJ0x0esG6MXt5GXJWmc/c1rLK2maygA5cK/49csVCqU1k3GhvGaeX9OSghm+KM=","authorEmailMD5":"6d646d4d1e56fa6231962e91d0c134f8","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I am new to this...and I have a basic question. I have to make 3 database calls that are independent on each other. Does it makes sense to use three tasks(multi threads) or use async await (single thread) or just use synchronous code.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2015-11-17T21:55:54Z","timestamp":1447797354},{"_id":"0093f78a-9b8a-35c9-bb24-b28defaab6d0","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"In general, I recommend asynchronous database access. The question of whether to make the calls concurrently or sequentially is not one with an easy answer. Or, technically, any answer at all.\r\n\r\nIf you have 3 database calls to the *same database*, then it really depends. You can make 3 concurrent calls if your database backend can scale - e.g., if it's an Azure SQL or NoSQL database. If you're just calling a single db server with a single database on a single disk, then there's (usually) no real benefit to making the calls concurrent.\r\n\r\nAlso note that Entity Framework requires concurrent calls to use separate database connections (contexts). So there's additional overhead to consider there.\r\n\r\nThe only good way to know whether you should make the calls concurrently is to do it both ways and measure the difference.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"c5051e73-3edb-3aaa-996b-d3f260f00157","date":"2015-11-18T02:10:10Z","timestamp":1447812610},{"_id":"e771c7a0-b0bb-3a2e-b39c-c038a37de96b","authorName":"Ram","authorEmailEncrypted":"i4YfqCPcbEPdF30PN+fBozma53qz9lHWUTYjWMkPkUIY5/SYsDsTudGKwcwOXAO+l3YeSctj031GN3KYgMh/yxqQ1whaZ1y9cH6mWONOiQ8e/CyJcIK3AvOeDtLYM2pChXc2GtDcJZkelZEOkVefDs5Sdss7r2YE4JK5imKgtktWbXOZp9dcs44KaKIDmQt5g1qNJC8y1JxaquNAmmiPFz7kKIIVeGCcao1T+GsuqZdRqEAYnCpWojmkcceNSmRWB/jOA9swwbbsZXhO9Ts7UGiu1v8VharPFAXEPn5G4BT1osjbwM9iq5CULYYwqzNCAK3uPW9iEPtxzLiIbAxyu3W+262xDmp6KOCjZCt/GcWBQ3dybtiZbrG9+dlKfBfp1FE6YIluHVb8Z5wNU8LASkRrkKYcOAT6J/bjeMW7T+9aTRm54UfhdR71OZTNx+c8SQATEjFD5LdoSpJetbp5l8RJ0M2c2MfKKufhbvogkayQzJprHuRAdw6H+2Z57KstrYUttNWJWIMvbPNCzHQAqB+0+EhuIrcQMuEGlMXAPFoZl/E15u8ge6mI9LTcPjw8us3IjqfboWn5zWi168ZAFVvW9jWr7TPir22TWjR82/YtX8ueC8JTRfuOU9OBiHAw16o7MFSkLy0wJHX1YwOHX9BCtIMWSR/Hwu5fwGt2wmY=","authorEmailMD5":"37bd54aba6e837f9e5f46e37a434319a","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thank you very much Stephen for your quick response. It really helps.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"0093f78a-9b8a-35c9-bb24-b28defaab6d0","date":"2015-11-18T15:49:58Z","timestamp":1447861798},{"_id":"2a3da2a9-f564-3503-b281-0e3e5b71e56d","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Right now, AFAIK only ADO.NET and EF6 support asynchronous db access. Here's an article describing async EF6: [https://msdn.microsoft.com/en-us/data/jj819165.aspx](https://msdn.microsoft.com/en-us/data/jj819165.aspx)","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"2ef41a2b-164b-3249-b840-81d0f58bb621","date":"2015-11-23T13:18:32Z","timestamp":1448284712},{"_id":"2ef41a2b-164b-3249-b840-81d0f58bb621","authorName":"Ram","authorEmailEncrypted":"Hpm/+oGtuYoOfFxg/S72WpIXnInlyoiwhAbll6O6m5DFG4EunGEE8tsYWV28rgUe5ynWcexgqWJqxU/cM7NrUcng+0yq7cnV9irZUWa6Gz7IIRZ8wBP9aAvsabvCabjEzFbzqdWrVEHTAYM80bAhVVQBHdvtp+yE4qQocL99IsEiYnV9HxmMLkXP5NgyepJXpGjcGwoaBWsCHBNJjToaSYt5dnB5p4iO0zNtPwKWU1lBEDRk/XWGdcmBvFiXKhK++53xtaNWLvb2i8AQEBaxtcex5u97zW0htjL3XA1XVg2RQUJjN5tWnHEI74c/gtoRdBp7qZ4XurjFgBL6ya9rgNL7Ispb7COxRS+Tmz8vGTS1UtyOSh18JIwyp4xg5pI49xBYRWlRksSbzQ1dH0809M5zcfktB0CYACcNYPjUGaWTjuITo6fIudqHXpK/oE4WuMsEIEMmC+hNZceWkrn399zayteImxaW25scN0B4/uqfXVai0B7MbsdhR5ADA7ASVKgwqoXQMQcYIlpn7sKoDiNWv/SGm2SR0IkMJudFIWU8reI4JS9Iv3sW8EhcRHXoZjpNaMI8yHfLVZ4moHk6BQmvKotHQCfJk1hGyrAsyk0wJZWgOCCWmPlnE2oUSt3PlUqjwLpeDkRW+vPLHd19U27S/VPdb/e3bPzg/4Q47I0=","authorEmailMD5":"37bd54aba6e837f9e5f46e37a434319a","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen,  \r\nI was trying to find examples of asynchronous db access in .net. I could only see some examples for datareader..but nothing else. Some of the examples involved are just wrappers to the sync code...so I am confused if asynchronous db access in .net is available and used in real world?...Is there any posts/documents that you can point me to?  \r\nThanks in advance,  \r\nRam","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"0093f78a-9b8a-35c9-bb24-b28defaab6d0","date":"2015-11-23T05:11:40Z","timestamp":1448255500},{"_id":"1a01b816-d0ec-349c-8153-33ce820037a9","authorName":"ck01","authorEmailEncrypted":"HNWHFCMxz/J0WrEy8KZ/f9PvYXcRuWl1seLpKLKZoBEv6HbZhNjmcL+yYgEDcrGw9tn/NMvQVf7Il/xREQ/lMOAqZXj9bv1u9Hp+tO0OTIga9eaZwGOG2PNWGlkfGczMzUS+JinP85vVxV5Av7UcaRDUSyMYgqmhPP3a7F5AMBg6uaa9jSBO8g6/+oZXOFbfjrq7Da/hfeXKgUVFp/nI6ZhucvKEWH1AKNlA534vATCuNVPgNO5d3LsUGXDbc0fRdLG2AbtxgXdA46RzARJ/ys7qv6q57+4aLmWM5CVwNHifkooAYR7DirBHlV2ICllA8gWvOUVWl8aTFioeoovfdpHqpU+kIbZs5XceOAskvdZvo1GwO9c4IaY6rycD0f84ALvhPUP9CaF1NR19NHvLISo0b/PYi+J8idO0p0P6+P4PlNGPtmLMpUiujOdfS5duFJLFmwpGxdbD7j+xMt+gDzD+R+0kGqgzwEGQOXTU7Wtf4O9vDv/Adp6V/SkMMl9uTdRafYJKU7CYRqDxS7YZ1sOEssgkUx5nKDRENMuRhjGl4JopxQEJdv40GxappYM1TsjrgetQnHCy6D//zNuOzSUrFTILb+qhdsfXpSnOUJevEq1cEgKOJq6G2Nh9v207hOR+qdqyuzhlJAdWYWAYFmhP2O65Pt7ml8zytE3yVVM=","authorEmailMD5":"bdfdca854bd0bb38f89332d96a22d459","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen. How to avoid context in IAsyncOperation?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2015-12-16T18:33:08Z","timestamp":1450290788},{"_id":"ca1b0c94-0748-3eb4-b09b-8971f73858ba","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"You can use AsTask:\r\n\r\nawait asyncOperation.AsTask().ConfigureAwait(false);\r\n\r\n[https://msdn.microsoft.com/en-us/library/system.windowsruntimesystemextensions.astask(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.windowsruntimesystemextensions.astask(v=vs.110).aspx)","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"1a01b816-d0ec-349c-8153-33ce820037a9","date":"2015-12-16T20:41:21Z","timestamp":1450298481},{"_id":"ac028f59-759a-371c-9ef0-4fe7fb7a2824","authorName":"ck01","authorEmailEncrypted":"U3ioDVeV9hLDlX7YXZts/Di10nh2P8R6zibMalCHiJl0PVYk8DX7BLv4nwMI5c4lJzq94Y+e/ePKmzxRdeBXMk6FZ5JSvfH0vTFh/0iyJZBPB1SEq9FulqkWzFlD326J77FeWeoW8psQhMBtfy0ZHdHpb0JDbT0rWuJmrVJCmUcFDXJKfLeFAtzIRBLTwvKEH4z66tjLbEFQOz+3W2tV2Li7Pm3Im+IIEyQXpjgGLN3pzRqq0NMRG9ZRzEa9URdTE+NVbRzdVBpcgpO/Ugd4ttYXzgrIw7QD98a/5RvAxIYs3RkDX+G3cNkPyddkrrEfO0Z3W92iwamlP7ZUvcXebxdIIw347vhB7JDUwrxV7mq3IjleDbErJJUSBgbsRn0qzJWqOjyIS1KOdbAgrx4V7zlArippyQ4i366YUgVzVvGXETyC0yDVtDmoB3pMep61spLGG/OzrceibdUlfg3MimxwqAGkqEjYRfiYi8IPRIx4iIBGXZraYDwbQrA8mQ2jnuxo9UZjCqvuTzaxprzbGJtTbnlprMh/ECfYdu5LK1qRymohajg9LXMXEv7mkmhYItZqLTCGxzXAGZa7Wtm6DYh56QBx5dXh+EBo3ogSkNthoOevXiwh3S6LQyiWlnEmIZHuAVoGLO8ITzp/CyptNaXUN/3DUrXvo67gztNFH9o=","authorEmailMD5":"bdfdca854bd0bb38f89332d96a22d459","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thank you very much, Stephen :)","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"ca1b0c94-0748-3eb4-b09b-8971f73858ba","date":"2015-12-17T05:03:28Z","timestamp":1450328608},{"_id":"a842cfa0-acd3-3082-a9a5-21d1ae405bd4","authorName":"Jim Balter","authorEmailEncrypted":"H9GT8C3xm4eUrQLGujwFJ7n9/NyPro5dUuoDKAEv/8UBR/C64+gbz1RG2qfJkhrZiwga3n3GqqqDNW9MuJWHx1+zQs96JZt/cNkgPuQrCW/X9SqNa8hGRE2oZvABMvFzwwqLjIXl8d/mEy1KJpE9oJQ0hLlwi31r8Os4bpsqS1AWk0ctnUhPx+IX/GYYZNm1I8B6xjjmJYjGCSERMA15wH3hoT8uEoLqm+wJsBeGsklA14czfOcp3F6NZ7Qb2ViBWV7tise0bi2qj2g8Xm+T+MswnqMkFB7h35Sk46oPLwO/T0NTY3NN70TISo6MUlsjAUplvpvYojuCAn3bJS8aIRWLK7Ie6u8RsTsMjwmLcNr2mI0adisxnAQi1cFBf4hNtsDPwTV/JH/zLaRmiBaKiKl9ZqMp6v8sYqu+E76+FhvuTBb1CpxOW6j8D/Vo2MV9WMLZCdW6r3ZbTIClPOLq48Wr6icKQnTm+PNfxgNBrNkYVBQ64Et4brLgKxF0QLt2e0aqii2foQSyMxK3kWel7u8r4yuADFlMpdSo2bBHvFz3Nkv/BE+fknaGC/ao3ahin9ha+JDfMSNNP1HlWYRcAVKB/nhK57nh42JTcFYR7Er6XC749wXfeP3aWQFbrbCqA2OS7xt+MDuFtT881ppvKroIem049trWwFFSkfyAMQ4=","authorEmailMD5":"ad1df76ef4fab96ec67b2afa080b3a0c","authorUri":"https://www.facebook.com/app_scoped_user_id/YXNpZADpBWEYwdm1Od2h4SjlJeThCVWY3OHIyTzc5N2pwek0yM0t1RUhQb2x3VFJqN01iM1hjZAnpVRlpHSmRwMFRMSldKMGtYRHQ5SFA1OUFhNWFueDRSb1dYNDBqTlV2b2VpZA2ZAZAbERY/","authorUserId":"disqus:facebook-1026609730","authorFallbackAvatar":"https://disqus.com/api/users/avatars/facebook-1026609730.jpg","message":"It would be nice if you would provide examples of consumption of the TResult returned by async methods. Somebody needs that 42, and they're going to have to wait to get it.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2015-12-30T22:54:08Z","timestamp":1451516048},{"_id":"da4d74a4-39d9-3189-9bdd-b390c91081cf","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"No, ideally it's \"async all the way\". There are rare situations (e.g., Console applications) where you do wait, but the vast majority of the time (e.g., UI apps, ASP.NET apps, unit tests) no blocking is necessary (or desirable).","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"a842cfa0-acd3-3082-a9a5-21d1ae405bd4","date":"2015-12-31T02:24:45Z","timestamp":1451528685},{"_id":"1dab57e2-2387-36d7-931d-2292dac391fe","authorName":"Jim Balter","authorEmailEncrypted":"hN8re8szv0kx1RydJOAZySBE9ROnU+lf8HkcMnh1JLH/Qv9pxCCFLImL3epfdn7ZMsYTXs7TCRDSmLIYtgizULJEJRGGuX9IHyPvWCVNwy4REx+LdW1TQbdVuSXnpwPEJyMMiKjP4pQM+d5RV+weAkT0Em2ntdUWGAUU50p91kTwiPdXDz7oOKmVHDn/dtRf/QvZPsMnGyRslNo2404It427sQC1qDKxEEcYQPZBrncTd9hkKe4n/5RnP6oKeyiiEHmw4tloN1AjHjtDdUTBItBKEN/Mr6k+o7fY8N71Zl2kiK32GGbCA8EHmeqQWwuBYMXtRdmoc91rVfEvORmg/Q0OmD68gudkDcVwRpmFXSoQkBda8kEJ0XBeW2+xAkCis8QzcE4mF2HLbRdntnkt2dKkym4NMjBU3fPTG57qi6QwTmNUAtXEZ9rVX2xiCVO35EvDNyeSnuS/l0Sle9eNrm+iNvzyCWI0BTKdlPJLtXhzOWLXzw3rfkvtgoT0M8rFjZi+0o7qF+kPSgcFK4LfbGZsYMPaeYlSaZcIccg84TGVgRAJz3j8oq9bV43iylsUbXXyffDknZgXnHRPvDClMugC+aT9ZzBImMkqlAIIFa7n87bJ+zqlPR2JwtZlbfJ0FoERaV0lC6KMpoCNIOIp3Vzt/OlVhMx11c7Od1qb7I8=","authorEmailMD5":"ad1df76ef4fab96ec67b2afa080b3a0c","authorUri":"https://www.facebook.com/app_scoped_user_id/YXNpZADpBWEYwdm1Od2h4SjlJeThCVWY3OHIyTzc5N2pwek0yM0t1RUhQb2x3VFJqN01iM1hjZAnpVRlpHSmRwMFRMSldKMGtYRHQ5SFA1OUFhNWFueDRSb1dYNDBqTlV2b2VpZA2ZAZAbERY/","authorUserId":"disqus:facebook-1026609730","authorFallbackAvatar":"https://disqus.com/api/users/avatars/facebook-1026609730.jpg","message":"Eh? My statement, \"they're going to have to wait to get it\", where \"it\" is a value produced by Task<tresult> as opposed to plain Task, is a logical necessity. You don't even mention that await has the type TResult in that case.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"da4d74a4-39d9-3189-9bdd-b390c91081cf","date":"2016-01-04T05:15:48Z","timestamp":1451884548},{"_id":"286a2cbc-a09d-3f42-b932-81ad273cfa66","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I was interpreting \"wait\" in your original comment as a blocking wait.\r\n\r\nIf you mean a logical wait, then the consuming code would use \"await\". You're right, I don't cover that in this article.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"1dab57e2-2387-36d7-931d-2292dac391fe","date":"2016-01-04T11:56:41Z","timestamp":1451908601},{"_id":"a0d23563-e0e6-3621-a2fc-91378d00306f","authorName":"Tim Rotella","authorEmailEncrypted":"HB8lcN5RuZRx9Dis3UMhKFICe5TMsf3TC6ELPvUxg3QotUwX+FYeYxyElSDNb2svAfx/t+l8cP0wyQq1UOi0mu91+lQ8RKW9eeB6k+CeNYJDJvTk14qucAWXAT6GNQWje5z+ZmMcO+WN24iHLJWF7ZvGncYpX6mt09zrmu9bSLOnOBROP/jXE413AnHRcKIS/kj3IuNeG0oqN6jUycciO8n4033KWbcL5rVdnoPw0En2jXdSkIX6JjfiIxX6ZdoyvXvdFFJymL8WCoRUkwx8CSFlMNJu/MCjfSIoZq8tNW0H2l9uuCii81zH6YPL9+kLkpwqjf5HHVr9TePOICIRtKBOCbi9mkq5W0Hz44nnZlODZk6O4XjWiUj/5bF0u5PYGOc8MhZv+00DsBfKjjqgHJWTDP+91uayLagUy1K8j50oKtncv6a6AuWzzKmplKE2NfLgySjh5HIHirSSglC11hZPa3/VEJQbCW6xeGV5YxSLKeHsJC/hna4rCZ4pI7uybzyIbhXVm1cTUGxO7o6bLuxxfU9j2Z1JZ8dRahRCbpjqXSY4mTmuNfWVH3z9/tsHMf2cyIGg8T/Q5+vzBrtCcNcobI0As6yM9nQlUuY2/nHPXwNUWT12V0PccpzCfMGZgRxNuPeyQK38X+n2NCvbh4YOWCYkGWHHeEXQ/hsvVhE=","authorEmailMD5":"5a0ba31ba2cf6d6283d996bc60996e22","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"**Good","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"cb44c750-2e0e-37b7-8bbf-837b117cf97a","date":"2016-01-14T22:10:24Z","timestamp":1452809424},{"_id":"cb44c750-2e0e-37b7-8bbf-837b117cf97a","authorName":"Tim Rotella","authorEmailEncrypted":"MXZ+QM9rkPMX6Z7L1QA0uaC1ClRUx4T/DIy4pwS3Tv7x/TDfjalx2FmhMIWT3FWMfnlke4BQBF2zJ9Hr+SuVoFiRlvPxvYud0azcGftFPyUz437VZe2uLslNdQw5pq3G8nnl3R4dXO9YEj11o+L6UU+XFxl44xFNt04ujlQU+/Eh2AUKtDXrkiOWa0W6v/rch2njVbH2ngPY1hUQD7MmDWOJhxMsTQQApn/30ASaBkrqXdqVFNRxkUAK7YAb5MgXxmqHEZ6ozKbN8jzUsGS1BxfDxP62zZ/flVAKdAMxbJFo3c8Fdk6lJ1cJ3VPPFKfVCEZGH8x3mWPouv2OfD1Eq9C6stmtylu2WOIVLaWzCYnc+E/IcIIHioWK+6dmOvtk3mwQfQPRiBdZ7C1w1lwGdpK9kgtCasGpnf7uGqPjS4dmT0MtMlDATtR6oeA2daiA4yZ8uANUX1Lf/kSCv9HDsRX/VZIKHpAZAzkgoZfktHNQ94GjZD+TaSR3nZc2Nu/JnJKGC8GTFQlLXh3iR9nEu3PMiuHoRYbSRW1kvLP0MDSXFMj9QKU5M+64MjQauXLjpNFILKiXvHSZ+9z15uZJzwFqHhYtPywzXwon2eN/Egu7uA6futZqptGPso9tfPpzupUFx9iXujyjQ4afz0huSizT8jVYOGy9REH80zx7Rec=","authorEmailMD5":"5a0ba31ba2cf6d6283d996bc60996e22","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Goot introduction","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2016-01-14T22:09:51Z","timestamp":1452809391},{"_id":"0733f58a-5e03-3175-bbe2-928e2d80fcc3","authorName":"hesido","authorEmailEncrypted":"G8ZbNowsH0WAY5EaR+fpRO6DuZawlG0+mY/YFJh1QHzW3nUZ846ueWQECRm21HA1jxMaHGQIAlhewQDqZSXthso9E3RmDoaYErw/MTXxUcYwgvVqBb1kvrgJ7D/ieMesGj+wIli3/wL5ngRBeK+sFerIzSeS80sNeXHiIKqgQq8VBlntV9kWhgVLvQDJUvAkCVnVOQWCJxdD5WE60zWFePgOO8pVc9Mvm30c5xduyAsHGI1OZ6x+3gHsvCgobJKQqepduTBA9TMQKvWgVxUAgn5p0dFJGuWe7reb45EuteFtqT/jHkmFfKQE3K48Zn71hA5lgMe1SqQ4EQiS5zjAhJVwjrZYWaVF3YLPSKwi/Bu9Iz4UReJSh+Wzviih2qu4YGHkd3nHapCeUv2ribxxrouRUuvGOi50W/sPsY+3xi58oAdl1Xj4JndcEZ9i1Peo/Gc+Aae2NE051JzgMh1Pw6kdb3LSl0xMYbBOCDvyP39DRf+szgtjubaAFhNCx0+BGHMFpqW6njhO79vTaT9aaHvu4grrePLe4PO+dm8eYP7zTm7R9vOO2K2pCpCqjkili9Iw+oAwRvK94la3U6tzB+T8lhIxlXwpeKEcj2rgRhX1WoYZ4ws4gzHv6+ywiezGnoif+4erpbahjRmz7auDUDV5nWnDXftF67Dg3Ur0NGo=","authorEmailMD5":"a6b2904e7b0a050b956a3ec9b91580e9","authorUri":"http://www.hesido.com/","authorUserId":"disqus:hesido","authorFallbackAvatar":"https://disqus.com/api/users/avatars/hesido.jpg","message":"Excellent! I'm wondering if async methods provided by .Net have adequate cancellation mechanisms, e.g., if I cancel an SQL async query, does the method notify server of the cancellation? Or do you also need to take special care of those situations?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2016-01-18T11:49:59Z","timestamp":1453117799},{"_id":"eba819c8-867c-38d6-9acf-7ef976017d69","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Unfortunately, cancellation support is a bit of a mix. If cancellation is supported, the API will take a CancellationToken. Otherwise, you'll have to work out your own.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"0733f58a-5e03-3175-bbe2-928e2d80fcc3","date":"2016-01-19T14:40:49Z","timestamp":1453214449},{"_id":"aea9ffe6-b283-345c-8ca1-fdbe71b66a37","authorName":"hesido","authorEmailEncrypted":"BwNwxdg2MfcKIu3T43SbYt1K5BFOS/ram/11lT6cnw5ObdnpWDA7I3iN09z5f2uWM+gTyDxgjg8yVDn5d6eL+0510Zu8++E49weYiGr8p5JK20sdCAlOqRQSzIRubUWfO6upF9HgnsZOS4l6E2xLCj2p731uGaI0KsrLvPZxOzrn48OjkTEblcRmBZjzmAJ8pvwRQxG60YJzeeVtkd4G+4alBlW1a0tjl2BjAlqhvJNLFkgcYDFQfKNRYGcb/whl6MH5B4MQF+XGPFW0/x0E5q6vpNJD4WaVQ28O0bjk+xjDTKoZsA4hzBnwlB9ar90Uu1F+iTjS2ooOlsZ192Ob6WQuw+Y4EFwyuTzsMYEO74FFvXxa+spvIzxcavCYdbX9fFOd/h84zpY3zxexalQzybX8r8mXeTbKfnXsryJdkMk5oHBBTbDEcsD23I9nrZ4FDk3HFunRD8UeOGgIYTM9zb8XPWirMG2gG2xkU/gu7mIbaV53vfKxZxjZ2RapqBHhpWViCAOcLb/4j+rd+afsfKMkPTd8mOagnGCxPjm3qdcJ/0W8HJ1QisdJEBGuHF/S/UWoYH4mQ1CK/QrIvtS5bKHdFQ1jgSC8AjpsRIjHReomJykghcoX8G5qhijukHx9R7AnW5CUKS9FOMejsCz5FGiAZYsEe7aN/lb6NiIl2Xo=","authorEmailMD5":"a6b2904e7b0a050b956a3ec9b91580e9","authorUri":"http://www.hesido.com/","authorUserId":"disqus:hesido","authorFallbackAvatar":"https://disqus.com/api/users/avatars/hesido.jpg","message":"Thanks for the answer, so if the method supports a cancellation token, I can assume it can be cancelled gracefully (like out of a very long SQL query, so the server stops activity after the cancellation, not just the client), this is what I understand.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"eba819c8-867c-38d6-9acf-7ef976017d69","date":"2016-01-21T12:06:53Z","timestamp":1453378013},{"_id":"b48d7c05-c370-3f63-98d2-a27c21da80ec","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, that's generally true. There may be exceptions[1], but in general the .NET APIs will only take a CancellationToken if they actually observe it properly.\r\n\r\n[1] For example, if an interface / base class defines a signature with a CancellationToken, but the implementation cannot cancel.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"aea9ffe6-b283-345c-8ca1-fdbe71b66a37","date":"2016-01-22T05:00:57Z","timestamp":1453438857},{"_id":"d22551b9-3438-374b-99ec-cbfee6d96be5","authorName":"Ehsan Sajjad","authorEmailEncrypted":"Mhqe2jW1s32HQFJFwDOMpXy2RclVBWA1VD1RBXbhPpfi64WZcYXaGBCJfYV5D//VfyoycYw5+lIfPE1ZbDyF/PgLzW4kD78bfdTNlTnaEL1otVUHeYo302YCUvfBwAsoMbDbUUryXJ2uEVPZ2zKK1zLBObu4L3qxW8w05AhkpFULuGQ/zZAsS4ALX6MGk+QZXgdr/VrSzp6aYESk6lpsK1dkwJIeUcx3HyZTgR7iE70NsFnTHjvXA/6NCzwznQPqqpvBfZpgB+4Prm4v3PjSs/hIfh47nw4rvLHj0/14GZ2dV/HK4/7lCwrHWdbTTjG3FEr5LeFxN2MIgbhLywruVrKlf1dziVzfi9y9eiNvid4oqFZF8A0bfBg+FW1RLTOVi9NMpUkKPIZ8uttU8XpCUEFiV+nZHrucULI4eRnM9qPZbebEmjEj0wOR3D9xA5n6GLjqnX7nonXh9JOsH/UxJmTwaHhN+FNd/9oQkFkI7FXQl8VzNEGtUjBplIarssuQmD8UpDJkiu/UASDQOwXCL/DWDIhlFKHHhP74X3Koi+p5a01AUpY2cDgZk1pCb/9i7vxJye5JZTvU/QQa29uxysG+rrohsvlBRZ4jaMzIyx9D50mzsuIVabgGU5+uuxE12ajlyY+UkWtsX8XK+OS//RmI9QmTd9B+Xp6kfVBKXbw=","authorEmailMD5":"daacb17064e6d03ddd19ae1930bec563","authorUri":"","authorUserId":"disqus:ehsan_sajjad","authorFallbackAvatar":"","message":"Thanks for the nice description, it would be nice if you provide sample solution containing all examples that would be highly appreicated. :)","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2016-02-09T18:23:32Z","timestamp":1455042212},{"_id":"8100da19-a12f-3758-b565-07f7bcf7a3cd","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"There's a lot of discussion on whether MS made the right choice to have the context captured by default. I do think it would be better if they didn't, but I have to admit that capturing the context by default does make for better demos.\r\n\r\nYou would need the same context if code later in that method needs it. A common example is UI objects in a client app: if the \"await\" is, say, retrieving some HTTP resource, and then later that method updates a label or textbox with those results, then that method would need its context because it's accessing UI objects. A less common example is on the server side, where an ASP.NET method has to write to the output stream or do some formatting in the user's current culture (which is part of the ASP.NET context).\r\n\r\nGenerally, you can avoid context capture until your code breaks, and then you know you need it. :)","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"c28cc35d-4dac-35ce-866a-00c51bb9cb82","date":"2016-03-01T13:04:13Z","timestamp":1456837453},{"_id":"c28cc35d-4dac-35ce-866a-00c51bb9cb82","authorName":"vetiarvi","authorEmailEncrypted":"aEYD49YZNMSalJCaMEHZtL5Olv91udt8h19s8ghnq3JEzMrqle+vgY82Do6AgUWfX2O1dXYINhZhAaFULgYWLP7EgPydqs9RgCwfaRZhqu1wZXwAPPlzGpZIJFxHKb8B4lJBo3wajF5+gSS97OZ6HaXY/eOtPY256vpQ4w/TtAwVBgphVuz8KNUrD9QzuoaUHd79Y1g5g7Kei0S7ZKuwtSY0xm/Bhes7N3kUIQkDbvqcXekY4cfyhZYIqvQx47DLc6fgk09M/e2g/cYPbryMEGYN+WbNoytCGNcs6flNxDdZQq0zWIT5T7y5oCRWh9VgnZux2Y3OcXmT9aB59KaQ/Jd4WjyRptRcIX+w6Jj9VkoLSDdW7EGEBflvNxbw/vDJCnpD2s6km0TtS/W7Ye7aW9MGbSRJqUboetqnUcnNjjyg7o2sI8CEw2/WGKwkKZjKs23xunbKytQ8lmAsDP6DeoHg1l1r4tOgHFuJMGCYAStVPvZSyaxiOwUzHMoPAYp9B3x1krslgQK+5Ct/adaYE/DcsJZPbXmxxOW/94O7msxRpgoSvvexY2ofDzNaOF9mga3riHNNPoF5nQr1wpljCKkz1BzRPP/R7UUdLHVzSCNdh7Hnj/QxiVcm+gjczXHbKss5hJCc51Yb5DJvl8Zc8Ais1G4d7IP6NW84pzo4jy0=","authorEmailMD5":"7b6460d94795ae02211b102b0dfe5355","authorUri":"","authorUserId":"disqus:vetiarvi","authorFallbackAvatar":"https://disqus.com/api/users/avatars/vetiarvi.jpg","message":"Thank you so much for this. I've read so many articles and a bunch of books covering this topic, but the none made the lightbulb burn as brightly as it did in this one. You have a knack of distilling the essence of complex topics. So, please do write more.\r\n\r\nThe only thing I'm a bit hazy about is...when do you need to continue on the same context? Could someone point out a real world example? (i get the part where you don't need to use the same context to prevent deadlocks, so why isn't not continuing in a context given as a default by Microsoft?)","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2016-03-01T07:12:33Z","timestamp":1456816353},{"_id":"e54a44b1-a8d2-3e52-8493-a60bc13de4a4","authorName":"Tyler Zuver","authorEmailEncrypted":"Tg1H13sLa6Py5kQ8kC9u4K2U3Boug5Lzs8WZHtUbdaOp9Ogty5YDsHW5nRQXZL1eMW27fGz3tskO6A5D4gb7DCdyMFuI4OnbqMkA6QvsK8xdIxo0EJE2+ZND4SvAZ/TnrkALs7Z8M3tujhEA+exm0HfwzGuDQQMtbma54IutqFqKGnlH4M/ON05s8FwqK62OiBtFYfzRUcf2ge1FL5QBKF9oHCDJQI3AyZD42UuvwRd1BfagJaWy6LJCMiZ9B4cyJilOpZGumAOxyLMHC1ySDNAjTBte+SLiO8Sy2U4OdYROR2hqPKCq5L1j/7Eklgoe1NrNHezrpdhAjkw4JzcigVNjqKoKws+tB+0JgxZMSZ8958jFQe9Axda4DepgbQfJVE+q7p8vLhiDbd+2gXW6oBcx6DkFST7jfKnduHSKvjdZSCdRlrEgf84Hy6xThl1vT1jCONVlXWJ6rrxGnIwO0Ul2fQd07WTNJAbQPClFl4A2aEwVtyr3tX6X2Q0Rwo9Aiq54KTC4oxZLsq5gJvyNaxjd3DfTPi9wNUCPfX/ZafQiUwVCwAopiISSPmbCre0Bfm5FJBgKyZf65KC7eKtPS5I082z5EPW3YZiDJlzEYsVlXtQb21RTXtbcBQOG6tjEE6QDD2r1Xeti2Nba268ebvnD3gjqcFjMo880fSXAAAU=","authorEmailMD5":"e117dfae69ea7f32fcd04874292f4909","authorUri":"","authorUserId":"disqus:disqus_RDEzRXUkKc","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_RDEzRXUkKc.jpg","message":"Thanks a lot for this!","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2016-03-02T16:26:17Z","timestamp":1456935977},{"_id":"806d53d3-b62b-3537-8103-7d5bd3be7737","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"For I/O-based operations (such as database queries), there is no thread: [http://blog.stephencleary.com/2013/11/there-is-no-thread.html](http://blog.stephencleary.com/2013/11/there-is-no-thread.html)","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"c332cee3-4520-3499-bc52-3754e8ba0761","date":"2016-03-15T17:50:07Z","timestamp":1458064207},{"_id":"c332cee3-4520-3499-bc52-3754e8ba0761","authorName":"Oleksandr Ekzarov","authorEmailEncrypted":"dZwWzGaFYFvhbqJDdprtMFJdwV0mACOPtI3JFNgyPppvMunSf6OvorZOCR/ENUvUtfXHZwjOFdpQ8Y3VrLOc/IuhX1JpHkDiHBVsuFhsn5fax5ClWTWfVMJkEJssHnHMCxhiPEiuJg4DDLbYr9Ti3mOe55+dgnA/y8G72wKcg3kD5Gt60my50jJh6ZSHl02q4p7BL9iBXdXVxNTO0hf9ECIN+p3hMS3BdsllK3kSjGvWxWbVi+Q8eraln3Sw7ceZoCtQkv8QruH4lg38WZjyKPEggGJbGwZ/H+x/nlDUXtX8CLVQt7T0x69ZwO077c5TrT4B/VQsr7wpLV9sc9yVP0ayDjlxBbaa9ByhGPp5KVMD5Ugzs1PIgVXmJWz9volt9/OC6daCkRMCQ4NJkL0JNcbBfZOUgKIjEQSXJDznJQVa+NMgFgz9ANTFkUADYX/CW9X7lQu16NGYCimo/u+pxu4jozeQelMTej4GOVJz9RmObfSATPh82eUXcOCyhpWp0+FwBzBAw8wh0kiYGYqDBHzly2pRMaoPz5EHZp4pMn3UAnsT0WeVRFlmqBaexXQ0mWlXrOywKRVXq/kxAFau6ryi8bKkRX+9YbS29iPjS80vcwDvxjeHwWQW81CXitX+Wo3RXxiLhVdGbIXKvvhOnHehm+5Arw1dwYSNX/60q0g=","authorEmailMD5":"18cd2a6663b6a81d3074260cccc8c9f1","authorUri":"","authorUserId":"disqus:oleksandrekzarov","authorFallbackAvatar":"","message":"Very usefull article Stephen! I have one question for me is not so obvious.\r\n\r\nHere is an example (In Web Api async controller I have asyn action):\r\n\r\n.......  \r\npublic async MyController: ApiController {  \r\n ...async Task GetInfo()  \r\n {  \r\n await from e in DbContext.Entities select e.ToListAsync();  \r\n }  \r\n}  \r\n......\r\n\r\nSo, we have SyncContext which is request context, which in turns is separate thread(T1) from thread pool, which  \r\nactually handles this request. Then we make call to DB (by calling awaiter), which makes free our thread(T1),  \r\nand returns it to ThreadPool (so it become available for other ASP requests). But which thread executes awaiter itself in this case?\r\n\r\nFor me it seems, that we just release one thread and hold another one (for awaiter), but in this case we are loosing time  \r\non marshaling contextes. So WHO executes awaiter in this case? And what advantage of using this in this case you see? Or maybe advice me some tutorial about this.\r\n\r\nThank you!","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2016-03-15T14:18:19Z","timestamp":1458051499},{"_id":"bb9d8649-daa5-3268-ba85-f9b8542b3a54","authorName":"Chet Cromer","authorEmailEncrypted":"QTS0lAHN3anNfDoRaai9vyuGJgUdxQm4es/lQtiafzJRQzPqeeGZPgDZb+o1DmOJQ029RyeG5hC3sTU9gbA1KiAGO7vlCGkyOVHcjuGNSY2RkMPl2kabY4k1jCsohxhKTFq3j6dUNZAk0c9Yq5xsb/ANJHTafgdrlc7MfIUBEr2nWuim5IX4nCs1Hj0Vj1ojHEB5rFXtBixlL5x61lr4vVUbwKH1REzlf44X51dbR/e+MZz43ovnpWWUbxCt5WZ+pjFI023GtyHSZprhaUfD5HrBrxGfEriptaf1mckFDqbN4uvadlfBJgKPfHRehCtiJXRhbkB2lQqrJURT1y6+qC0EU+JczppSxfuu+2BnvHMP1zdhmHDUcYgOTb/YTw9gJEL9XiyUPFOYVc03L03s24emIWFZxk53Ds1H+/r3tPDfgASEWL8n2CoUD/pFWAkTs6TtRrqTR5Nucc7vpgj2+MoLFdKjdFr/CEy1qw2hfmsKOmn7vrxKYWToH2GOpEq6kMI7tvmmAH+nxQYUMTAdo2hPEDDxkWMtYn2JVAMfu8wEFM2VQo6eEBEuNZXAnUgsS1XCqX4m+hMwCBTbkMpu36AaeyQWCZ+6rk5IQZwFHQwXPV6fCtPTycLDLtXDCQNyKHx0kDl/F+ip68+kQuQbF+oVeQystFpnutWigILYlfA=","authorEmailMD5":"5d7e5c153437efaf016e8d1b290ced8a","authorUri":"http://www.protegatext.com/free","authorUserId":"disqus:chetcromer","authorFallbackAvatar":"https://disqus.com/api/users/avatars/chetcromer.jpg","message":"Excellent article. I'm just now getting my first chance to really dig into C# and use async/await is a HUGE thing, especially in the Xamarin-based mobile apps we're building that are heavily UI-thread and Web-API dependent.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2016-03-24T16:51:19Z","timestamp":1458838279},{"_id":"17b4f153-f0d7-3823-9101-74dcb77c7de0","authorName":"michael lang","authorEmailEncrypted":"X8YrdRmfokDZigGSfI8OvC8LotyBd+pEjqcg/JyjFSLl+7iApufpRW7LR6Wl6swMvvakGEh2nFRIUXD4krlq4PBctZLuT4l+7AQpVN8t5LHhyGCEGjQ3hqGge5w0yH+WUqE4qU7bf4Brn+rkriSGL5LrimAEc8igA/drk87o9nHcscREyr1U2+rc8Czeq0Wu7M7WloBr1Y0wRTAF9x3bny5T0k6Wq6sL3hrnV9lL2lGCgZkBt7AkFt9InlMH879UB0G9U99Y5zLRNhPUZLqh+5NkNT7eiBYwDXR47PmDXrlm2P8YcSKqzzw2OGdbo4sqLfXiq10k/W3d1wmZ5hBDR76X95UW5ORDI1AncTXQn0YuO1Vw/77YLj9ScKEFpYFr+7t6YKFS8AgimA7n9iZfs/wgAqHJyYALFPDnXVkzb/IRIbYziiExmtUS899aS+JXRmD5xqEKTN+vz6+UTsiOL3t++pryIPKw7AkyfafFwtBcL1FuZ6Uh2YEnV02KLZzW/y2a16fsp6a7OcD1mtgocmAH34lgYoRe8SlIRLJ0lMcgiXzdl7ieUHD0oX9JSwUWNpE2stkPI6Yi2Bl+SA3BT+ddpRI8WcX6P+whd3QdSADLhp3bUkRxGxFu2asKqRFhFrBsCgTslb5hiD2Jn8p4MdKTZ/Q9HshLgkr74i5aeuY=","authorEmailMD5":"542706c32df308878a209ab0e13391b1","authorUri":"","authorUserId":"disqus:micklang","authorFallbackAvatar":"https://disqus.com/api/users/avatars/micklang.jpg","message":"So you're saying to people who are trying to use an async API from within an application that has not been developed from the ground up as Async that they have to use .ConfigureAwait(false) on every statement that uses await?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2016-03-30T00:41:55Z","timestamp":1459298515},{"_id":"88e2dedc-f0f7-3d06-9074-5e3fc1262312","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"No, I don't recommend that approach. If you block at any point, you lose all the benefits of asynchrony in the first place.\r\n\r\nI generally recommend making a single \"vertical slice\" to be async all the way, avoiding any async-over-sync or sync-over-async antipatterns. But sometimes it can be useful to have both sync and async versions of the same method during a transition period; see my article on Async Brownfield development: [https://msdn.microsoft.com/en-us/magazine/mt238404.aspx](https://msdn.microsoft.com/en-us/magazine/mt238404.aspx)","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"17b4f153-f0d7-3823-9101-74dcb77c7de0","date":"2016-03-30T01:15:17Z","timestamp":1459300517},{"_id":"128906c0-eeee-33be-b7e7-1105f49f6785","authorName":"Meenakshi","authorEmailEncrypted":"qGVsSFTl5btV/0giQMab4lhLpQjJ5M8dubUbVlCAlXVgxhc0Qg30PDXksEPw+6oyvzJaBPHpijf9nrs0p3Q8Yv+Q2lOtFCWrpOXFTAzjop7vFUpdLZxJ3CQcf+CLZCkzDhFFzIF/+/D9UCH7bfXjAwSQJHFvkTECyzaK4a8yf9OCzG5vTVcQ0LIKgUp37iN+CXhXXzmV7xeohaYSzK/plZKU/oavkbI+sTWZ0h7TCELcSUA55i/cS40r1DMYiT3xBJPdugLOSYEc/lwh3n8jz3mlrinLXFMAWH+ezhe/mlhRUj70u26Y7aXVg0qOnetwaJHCw/Zt+U9FAPeLbWY4b3jO9EOcUtnvDpLYRabB2PIlMIXa3Qe5CdEjatwT2dTvmKsmKz50kd2w7c1qn6dwUaktP7JY01wxZz8MSGSYvVJIwt/TD+tnL/CEFBUmVku6y7aJ6ZKXMk6CtzYYkJzzag4ROGALCTYKDrJR6Ltk6L1/e64kQxYTT2GyAiQ8MGzS76oSrCZor1TMPX5bv2D7KxP3cTK8RbXHbwwzIpnmM/fzWLRlfW8tA8KM15KjeQcCMZyu338/xgU9mjyYijdsHkfqiaveQPpMiV8B1FCI8+K/xJzD+Tm7iQak1PwgG5yP3gXpP1lVdUv3HgGkcZDCkUvxpxOE9L9n3Hw0T86vWqY=","authorEmailMD5":"7ca364875680bda6094e3f7559f5a0a1","authorUri":"","authorUserId":"disqus:disqus_cUvNht3muL","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_cUvNht3muL.jpg","message":"Way you explain things are very much clear for the new comers. Thanks a lot for your time.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2016-04-06T04:11:49Z","timestamp":1459915909},{"_id":"747a4dca-f5fa-3931-a4b2-31777b4f5c94","authorName":"Chiranjib Nandy","authorEmailEncrypted":"IefUt9EkhjNblgepAFxBk9awSzMP8Db3Vy50tvYJkU7QJ05DB4Wpt76M559Xu/9x66D5h17bgcsE3f01hkN5H6DhIA882opHwnUQTpkRYCMQcyaysXLyP+ZFYIzKAPqhWzeDecKtuW4Ct5cICqI6C/awQuAWNwxyTxdHLYADcezBAAaRp7VisBk3FsXgnWe+cjtCWo/wLd2vFOdDHXK54Aok98BqSj+SeRDIfETWnNBDBtnh4W/F3HgDcReeId42O3AsKWWfCx/Q+Yb1zIm7CgTqPi15YYHXxV8rRmln3o6/oXO/LUrBea7u30sADsRzpY0vJY8yDPx8G/W8WayweYHCTvzzup/BFHNBgio2YSvzQnKjOYEonxOruHoxukm2GOenRQIJXIxqH3rsoXpGIkvOsTmY+6RVdWiags+hsl3oytjCzqkxq3fB4DvNaUhzthd2Vvj0siqHZjaiHUn2VvBq9gBFri2SYrbZ9U94/7cL+ysI4+599bCdVuw72VgzAujcPe+Hhw3YCM6M4yyn//eyu93qsc0YXo2hgpMNcnqa+STlC/pBu1GX8pVjrwZsBEXEHM19vZ87+kLb/Ns5ICBdZgFRYpcJnqjilE2muNDNV7XL5qVa+lXyzy8XRAY60xaG0kQ/PH1piMaSBr5fmFvumc8VcnKQNSLk2rP+buo=","authorEmailMD5":"6fb9392412fb481f785a114073349699","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Excellent article Sir . I am just new to this world of asynchronous stuff. So had a few very basic question swirling in my head . Please bear with my lack of knowledge.   \r\n1) You have told \"It tells the awaitable to run the remainder of the method when it completes, and then returns from the async method.\" I did not get this part. So does it mean the method still keeps on running synchronously and waits till the awaitable returns and then proceeds with the rest of the method ?   \r\nIf not please explain then why [task.run](http://task.run) is needed to run a method in the background or in a fire and forget manner. I could still be achieved via await also right ? i.e. The method keeps on executing the rest of the statements without waiting for the await to return . I hope that is similar to a background run approach. Or is not it ? I am confused .\r\n\r\n2)If a method is marked with async and await and that in turn calls another method asynchronously in a separate layer that's also marked with async and await .. then how the the call of the first method that's marked with async and await from a separate method say name ABC should look like ? I do not want to annotate that method to be async/await. So\r\n\r\nTask.Run(() => DoWork()); from ABC () is fine without marking it async/await? Or is it against the principle of   \r\nof asynchrony ?  \r\nDoWork which is async/await needs to be called in the background in fire and forget approach .","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2016-04-13T17:09:02Z","timestamp":1460567342},{"_id":"a031d998-df5b-3a32-9676-56a93117f94a","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Answered on SO: [http://stackoverflow.com/questions/36606519/async-await-vs-task-run-in-c-sharp/36609935#36609935](http://stackoverflow.com/questions/36606519/async-await-vs-task-run-in-c-sharp/36609935#36609935)","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"747a4dca-f5fa-3931-a4b2-31777b4f5c94","date":"2016-04-13T21:31:05Z","timestamp":1460583065},{"_id":"08625892-1a4f-32d6-b4cd-d3eddc218c25","authorName":"Chiranjib Nandy","authorEmailEncrypted":"RidSTn5uNFHqRSJ2aAwjMdoWZuXTeNbpNDqTfB6NwdKfy5H4R5aAZxAk3nleJNZpekTzPm/axzrUIpEid/7QfIySvn6lJWCNlJTUrfynvk6B/bfnBip3xS9gklutF8YXWUQPV8jvCwag7J4QO8+GeLSjrGtjFHCE2B2LMmqnsH/NqnpWUctc+8KFF3vyokRnpGMkd0ojC52oDZPdLnSOv3TlzZNBfIV/ycQstAZi744CxFupKQVDkQyHYHyna08kdArDMfms//DaoWqyBQYscx/xDzrhadWDUwHjoS5wJxF34RBNaKWkIT6xDvCjcGL7PC8rRPquRF5C54mnQfvufeiuQEJpalpXdl0WBiStjTv2USud0bheWM3dinzRIVhZThJ89viHjcb2Sf3SE6vMQ45QrU7TmnVN6kBSGmxU8bVaetHqVjwq+yLRz/GVUp1nI5mZa/BTIJoWYZNtkYUsgHF5NklyOJFRyy3/nsExAuLpfyvlqUBJ8eNIUsEfAJ0XISZi1hv9w+n7GRfXQM58IpotU4tludrWeghZKM/1BGeIEiHViougNkwNg2tpJaslFB7W/k1+X6DCj0kwaedtz0+uFd+GN7zgPVCdenJ8oTshNmlOAOVznjAL51CSG3keo2a/aKxIRs+MSoDlyqx1OToSBBXTmV5gH91V0aWytCo=","authorEmailMD5":"6fb9392412fb481f785a114073349699","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thanks for the answer Sir. But again may I dare to ask ... you said \"If “await” sees that the awaitable has not completed, then it acts asynchronously. It tells the awaitable to run the remainder of the method when it completes, and then returns from the async method.\"... so suppose async Task<string> A(string name )  \r\n{  \r\n .......  \r\n var resultset = await rep.B(input1,input2);  \r\n return resultset;   \r\n}\r\n\r\nand B() alsi is marked with async/await .. so in this case method A() will execute till it finds await synchronously and when it finds await .. it will wait for B() to complete . Right ? So \"rerurns from the async method \" you said ? It returns to what ? And if there is nothing to execute after returning . in that context \"It is something synchronous execution only .. right ? Means\r\n\r\ninstead of var resultset = await rep.B(input1,input2);\r\n\r\nI could have written var resultset = rep.B(input1,input2); only . It also does not proceed untill B() is finished ? What am I missing ?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"a031d998-df5b-3a32-9676-56a93117f94a","date":"2016-04-14T07:12:45Z","timestamp":1460617965},{"_id":"76f9fd28-7776-3a62-a176-82bfdec62c60","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"From the perspective of A, the only important thing is that B returns a Task. It doesn't care whether B uses async/await or not.\r\n\r\nThe line  \r\nvar resultset = await rep.B(input1, input2);  \r\nis the same as  \r\nvar bTask = rep.B(input1, input2);  \r\nvar resultset = await bTask;\r\n\r\nIn other words, A calls B directly (synchronously). B will (presumably) return an incomplete task. A then awaits on that task, which causes A to return an incomplete task.\r\n\r\nNote that at this point both B and A have returned incomplete tasks, but they are not finished executing yet.\r\n\r\nWhen B completes, it will complete the task it previously returned to A. This will cause A to resume executing, and when it completes, it will complete the task it previously returned to its caller.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"08625892-1a4f-32d6-b4cd-d3eddc218c25","date":"2016-04-14T12:20:44Z","timestamp":1460636444},{"_id":"723b4504-cf7b-3202-ac9d-bbbf59185037","authorName":"Chiranjib Nandy","authorEmailEncrypted":"M3wQIzb2fsrKTCanZJHz8LUoqKsxZDn+lcWjm1uhLvo5cq8Z+PqFgdE5Xd0S2ZRNBs7mPEFtqrL+xinfeNffI4PPz0gznV4IxO6Kpps5HLUwMNmjrwqbgVekBiKVKYenDxaa9GWDs5HzBWyj6hT1bibjogYE4C9j89oftVTVyIf3BFh2HeMCfKqbHIphY+oakq4Jqj4ha9SrFdSRyfIhjL0nJXL14IdKQ5LHoPm/59ZcWNpE5CJZAEQmaDXCaiHwjnUO4eM0Ro2cBpiu1xz7zjxCAl6TQNjB9q7hKQ8FM5P/IpWprqzJvC033FBd/g9XfWhuYuziX2VvcUsS19V4JIPdh1qc7CgnVemt7NNUh2qFhcMHufpiXQkeo4h0oeegMfOUXle33TBhUE4d0ApC64Pk7gxjhUS515SsE+zjpn7NHupBtqgExJpvdSbgw1OiadobRB5VjIyrqG0VZ7aeWwKaHzilfCUONyn4yBjHZkrGt42KSG/fCWoj30LnGu6txRfaBj7SndimmZ2o75H4PpXNyw4XtxoVJX5V3cJhc/GxRb3tcCTTm1wO4AS1exWwdZXrAH+y27JBo82hDleOfhnkVYAcHqWyFfSOv5YRkTmCNoBV8a4i9ssmlDrBYhLib1vEAcVX/9hRtBfBJJn3z9/ypPAWEpI4oQo+ibCo6eM=","authorEmailMD5":"6fb9392412fb481f785a114073349699","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Okay got that . But now it is the problem I am talking about . Suppose in this simple example   \r\n static void Main(string[] args)  \r\n {\r\n\r\n Method();\r\n\r\n Console.WriteLine(\"Main Thread\");\r\n\r\n Console.ReadLine();\r\n\r\n }\r\n\r\n public async static void Method()\r\n\r\n {\r\n\r\n await Task.Run(new Action(LongTask));\r\n\r\n Console.WriteLine(\"New Thread\");\r\n\r\n }\r\n\r\n public static void LongTask()\r\n\r\n {\r\n\r\n Thread.Sleep(8000);\r\n\r\n Console.WriteLine(\"Long Task\");\r\n\r\n }\r\n\r\nThe main thread still continues and prints \"Main Thread\" after calling Method() and encountering an await for 8 seconds . So accordingly the Method() returns to the caller i.e. to the main function here once it encounters await , saves the synch context and keeps on executing from there . It prints \"Main Thread\" first . Then after 8 seconds complete , \"Long Task\" and then \"New Thread\" get printed.\r\n\r\nThis part I got . My question is in my application :\r\n\r\n public IList<createcaseoutput> createCase(CreateCaseInput CreateCaseInput,SaveCaseSearchInput SaveCaseSearchInput)\r\n\r\n {  \r\n.............  \r\n SQL.CaseSQL.getCreateCaseParameters(CreateCaseInput, out strSPQuery, out listParam);\r\n\r\n var AcctLst = rep.ExecuteStoredProcedure<createcaseoutput>(strSPQuery, listParam).ToList();\r\n\r\n if (!string.IsNullOrEmpty(AcctLst.ElementAt(0).o_case_seq.ToString()))\r\n\r\n {  \r\n await saveCaseSearch(SaveCaseSearchInput, AcctLst.ElementAt(0).o_case_seq);  \r\n}\r\n\r\nconsole.writeline(\"Async called\");  \r\n return AcctLst;\r\n\r\n }\r\n\r\n public async Task<ilist<savecasesearchoutput>> saveCaseSearch(SaveCaseSearchInput SaveCaseSearchInput,Int64? case_key)\r\n\r\n {  \r\n..........................  \r\n SQL.CaseSQL.getSaveCaseSearchParameters(SaveCaseSearchInput, case_key, out strSPQuery, out listParam);\r\n\r\n var AcctLst = await rep.ExecuteStoredProcedureAsync<entities.case.savecasesearchoutput>(strSPQuery, listParam);\r\n\r\n return AcctLst;  \r\n }\r\n\r\nHere also createCase is encountering await and it should return immediately right and execute the very next line itself and print \"Async called\" before even the SaveCaseSearch completes right ?\r\n\r\nOkay if I am thinking loud it might be \"control returns to the caller\" . So is it like if I wrap my call SavCaseSearch inside another async/await method named suppose   \r\nasync DoWork() {....  \r\n}\r\n\r\nand call this DoWork() from CreateCase() directly so then \"It will go on printing \"Async called\" once call to DoWork() encounters await and before it even completes ? Am I thinking in the correct way ?\r\n\r\nAlso sometimes I see and get confused between await someAsync() and await Task.Run(() => soemAsync()) .. what's the difference between them ? and which one to follow ?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"76f9fd28-7776-3a62-a176-82bfdec62c60","date":"2016-04-15T09:48:32Z","timestamp":1460713712},{"_id":"86c0befe-1985-3648-a69e-6c3fa0946d22","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I'm not able to follow the thread of reasoning here. For one thing, blog post comments are horrible at formatting code. If you have a specific question, I recommend you ask on Stack Overflow.\r\n\r\nRegarding `Task.Run`, you should only use it to offload blocking work from the UI thread onto the threadpool.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"723b4504-cf7b-3202-ac9d-bbbf59185037","date":"2016-04-15T16:57:38Z","timestamp":1460739458},{"_id":"ea86be6f-c04d-3214-ba5d-f98dd79e1b76","authorName":"Chiranjib Nandy","authorEmailEncrypted":"Lb2eceVSYiJ40VfHkztqbS2VYfP0oP4TYzcO5aD9Wfi85WEGJRAYQojZK9/AUFGuReL9xk2TDZmnSKscVtz6b0sF1nH0V9hz8fWRGSqlfIXCs4I3NiSFmKngDzPipqNNNOuS98AppgFwJy19rAWl6Z7x83O1MYzWQx+KUuVMQLDvAWTqw92VF0bdgUteOroxsMlMawQuyiiw+jZ5JxEDJlNrqz2oRkC4NBoUAI6NeVpSmEZJCxM8CFVaJFeZNAsFjx+r4pYWm802jzkRlg7ul7ol2aJav8+YUavyClfnq/poDhz0nWQs9DlWKrAnenscVrCD/LjJP+XL3cJoYx4Lt5uolsHma/vD2c+DHYfsYrWsL1V0g8gyWKlB6dn0nxY3oh8+tP3qGRP5xUD4/JJ/xU0cZw/JPK88JHfRemaGBl9BExybh+4TQzceBVYdKlOivPy5M7QxrQ0JSM4ORSS3lARcToMQL3KOAEuoeD5kM2lVk+XBuuWi0J2EtxXomJk2bQ6oRnJ7dJ7Fh+zDx/mNb4uAT8FyPzV6xLRJGvlKFuWqUUQALJpLhhIFxMaMKGqB/FeMAbsxsghqi1Y5au00XfK25S+I0N9k0QbSpJaZhfs0UjYUta6ZMNXEDacriYw+nTluGPOvKQ4I1QIrCJhhgYvvF6e5PkjmkQeSgpqcn7g=","authorEmailMD5":"6fb9392412fb481f785a114073349699","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Please check ..   \r\n[http://stackoverflow.com/questions/36653926/async-await-vs-task-run-when-to-use-how-to-use/36654521#36654521](http://stackoverflow.com/questions/36653926/async-await-vs-task-run-when-to-use-how-to-use/36654521#36654521)","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"86c0befe-1985-3648-a69e-6c3fa0946d22","date":"2016-04-15T19:15:45Z","timestamp":1460747745},{"_id":"f45ea317-5de6-32a6-97e9-287f2040d5a9","authorName":"Tedebus","authorEmailEncrypted":"csxu0d2OE8/T9JZZtHqfb0IPe4fS1zqR+b72wZxn00ixH2qGpdwoutJPC6G7hJtmqocZRqMM/bZ0L7ebGvVvyD2SKGcwJVtj7+mnUewPR7cv+ybLKOoTyT2LDRgbENeqdCOqGbTNR0NJuN8v/h7C5wVK5QCS5A9TxT4WnEsh24YdeCr2bF1kAyxoMymccgUraHoOFReeDBko1Sf20+GoenWaVT9fCP/BfxJr1KJIT4OHOaqbr8Y/mJwQBMz9UMoGYOLglqZbRtkXswS/E/efDoelzW1TH7kfXCcAUGQVN3/CAjszDRlU6M7F+UrHKT9zCWM7fwVTbVrvUTMhbeTfys7kxKL8kgY/IwFxk8asO+HDpuuj4PD9Hcd2519fEYFD7ANRxJ1JMv+OFKgpysYCHsOCCHYEeJ4/pAV+I3xU3H7WQRSeJNTvx5pwb7mafJ7jk+Gfpa9B+bWc24XX8qjxfaONsVufjN6Ah0AxLs2j4JHs3x+pA0+g3+lsP3SvrhD2IFHDqSrNv7ZNQn7bblYAyx3XX4n0H3GOd+cNSIiOh9llif8SozxppP3rFpNLF85J8Kp6toFbw/U8uHNfPXwCkUE2mc2welejJeIZMrX5wixTrFOB8ZGSfQEszt+oDvtPwdClRyJOpFwLq3xLfMcthzgD2xTz7LAH0P4S4aJIuBw=","authorEmailMD5":"a1bec69106686f23c335abc1f506a9ab","authorUri":"","authorUserId":"disqus:tedebus","authorFallbackAvatar":"https://disqus.com/api/users/avatars/tedebus.jpg","message":"This article is very good. At the end I found what I was looking for!  \r\nOnly note: maybe it would be useful to do a complete example at the end.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2016-04-15T09:45:58Z","timestamp":1460713558},{"_id":"10db9e9d-b25b-3ed6-9080-02b365cc8171","authorName":"bubobubo","authorEmailEncrypted":"tG+3h9Xhz2+qgFY4P2rmvEHBphSuok1N3Lx0CnL5BC97FUybqC0ETs6LFvyYUrV1N61AbdP855kPjTg9EFNcO2Vf9wYLqa/+x0pyYeoyD5AJWiW9YVnV6SrPlDhBUQhv3sR3cUcM3BsvwlGJMJWesjqm0Ubl4ta8EHIjtCCVul4Q6FiqUEs6UydDhXKvifzB8TyV0qinNxuwCSIkSVfzY+tdQ0sJU27qMa/NG0mjw/6YFI3Hy511xZgk2HKJqbTQOOvLndfnfFNZWDg2MJfDXzICDUyeh7hSNIIe246NsyZqo2qKZmKD3oZdk8L3vzoQiHeoR3Q8Y0XqRB8RGSyvbUUxxwbdB0bRyFfIe8c5uEq57zlaAXKGj1hN8zqh3dHfrBDUrPwm01nUE4CWWOF6YUSzVli/j1MK07niLFbS8jsKzOLjx0nb+P0cVGdqOpMg/W7UmJX85/swwcBApLdVfDOCkzHBZkt30jiL5sKC5k4ZhrYJb58YprAQ4FrEhxqN9dyAC4m/LIuyaB+eiLbrRC+XV1fKOW5mZ51SG5iFAaaenaFQ86GhU7yU8j0GfnSyRKdvdyxa9Zi1927NcMmgPE9TarwJn47zfRwo3Z7CJx3NmxNVIHInUp/0frncCeAM5mEBJK9klAw0yZQb3XaTkpxHiS51HpETNvwj0wL5eds=","authorEmailMD5":"250d2b9cd4221c83307f83ea999ccd24","authorUri":"","authorUserId":"disqus:dariusberghe","authorFallbackAvatar":"https://disqus.com/api/users/avatars/dariusberghe.jpg","message":"Now it's easy!","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2016-04-25T08:43:26Z","timestamp":1461573806},{"_id":"d582c55e-fab1-33ee-b45d-5c54486b14ab","authorName":"PierreDo Savard","authorEmailEncrypted":"hl5bOrToXMM7ILCBbue7bRtFDu0+jXwSzIG7ZOkpZLTLrOInfkJWqFQyXQeXB4M6R93qm+BJ7qTURQk15qDSwEPS3R/shha7xohwVwdkSlD7kD3srk3o+eJSKnIYeFPTx/YUGpKAQL6ioSR7MntLu4A91AFspiitmYyysim/imwYanghEbStR+qu4W9ZLAcPAeZhcS1QgGGBTwQRmPdHGJ40vIzy+fY0RdV/K+TVMav6TRKCLffllPioSPexxtQUXmwfeJxzgGOgqDQK3PFhCa7jvGBbvHXSM21gO4r+sJFF0b5pgpuqktBt3OleLxphxE4G44PPxNO5GGwcuEJjfdDX2yqUJ/Wdqr6j/gkSJFbhW1dsOiqs2h/aexvFwMP8kbZGYZhNaGypv0PuZd5BOUAsJtNJzfpi1ILwa1InlVKDIB3Js2F/s4uw4KlBeIIBvLnxMBgyFS9tjfLb57mOiJDElbASVwlHhUTIwo66WkXe7oIAGqNQp6ddUAtH90oxnPJvle9zEZdW/z4gJJimcUevzkgWJXsz/41hSYv0QodPKItcxrboF2EYrQ6OzoHIKiq0HvKrscbZyxbFPoCHSWhUMZRYiywye/5BZCy8yCaaElG61tE1Pfod1CsXdYmPq3KkV1arlJ8MndNakL5mhUr9O6YKLO0/zUnvFGm1TwY=","authorEmailMD5":"f66df7035dbb0d1acd44ad3257565b2c","authorUri":"","authorUserId":"disqus:pierredosavard","authorFallbackAvatar":"https://disqus.com/api/users/avatars/pierredosavard.jpg","message":"Very good article for well understanding the Await process. I am working in WinRT device and I follow your MSDN article [https://msdn.microsoft.com/en-us/magazine/dn605875.aspx](https://msdn.microsoft.com/en-us/magazine/dn605875.aspx)  \r\nfor binding my control in MVVM way.   \r\nSomethime I need to be called back make some data manipulation before updating the binding properties. I try adding to your NotifyTaskCompletion class another constructor with an optional Action parameter to be able to add a callback function. That work great, except that the callback function call the raiseproperty from another thread (not UI thread). I try to add:\r\n\r\n Window.Current.Dispatcher.RunAsync(CoreDispatcherPriority.Normal, () =>  \r\n {  \r\nif (Connection.IsCompleted && !Connection.IsFaulted)  \r\ntitre = \"Logged user - \" + _settings.Values[\"userName\"];\r\n\r\n });\r\n\r\nbut nothing is updted (no crash no exception). Any suggestion?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2016-04-27T21:18:41Z","timestamp":1461791921},{"_id":"f55ef64c-58ff-3bb8-b97f-7ddb9184b9ad","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Instead of changing NotifyTaskCompletion, just change which task is passed to its constructor. If this isn't clear, post a minimal, reproducible example to Stack Overflow, which has much better capabilities for formatting code than these blog post comments.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"d582c55e-fab1-33ee-b45d-5c54486b14ab","date":"2016-04-28T02:00:24Z","timestamp":1461808824},{"_id":"2245e67a-2c0c-352b-abda-16a7d0e7d730","authorName":"Nassere Besseghir","authorEmailEncrypted":"npi5FOfCm5vhgvWsV3AaxjEbywSpAT+K+CBhrTBBadYGnjzZLF9/C3bdC3ESaQO5tXPLOCHd5J/mStw8TsuktnDqIRgR7zsJ8Zn7vFk7Lvfo6cQkylmk6BM59YB1XsdvWwhljaQzOFdsRJ15E52M/xu6G0/jgaRVLX5pTcvJ/boOSnGuO1SgDwPh+rKh87vexITBJt/DzoN9g4Kx2Er3p5o8rF3g2VwHMjJdZy+18VLyuLpDFZLm6jUqk5Oyp1cHuy9dzJNMVb8RVFhcDRph2HVgdgBorx/1CLaNHD5yyEwAHt+V1eB81TADGh13n6hh3DrjooqO/q+pgYjPdtEeG1CB8UEgA3x4gsQxXHP/EkQHeg9KWSGppGk4okZ0lV7TmL5kwd3lObG1zwBWvmSxXIwfrGJS92y1GPIXi4IBYOz9DUldb3QTqtG1NiOrPA3HZk/J9CgYgpo09NI4fcbsenWpxuxW2uRi6LRqsDNLDZw9zkj6sXQM9biFWbJBPIIsBb0xST3+LX0bjBQcXHs6lNoOOhBvAmaEBeFv1w4s7EDGb4+E7V0tp/4o6Cc2ST+CZsYqE/Mdf1idLjOPH8Knevcz0160gdrWwgTcQya2npf13R6iLHb/nOCGuE2zjYfLY1v1QmJ8rD3ERgCXOpQ5D1oVAZXJ/EPI0UUMkVBq22g=","authorEmailMD5":"e79d6a91e941cb9a4d5838958eadf422","authorUri":"","authorUserId":"disqus:NassereB","authorFallbackAvatar":"https://disqus.com/api/users/avatars/NassereB.jpg","message":"We are using ConfigureAwait(false) to solve performance issues, not to avoid deadlocks. (async all the way down)  \r\nWhen using ConfigureAwait(false) speed has improved a lot (4+ times faster)\r\n\r\nBased on your answer:  \r\nDoes it mean that when I want to optimze some async method that doesn't need the context, I need to use ConfigureAwait(false) on all methods all the way down the call stack?   \r\nThat would be very hard to maintain.\r\n\r\nIs there a way to avoid that?\r\n\r\nThank you,","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"d4eb5318-42b2-3a4e-9435-3233c18a84ef","date":"2016-05-03T13:05:01Z","timestamp":1462280701},{"_id":"39e88d2c-d62f-3fb1-a865-8d195abd278e","authorName":"Nassere Besseghir","authorEmailEncrypted":"K+75T5UqpN+fPi1M2Uz6pL0uf/GLJt4dSCqIXfCxEoMD3+et+dUsprmhRPD7lFhVAxd08jIWwDZsPj7P5VJQjNvcNOMBBeB3KGV/8DYNOcfO304FM05JsM1m3N676b9JBtimRU6N/L/61T7WqSIHALZphKSahGWqBIAZTepmtDOW/WNEwRvK+B9c/Juh8Uc5OlXZCCRM1tpmGki1bkY+DXeOVDayCcFN9n+9qei5u5Ziv5dpK8tf6D8MgpAHcCkiXSHHXPHgeoa7i1GG2pWVigDcT4pfN0ousv2ZfhtxGD3Rvqfd6rOZM5A90sN+GhihPdBV/A9S1gucxTFNViDNAOFJlpNE+kvfWLfEce/8mU3yyVfukuaDMR78fRHG2WvByHcQd5DXU2dCii/07NyGDy5iKVhMWmcsZRDYzNkHCE4bsaKq6WfOoZWsYwT4PqN5P/wmpD5KfSJjVwIWMOaPGzbr0c49kZxvSxGnmW/QijG/YPcZfoIvPOQvAmPungdshiALmnnP1wBc5n7tFpFkbAfwMxiAltNx9o6JTUgVlK0EGYUbjf+F8L009jrGg1465d7ccoIDvNweyFqlhB8cu8KhV9cW2rM5bVvMKc3N1zmyXHZKPpimSyO6P/vcYrO01DLRr0t9/h4b2VMDg0z1b9uTqNGLwRZDFWi0Ei6VPyU=","authorEmailMD5":"e79d6a91e941cb9a4d5838958eadf422","authorUri":"","authorUserId":"disqus:NassereB","authorFallbackAvatar":"https://disqus.com/api/users/avatars/NassereB.jpg","message":"Excellent article, however I have one more question about chaining awaitables.\r\n\r\nConsider the following example:\r\n\r\nIn the top-level method I don't want the awaiter to capture the current context. So I add ConfigureAwait(false) for the DoSomeTaskAsync task.\r\n\r\nShould ConfigureAwait(false) be added in every sub method given that every method does'nt need the current context.\r\n\r\n// \"top-level\" method.  \r\npublic void HandleSomething(...) {  \r\n var task = DoSomeTaskAsync(...);  \r\n ...  \r\n var result = await task.ConfigureAwait(false);  \r\n ...  \r\n}\r\n\r\nprivate async Task<tresult> DoSomeTaskAsync(...) {  \r\n var task = DoSomeInnerTaskAsync(...);  \r\n ...  \r\n return await task.ConfigureAwait(false) // Is ConfigureAwait(false) required?  \r\n}\r\n\r\nprivate async Task<tresult> DoSomeInnerTaskAsync(...) {  \r\n var task = SomeLib.DownloadString(...);  \r\n ...  \r\n return await task.ConfigureAwait(false) // Is ConfigureAwait(false) required?  \r\n}\r\n\r\nMany thanks,","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2016-05-03T09:11:51Z","timestamp":1462266711},{"_id":"d4eb5318-42b2-3a4e-9435-3233c18a84ef","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"ConfigureAwait(false) is an optimization; it's not *required*, but I do recommend it. Each method should decide for itself whether it needs the context, and should use ConfigureAwait(false) (or not) based on that. It doesn't matter whether methods further up or down the call stack do or don't; make the decision for each method individually.\r\n\r\nThat's the general rule.\r\n\r\nHowever, if you're using ConfigureAwait(false) to avoid deadlocks when you use the sync-over-async antipattern (which is certainly a situation I do *not* recommend), then you *have* to use ConfigureAwait(false) for every await, and every single method you call also *has* to use ConfigureAwait(false) for every await, and every method *they* call also *has* to use ConfigureAwait(false), etc., including library methods such as SomeLib.DownloadString. This is a difficult requirement to meet and maintain over time, which is why I don't recommend it.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"39e88d2c-d62f-3fb1-a865-8d195abd278e","date":"2016-05-03T11:58:24Z","timestamp":1462276704},{"_id":"cf02ea29-e3e3-3ec2-9779-c26d6463cb09","authorName":"Nassere Besseghir","authorEmailEncrypted":"LpMNdujyl3215bHT1Yrsj62TQ5qNzp6xq+RPnr+Najoh5nPVyVRZX3AgM55POmNWgbYgjHDVBfyI8FUzSrdVe3TwohNAIlMnGnLiNopxnY9/a1Kv7zceF1E8YITj6RoJP18yrlfVBx9i45pY133b/1o4PaIGqnAyVeHRaYJU2Q1v/F4UjpmhqAnoe5wV7xkZb/ZVgL4oc+fp6wIzXnjns2heM1Kyoubv1v67j0ziukmkF12CJqJZue5Mi/LWN9EqXNdMriYERCtkpOAjonuvLT5N1q6eUzwGRQIfBUMIgqH4lrxsPPBz/rfbzpP1a1a2oauDOqKFuPxE3cgB0tiBZlYMmMjNRmSYV1LVdGa/8oG6KKa2esZySGEyljIyIzUoBLjBBj4/zt+xXZ+bgrKuuiiXVGmv4KjrF4I38RdoDS59p1hDNzZ7dtBIZbRWFXMKh20ItcyUJgpWaCrh2dPDKb9jlOZduPGW/WATENaqau/NGL/CJQH/LUmvqUa+WroYTQQ1E1MYyteRxkn7ZsTpAcBp9fZ0OU5QbRtzKdd1Fad2EvZ+DL3J/QsNgCgBJjFAx/1IU1z5OUMsqE3LhKjjOfKzWa0/IGXpgd14w8EHgb9WjibYgEQHBW3mUA/PYQa5YUxIu6cj+br4B0poGS+hkzO5MLT6n72u8dCfZacXvMQ=","authorEmailMD5":"e79d6a91e941cb9a4d5838958eadf422","authorUri":"","authorUserId":"disqus:NassereB","authorFallbackAvatar":"https://disqus.com/api/users/avatars/NassereB.jpg","message":"Thank you very much Stephen. I've learned a lot from you.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"e13918b5-9d63-336a-ad4a-8b3de2f21cb6","date":"2016-05-04T07:08:21Z","timestamp":1462345701},{"_id":"e13918b5-9d63-336a-ad4a-8b3de2f21cb6","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"If by \"Is there a way to avoid that?\", you mean, \"Is there a way to have ConfigureAwait(false) be the default?\", then no, there is not. This has been considered a few times by the MS team (compiler flag, etc), but it has always been rejected.\r\n\r\nHowever, it should be possible to do that with a post-compile step, something like PostSharp. I don't know if anyone has done anything like that.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"2245e67a-2c0c-352b-abda-16a7d0e7d730","date":"2016-05-04T00:50:03Z","timestamp":1462323003},{"_id":"036fd8b7-a20b-3bec-ade9-5e0267569dde","authorName":"Prasanth Sarath","authorEmailEncrypted":"S+1vv+dMPeCJcqVwVtQyot7oKpL1AWGZ/Fu6DkNgT0KrX0bam0Jtzv9trRbGvWd/GVajwfrfCkADW5HboxavytGR96CGBrpBcCuH8nHDDJn9R+x9MZoeNXadMH30N8b75ILsbbKzY2tA+ar4/VV6rkulTZQ+8f7frPtLeRGlllkrBP/mKVxQJDhnXOwysNF89iJNzgCsS44lXnQiWyBH9wGJH/BQARAZdOV7upqwCh1y0/kaSQP58NbD+SQrQhbH3l1v/wxrwu+k4a4//Kt1Sk5+ZAL1YB3Zcy9/tinIrCO4d/veEF6iVvDAkEj7iLYzqplR/Rh6II6wHSkRkMdAgtzgbYn/694eMQQX7Sf/fEd4aMSy0tqImSXt8jNOmCZIUjHkSganZDa9RvDObhl/C7HkG76FCNwrFWITiKvlrjEb2Bvzsh+sPAvexdtc0eMqSvGs5bC5Agg/5zzOpwA+i4aD8ehgR5CNvjgi2OO/lsHXpntUsebsVNTAQI7nd3DA2o4DXg4N7RXAeAToaQXUyw4xAqrME7tu+dZQSfOOTbyJxTGMd4o3LRhMe+PL6oDNgJESXzabcuu6qlu0vvqqaEmCgE8SPIM8v5Fpz8gkIicqdfOKyF2JqupodY6ygveU7KOv4gJyhATdyKNBFmmkOZwEeWXRNGQIQ1+3O3uDjE8=","authorEmailMD5":"a6ffbb77fde3dba53002490d43e00344","authorUri":"","authorUserId":"disqus:prasanthsarath","authorFallbackAvatar":"","message":"You mentioned that async method doesn't run on thread pool threads understood, but this msdn blog post ([http://blogs.msdn.com/b/pfxteam/archive/2012/01/20/10259049.aspx](http://blogs.msdn.com/b/pfxteam/archive/2012/01/20/10259049.aspx)) says that 'Continuation of remainder code in async method after we hit await runs on thread pool threads' (right after the dictionary example code). Bit confused here, which of the two is correct?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2016-06-01T16:33:31Z","timestamp":1464798811},{"_id":"0e7d2b5e-ecea-336e-ac6a-e6a5fb62b348","authorName":"Prasanth Sarath","authorEmailEncrypted":"LivVWk5nxMq+G/sBbNLVMduSRVBNlGobAVsPQKjRn/5jCb+20tnIkgp3zzo9d2dixy0Z+9rFfk05E3v7Wc+T1YoN/d4QhlnUlScekoJjmgg9ItMcfIRqlXWiQPF+UwOsH8+x8A69T8Ao2km83WpGurPA0m3X2pxb9iosaY8epUZEcQkvpLxGDawhv0A2dsn+m4kDdP9K5IZUwUdJr4BSz5SSY8WESkU9aWx3oMjY4ZZX1/wseDmOUZ0KpTf9oO15NXDqwaN37nBuaVUL9TooOO2KCgxf3Tuh3FdBm9sWgTNP3VgxQV01vBfLTR0ud0q3J/9oHdxCEkp0DR/kgGUtoTOdqtNoVftSDAGtFYuXyssljG3UniPZU5QB0sGq+X+ICOPKq+dNR+MH6bIHQ1S/PBh3DQljwOwoObJOsTLNRqUuxmH4BSSA25VEoi1d6yCanX/J1BL0LKj5znQeOChL/W2E35L7ebiOosnvdEynMgG/NroZNbgUHv66B4epexPaSAYCKZa6hYCM+VsQQS+cwN3yCFXabmo55HbmVac/PODTPJEIv4gEqB7pipAefvg6+VEfsKOx+oFmc3tWytc6fmGBH1K0DXIvm0zpx95a4eHrvgKTkWRhnZw4it7rWgXAGxhtnFFcDzp8VQs54LateszACJimdqCuEroXE5XBpvE=","authorEmailMD5":"a6ffbb77fde3dba53002490d43e00344","authorUri":"","authorUserId":"disqus:prasanthsarath","authorFallbackAvatar":"","message":"ok thank you! On a different note I have a question regarding how the compiler switches the transfers between async method and caller method. For example when the compiler hits an await keyword with a long running process in async method the control transfers to the caller method (and assuming await code running on thread pool). How is the execution carried forward from caller method, does the control bubble up all the way to the top i.e the Main method while the thread pool takes care of the rest of code in async?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"40ecf2e9-a5bc-3a70-ad92-c692d15d6bf3","date":"2016-06-01T20:26:53Z","timestamp":1464812813},{"_id":"40ecf2e9-a5bc-3a70-ad92-c692d15d6bf3","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Both articles are saying the same thing: `await` will continue executing on a captured SynchronizationContext or TaskScheduler, and in the case of a Console application, there is no SynchronizationContext and the TaskScheduler is the thread pool task scheduler, thus they will run on the thread pool in that scenario.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"036fd8b7-a20b-3bec-ade9-5e0267569dde","date":"2016-06-01T18:06:36Z","timestamp":1464804396},{"_id":"64a738ea-f853-3953-9761-899b0f57cdc9","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I explain the full mechanics of await in this blog post. At each invocation level, the caller chooses whether to await the Task that it gets from the invocation; if it awaits, then it returns an incomplete task to *its* method, etc. The thread pool does not come into play at all unless the code explicitly places work on the thread pool (i.e., `Task.Run`), or unless the `async` method continues without a context.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"0e7d2b5e-ecea-336e-ac6a-e6a5fb62b348","date":"2016-06-01T20:40:32Z","timestamp":1464813632},{"_id":"4ba042b8-db4f-3c51-b832-4218948281f6","authorName":"AJ","authorEmailEncrypted":"B7JHQUc6fHh5FiVl6UaGCD0UxjLF7metYJLf9azJrd2WqmUapy2NVjSxlyWPUxW57xJqDZGe4WAI1Csia9icCqxa5c9Elsmbwpf4HHNGhoNe1G8RdOd9xJeJBaelNqF/dOLCNKsg1WkThnCZqRwTAE4sBtSLcU64hK6cRZgap197UrLpQy1V48c2EjJlqI+Shh6WbJ6a62hFPL0MsdKFxAamEkmDgPKb7MGf2wwE50PKAQApmZ5vzdnfuGw5o9OUUcnX46EP74KnLOdupAN1n+t0VFqgqUvi4F2ic5p2jvs/vNs9r73baLn1m7lxGsSitVeWTHGpa4vXg9R05M28Kn2ZYeiYzMpZdQSqWbP4ltpiM0XqzhQ7ZTkgBDHMigWG699sqwyWT90pZMUGasOOGG/VoIsLSeF8jv2q8kzKvTAnI4HYuLkeEAGY3CWKJj1W832vQj6pUnZOSUneQYr6Kcy0TDVoGTU+OmPE4juRsFoUD6Nmz+o4uKdNCT2EjFIXD9TL5cfsoQx+Vt3D4UgkFsmxWLLnoxxQmLjujF0e6RKSCSImzQpxmPi2UgL0tLOvLC7E7mNhjOsoQWKp7WlCJNWBz5kKSYh1g21WoT/GTdkakIEMLQRhtfIVE8/oU7jnFeXOQHSfgpzsrgMKJL+4INmSwZaogCZsWzLsGq4FYKU=","authorEmailMD5":"b84e9d97a4571dbf590e639328016d8a","authorUri":"","authorUserId":"disqus:disqus_1uUWOrHsTm","authorFallbackAvatar":"","message":"Thanks for the reply. I tested AsyncContext.Run() and it failed the same way. AsyncContextThread looks like a lot of overhead to run one (relatively short) task, and I wasn't sure how to setup the task and then join on it (and get the T result from it).\r\n\r\nYour AsyncEx lib looks very cool though. Will look through it further when I can find some time. :)","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"ba3895d2-138b-3e56-94d5-a1a2b3decc56","date":"2016-06-07T13:17:29Z","timestamp":1465305449},{"_id":"5ca49c8c-57b8-3ce8-a122-a20b7bc1852b","authorName":"AJ","authorEmailEncrypted":"iiLdSr38LbJCaUC2bKJvZPgp5UfsFAIfH5WYNegFJkRXmB2QNz9iK+RAR8adyaO06bHkXYtACZ+EuHpmtdct+czFbgB1pyHpYpqjYSGkW20O+5LIX2XtITYIBOuPCiVvpRLsUrRmqRjXANfsXWSzqULjn1qEjWI6eXu8SvUhUa+9N1ZZhlPi+rAEF0YZgkUZTCcxIktYzELHx159qhP/Ici5ts/ZEPBopA6JovGBGf0+hkTe1fqqfUYMsOR5G+S44yb2hX5sq8ak3QwtqEBaw+saUSf19n6bixPb0u4u2C29XeVkeyGKmVd7QOmSFdbLQAfvaFzJ4S306kir/J90PazeZYcRRicL5jSSVQOa80iEhN7FYFiNFeFOMl+l5VuExEoadeSt0bHIKK1HOwR3a5cVeuu5wg7pEQfuEhjogXQg32AYpzxOJAW+TLnA3jgZ3E5JSC5yNm+tlvMg2ujF5IWFiAYQMWNLkzGfj7tYqnzgUVF61zyhHQ6//4mTOeUoepv2sXXw4a+45gCWpqEWGA2AJsAFK2I/66a1U5M8cPgAFDVcBYCB3UeoE4qL1OK2o/kTGDmeExivM0sDLoXQCx4B2cylstTHQDW32zB51dMyIFiVSWPy/TDIGefPkGfitJNS9lp95UzxhKu3B+Wo50PYti8igUiWi0Ctwg1RNLw=","authorEmailMD5":"b84e9d97a4571dbf590e639328016d8a","authorUri":"","authorUserId":"disqus:disqus_1uUWOrHsTm","authorFallbackAvatar":"","message":"I ran into something strange today where it appears that I could not use the await syntax.\r\n\r\nI have a method that uses a global (named) mutex and it has a helper class, but basically it is wrapped around my code via using(Mutex m = new Mutex(true, \"MYNAME\", out _owned)) { }\r\n\r\nWithin that using-block I have to call an async method (or \"want to\"). Calling it with await (even without the ConfigureAwait(false) ) would seem to allow the method to run correctly until it hit the Dispose() for the named-mutex (which is attempting a m.ReleaseMutex() ). This consistently threw a System.ApplicationException: Object synchronization method was called from an unsynchronized block of code.\r\n\r\nSo I guess whether or not the \"SynchronizationContext\" is maintained, the method may continue after the await call on a different thread...and that blows-up the ability for me to release my mutex.\r\n\r\nChanging the call from await to getting the returned Task and performing t.Wait(timeout), then retrieving the .Result works. It's certainly not elegant.\r\n\r\nCurious if I missed something obvious, or there's another way to ensure my entire method runs on the same thread (due to the Mutex needing to be released from the thread that owns it) using the more elegant \"await\"?\r\n\r\nThanks for a great read!  \r\n-AJ","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2016-06-07T00:32:01Z","timestamp":1465259521},{"_id":"73ee420a-03f8-3400-a29f-8b183605a476","authorName":"AJ","authorEmailEncrypted":"ICLtnzXfKlifX0NAewtwdMo4jFiQmLEhuhUnAKia1WtNXMKj4Ow58ujEMohY3nKVisj2RqMV7ZTn1PnoUgDPwwumr3/NOxXsh7V50B+CuJ7pvrAPhJ7Q1waqW0jm71XeTB8iplkeQPNlU/j7xWhObLJg622/L/rk7E9Fq9fcMsy8IL+fLv/lljTiAmDV2yj4bJ2CpR1I7dGdILieMBFVh5h9Lh7z4/CoayW5X+cJe36lyCcU25OVebIkeIXMUJG1ypoBd29nXWQvfxywY26gw/2riOEkmp9VGu1jl5LvnPxYm7rONGK6jPCpi55NT+iOCoExI6jWfaNXvkBWXFRrehSgeG0PN5HIAS8fowj1aja7hbtkeOucQefkLYkr+rs+X2fs67WrzspyeXbKMuGmhlADEtSgqqJop9CopJIbQJpi4xIZ/uBULueeIfYFgWHrB0VHkD2S3D/aQ9u7IE0TZHZuVA/Tp+engxtzv6Ut1hQIAmYqItFJKEEXEAbT0gxiXucYcVNORPobGvn7y6dyDGY2mjj5SQBvOqiKM3YZN8e7qQyKXg/AH/UyB3tGYBS6SJAdmZJwA0kiginOMN3ozaTvzZgA3jqGY/vNUb8bxwgZ1QhLaz4pOGX9xEvIbdYEgimlHlBeVTxXWXLkUpmCnTMiqouMFpizWxAO1zrk6ig=","authorEmailMD5":"b84e9d97a4571dbf590e639328016d8a","authorUri":"","authorUserId":"disqus:disqus_1uUWOrHsTm","authorFallbackAvatar":"","message":"Thank you for making me go back and look at that one more time. I had left the .ConfigureAwait(false) on await call inside the method. That must have then upset the work AsyncContext was trying to do for me! It works with AsyncContext, as long as the await is not using the ConfigureAwait(false) optimization.  \r\nThanks again!","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"7cca3330-bcc8-316c-81a4-6a00337cb656","date":"2016-06-07T15:56:22Z","timestamp":1465314982},{"_id":"7cca3330-bcc8-316c-81a4-6a00337cb656","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"AsyncContext should work. Can you post a Gist?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"4ba042b8-db4f-3c51-b832-4218948281f6","date":"2016-06-07T13:49:35Z","timestamp":1465307375},{"_id":"ba3895d2-138b-3e56-94d5-a1a2b3decc56","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"As you discovered, mutexes have \"thread affinity\", meaning they must be released from the same thread that owns them.\r\n\r\nIt should work to have this code in a special thread; you can use AsyncContextThread ([http://dotnetapis.com/pkg/Nito.AsyncEx.Context](http://dotnetapis.com/pkg/Nito.AsyncEx.Context)) which will set up a separate thread with a SyncCtx that schedules work back onto that thread. So any awaits will resume on that special thread.\r\n\r\nAlternatively, you can use AsyncContext (from the same library) to *temporarily* set up a SyncCtx on that thread. An example with AsyncContext:\r\n\r\nAsyncContext.Run(() =>  \r\n{  \r\nusing (Mutex m = ...)  \r\n{  \r\nawait...  \r\n}  \r\n});\r\n\r\nAsyncContext is a \"nested loop\" approach to the sync-over-async problem, in contrast to the \"blocking\" approach. Both approaches are not ideal, but they both should work.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"5ca49c8c-57b8-3ce8-a122-a20b7bc1852b","date":"2016-06-07T12:26:46Z","timestamp":1465302406},{"_id":"0b5597f4-5bbb-31af-8199-52aa3b5a9793","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Truly asynchronous operations do not require a thread: [http://blog.stephencleary.com/2013/11/there-is-no-thread.html](http://blog.stephencleary.com/2013/11/there-is-no-thread.html)","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"8f2cc8dd-0e7f-384e-8daa-adcdee63c799","date":"2016-07-27T17:14:49Z","timestamp":1469639689},{"_id":"8f2cc8dd-0e7f-384e-8daa-adcdee63c799","authorName":"Shilpi Rajput","authorEmailEncrypted":"bpG0VSEMC8WDSw+RaEuSN+RfDbVgaEOwiNnBkoVr/2STs+cHPvrWTf7Jar0AUWpdaGMzjF3z62EuUjsaBL/1qboa7AbXfV/uHjrjKM2/Rg1Xkry8FhFhhdM9zuRqj2sOUtGwjZVxGni3EALe8frxpm3USlm+vwW+Swk9wXEH3jLUL9URpGA2h3BvJYkjaz1TovJkikIWEMQsktAbBC4dQKsT3b7tfuseWOQL63C4DyVM6A8BxBDVwFrh7h22EQj8fnN6MqlVLGOaiZvDL+QXtCqCAIXdb+svZaYB59hT17lziV9OcZ7s1ukGPo9ZawKtK9AJFCZyh9xZY0XflyvbasbKYJoq8gk9JyryyObqSaU33KAu3wB9laZvRm95vjifGhFWIg1i+Hx7tMRMJbKdvUwy+KLRFm+cV+GaB9h/P9qtU+MLP3t3DNsydyjBV8LgN/vP7wkkKKpQWO6yuY0wpX0v3CHtxf7azDT7fPVkTOiN2r1wIdxibpSU+Zj5HcmceuiwKzdsrGJ5lo6QytLr3ng34LpkasPQdM4T0XIf3zoqKxKvJPI7FdbiTU8zfcrAiIGTsFV8in7UmmoZKl9hymBwNugAUD75RMCfCcHz3Z289ji1JRdraam3f0jqLBBIxoioLcC12czsFoSF8KBI0zYcaKEJDIgfP0ug5iOW+b0=","authorEmailMD5":"5d6543b1b3897d652da9ad824cd1c92d","authorUri":"","authorUserId":"disqus:shilpi_rajput","authorFallbackAvatar":"https://disqus.com/api/users/avatars/shilpi_rajput.jpg","message":"I like to think of “await” as an “asynchronous wait”. That is to say, the async method pauses until the awaitable is complete (so it waits), but the actual thread is not blocked (so it’s asynchronous).  \r\nWhat is the difference between \" Actual thread \" and \" async metod \" here?  \r\nI can make out that actual thread is running async method.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2016-07-27T16:49:17Z","timestamp":1469638157},{"_id":"113e9528-98f3-3694-b0da-33912031a8d7","authorName":"Shilpi Rajput","authorEmailEncrypted":"VFrwTDSHy5AVVoXy8Mqqp1S1Fpq2gFjJtTrcidXnrd8bJB8bgdYcsSbVvheRKFFmiiI1DJqp3n+JdS2Rvxsgeo2qI/+1B1Olni8O9R4NqMXTffKifwQ2ZxN2fEuLPzF9tnhn3S3wY2WY63SJhjfxWVNNQY6mAjaW7C1F18UDOgBFqwaSVss1WkM+1Mlk5AANe9NNmyzzFg0wjWy9oTD9taJmAf2PRBtd9th6KIcRghHUEX8uAeYWxTDGqhP6rNbh0DR8NoiSXuD6rdxTEBW49CEMXteSdoI0mCnHHRHir3T7GEnK2npubttasvL4rbbjfos2o330BkZMJHeDRGjRse8TSS07d9WPb97g+NE1RNnjKU7D7b4Nq1Eq+LhGfz1SH8FZLvBhG35Sa/BNvQ/xPNqeB2qE0Z67Lo7ViliSgQCfyYbjSNXR7LF9UshbVvWa5YGzxan7X/ank3XQdNc96Erur4iJlIh1V5JIMANphGYnZC4KqqnGH63YfHIQA20myd8pHb6eZSYCrKDFgr+fhNWz5cS7wSsL829ty9ovtn5f6WBSM6XPQJsiXt+/IRnEGq8yfSGykyeVRMhipiU3whXQfZf5GTKoXE8lY9FVf99sq44e0YA/iOfgX2yFBJ+IRuX0tg4eLvGxSk2Ckanxo/1UW8kgqwQjuYnKk6P2tFo=","authorEmailMD5":"5d6543b1b3897d652da9ad824cd1c92d","authorUri":"","authorUserId":"disqus:shilpi_rajput","authorFallbackAvatar":"https://disqus.com/api/users/avatars/shilpi_rajput.jpg","message":"Thanks for the reply. But my question remain the same.   \r\nYou said \" async method pauses until the awaitable is complete \". Even in synchronous calling , calling method pause until the called method completes. Whats the difference ?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"0b5597f4-5bbb-31af-8199-52aa3b5a9793","date":"2016-07-28T04:10:37Z","timestamp":1469679037},{"_id":"c751760d-c742-3c52-b6d9-f68e0e636323","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The difference is that synchronous calls will block a thread until the call returns. With asynchronous operations, the thread is free to do other work while the operation is in flight.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"113e9528-98f3-3694-b0da-33912031a8d7","date":"2016-07-28T09:27:43Z","timestamp":1469698063},{"_id":"47dda480-0895-34ba-9cd9-5729334e5471","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"They could have had it default to false, and then you could use ConfigureAwait(true) if you needed to resume on a captured context.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"8f69f151-ab94-3176-b6f4-3ca89c94f505","date":"2016-08-15T13:14:09Z","timestamp":1471266849},{"_id":"8f69f151-ab94-3176-b6f4-3ca89c94f505","authorName":"A Muslim","authorEmailEncrypted":"VIwPKZ5mMYk4Lm+ZPRk8ofnhO1ZfzMDaFjT3mGJVND53oTsPo5yOosaIHVW5PZ1vSRGwXBjvI9GlBG0LlC/WuslPIjhDM+N3JQAOa2OLaAVE0JuGEWDqislagnTuFsdkq9ahJx0Hm2BiRzawMEaxDHyBsqm+53zXkOfP0pU/swY+EuPP5JW8jg1uMpDWnIdy1eqat3Vx1SFrGHQaPYiDXbyy87vMv3r9mA0JDdEXYr9JR44+99V5KzjIwhCJV6/8rNNfsC43xpy1E8hqlIyYla8oM5gmMe0o+ixsF9YFhkF/ijRCmoqzanzsfEKzCH5geT17Dp+S7nQYsIs2Z3WWo9XEtLb5mhBx80ujA+Cxz+P8tq4d/Xes/fvqlLNZ4Pc008cwKHwf4p0OKlWoJWkf8oUIX8ubV3uUrfzWyclIliZ0zKiJCjKukWoheoLVNlYAxkqyb1ZsH+wi3WluF1VMxEMj82XY61h24d0NlfgY7wxHtTkPQKSFHsTfWWdLRVaz1DJ3F6YFvV20me9wAMDpUBOzQklYjWWHvs00sy+bE5Skl3KPqiUyBT1UOkGNbu0ctKjtKzIl8gGqi4jr4f6epAQkBeLMDwbH/BJGPWMf8MySlNarUVnY4RB1XqMOImjGE/0thoyqw6XRGnAo8+ajC5zZGeDcetZfixZ3KFgrB9I=","authorEmailMD5":"89fa2a0f061a5bb2050c717e6ca2f342","authorUri":"","authorUserId":"disqus:disqus_pwPFFsEWox","authorFallbackAvatar":"","message":"It is not made default to false, may be because Tasks are often used in UI applications. In the GUI based applications, when we are done waiting for the async task, we might want to resume in the same context. And if you don't resume in the same context as of GUI, you end up with a CrossThreadOperationException, requiring user to make call to BeginInvoke on the user control thread","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"c9cdce9f-d132-3fbe-a1d3-dd719a34b54b","date":"2016-08-15T03:39:12Z","timestamp":1471232352},{"_id":"9767884d-e652-3473-a905-9c17ea512dd4","authorName":"devology","authorEmailEncrypted":"OplItoCiQNfRKV3hjkwF0pdkbk5U8081MlUs00vJp67HVmLT0QR/zBozskTNefvN0lDZG84STevQetDQiUgM4s3hdRZMna1KVRlhwTPa4ZU6ghYg5B4eQQqx1xB8wPOgwHY1Zo0wxRU4pTW6NQB/uHcAdsMl2O/F7wG1/OjGk6Wxnv+5Q136uK81ScOzDjk4EQO7RvBRjVKHOUNn4dWDWdIbpzGDESQBR0XaxP6TNTStZJ7gGyeCv4w1ngzbCHxoIsiArfHbrUlP8RcSFg1FqaLvQ1zsPcfSFBnBKN9aU77KiyqSsDBTvqbIHrD0lLp6o6eEfyOdZJtISehZO7uvz2wlqiGqs1YzO52HQ84anaWdq7d2VWxFy4cPmDS0gbAIzGRAQtomZYCCC3RmzvWGzXhXS67sV2wnhTApMTPKy45K4VdB5WxMVslEWDSEGWiGtKWp5ZCJ1sUli7xpBKBDbdpdnYADCa+LoOu9IbaFzxBeLsxDbFT5IXkriwSpdlPjeppDi70sxc5leEhC44ViNx5Kxl/o7TEg4aseoEsKObSNS2eZYv1UlcJXXlW62OmJRjf5Ys1KvmkJ8FKfa9ep/dBck56zgIbOrhqeaM7fmBOMh66Ec7dzgNa75H2vU/Rxg8Nlx1FZ0bw3Su5ka9oQ8LhETufXQ5PbZL+GJmacRYs=","authorEmailMD5":"d1908b935cbc83952896a520badd2cf9","authorUri":"","authorUserId":"disqus:devology","authorFallbackAvatar":"https://disqus.com/api/users/avatars/devology.jpg","message":"Excellent & thank you!","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2016-09-26T11:57:04Z","timestamp":1474891024},{"_id":"08572855-5f0b-31b5-a174-d0b8050fde32","authorName":"Nadeem Khoury","authorEmailEncrypted":"YgF/bc9CJnGwk54vYkYF2bgKMkDNvfeCaCzfDwl4zA1RiS0JyD8Be/wsIPLsAy40a/EXwcwSeYNvJtmFzDPqDC6raX0bsfP/YPRF3Ac/qnqcErxf6qh92+ILUSuC9zY1Ecdcoew1ok3YLSBHlWzMFwFhlFzeMOPkE74/ah0XB/u1jwN7h/9AAgWWr50RluWIKIQuA43MDqcw6rercSMYmsEXjUU7rG6ufkN+G+m/zzLlsnJtwtDUGl2ddR1ZfyKu8F6JQxsNmD2nd+PzIc1fx1RViE7M3NaGvnxx6iBmDWbAooIQBlxfrIZ84wMxuDN/ciCd7DFt08afxw9hDNWxMkssD6SnxsJ66GmD+8czFNDlECBD3NrXh2uRlQ24Sv2HF3b8+dYxU4nKVmcweFn28O1TeylfXEmA2sqIePbAHzl4rH/Ycx24iZdGP8Ht1W4SOkLOfNjxRQBc+JNM3xh0pwMUJiaWd7r9p3oUiTRjLx8cP3nSin/rQSKTKNX+CTTLGSnha3D+uETD6252STHnKWZUPCSWLc3Ub52ownasjaoUZ/bdplZx8Lj76V4/Y3a4snf1cisskozetLM8uqgh86pHDOnnvqb+FKlllvDjp+VPFkzzDk19B+xgQQaJjDgUAt5j1admnsLj3tn78q0i5ve/NbMs4ewNU7Gp0DIBSKY=","authorEmailMD5":"4ecc0095c1bfdbce531cb91932f5ec8b","authorUri":"","authorUserId":"disqus:nadeemkhoury","authorFallbackAvatar":"","message":"Very good article, thank you so much","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2016-10-01T16:42:27Z","timestamp":1475340147},{"_id":"794bedb1-0a66-3182-bc23-dd3fc4bcebf6","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I wouldn't do that. If the code is synchronous, then it shouldn't return Task, and it shouldn't be awaited.\r\n\r\nAsync/await is the best way to write asynchronous code, but it would just get in the way when writing synchronous code.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"e12ec539-af51-33a7-98ca-22e913f1f2ea","date":"2016-11-16T15:29:28Z","timestamp":1479310168},{"_id":"e12ec539-af51-33a7-98ca-22e913f1f2ea","authorName":"MK","authorEmailEncrypted":"wNz+gvX4ziiUaIPwm4xnBUhArVcc0fybMDYs2inLsT0Q2Ht5HaznBCgKQAAu4VqaDr00S/RSh8LC1YgIyUuHemZckiiAhFZNg5GCPP4njLpPgsefFm5/Lm2n442ZkTz9UA7ZTLxd+cUa/UQA7DrkqllULRcRbzPLmwvbFlLYMHxkxYOcxbz+yRK0hxA4XOLiHz8Ak0zG4KOv/NiPSt0e16toowl9rlhGXzL+stRas7wDZepjpZIDl/rBQoxuzAYBjodhBTekus+womj3mDFzaHxQ+YAXxrTqRbUoHBRA7HEE4qSZl6KdKYnru82wAW944FNM5VOVL5TlbZ9ih9yWUDzun2G28qLlZOp1lGZ3VCuWyAleWcGD0Yp16KATrSUNg0c3CswbjhY99+jXVnUrP3UMf9oBlsq1qbWpvhDwiMmpqFK0C0RNCt19If1HBL+TrEq9Errdw2y2KJcoTz82qJUF1gH/rcN1ZYATF0uX2SBKiag3Ti7EJxRyAB1TYXwKxho43EmSd8sMUvd3hJToqqKzXKryNkIdMS6cuXa94W3OtOV9EDDgKgczJHee+WoA4hnibcT28g+gBKiRGw3YXJWeO++kvhnPdgqCqR4leZYgUg9UD5NIAAX+1sCxzanztwCUKFyEYCyWYEtii+6Z6SJ6q0sM6MQOEHnX4GiPA0Q=","authorEmailMD5":"089c564506a6a71539248a82c0d60918","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Stephen,   \r\nGreat article. I'm pretty new to Windows programming/C#. I have a console app with a situation like your example above under the heading \"Awaitables\" (at least one non-async method that is awaited). I know the return type has to be Task but if I'm just updating some buffer in there can I return Task.FromResult(1) just to signify that the method completed successfully?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2016-11-16T15:19:13Z","timestamp":1479309553},{"_id":"2aff01db-dbeb-377a-b6c0-184e9dc73d3e","authorName":"Yair Nevet","authorEmailEncrypted":"ZioV+dcijqnFvxM5QOdFNWwRgTwlQMz7CZzVOVysJAyJItAWAx8cJgpKs4ZQcN9QHaMjxwYa962M+8duc2cOh1KOlzAsAZJLbQLodmcjSzo/Zpe6K3Y+CNMa6BWyWCJZMBy4strTiLl5bQPk3hxINLSz6zfgsai5QV0/XayrTUMMzfc1SfnP6852sfHcJ/p3WS8KNJXGjenybsw64lTzZPtwCZD/9cCDEIdcJf9+sNc5wuFZ+jcBaufdfeUKPM0NuVkg2hyQMcQgjnVctepl1FtFmSP8QKOsoDPEm0Xmp8Eph3YZswFkfxYkr22e7I7iO+V9zpGGpHmm0ithRNah4um6KREYfmMvdRULjfR48N6POdFHlSN+R6Dy+8Lj/pp+4UXIwNSJMToLFXBjpSLLhyOkdDgFPVaDutcurH9CSnUEHJqf/YF/Salk17RI5kJDWEHdR306k3ni4jErgYRij1Ab4oEDfI6HJrZC4UivtCF/xEIxitPROiSoZfu6pOFsT1S7QtvCbuyYv04GgB0hZUuiMuGPqiE0IiU5OuyOLtEboScV5VD7nQqDm7AHLqblPfYNKmM8obtf1q4OS7wE2KVJpPGIogizPBniB6EG+fFTnxgoNTluMaO+IC7A+YkJ16D8wzO5U8ZiBKPymNk1GvSp8ArvwYb/I1t+F2bt92g=","authorEmailMD5":"985213f85753377348a83b92f33f60ab","authorUri":"","authorUserId":"disqus:yairnevet","authorFallbackAvatar":"https://disqus.com/api/users/avatars/yairnevet.jpg","message":"@stephen_cleary:disqus \"A good rule of thumb is to use ConfigureAwait(false) unless you know you do need the context.\" can you give an example or explain this phrase please?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2016-11-30T16:46:48Z","timestamp":1480524408},{"_id":"6875a8ac-af94-3c83-9048-b02f8c761993","authorName":"Alexandru Mihai","authorEmailEncrypted":"W7vvF4dEDPGPGrD03xJ6kpT//uIcM1M1QH/43GY7qx+JIgrrRMXIFlUFrpHrAcn8tjB8lt305SBtt1El6MoNVBfrxsT1YFpBzc09BG/U1W2VBclLgp+wXtSRK3W+L+JvKifsxU81zuX37dcbP0h7/ojAoMFbxdWqejZ+rj+FgtEV7IpZKHH49GlXdDnAGBCiAxNOnYab6E8au8tUULG2b9adMfx8xyFrPURhYR1m82lvE6kf9TmwJJjw01nMiBEnHShlbcp1m6Zvg7Zj7glXoPOrVplIjhMlDe1IlSwdJaZjD+T4vSidY+MK6b7UoOMbYXY6PgyH+tR+nxFt3tTD/ZZ0tzWwc+TPOfXWlzdvnLxLKfp/UtpuT+d2aA3lTj+CWrxKqjvt7ruVl6UV+xJyyZc8SPO24Hfw1bqAZOb4bhf6P9grMDfKtJIaTOWEpk2MxZcPl7u2OF/81xi8i8SQRLtsScP/qNCNITqxZzeE++D94wgjOQDcrGPWHq8dT2cs9aw/Gaya2cLFWA39yqdsfQW3CcCF7smiw61Rx6/EoLNApFDSHLtd+rnFTKI5CxxCym2gKkcVdwH6IS2At8kvlGL87oQzE3l8PmKxT3TXDEskpoKtU8AGHFxToIWWpFUICqfBDW7C25uEJLgodQ2gNKqjrNR9oKdstGQIgSkrGc8=","authorEmailMD5":"fc86f00d33a6cc4f999b151e4d492b24","authorUri":"","authorUserId":"disqus:disqus_J47Mi9Dauh","authorFallbackAvatar":"","message":"Excellent article.It is one of the best which explain the mechanism of async and await.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2016-12-01T22:20:03Z","timestamp":1480630803},{"_id":"6afb5f2f-35e3-39b2-a0c1-c48acd3806ec","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"\"Needing the context\" can mean:  \r\n- Accessing UI elements (needs a UI context)  \r\n- Accessing HttpContext.Current (needs a pre-Core ASP.NET context)  \r\nThese are the most common examples.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"2aff01db-dbeb-377a-b6c0-184e9dc73d3e","date":"2016-12-01T02:24:15Z","timestamp":1480559055},{"_id":"b8efe0fe-d3b5-31a9-816f-90e9a6f6ceee","authorName":"glkelly","authorEmailEncrypted":"Ge0WoX5ntgEH84e2EQdhtO8eEStQI2I5GEMmF1Wk8txPRxlcKFOF/mMLpRhZySqjHa73ksq8Ke+bbdyhwIyjLgfBQJ85cpLGPpYVUwLUBrW8SARJHDc7FXvDQnU0JhImINwtpYA9hBi+MjrpGMAhpJyz9kgSsaCjXL7xnsvBSEIylikh7fONqj06fdktB8ysA18e2eUlZdorDZYnXNXChhrV06RreA/ZXA1rg3pBI3E9NM58CnHjKDcW2hZgrDBdvM5/7yvY11jSzav/qigrxm7zyYNTCKMvoq/CV/VpglTTNBPcXN/Y8huV1vgOWr63+lgR1wyjG2DN1PGEO7yUAQ3PJTKXDlzaVZZMh/ATzFdN7z/U4jaB9OJsGJ/Ew+uaxZ5NBqHvsvPV6v930KPVnuus2OvJUpJC+KPQYjGbkZfKAAluWrv4eSLiLH++r0PETLaLL4H4yUi1HOu2NVXC4LF8NIUUsNED0xlee4WCu+lzoxwTv+PVS8pUz1txBnv/0b/y4M37nC6Xapbg7UrOYRuLnH4exkdX5V6ftcmmOdzNZI6lvzh2DjRi0B5Je1o5C2QZxwcvlW+5HDHEd3huV1j1bC2LOcvfYHKAYs4hSspt9US1qeBZRi53SqGnxtcHmDBP4ExeY2y7shSitlH5Tnz1ggcz2acmrWYvWT5qM4k=","authorEmailMD5":"73855a485969922f9812979834ca6f30","authorUri":"","authorUserId":"disqus:glkelly","authorFallbackAvatar":"https://disqus.com/api/users/avatars/glkelly.jpg","message":"would adding:\r\n\r\n await Task.FromResult(false).ConfigureAwait(false);\r\n\r\nat the top of each async method be acceptable?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2017-01-09T19:13:36Z","timestamp":1483989216},{"_id":"68e57930-3f40-37c8-a2b9-cc42cd27f60c","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I don't see why you would do that. It's literally just going to execute a few CPU instructions and generate some garbage for the GC to clean up, with no benefit.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"b8efe0fe-d3b5-31a9-816f-90e9a6f6ceee","date":"2017-01-10T14:08:22Z","timestamp":1484057302},{"_id":"e9ecc01f-7828-3534-aa1e-a16fe42ae73c","authorName":"Burhan Irmikci","authorEmailEncrypted":"tquKNMatGi24un29JNAT7I4rydv9iHfN0BSMpOZqpg12copY/U1HqIQdvaaGATgmkSNi3JzTWzUGcrm7UKbndtx+YOEXkJtlbl4YN+M+uQUKefTHjG43O6zzJ9K2lzHreZfxdUjLAyaDl1SRGM6kbNEeUdWnhsN0fjrJoLZZxzoQNUHTsQzA9LM9jfOCE+WnqWQtKxZ9PcDQX+NRU+tvO12o9BPZIGBosEf8vqXngId7cNO0n1o0Kq6z4WrDQBexDWBp5tCCQRdjzCXNcvXPZeW9Q4Kclo0M8YXYGHgXDVWkbGlWgVrile7CQH9VegnZMrza6PMVhMtwGSq1GOOXuu+FSoeK9Ll5EYOWCT5Fq95Dtam+ShQtgXF8vHeygHBhshlmgknIjYtzCN7SSg3GqJkY2s+pel2njQve5UAU4IlHUB8uoMenupnB6yRCGtj5as+KOUdQ+yGKXhrYjSPDL0XRQdyyJCvWOKBzgkExGTFyFj1+BOKyoeffb7WuJH97kuZa3a0VcsdiOVynCpkIJUjgrUQHkK0rR1E9CU7UsZc0QpJAjYLaKt9kT2H0KrCEqzreskVgN4qHGS2MDVa8i8DOlIF49H4xxDy8Fz5saQhaEnxEcyRNzNkOW4YMpPFsSeuHNlc8sDVDmsbzIGnGwEN+5dPfFvLK19Fvpt+LGV0=","authorEmailMD5":"8896c4a0d200fe2e2e6eed6f95c01434","authorUri":"","authorUserId":"disqus:burhanirmikci","authorFallbackAvatar":"https://disqus.com/api/users/avatars/burhanirmikci.jpg","message":"although this seems a bad way to achieve 'the goal', i guess (s)he is trying to offload CPU-intensive operations from the current context, probably a UI one, in which case Task.Run should be used instead.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"68e57930-3f40-37c8-a2b9-cc42cd27f60c","date":"2017-01-11T20:01:55Z","timestamp":1484164915},{"_id":"32c4a065-3067-32ff-a62e-edad17a880e7","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"glkelly's code wouldn't actually do that. But yes, if they're trying to push CPU work to a background thread, Task.Run is the proper tool.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"e9ecc01f-7828-3534-aa1e-a16fe42ae73c","date":"2017-01-12T14:12:03Z","timestamp":1484230323},{"_id":"49f179d2-25b9-315b-bcc4-7ebf3faa2bcf","authorName":"Burhan Irmikci","authorEmailEncrypted":"ZoJm7lrB38IM2B9avJq+b+8k0UCPHKEGREuX94tweI/zggaWPvos3inaGPgWy24p64pf0s5uc0G5ZKi+EN8mInpMBQLRDecR6bLvboDHy+AZvwLCuwrRV9c2Jl/89HUhEkmnUcszpsET7xcTfA690AtSgyIQJiwWWsW2Nd8tCb+jrPkkpcSZGDm2eJTRCyD4dmhCgl0+9gc7Kz1uAwj3zmPhc1cP/O2kDwX22FgyIOgh5u1nyGWhhyrypUIBtyeF2nM3LMcOuS/SeHSmB4LLS4RE+/4xxmEBck20t5o5GZFA9CNq67VbkMT2TpbrSKK4LgK7cWfPxioL4QxfgogOvl0B6Ju+HP5vQ/Vu9hvIz10KGO7NFQkuyo3Q9tJ6oKNQy6NvkgnUm106sronw52X+dLrmRzyW1OwOjOTpbVyHjnBQedVbbjbhG0OsxqsJYxsDTl9038yeFdG7CF49HPndqqOyrSdyxYnz5U3L7rtZBQ0A753w5cR39VAH0nN/VvUT6G+3ZIG+Xstrqn4cAo8DZJRAJpbFHDqUj+8/cSarT+ow0pKLBYAdf18Ql6tY1RHRwQ/RjAZdYXORx79qQboGHhgB3ZcCqvx1wcF/xPxNCyMgDOkUm+FdAxLQ/gJHp4PSfV+gZYaRc3nvtWSlh3pTDZIdpAPHwVoosIAfEVkbp8=","authorEmailMD5":"8896c4a0d200fe2e2e6eed6f95c01434","authorUri":"","authorUserId":"disqus:burhanirmikci","authorFallbackAvatar":"https://disqus.com/api/users/avatars/burhanirmikci.jpg","message":"i didn't either understand why glkelly would do that, but just tried to speculate about the reason. (: doesn't the following continuation help offload CPU-intensive operations from the current context?\r\n\r\nasync Task FooAsync()  \r\n{  \r\n await Task.FromResult(false).ConfigureAwait(false);\r\n\r\n // CPU-intensive work?  \r\n}","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"32c4a065-3067-32ff-a62e-edad17a880e7","date":"2017-01-12T14:40:20Z","timestamp":1484232020},{"_id":"934d6c81-ef03-3545-854e-c11ff0418777","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"No, it does not.\r\n\r\nConfigureAwait only comes into play if the awaited task is not complete. Task.FromResult always returns an already-completed task, so the ConfigureAwait doesn't do anything.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"49f179d2-25b9-315b-bcc4-7ebf3faa2bcf","date":"2017-01-12T19:32:07Z","timestamp":1484249527},{"_id":"c536d982-5f4e-399d-85fa-8e6408f8a7a2","authorName":"Burhan Irmikci","authorEmailEncrypted":"Ew5J0A0aYkZt+EWeAKpFpX4jDOPyduiLnr9FLqbJXcrojQBp3mh4w9x4bsKKv18BEPkw7xHX5bqxel/WPyFLhDx8RaVWiNQcMcbiOcGEWBngwqLdwMqBsuvKhUBQp+122pKoT29w0jcxRa1TnQb4NcH5PkNO4fkDrrgGRkzMKw2b0pTsfo+yEEAzuv0+d1oC+MYpViMau+oYWsxR6WNbQJUSWynee9qut31qbM40bSJo3cjTHudp/FKDIuBcALb2n6PfL7qXydrRU98VEi/DWQUrUepmDUYi+LrGSzI2awbdIVm1Le4E4/0Jsm9jMQG6D1Wj2MCrUDdth6tgKN3grSE3S/emJi8uI9KYD2O2sYSGLG0V0OmqECpeYt2hdIyElh2rZ/zAhzHi79aiOfKSSO/bsEFLYGY5BfMaqNhzu/n3+Rnrz8bqgWSqRl5i3MXea3NWEZr4bw1pYazINZIajKy0tlQUZwjx9AhPylcUWEKxdGs+a3wf9qHLJ+LKmX2teyZe84IwpgKDrqNh/bbK5I4VV09zM6nS56tFyiiTJBKWs+1EpWvhOpObQVasgKDcNxfKgFvtErqwlTG/4l2tdH0ltPawyKBnacjRoDEZNypbvxc6/ZaQ5yhn+hrkvNiDI15MicFe+ATIYHejlXd/aX7+WDiNTyb1uj1q4UvvGyg=","authorEmailMD5":"8896c4a0d200fe2e2e6eed6f95c01434","authorUri":"","authorUserId":"disqus:burhanirmikci","authorFallbackAvatar":"https://disqus.com/api/users/avatars/burhanirmikci.jpg","message":"i got you now, thanks. (: so, if the awaitable's result is already available, it continues executing the remaining part on the same context. great info, it seems i forgot that even though i read this blog post with ultimate attention more than once. (:","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"934d6c81-ef03-3545-854e-c11ff0418777","date":"2017-01-12T19:55:59Z","timestamp":1484250959},{"_id":"5a12e7f1-3ea8-3b75-ab8b-ee4321146b2c","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"If you have sufficient scale-out capability, then you can use the less-efficient synchronous code. Using asynchronous code all the way would be more efficient, but if your company has the operating funds to be less-efficient, that's their call.\r\n\r\nSo, either synchronous or asynchronous code is OK, depending on the application's and company's situation.\r\n\r\nHowever, it sound to me like you have a mix of asynchronous and synchronous code, which is quite odd. This might make sense if it was only *temporarily* that way, while moving to asynchronous code. But a permanent mix is not a viable development strategy - it's probably just an oversight. I would treat it as technical debt, and make it synchronous or asynchronous eventually.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"a9a7469a-ee83-3ad9-b2ed-262cfd982ace","date":"2017-02-02T13:58:10Z","timestamp":1486043890},{"_id":"a9a7469a-ee83-3ad9-b2ed-262cfd982ace","authorName":"Chandan Gurjar","authorEmailEncrypted":"C2MnHKTf5vrAXZiI/6cnyKR6GkLxc0Kz4FzoX52FbUVixvLWhDhM89if5SkybubplAOXk/9c8Wqu5WKXO/zxzHASLwRcGrjKtaqHfT9ydbXKlWOh4htfpqWP5KQLEofV1CG3erT1aOS4WQSHCU/d8K+8Asr71YCtWWxdi69m9iGDqwbWYmBr2MwLd92adXp9vwjBsQD5I4tG9OvBsRcNFJ+ktdmTsGmoeldX/VysIJ4tHyzHzyovk8sZarWFlWQsSxOFVue7rKttihPcyOPTobdDTwmeGKCmjUSMADA+fwbkCmmV2xAbcQsnNDiWsuROKyioUphqnRCjEzDCH9J70ZrJSi+uOxi6VyGGzYcEsfFp7tFn9Jt/QF4fNPs/NpwHZuIa7kfXX/4rltffbFROKXWt/Bs9mXY78uiO01bV+CsFu+mGJaLBB28fVCEJHRG5t3e0RydIzyGtjXCjLLtzCCZ3n99DvhoMYKsvGZypmog1P2CC408wOpfEnAdzpe0dLMUGOefWBVNJrFsoNqMNDmXTtYYURbuNJPqqRPueIaPuiTgV3krXCbfL8uKoP7PYuiEdZx1GqOp32ZpDfUDurc4xuhIvYQY2j/Fcw70nSrNmmGeAyiM3tPKdBEANKHTRVmrubHlUVQBwui0C0/XUEzHaTdPCx4867RXpdbHAoMI=","authorEmailMD5":"f40d82cf0c8e510ab553cf72c5b46551","authorUri":"","authorUserId":"disqus:chandangurjar","authorFallbackAvatar":"","message":"Thanks Stephen. Your posts have enlightened me on the topic. I saw a lot of blocking async await code in our app by either Wait or Result keywords and when i pointed that this would hamper scalability by holding up the thread for IO calls, this was defended with statements like \"There are multiple boxes. So scalability is not a concern\"  \r\nThe app here is a web server that needs to entertain multiple requests.So I got the feeling that non blocking await on async methods were being treated like premature optimization kind of things and waiting (blocking the thread ) was fine as there were multiple boxes to help with scalability which in my opinion is incorrect as it does not squeeze enough juice from the boxes. Just wanted to get your opinion on the same","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2017-02-02T10:28:39Z","timestamp":1486031319},{"_id":"e102ebc2-9b8c-378b-94a0-589071e1aeb7","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, this article is still fully relevant. I refer people to it almost every day.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"ea8c8769-497b-305e-9bc8-0125f06e877f","date":"2017-04-05T13:40:50Z","timestamp":1491399650},{"_id":"ea8c8769-497b-305e-9bc8-0125f06e877f","authorName":"kiquenet kiquenet","authorEmailEncrypted":"cZLOm1vOJX7u4vG+c1Sjedxm4uQps+F7AVigE24CRUiWHuDGw+zuUUsR+vICtonIpnBXFNvOaHc5P+SnC5b5HWbAW1LeEXikq9C+mcALKfu350Xkh3aCHAnrBmOiNZEv56dvzhkpUl9uO9hhqGXswCEEyNcuZ7lxSG3CEOooJUyV4m4mhP4lMFa859g9bYnxydpsk1VGdGBNd2JWHgHc69o7xSkoAty/712jqMfpu0eKOiU/WMA7AwRbsE4dn9ysYgzXvhMrOOhBdTVGLAkkrLjFQMmO+0IYSMWX9pETkwSb+jDEBmU5X+xNPCi4KbQeGmdCSa6r7xGYIgjWzxkoVcWXbBaib8RkWUiBlx04xycwPZcQ4HCxTKqV2ClOUecA4W9aDwKfmbTztDFzhBsEyA6bhGVuN8dLK9jZtfdtEUSqHpBJNvIicijYYCPZVs4Of8cF3ypPIHaRsrflfK7uxyIPtoSWR0h2KRIxG5piAFLJ9AM/nwtrA2gcreE1G5MDfll7LN8m+2oBtgNuwLh2U9xbXWyulptw1DbSF/P0Is9a3SuyowItzNvJQxE1UhULDi4OpzX2g6kRieR0l/lzvmv3soxFr1J+ZJkYDKmIWsEF1poOESWcITP4TxOW3sFJgmppyYUMoeVsS6HGVsC+W5g/7I08DhK9cj4ezohkPDM=","authorEmailMD5":"d1f1b733c6a24d56606e7ac535e27545","authorUri":"","authorUserId":"disqus:kiquenetkiquenet","authorFallbackAvatar":"https://disqus.com/api/users/avatars/kiquenetkiquenet.jpg","message":"Excellent article 4 years ago. Now in 2017, which are the Best Practices in Asynchronous Programming ? Is this article excellent yet or there are new excellent articles with the latests and Best Practices in Asynchronous Programming ?.\r\n\r\nMindly notes: MAIN target is minimize learning curve \"in the shortest time possible - in as short a time as possible - as quickly as possible\".","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"bbf339d4-d084-325c-9ef3-24e77a83f657","date":"2017-04-05T08:51:48Z","timestamp":1491382308},{"_id":"ea8763a7-b96e-36ad-9e00-61a2e3ba9352","authorName":"f3ck4r","authorEmailEncrypted":"ALlXz16kuqpsH2tK8vChud9srxzJq7zlApea3NkDdOLErQO95zGTYNGC0VVQPkfxLQ/aeI3KYTQyVZcCDQUyhBsYYXzfX6pW3ocs5N1gqoFGYG7GGL+fkWO2dVLFEynQWiHZLtfZq9uQBtGkFtW1iWrDzwCgJACpwxZaIhth8xJDv0pHBXgNbU12lnjIwc6uYZRNBBYpLw+ywxMVDzDoC9QNiLMHovk4x6QxEUCx+46U43sLv1+znImz5z4vYoZXHTD7eMvFd3Nm8ltbbSCDqY6FF5fRQuW6WH0qFTUO+d15K8bK2xVlZTmJE2hGdi8j1mb8AWFMHgIFpHvdBeVsLgjNFQyhdMWPep5nxjxlc7zBM0XtWyt03ZHutM484qo2+pVK+jmRxbzVekYjrqTw6OA0SqwvHfvsE3GRRebwmZzjKt+5/3b4iNXeKQkY48DhkVTFBrd60r38OA2K/ydf6aKrarpN2qONfPQP8NqB3+cv+ieAF0PMRmY4mOWvfa46cWijjraUcT1/nKnTvKr3oFnNW+ENicWVAcaIDsjHlCLRh9B4yDDa1qVuV3Seg/YTzSqQLmy7ELomUcwWfUF3ztIjHMP1o7JTTAK/tyC3NmbYA+mbhbcY03Cu4HiZD3DsxOMB6+SCBSHXqBUqW3fYvs8IB6TQuE2VPgNzz/wgVJ8=","authorEmailMD5":"28069875c50014a0178699be916e1d71","authorUri":"","authorUserId":"disqus:f3ck4r","authorFallbackAvatar":"https://disqus.com/api/users/avatars/f3ck4r.jpg","message":"thank ya!","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2017-04-21T14:25:06Z","timestamp":1492784706},{"_id":"6168f416-1a56-3e20-8288-41331078d043","authorName":"giulia gualdi","authorEmailEncrypted":"qSdL4ftH0XrtZfvcCHroLHohc1KEc4n98tSOMMbV08hztnyZ9dLCVdx8SE/4ZLa7lcJ7NMIbzMpgzrvpBWP1HvHwLG/LSQmh0LXuhQlHX2eYlvmsq7rKHMNABRB5MICQozvf4Z07efAjOc6bmn/yu8F93sawF/9KD7joEiZ3CYjyDdJpgUV5Z1c2DXlkCWNEhJsOUiY+8bKrli7Z6bjRuOzR72BHCYT3fxWfZxCz1n32oL5jUs9CM1FZ75WYYKDSM9ftIWRV//CydQVpKS2nau6EomnvCssLf9ZaHf6UN+n8C/hSq1ZxKL7HqLEieVPwwqFKIoOqGBSkLmLHaipusRgfDESbg5fcAQWZSJxYqJ+WbutYFEsMmZ0/vTyBYoG0IHB2aeZy43h80+RhmAcNCI6qK9r60Xiqm6X3XPBhG/aUFaTjMptQBJ9NkEAYcUqHDtw1yC1xWeDjYTAc2jWIdZIIl0krwGHgi09P5Ags4JH5H5e/LSpB69IqdDESb0ekjEhRAxl51S4tTMc2Yvid9WBpyoCwSiAEGlYF6ql16BkLvcb8hnJjrG/fkk770oHppmRYt7jsBejRqxHpJfaTTVpADE35VV7ODeuWQQPgWkZklrG0GqpniudqYc465D71DtW2UYrMSdffDbWsj9A+nPSu3OFU44HSJTJ6r5exAzA=","authorEmailMD5":"9735d2c2dfabf8d681d31dcb03135678","authorUri":"","authorUserId":"disqus:giuliagualdi","authorFallbackAvatar":"","message":"Thanks a lot for this great article! I am trying to get a deep understanding of asynchronous programming so I am reading lots and lots of articles (mainly yours!).. However, one thing that I am not sure about is whether the guideline of using Configure.Await(false) whenever possible holds also within a .net (core) web app context...as far as I understood from various readings, in this situation switching threads (i.e. offloading) could actually harm the overall scalability on the server side and should be avoided most (if not all) of the time. Furthermore, it seems to me that, within a web app context, it only makes sense to use asynchronous programming for I/O operations which, by definition, do not really need a thread. Is my understanding correct? thanks a lot in advance!","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2017-04-24T13:21:02Z","timestamp":1493040062},{"_id":"7f1af948-648d-3f77-a2fd-a157340b5b3f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"For any \"library\" code, you should use ConfigureAwait(false). For \"application\" code, you generally shouldn't.\r\n\r\nIn the particular case of ASP.NET Core, it doesn't matter. All awaits do not capture a context, because there's no context to capture in the first place: [http://blog.stephencleary.com/2017/03/aspnetcore-synchronization-context.html](http://blog.stephencleary.com/2017/03/aspnetcore-synchronization-context.html)\r\n\r\nSo on ASP.NET Core, ConfigureAwait(false) doesn't do anything at all. It's neither good nor bad.\r\n\r\nConfigureAwait(false) does not cause a thread switch; if you did force a thread switch (i.e., \"await Task.Run(...)\"), then yes, that would be bad and harm your scalability.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"6168f416-1a56-3e20-8288-41331078d043","date":"2017-04-24T18:35:55Z","timestamp":1493058955},{"_id":"123fdcc3-204c-3c18-bbd2-adde7503520a","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Your understanding of ConfigureAwait(false) is correct, except for the thread switch parts.\r\n\r\nThink about it this way: await will return the thread to the thread pool at the time the operation starts (this is true if you use async all the way and always await immediately - but close enough for a mental model). So that thread is gone. When the operation completes, there's actually a thread that performs the completion of that task. await has an optimization where it will try to continue on that same thread, if possible. But it's a question of whether or not it can continue on the thread that completes the task, not on the thread the async method was on earlier. That thread is long gone.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"b46f9538-58c7-39b3-a661-079eb12d59d7","date":"2017-04-25T13:49:03Z","timestamp":1493128143},{"_id":"b46f9538-58c7-39b3-a661-079eb12d59d7","authorName":"giulia gualdi","authorEmailEncrypted":"waVcoZnfkrTlLZIx0wdDk6wucf/5PVU2oYz20TuEYKZG4XWOxw9RB9LOLfuEn6paw4IsCDcTm8JUn5XEyXF9weADAJCnkrcmM2sGhPIbLXuw+bLvDfPWZK7Ts6SQVjAUJTsQKRjLPdnB4sK0LGpPdKxoU59n9kiqUccM5PfIspsbKZ+fAExikNIH7Y80mW7sB/WVJ1so28IRaty3Bv9SBC07xYoT9hBQXWXXF45QDE18de7kDuv/xMmFCkUmo4Psg3KfzkCxpudg7MVO/+KGLyxea7ByVVyiczts1ud3Cdx0gUEbyAKBZfU5vubfidh/5oyvJVkZ6UKTDGNWVvZCfexVrtdThd4+8hWRdm4NcO5jhcocnNMzSLhGcTkiIDwWpN0hOzA2O5bhVWEyJtA2Ug1YVshb4V/21GUWgv6a/Y8ozeXDVXCYhE+ryKlwv86g+/nYkd/7c67uIEEEf/152KFFc/Vd1Boio3Yi0DJ3jU0lPOwRAZMkP6qKye1nMeMP6jKzW03mZckhNN7BeLznkL7nNae3CWWFHasKmW1KYKqrmkPozX6iswmg4H9Ns1lib40nvFdadQu7Mp6RbxvX3E8jnYFbGKIlC00SZ0iQt3Lds9/rk/PrS+PDvYffT+tlZgPaUQPuScfi8IcMpJHhxLtKJqBXqSoz9HLMfQh8JPg=","authorEmailMD5":"9735d2c2dfabf8d681d31dcb03135678","authorUri":"","authorUserId":"disqus:giuliagualdi","authorFallbackAvatar":"","message":"Hi Stephen thanks a lot for your reply, and for pointing me to a relevant blog entry. Just one more question to make sure I fully understand what you mean: I understood that whereas Task.Run()offloads the computation to a thread pool thread, ConfigureAwait(false) only says that the current context can be ignored and, as a consequence, the method can run on any available thread. In this respect the thread switch is not necessarily implied but could happen for \"internal optimisation\" purposes. Now, if there is no context to capture then such optimisation is not triggered and no thread switch would occur. Is this correct? thanks again","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"7f1af948-648d-3f77-a2fd-a157340b5b3f","date":"2017-04-25T08:50:36Z","timestamp":1493110236},{"_id":"67f34e8c-0bad-39da-87c3-366cfff8193f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The \"thread that performs the completion of the task\" is a temporarily borrowed thread. E.g., I/O operations do not need to block a thread during their operation, but they do need to \"borrow\" threads for very brief work like copying data and completing tasks. Most I/O requests on .NET are based on OVERLAPPED, which will call back a completion method (on a thread pool thread) when the operation completes; that callback then needs to complete the task. It's the final step here: [http://blog.stephencleary.com/2013/11/there-is-no-thread.html](http://blog.stephencleary.com/2013/11/there-is-no-thread.html)\r\n\r\nSo, the optimization is where that temporarily-borrowed thread (which just completed the task and has not yet returned to the thread pool) is used to continue executing the request, instead of switching to *another* thread pool thread.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"a151155e-8218-3fe0-b240-490bbb1ca724","date":"2017-04-26T13:53:44Z","timestamp":1493214824},{"_id":"74c4b8b0-7bfa-3edc-8052-232ab79ae3f1","authorName":"giulia gualdi","authorEmailEncrypted":"Yy11OkPMKY2xX/WD4aGgcNtEmpw+yRY4PW5T8xexLw1iFWiI7Z4RUBF8HpZwA2kNAD53iMfyYEXa11cfxFwSqMIM+RiwQ/o30XfoEMhaazXEYqX722MeuagAWXFq4nOpqq+dA7D1q22Qk8IjMnCVtMz1rqELr7oYh+P02LFS+k1mNU8ESZMkKds6bQj7xKkNl2F/mka73nxg3Hjc/nXq8BRleLVkFh0BFfWvLAO0d9CYQIsSmlFAn58WiY7jCkfn3ZVh+f2Hf0M6vMhHQgKrOjkesnxcotgNPFCo1iGgFuECMVVzOn2xdjJd6Li/61DBJPmeq9/+Bp8GnfQs+RajpSKraSDOWbCeOiJDg6Rkse6wrz8kklTPG5Xjk15jiKrzOvXH06IgU8IUa8SWzxzLcOzK5CdFb1dTLYZrkA2FlJzRyRTpzqmHPPuLexbzopRtV3C/uY5Nbb+0UMz716tw0lEEO8XihXWuj14UkFpEMINZ1sjDPjRp3qUR5DELu68cWzSyF9Qvg8lOa989ABGs9JXh+/FBz8HbpkOqnYCZHDSEmZjVC9O8fGEkORjOqiqbs5UJYU6mGz/kzqLUdlXeFzwLlUeNOeoZXdTnPYqYUa+CuSewHlkaMbyb3ZQYsrm9de25iuWXhRbFRBeBJfhNDmrMOtXglIPa8Rg+0p2cJ14=","authorEmailMD5":"9735d2c2dfabf8d681d31dcb03135678","authorUri":"","authorUserId":"disqus:giuliagualdi","authorFallbackAvatar":"","message":"thanks a lot, now it is clear!","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"67f34e8c-0bad-39da-87c3-366cfff8193f","date":"2017-04-26T18:33:39Z","timestamp":1493231619},{"_id":"a151155e-8218-3fe0-b240-490bbb1ca724","authorName":"giulia gualdi","authorEmailEncrypted":"ZaWkfAwnrtQmpmrs6hrJehBVkFfDAR4F59uT9tFJ3W83wQTfWTZ03T8E3hp1U+DmppD4/QGRZApDwr+Ogag6jh7UysTP/HpeIS6PdXKw7xdyK1wPwfFsWUKVi7JK+ezC7zyE9VfBl0XFtWmoBDkUneIG8GBNlydwemyNQjVh0FD95xi1WioyQvLFwPHauE5+OYldMUPhIsZFbJr69kDGBTja283EnfsBIBBkmFEjKOQV/8Wsc+uRIi4j5013mNyDR6mfWyg0an9EaACkx9WKG/3W0zlcNhZtvjRC49gFZWwJOySmC7EX11RJF5t6PD3CEAICquLs3FjPnwCPkU/bR5eJfem7WS1VjAkX+EQ+6VueLWerYafUHrWqiLPAK5wURplFvWOFoCHl7i/UXoUULFzUlFuZPonW63EQP1QYS3RPXFwG6277FIesQ7hm1JPHrjJqPGwy5gCc2XEKwfYraY8wP8URDEIudWePXnKKycngagOY6jMM6GnJ9N+/uyVXDa7ee3DyJJVTxpMeRxjjm/h2ckP5a+7HN1Cyv4PxU3+TdcLDeA/L3qW8QtxWHaQopJszt1JeTDqC9Bof0mF/RoEiAjCsJjSmELzzkKqky6NQiRVcIctZLsrcpTbTeEWXk2gdffSBsGPuTHT9XHiR8BUq0bLEoTucNSmcMQw0bWM=","authorEmailMD5":"9735d2c2dfabf8d681d31dcb03135678","authorUri":"","authorUserId":"disqus:giuliagualdi","authorFallbackAvatar":"","message":"Many thanks for your reply and for helping me understand. I am not sure I get what do you exactly mean by the thread that performs the completion of the task: is it the thread on which the async method resumes after the awaitable completes? If yes, then which thread is \"that same thread\" on which await will try to continue if it is not the thread on which the method was executing before hitting the await?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"123fdcc3-204c-3c18-bbd2-adde7503520a","date":"2017-04-26T13:09:13Z","timestamp":1493212153},{"_id":"0f85e92f-d960-3259-aee0-9ee2caa30656","authorName":"Moatassem Talaat","authorEmailEncrypted":"pGonx7x68ueeZ8hh2tLswNU2QQFO2qHG6HCWGbjMSVVXoVsAxwhuoZF3/BlwKF6hdlLQTf569j53OJzm7wn/mkbaYvdk8iPhw7pRRKFaretwPoc0e0oieY9o3kJYGJxyXlrtjv3BzeORT7LTG3DqIPi4/aOFKKJq79D0OcweiPeYORCkOt9U0M+5ovZWmOULu15i8Z4vY7ShR1EKFJTVvXXVH4Q1j2rIt2WcQqS1oyGaUqw2hI6ot6qvT55/1fvitLqIdUnyEQK6VGnLzn9iffzkB5lxfmsxlxYlr5K5IqofQ3TkxwxZ3CmCmPAZ434YHmN4ZfLpah8yBKjZSMQWJ1tHGsbY4yi5B1kso0Ef+TsiL4RixA9KmKJFqHF+wr5KX1waFvknwgwNFu9R4iovhZT3Xlk9ijhI7jTdVb3V4mtPZ5dSHL0gNviZ3L5qOZ+GYQUs5ef3cjCtbp8rk4egWCGgzRURf7vUeWLSnLwZDp16KqWNkH9cexfnVUUt9OH0ZqKLkQ77+0odd7Aesqmpe7XYCtJ4T7q9LyEZROvql+UzLVq0nQFD3SV4jU5yfdgT8s4BCHH0lgE7wFmZ3tr4u3q2O1s6rWI2NfBaj1Kx8VIcBS6QD0YWFPs0f/n2YjsBCAkCw2BCEyHpzq0KoZkmIH+FKIFmAN3emIc1CrITfaI=","authorEmailMD5":"ec0cd15eb1a697f97c2e98bf07a45ade","authorUri":"","authorUserId":"disqus:moatassemtalaat","authorFallbackAvatar":"","message":"Outstanding article .. extremely well written!\r\n\r\nThanks!","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2017-05-13T07:13:51Z","timestamp":1494659631},{"_id":"2d054d9d-6b7e-302a-acea-0c7cb5ab9950","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"You shouldn't abort threads/tasks. Instead, you should use cancellation: [https://msdn.microsoft.com/en-us/library/dd997364(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/dd997364(v=vs.110).aspx)","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"be6b4511-28b4-30c7-aef9-5ab376ba9fdb","date":"2017-05-16T16:08:04Z","timestamp":1494950884},{"_id":"be6b4511-28b4-30c7-aef9-5ab376ba9fdb","authorName":"Moatassem Talaat","authorEmailEncrypted":"trYjmzXftpRNt2kvKtYTstctQqb62R9B888aXjBbUHjADa7yCOoxFCGY/UnGXCe2nO6SzDRd8M1K9aJdM45T+10jYSjHJmOfory2L4DWYRii4h10U7AYjEqVb9YuLbprSTIva3VNc+MD54fAthLco9eS7D3CYIMqx7Jcj0IAb66ixLlv292/f/abR4QdhvtxGwP0d2+2KB07Yp3fASisjywXPne2+fVko1jMZXeILQXJBYCGXnyvLKDmdskFFiL4k0cfJfyErzh5TpENJAc9rso7+vA1AxRYybbrtHJE6qBDF6UmfeKlIImg/p0/uUijHFFc0Z0RdhduVWcQ5J84xD9fIcWGzQmffBAUEOxmc+YuWyrKPQEGikD45FA+C71kiXD9FLX0VuOXGHQfSXk4xeUreezL3mrDdEnwwr/9iX5q/OGT3HUgaLWmNnFY3/boyKqf/xvmeCK8J0XINMcV5pLnZNRmEIklMMuT8cOrzRHKXs2D8gEddWh60hBJVKJf22TsJB5bqf23/fBgOa5AnUn8NKOQV5hbxoCsC4bmaWIR9b3JYoBXJ4EIImbiwTiLCAiKHFSylkPpx2gFtUneDlA3c4WtmuC4V29Fx1Oo+7qTYbPB0V3FsKIKLZVonWWHwi4+960kCg55KNz/d2pNVNYVPaj+e9fs1D7EVk2Iyk8=","authorEmailMD5":"ec0cd15eb1a697f97c2e98bf07a45ade","authorUri":"","authorUserId":"disqus:moatassemtalaat","authorFallbackAvatar":"","message":"Hello Stephen,\r\n\r\nThanks for the great article.\r\n\r\nI want to understand a point please.\r\n\r\nI call from my main form (i.e. from UI thread) the following ProcessingIncomingMessages, which doesn't block UI thread naturally.\r\n\r\nI want to know how to \"capture\" the thread of context that is currently processing the incoming messages .. I understand that Async/Await doesn't actually spin up new threads but rather contexts. I need to capture the \"unique\" pointer i.e. the context (if I have understood correctly how Async/Await) and call Abort on it .. Is it possible?\r\n\r\nI tried the following:  \r\nTask.Factory.Scheduler.Id ... nothing  \r\nTask.CurrentId .. always same ID  \r\nThreading.Thread.CurrentContext.ContextID .. always same ID  \r\nThreading.Thread.CurrentThread.ManagedThreadId .. always same ID\r\n\r\nPublic Module Stack\r\n\r\nPublic AREvent As Threading.AutoResetEvent\r\n\r\nPublic Async Sub ProcessIncomingMessages()  \r\nAwait Task.Run(Sub()  \r\n Dim X As Tuple(Of L4Type, Object, String) = Nothing  \r\n While True  \r\n AREvent.WaitOne()  \r\n While Queue.TryDequeue(X)  \r\n ConsumeQueue(X)  \r\n End While  \r\n End While  \r\n End Sub)  \r\nEnd Sub\r\n\r\nEnd Module\r\n\r\nThanks ...","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2017-05-16T12:28:29Z","timestamp":1494937709},{"_id":"159faf1c-4ee9-3031-9297-2070ec102db1","authorName":"Olaniyi Falomo","authorEmailEncrypted":"XCappCY64vGRUFG1+ijexDVA9NGs9avBmrj4+f9xYA0aczhzS2T0U9Pv+fx6my0Xdwr5M/B6CsVz8Q1KrYxLZNeun4s2PBriJWNBoZthw2cerI0Jeoc8Y+pZpMr6r6ktfTkD+M3projlU6MSK82SYh8K9m/GG1bJ47Ii3mY0eTX6W1XiBAAeXRZhEYrJTR1dks4WNvT8OTZwHHzKUtUIa+LzSWJ+Or541lVNRI6HcsIidd39N+iMsW4ferYlcTP7XcShXdPOlCk/HyL1+RBvxM0/gvYB4JUqZ7LJyWa2ocmC0GA/fmnTuU5O8IVJBL2Wn0O5QNkv8SnLa4OqPsFdyIrcE8pBPWdA7IYwWkO4wMtpuSdQ9D6+3avxQMuNlp3IMiBTh5PykIZzczdqoAYCVDc8mZjbJamQIng9VRNxJAhQwK+Ds8iPkGC0yhdEgulttwbCuzelz8CNTrx2yR3EWE0Q7vwdx7VcS0tz0EQzFdR3/iiSNNMjVhG6lziJPfgZ7CxdYIv7+Lb99UPpwa1pwOQYqQzVXiDJvPyrGbmNjLLalDbFQYtr6QRpt6I6eUpJN01mXWtmHM1aedET9X6smCAl/CdUqlC3AQmmsMIeZfvmgwW2hkPH7Hm6deLFhsALt2Gsmz6LSwnHamaLwb1PDLFHJ+EdY9+aFZpY8wH2zK8=","authorEmailMD5":"018195409adfaa025483b4419a1a9bce","authorUri":"","authorUserId":"disqus:olaniyifalomo","authorFallbackAvatar":"","message":"Great Article","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2017-05-21T01:23:01Z","timestamp":1495329781},{"_id":"f53ef692-8ed5-3438-8417-302bd8c6deb4","authorName":"farooq","authorEmailEncrypted":"Z6fFSuIJSUfajw/p3RempxfnWEKia2mnmZcoAdMxduGCe0+3VSMtksnx/IVWWR6GkSHG4b9vGRtL4s/ZeUd0cLrjlbFE2Fpxh/V/48JMuu9Xl8933Y0Y89DYwDb+FwNtS1HcJ2p+/hCVXCUGPNQKoUEWVlcIM5TofxLe8le9WUOTQUiA/OBoqkiJjXHprLqruNqXeuvZrWpGOa8ZrovSl8aBml8b0rZqUfawSvwyjCWC54xKF0qeme3q7zSZ+vj5SiV4qY3BQlnIgomneytgGB1AI1nCwbTYDe2fk48i8gcVgRBi//ahP+cfFAglMcM49qRyiNoUD6aux0iCu4pFxHZ3UZGOm0vHpYtrMfK9bKFjY+wTMKUMRQ68c40g4Vh5RgZ55MJZowArjHS4Nrj95eNl1ESm+0ATdETSLgUF362oJDeeiiOWUSXw6DhF4NsG7JiLcMPAvCpRMdOmhQE/anwyFyK0r3YdVDf5AQ8AfL1OiivGN4fPk6wdO4UQov9DjmSwwLtAjCInSRnoUAODwK3oAIU7p+hMh0QsxZIJinnA3TgW40UGYoeEZX+uuuEi221Nzz9kcg80jhnLLhLaX/PaIt9qNKyfxkgHa1+YjNYU7hr9ang8KaWxgOGcfmK1+DrLPhewYyDWPLHG6SjVnxuDiFJd77BYe1c5sumBbWM=","authorEmailMD5":"bcda65b54c74bcfbf88a3d52dedb713a","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Stephen! A very well written article. Found it really helpful.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2017-05-31T15:06:20Z","timestamp":1496243180},{"_id":"cca5e624-1451-308c-a7b0-f5ea69f62222","authorName":"howiecamp","authorEmailEncrypted":"itfWS86g+RUKt2Rufi05Ha36Y92gvHRNoZiqJec/O6AVgrj0kFJiN0ipGw50GhHd9toNJ7R8KHti6YsSv/nsvnAIl9CTz+7LFh/rTnHOUZWDg3UYdEo1VY0cREC30Ww7WtBpI66oZ6BlSO1P4CDLke7gDlGXpeLa0m1dkGav5vTDc9SKSzutPs/5x0CWK9xRin60etY0gslg7RYQxx4TLQMHLuTuZJhqKOBNDRtrG8y89fyHkzrJOYoXdhidDp6Vzh/LZA7xJzYklsPjwOQ8JxtLk4X2ZDWqTmVMTJTZL3ZN6EecVKBBPsK5tT+MOLO3uVZi3W0n1uqpwyhaPZxYfKE//VqHsb14iyTY50zKumTpqanIbPk5oRE33bI9Iiy0G4L5UNAVml3/UI6UrC1+QEtKucL4RrUmIgmugmePKyZ/Dbx9MtaI0jLrm/Sj7ZUj/FgnYG/tB1TVYXSe7z4N8NcIP0UqUwjltgtschClHy29lNyjPLlovV4SV3AmHBF6+z2zygFODI0M3scBLUMait3mymsSz8m1af0yEXJNhk+MDkRczpxLpc/H6P05t0w/zkwTLTzDlKcdzkHVkplWazeqoF7J/CxWfIy/HpCCS2s+ZoKdnYmRZ0Mie9lY+hVo/tPnhgkG573YI/R9FQYkYZk1BZTOUigjU7Aqt4+xKfs=","authorEmailMD5":"3fed1441db01470ad63a9361a9368949","authorUri":"","authorUserId":"disqus:howiecamp","authorFallbackAvatar":"","message":"Using ConfigureAwait(false) when *not* needing the context implies that it is less efficient/higher overhead than letting the automatic switch back to the original context happen. Can you clarify why this is the case?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"6afb5f2f-35e3-39b2-a0c1-c48acd3806ec","date":"2017-06-01T17:44:01Z","timestamp":1496339041},{"_id":"b488870b-1449-32c9-b121-2abf12a94360","authorName":"howiecamp","authorEmailEncrypted":"PDiUyR3D02xHQX2rSTI3X/WlOhs52PVXvPZLHvkoJRHflQ96IP3Xosz4akdP8VdWzwdLMJYMCMIWdLLhA8P3yu3/HucGDN7PPR/lwMX467Yzs4ah5CjCYgL6Rqw1iD2czjTy1bsmUWqNmhW4vBOIK30nM4w4twQIdMIJLGJ38e5o5hDAnfDGZc5T5UKREIS//jexefBHoH/RfeZl+V+6h9fEuX0AL0yg21yzDcr7iCbToHhDg/SyiOFPpVPIWKH9WlehjXyIylU2oKgweqZZ0wl35SssYKTVHB6Or8aQRsjz79iGdy3nGAhrMQ4+kQn5jGtKyUeDYMHyKffIghpgeFKIHHrLEs7hAqndKflRBSWq7D62a63W8tMjbwS4Zse2eYLHFE2DEL4VwNNCzUVDrRSykzzHRhR6DIKaSYds0acGNlXgJA9YZe4l+7cEXb6XUhqZWamq1Sj7jEvu1esBM9FplVG5GgMGwJD/ndje/8Ajkmfl4bRgha5Kt0v8qEq3iwi8evWylZprslkVO/YFRF/l7X30O41JAtl2No6vCjRfJF4FMO/khNRCrcVRVCYH/djzA6QGGo8SifeaoAYt4iz6svy6KLdBbdXxM4OQa8aQBqio65idMnB69h42Qfhz5EUfDvSRCozk27PYEfCLiiC/KXoq45YihOeD1PyRSrE=","authorEmailMD5":"3fed1441db01470ad63a9361a9368949","authorUri":"","authorUserId":"disqus:howiecamp","authorFallbackAvatar":"","message":"I stated it backwards. I know that the awaitable is executed on the calling thread, e.g. on the UI context. But then I've read you say that if you don't need to return to the original context after the task completes then do ConfigureAwait(false);. What I can't understand is, if the task is already operating on the *same* thread e.g. UI, then isn't it more expensive to *not* maintain (return to) that context?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"e72dfb0d-8db7-3d62-95de-fcf66fadde73","date":"2017-06-02T22:17:58Z","timestamp":1496441878},{"_id":"e72dfb0d-8db7-3d62-95de-fcf66fadde73","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I'm not sure why you would think that. In most cases, ConfigureAwait(false) would be *more* efficient than the context switch.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"cca5e624-1451-308c-a7b0-f5ea69f62222","date":"2017-06-02T13:22:17Z","timestamp":1496409737},{"_id":"85c88fec-8d7a-3539-822f-6f344e6ebfcb","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"No. When the task is in progress, there is no thread at all. It is only *started* on the UI thread.\r\n\r\nWhen the task completes, in most cases it is being completed on a thread pool thread. E.g., I/O completions and timer (Task.Delay) completions are run on a thread pool thread. Thus, it is ConfigureAwait(false) that allows the async method to just continue executing directly on the same thread as the task completion. Resuming on the UI context is what causes a context switch.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"b488870b-1449-32c9-b121-2abf12a94360","date":"2017-06-03T03:53:56Z","timestamp":1496462036},{"_id":"a2335ec3-165b-32d9-82ad-a616eb4de913","authorName":"Sandhya Rajesh","authorEmailEncrypted":"uHJCu4hYMoKdPDNA2HS9PdWrLULYQBIVZKW9SU4SKEIDliHB60EzUzB69iC9BzN+Xfgub2LcgNwUjB1+wM5QrfeRzIAKxCoIay2JZy3pFybiOqoCTAZb8hyAwuSI6PX6syXr8fTIYV0G8MJu7NImDgtWuOShhlHkDakiVNCZb3AsBNP9OL6kVb05hAm53E25DTwUEFuwxpkrItfltVLkcfXIrX+f9OMvgmOHYW9qYNUKppilMB3vps/SmDoWjRTVSpPadlEvyvstwsMIA6hLM1DaW/X/iydgahjjmGBKtA34YYUXUpIhRp1PXywtLIjKBHHF4I1UA7pXKE04D83NsCrdYR7vRy3gP7j1mpKhVGWNskxV4Kv8DZ+RQqxfuPY7hH21rM5kXtbqhHzAMy0Q8rd2V1/f6OH+mS+4uxUw1YA1TE6F3LXAODPN8RiQHfCf18wterx7rqWnNE4p9MPdd3JBRiWoFb7g6uy26ZnV+98Ccks4e56NAyBgb8CYNDKoJEoNive3brlIfQzlthDNBMAvokNZqhox16yM9TBCZc1oYiXztJOjo/dPjEXVF2omhGBX7HG3ac/qFN2fv95svP1ES0yV+sLUi5fjuPLzi1WWvUIoHsk/cCTvt2wRipG4Nq++EhLy495YuyDvfhEbnvrfIVopbnPVsWQGB+HhCmo=","authorEmailMD5":"4b69054b1075246294f18c65becf7f89","authorUri":"","authorUserId":"disqus:sandhyarajesh","authorFallbackAvatar":"","message":"I'm trying to understand async programming and I had a question. If you had a function call TestAsyncCall() as below, would one thread be used to execute DoSomethingAsync(), and another thread to execute DoSomething()?  \r\nThen when await is encountered, it would wait for DoSomethingAsync() to complete and release that thread (while also not blocking the original thread)? Do I have this right?\r\n\r\n public async void TestAsyncCall() {  \r\n Task<string> TaskResult1 = DoSomethingAsync();  \r\n string Result2 = DoSomething();  \r\n string Result1 = await TaskResult1;   \r\n }\r\n\r\n public string DoSomething() {  \r\n return \"synch\";  \r\n }\r\n\r\n public async Task<string> DoSomethingAsync() {  \r\n await Task.Delay(10000);  \r\n return \"asynch\";  \r\n }","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2017-06-25T13:48:19Z","timestamp":1498398499},{"_id":"065381db-7992-309e-ae10-54eef9620c5d","authorName":"Sandhya Rajesh","authorEmailEncrypted":"kDz6rC44qNexO1WAATqktiv7gM8B+NdQQFM5TR3U3CMGziGYwxQVfX/u66umiWNbkgoadamnpeGbjxZsjk40FKhJ/AZEX6+FqeVRIsY1pvYrRkn2r7wiDX/fG1/mw4gB0dhB9ibik9Xj+z1h6WhgNJQR+oQxp9PHD724U6fSFJcPP/ddvZ+DHV0CY+Taab0/HOGNaMmnUzRzvLclGsjGl17CDcebLbr1KFfkhbMX9t5G+DTehu0y5yh4rkzgBPbkTxtQ9Q6xP2CkF0DovkZgs+fhMkoAdyiuze1N58KjMOTGmkCQ+X8MeJqx986kEjXK9amVOQusaZUyVPxdy9d3fjd1akZPaYzqxJCtiXVomp1eXMTOqId/T+xBtQ6b85BOyZ0G+d7cm7DhExmZoCWz8jJtsVvOY2CT/pQjNEMaNJdK4idUj43YywjVSRYJ4r1BIG2dKcwqHGadT9iXNJ66NbO6vdJGEp8x3kYWzsf38IPaTGJiudLOxTvKFUHBSQOCL5jVYz4rjzT1GvCsz4MmlOj6se5079a790SDO9zvNvgh4ngcMMdkTx4OoY60JmdcgyWpSQ7mKs7IJWXKBoOKPovEGc+bnwTdhzfNmdNhfpBqouHfn24U3vv37M753wYEC00faBLFEwI+Sthg9i+3LgTXZHa06eiHbFofdGTrcTQ=","authorEmailMD5":"4b69054b1075246294f18c65becf7f89","authorUri":"","authorUserId":"disqus:sandhyarajesh","authorFallbackAvatar":"","message":"Ok, So if button on the web page calls this function, then the button click event handler and consequently any other function in turn that calls TestAsyncCall will need to be marked as async (in order to call the async function TestAsyncCall)?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"19c6e292-2590-37a4-b222-bbe351d83d91","date":"2017-06-26T19:57:40Z","timestamp":1498507060},{"_id":"19c6e292-2590-37a4-b222-bbe351d83d91","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Assuming TestAsyncCall returns a Task, then yes, ASP.NET will (asynchronously) wait until that task completes before returning a response to the browser. Technically, ASP.NET is the caller of your action method, not the browser.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"1c813166-4a24-3669-ae19-78950d458e13","date":"2017-06-26T17:55:05Z","timestamp":1498499705},{"_id":"1c813166-4a24-3669-ae19-78950d458e13","authorName":"Sandhya Rajesh","authorEmailEncrypted":"nmSgtBMxMCxIA+KXoOiHw6svcfvHy55VWKG+pQ36e5Xq8ahAFXh4oliePaY5qztXxUI0T1YoSxpc7pSsmLT9jocpDUoWde9CRf4RujvsYRmLT8XU4MiGQJKN+ir3s22qNw3SEPXkt0FtWJi+Ln9JMwLtXCGx9cxFsnTGNmJvobp3AZ0r1+aEFGqPdMwDMKjETw9lkeneIle7xSL6h5pHm+fcA2/ttI9d8dJlqVA8gik6pCXtPmj4QRuvX5mCw9qylIezb3PgMEl/M4QVDPhTKAdLGszSBjSIz/1FEgYxcIFOcZZg66YFl4tGQBinmSdSKPGqZegMfJqh+LI340glPIPE5iJzzYzloAN05FZw/nEJRTgoXxPfp0drzCfx4DYOeWsS94H5NZnCokQLDpX+GRYpLENIPeWeqaOweUUqTCIkmRW2+l+CzQkCvzUWLjKNETBJL0++XTKGcTb3bEJc2kpbk09EF3UJFmFEL6AXmQgvqauFiiU2IcmvzblOe/6pUzDO/DGDRm4PhdI4Cwj+tlBMYZRZH2zD4mmS6vUfWBI84MrQJ6eVe+UFyjJIqCfD084S/w+JPgkvrdN4tGFmoyyCxWTXzQHOzUetBOBz70UE0HtNWN4mohU460IOxwAsA4Vcf9UIAcQBMrMi3A9Ud/JBkDGPmVM0ayGZ4Nr7RqE=","authorEmailMD5":"4b69054b1075246294f18c65becf7f89","authorUri":"","authorUserId":"disqus:sandhyarajesh","authorFallbackAvatar":"","message":"Thank you so much for the clarification!\r\n\r\nI had a follow up question. You mentioned   \r\n - TestAsyncCall awaits the task returned from DoSomethingAsync. This causes   \r\n TestAsyncCall to return to its caller.\r\n\r\nIf TestAsyncCall is called from an ASP.NET application, then I am assuming that it will await the result of DoSomethingAsync, and not return the response to the client (browser) until DoSomethingAsync has completed.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"b54a93f6-1357-3a18-a59b-25ae0868538f","date":"2017-06-26T13:58:23Z","timestamp":1498485503},{"_id":"5e2732c8-a42b-3acb-9126-3b8d5abc21d1","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, that's correct.\r\n\r\nASP.NET WebForms can use async void for event handlers; all the other methods should be async Task (or async Task<tresult>).","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"065381db-7992-309e-ae10-54eef9620c5d","date":"2017-06-26T22:36:40Z","timestamp":1498516600},{"_id":"b54a93f6-1357-3a18-a59b-25ae0868538f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"No; \"async\" doesn't mean \"run on another thread\".\r\n\r\nThe way it would work is like this:  \r\n- TestAsyncCall calls DoSomethingAsync.  \r\n- DoSomethingAsync calls Task.Delay and awaits the task it returned. This causes DoSomethingAsync to return an incomplete task.  \r\n- TestAsyncCall stores that incomplete task into TaskResult1 and invokes DoSomething.  \r\n- DoSomething returns \"synch\" to TestAsyncCall.  \r\n- TestAsyncCall stores that string into Result2.  \r\n- TestAsyncCall awaits the task returned from DoSomethingAsync. This causes TestAsyncCall to return to its caller.\r\n\r\nsome time later...  \r\n- The task returned from Task.Delay completes.  \r\n- DoSomethingAsync resumes executing. It may be on the same thread or a different thread, depending on the context that was captured by its await (see my post on this page for details).  \r\n- DoSomethingAsync completes its task with the value \"asynch\".  \r\n- TestAsyncCall resumes executing. Again, it may or may not be on the same thread.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"a2335ec3-165b-32d9-82ad-a616eb4de913","date":"2017-06-26T13:53:14Z","timestamp":1498485194},{"_id":"7472f1a9-dc40-3274-b89c-0547ce765209","authorName":"Saket Kumar","authorEmailEncrypted":"UWK8gWwGyPNSRmlzfJE/z0w8vha8qVejpRLaAMJnPK/Y8LybC5neZxszzwJiwoMkk7EFDoEEvihrgMdS23W2GVhS0Z3hnlAWbzND/USpkG+478wzS7xskOHrZvKYlBQ8TVpoTPt0tThw+Vty2kCVyV9hjT6YwcZwIFINRhLMt/0s8xsVyhCH1Bx3KGROiRJrjCG9b4ygvwENqdohjyMNyUxs27bNfeAAIRtyBcEBY8PcJy0vzYubLVcp+XXMqoQuzL+AURxtAxYi1pVXIOqGxORJz1gzkOz8yZ23BxtTQ1L8oWk7DhUHc+kmaZl4PpOwx4msl45MUqjp5PHajAzUiyC/uEnNknX3x0VOgypaWqln87s5AcKRdk3wgZz5DA7H6kqiMo1pRAkZcKb17cEhj3oCnYfFlTMRo7XYoZC6Y3SEHBHrIuEngzFVqOUEVjJQ2l2euix+4MN9XkcIwsJawyUy2DziO4NFvUfGbhFau6fIGi0awtJrAs85mNIr+1qTw+5QFnRYp4J8A63pDLvuNuvxs5ueSHUe5U5/PMqmBHPMZxjPOcDCdQFC5NBeoA6gKC/X65l1hS9Y/b3oqAWlYSV6SNbpDDrgXjjVeBBcCGSoXlBQr4zE+MAlxXRQ5FfdyblUw4IIjBp8EYoCCJj6nKXE2euHq50pNVpaZIhmRpE=","authorEmailMD5":"f54667937bee1ea92f115d30e457be0e","authorUri":"http://saket-wantz-u.blogspot.in/","authorUserId":"disqus:disqus_FYXXXiGM2Z","authorFallbackAvatar":"","message":"Thanks a lot, Stephen, for providing easy explanation. I have a question which I would like you to clarify. If ConfigureAwait(false) is used to prevent capturing the current context and then running in the thread pool, would it be any different if I use Task.Run method instead? For e.g. what will be the difference between\r\n\r\nvar fileContents = await DownloadFileContentsAsync(fileName).ConfigureAwait(false);\r\n\r\nand\r\n\r\nvar fileContents = await Task.Run(() => DownloadFileContentsAsync(fileName));","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2017-06-29T10:27:04Z","timestamp":1498732024},{"_id":"84d291ec-a37c-3d1d-9d66-c4f498ac5d2e","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"ConfigureAwait(false) is not a way to run things on the thread pool. It is a way of informing the runtime that you don't need to resume on your context.\r\n\r\nThat said, the code after the configured await will resume on the thread pool IF the task passed to the await is not already complete. You can't really depend on that behavior, though; e.g., Windows Phone heavily caches HTTP requests, so DownloadFileContentsAsync may actually complete synchronously, causing the following code to execute on the context.\r\n\r\nIf you need to run code on a thread pool thread, use Task.Run; that's what it's there for. If you don't need to resume on your context, then use ConfigureAwait(false).","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"7472f1a9-dc40-3274-b89c-0547ce765209","date":"2017-06-29T17:27:21Z","timestamp":1498757241},{"_id":"ed42ca10-376b-320e-aa5f-b5d32fe24e98","authorName":"Dibyendu Majumdar","authorEmailEncrypted":"ifeilVCGjPZ1C/hTfpYN9+/Sq3ZxgLPY+g/58h49jneKVuuaeu8iudyxtrK4CdU/phIXNIcD8AJ40FPQD0VXJYH8W8S8dskgrHFvqUApCDYPWNODgAobTVTmZPg92KvyCqSu85+jkgW1DrwXVeNWG3wzDJ1rxVR0ckmOktMeV/U2IB1W+86B2SAiAxR3Y5P0fZNh8EMPqjrmcLPbvk3f/uncfiLnl+TdaznpNcP5B/Zb7hPSKvhbxw1edxAAKrO2IHkBl3PskNePkeiynlg/j9NZBabCUBQBML8FW4WLCzqHoGccfBf0yhwc1ZIjCEGZTBVcjyk6SGix4b1mPVXiun6GGCDPpZoK+4oA0qP3vePXDm+L/eikRkQdZhWx5Uo1t86bCq/QbFJAqV4MxPXQypzgOTWom3OKouKqKJGUknq7xVlUCsqNjGG1ADcEOeiMCRWYQ2zm2y7pSqrmlacUIdnHJXvgLtSlwJjATwqpu6QpDPFDVZO8j+2LpZWpB2xvNHdcprOm9OFCfGjnI6Q7jb0o18Qf7GV+nrnSOfvlSejF79uD596cq+XWPRoqPkSWRrKnu0rUZJ0SuwbNnauBTr/Uw6GPH56c8x4Kdqbth0b4diTyNTH8qvoETdyWUm8Oe8AgycIOgGwRpwwh+XgVVftKrq14h8aIKGUutfDcthA=","authorEmailMD5":"ca70bdb3cfd7775f385367d934e112c9","authorUri":"","authorUserId":"disqus:dibyendumajumdar","authorFallbackAvatar":"https://disqus.com/api/users/avatars/dibyendumajumdar.jpg","message":"Hi, I have been struggling to understand one aspect of async/await that I hope you will be able to clarify for me. When an await instruction is suspended because the awaitable has not completed, there has to be something that monitors the completion of that task in the background, and when the awaitable completes, resume the await instruction. What is the mechanism that does this background activity? Are all pending awaits queued to some background thread for monitoring?\r\n\r\nThank you!","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2017-07-11T23:52:50Z","timestamp":1499817170},{"_id":"11224a28-4126-36e9-b2b8-10e3561db417","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"No. There are many asynchronous operations that do not require a thread: [http://blog.stephencleary.com/2013/11/there-is-no-thread.html](http://blog.stephencleary.com/2013/11/there-is-no-thread.html)","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"4884f3b1-d55e-31fa-b649-6f6da7923b6a","date":"2017-07-12T15:20:27Z","timestamp":1499872827},{"_id":"4884f3b1-d55e-31fa-b649-6f6da7923b6a","authorName":"Dibyendu Majumdar","authorEmailEncrypted":"ddi6Z4FYuzbVNMeEjV80+V8VOAyka8VRYMR+enmAEdWextcE9LBcTVwUqO7KveJZ68WJC2aO2JRvo73ufXZpsywBn5EULZ+ItwJu0RBGlq19BGOstoprRvvv8aXybtst1w8aAzp/r9+B8pww8KiGjoyeiF0AHHERoP3EUo/n52Jyt9k2NqdBxcOCpb41FIyOwCXGZyxhNY9mUOG9yTJpQLK5ogim22OF2NlPL8YNBpE9WxUWvzhMUIjv/V5Qi1QGv/Ckzu3VIpW6GlOQc+y2pRCHoSuFBUBgAZIwVWAUq6cN/LaTf18VOdk1/VMeTPDestOvvAk641qxiGzu+gX/SJmSmmtl4zjp4l7bmEDbtrpM6m8JjSvPrYUo1hLRQ85Ztuqsdlvdsy6Rvxzq/XiudcAjXlbTlN/JJ/vFEUc62k3bd5WzpA7iga9SfaOKpceNLFxSqRkAOT0FuvjOosqlG+wW9JYwqnEyIEwLWytnSG3h53+DyD3eqTE/qmfFy7RP6pmB02eIxiPRn4wHgJYhgOQvKVWdiSUilZKJrCQSswbIyr5I41zFzB6ZJ/JO4/srSHT7/miwqycfl1Ccwi0QuEoC44AuVg5vDXiEaLJRFS7ygXGz/A7d4KwrHwH072Y8va8y81RW8xL313CQ0elXoQbIZmWQWW6S++70quHTyWo=","authorEmailMD5":"ca70bdb3cfd7775f385367d934e112c9","authorUri":"","authorUserId":"disqus:dibyendumajumdar","authorFallbackAvatar":"https://disqus.com/api/users/avatars/dibyendumajumdar.jpg","message":"Thank you for that insight. So does that mean an awaitable thing must always be running in a thread of its own - because the calling thread would have returned at the point of await?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"ca603152-dac8-3cdc-b38d-9e715f6aa9c0","date":"2017-07-12T13:39:22Z","timestamp":1499866762},{"_id":"aeb23d2e-c8a8-30ad-8c93-dc72b589236a","authorName":"Dibyendu Majumdar","authorEmailEncrypted":"CjWmQ3SDZels6Ub8PLAVHXVOpmahYqu/FIjSYBCWrgYHOrTU4Htcmue3hhRAyVlYswH6XwpXfQ4qgvlRBv1czomJxdsUIgHC6VZJFzRkX5WjUMwPKjQNyrqORLGpmOBj+/RBxOjda/v4dpKw0Z3ju+QC/le7DUZaEl6iMdan7VFFUGTe0JmSipzmsn1VsbuY0Z8CtidZLeC3bRxbNmxXGwTpsyvpjoU99weEvZpG9Etra2jzpRmYILOcD9aaP9tAnvp7HJgqyxUxYdJFxsRre/CjY38ZzA1VfXUxgklddVgjHJVKY5ZhhGqNKwSspfXw7miMroVYziQ1Zx5K8DFD15RUOgzh/uoYzYuLtWBRXQUwJ08CdZ0b6D//VYkMrNbJQ6y/Ps7s0HiAqUFsfZMlUTx5HlZnTIp9+dyjs2Nhas97gstQxjI+AtScRmkEmngpE98nYlljC/eC3J3Wfp5Nv1gW15hBRK7wQClpJVA87O6nGWEUqSAU1MP6bL7hS/18oOcWxWma/EadNSsoNuhdFlCvgUg7uTXtF65aDXh7JSYxd2OWrvcxzrySJUeMWPSvFcGWw/16Kc5Bl344fqjVfZvOxekrzMGEWMdYvfwgkemgoC6EPZ9O596x1WVguzTk2zEGv9pC/mePsjlEmGWVGAIJaL575nSq+5tFtWxBO6I=","authorEmailMD5":"ca70bdb3cfd7775f385367d934e112c9","authorUri":"","authorUserId":"disqus:dibyendumajumdar","authorFallbackAvatar":"https://disqus.com/api/users/avatars/dibyendumajumdar.jpg","message":"Hi, I read that article - but that is only applicable for an aync IO operation, where the OS can trigger the callback. If it was just a compute task then who is going to trigger the callback?\r\n\r\nBut I get that there is no additional thread monitoring the status. It is either the thread doing the computation or the async IO op that causes the callback to be triggered - is that correct?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"11224a28-4126-36e9-b2b8-10e3561db417","date":"2017-07-12T15:34:55Z","timestamp":1499873695},{"_id":"ca603152-dac8-3cdc-b38d-9e715f6aa9c0","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Nothing monitors them. It's actually all based on callbacks.\r\n\r\nIn this blog post I say \"If “await” sees that the awaitable has not completed, then it acts asynchronously. It tells the awaitable to run the remainder of the method when it completes\" - that \"tells the awaitable to...\" is actually registering a callback with the awaitable.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"ed42ca10-376b-320e-aa5f-b5d32fe24e98","date":"2017-07-12T00:48:29Z","timestamp":1499820509},{"_id":"8943cea4-13fa-370f-a342-674898dd88fd","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"A task that represents CPU code does require a thread, and that thread triggers the callback when the task completes.\r\n\r\nFor I/O, completion notifications usually come in on an IOCP thread (within the thread pool). They usually - but not always - transfer control to a regular worker thread pool thread before invoking the callback.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"aeb23d2e-c8a8-30ad-8c93-dc72b589236a","date":"2017-07-13T17:48:53Z","timestamp":1499968133},{"_id":"62e4d236-62fb-31ad-a34f-66f0d99ea03f","authorName":"Supratik De","authorEmailEncrypted":"VSwppa1AUkMvzL3pJAFik8v6rg6rB6OwQjLKn7P4KU9FyPP6VY1P2X0Bu/oSn9mUOLedVdQM158mvGFu9zDEE7otilMxX7MRodtFxlFCRJpl8+WjQ8L3Z5m/S3ZHgZYgjnXgHAxJDcfXXEjIaVoce2VcZ8JltDmeVft9Fmq34Zj++H7fF8p6HAfMHLq0oNWNThzMgeO4G1pD746/rmyj53T3HfhzWF7zCLXmp9jrGajgjaf0Hc6REy2obyH//LBbkBQs/iHv+6RFVfJSDsmTnrCh/gv5Wb39cftv50u1s+BRlaEMuw8aVyZLLZ2d6MPqJs2+oV++iWrMsFjGNfYKxMoM6cte4OJ8xsiH6vS7SKtzmRVKekXro8N0nBKnFkn4bORuah1Gtjxp0M8JL+P+9ZmKzcP+BCwC24MJ3rIWMH0tghz7iHpLcUMVjMuJl+5xGpFm0/pLq7EDjLWANPZOclN4ZtXXeZgciS72nHybIReRc44OA5WbGcdrnApWuaphkLMYeN+17YC8i2G/k6sS/l6o74izhhaGRWo2GGxbWOJjxW6kbrqBqtnEkXkXj9i7oEvppGse26iPZytC+LgtFi7ncWi1iEDsp3dNBnSr8KvoPuhuW7NxZJ5Tbh6B99smMn02IoyZ8iwB+VSFi2+InKdaZfQtnlMxOhTfY33XCFs=","authorEmailMD5":"5f31fdb78a9566f3ca4207e69276dcc9","authorUri":"","authorUserId":"disqus:supratikde","authorFallbackAvatar":"","message":"Awesome article, want some good writing on - 1. Parallel task handling, 2. Efficient way to handle multithreading and 3. Efficient way to avoid RACE condition.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2017-07-18T16:43:41Z","timestamp":1500396221},{"_id":"2debb39f-179c-3c0c-ae51-1990361a1712","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Some tasks do have to \"run\" somewhere, e.g., Task.Run will queue work to the thread pool and return a task representing that work.\r\n\r\nHowever, most tasks used with async/await represent I/O operations, e.g., HttpClient.GetAsync will send an HTTP GET request and return a task representing the HTTP response. There is no code to \"run\" while waiting for the HTTP response, so there is no thread necessary for that task. You can read more about the details of how this works here: [http://blog.stephencleary.com/2013/11/there-is-no-thread.html](http://blog.stephencleary.com/2013/11/there-is-no-thread.html)\r\n\r\nThe current thread continues executing. The asynchronous method returns a Task object, just like any other kind of method return. So in your example, it would return that Task to the Main method, which then calls Task.Wait. Wait will block the current thread until that task completes.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"ba1e2d4a-e2cd-3694-a30e-45ffdfe646d3","date":"2017-07-24T23:03:45Z","timestamp":1500937425},{"_id":"ba1e2d4a-e2cd-3694-a30e-45ffdfe646d3","authorName":"Rohan","authorEmailEncrypted":"FpuQzsHh6FpBLTnYWJINrFjOF4r80e61RAWKRreMuibzTGEinC0wgcNsG0gsnxnBBZ1j6uyAQPPA0D/lXjrkF0OvFFe6u0N17QfbrqVqJDS8T35aQhBPwh2uHxcM8dX0MM0G9ELupfrraTjAh5B4irb0Wpac0G05H5UeN8bUjdVISFJvYJ2OxSRUVSaRWqoqcmTHL2MG2RFI3roS9R9jS4o99p5bdM5npoRRA++eD7tIUBDjz0beoU8OixBfu330prqbMqAt3YJtd2ZUN6aZED3F5coNM7LTn4fmSHvRsZ1a5SQan8bdpWZI7PLq0vmrT9AMwIGk0zU/G1GA9kq9XrbT2e7on3Hs6SocVeRuyziOn+yWfzSksv2ZpvtTONlTgOuo+HzcRyzdtVM1PdWaAXOj1PmFIJOPCFMbSs8yymM0zewLTB9nCN5KelkutKWiwkxvRZqkj9ycyqyTRy3t3etNxX6l7KOgwySQHAdIG5tqpxnYDp3nMrXJdvCAUUh6Hj9NHEj2RY6pJhr5H4rdBhgZGnlb71Se8iIZat8evA4hL+HQ3+y4yZdnT6gKYIzfZDge5QtnzuCjaRylmcTShBXnDtOEkMdKWBtLOpPZFaoam3gj0/O+BvAQeLeGwcBjlQnLC6cEUGVQMDRH77UpAnvGr86nN15MR+o06800kTA=","authorEmailMD5":"676a11fae71514ad235cef0921a85c47","authorUri":"","authorUserId":"disqus:disqus_KZ1nxsZBDo","authorFallbackAvatar":"","message":"Hi Stephen, you have said \"It tells the awaitable to run the remainder of the method when it completes, and then returns from the async method.\"   \r\nDoes the await spin a new thread for the task?   \r\nWhat happens to the current thread that was executing? What does it mean when \"it returns\"? Lets say its a console app and the control retuens to the main fn and we are using a Wait(). Will the thread block there?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2017-07-24T19:12:03Z","timestamp":1500923523},{"_id":"0786dd53-f586-3681-8203-3431316bef32","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"\"Asynchronous\" doesn't mean \"running in the background\" or \"fire and forget\". It sounds like an independent process would be best.\r\n\r\nI've worked with logs for often-disconnected systems, and have had good success with a simple approach of rollover logging (maximum size) combined with deleting old log files based on disk space (rather than time). I have some systems with years worth of logs just because large hard drives are cheap.\r\n\r\nI didn't sync to a central server, though. For that, I'd recommend an independent process, which can be running in the background inside your main process if you want.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"694b0655-05ce-3e2b-b18b-3dc3abe339f6","date":"2017-07-31T21:03:26Z","timestamp":1501535006},{"_id":"0bb05938-a234-35ff-94e0-0882cd911de6","authorName":"TW","authorEmailEncrypted":"RKft/PeZsLywjjh8w2/zNLFHSxF46JvvODqvqhMEeKA56Yohft0AHW7BoWEPq/DRCTmrUNM9pti2XHZPiLM4fFMtYIVZlgNzURstZVziB6iHyWLkYeVSaoLemZt66Qa9fDoybLvNphMVgtYNAJNr7HlZLjwsaI/66TPstV6Ob6aqzzV2NAAQjyp2S98QQ3S/ZOs2YeqcgS8rTNM4TrXuhiRlD7yuqUTtEnVir6HER/gNmKhEKujrTtu9ysBbCOD1NiBEVYCShW1mAyXlCnrYIvfypsYvNO+FEttKmCpVd4wvn169NiIhmRmtN6itwFVVAhAWLYqzAZlWs7dFuP+owUvWsdIacfph5sbvADBSuruXXuz8+F4w9IsTgk3nWEo8E2Mc8LpWEJH/W1HQwjY33llJEq7PqaFceJ0SjDPl1QQ7h7OwIeZCxLhYrhEt3FXRCdXqMcU0rpJ109v2frkz+uZRxGgXX5tmnpRXnQNaaBuCT5gnisW9LfZO97i09xCaVAfh6lfELm+4GdwOvasrsm6cTI13mh8AwQvQV4BNkqIQAr10VAZWjWF2WJfWe8OnRYWYq25G5j0MWiCnP8VyE0sBFo0G1XjkUPPeYyLx0j/ZmsJcS1KoZgtMdc3pSm9cdD0VPddVomaZ6K93UEyqqoYS2IwTdgo3NlgfAjGXs54=","authorEmailMD5":"7bee7e0927cba49b5f687058a90aa5e9","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Interesting article. I have a question about application of this. Right now we have an audit process that logs to a text file locally to avoid connection issues, and to avoid filling the harddrive we delete the files after 60 days. I'd like to setup an async method that just keeps trying to send these log files to a SQL server until it succeeds in the event of a connection failure but allows the auditor process that reports the error to continue to check for other errors while its sending the first error message back to the error repo. It may also find other errors and report more.\r\n\r\nWhat would you suggest is a good way to do this using this method?\r\n\r\nIs there a max limit of tasks that can execute asynchronously or would it be best to keep our old text file methods?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2017-07-31T17:19:04Z","timestamp":1501521544},{"_id":"694b0655-05ce-3e2b-b18b-3dc3abe339f6","authorName":"TW","authorEmailEncrypted":"AnpED8YiEAGJVP1AnQd9dL7byCYMPajGNK9TDXaX2bq/EwpXnh7WaLu+RRE8swb56yHqvqRup9y8E/xfgA7sJ+wdqDrsji/zj/69DkI/S3h/pi58vAIWpB5fdKTD1T5281RiU0dB7hgxm4LuqDMft2STU5fbe9bwwGmRJL8zackm8Txd+YevGHRi/hY9okUFp1LUni++XCVKeBiozIjtTp//KwcZF3VFzK3mbIjW+v8jqoM0v3Xri94R4RL6clTNJehat8uCSyhR1+SLJMzmvdj1rhy8RfZ1Kn7YjqDPGo11LBDipac22NjFlFXLKocdDMCX8laEBlR26yZwI8GtnDinmnzpMioXBFNCiv3WuHyYM+28/KOi0iY49IidAp2roV+UdX8AJkmZYyY9kRaSaEA9GLtxL6QlN+ECpIr7oG5+HEBjVsa8MXMDlNYdKQk5/zhSJBXHrgvRD5BtkNn22XIBCARScSYBFbA1KCvAb9dXipbjokkIh+Ej7EPxGX36DEcgOZv24kRsohJGHrFniMGQXcxLJN0v9ZvgVlqZNlQVy1ok6RZXU3MccKo8Z5zyoPzDh6+UonxjJRv0UOvPANTlhIk40emcBDaTnQNNtPgPPSt+f0adN8oSAIqHfhZyc2WeAEDb7GUSaIFaA1eDfeP/B+emlW14Q6GBi84GQ5I=","authorEmailMD5":"7bee7e0927cba49b5f687058a90aa5e9","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I'd like to note that sometimes our connectivity issues can last several days and the logs that the errors report get rather large sometimes. Another reason we'd like to move to a central SQL repository. In most cases the connection is good, but some locations are in the boonies and can be without internet services for days. Additionally the fact that we cannot track issues more than 60 days old gets annoying to find a history of errors as well. Some items only occur once or twice a year and we have no way to track the error frequency.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"0bb05938-a234-35ff-94e0-0882cd911de6","date":"2017-07-31T17:25:20Z","timestamp":1501521920},{"_id":"165f92b7-442c-31f7-8a13-fbe3b904adc2","authorName":"Jacob's Trouble","authorEmailEncrypted":"I15DP9pnRXx3ND13vviTa5NaIM4jK/qudlEysX/PNv2V0obXwhIZghmwMjKy+hZyIzxCig9+n8snMlc0tA2mEO+Kzg0T7uA1yvueznpD6pl0QffboOU9QIuuP23NpwpU5zJyI9IZzpRiBE37DGeq6GYs2i4sej+GSW6gImSV32hMyEGuGJ9js/1zFw5+yNzOBfpl+5uQqROQ5N1/ZjmIVwyZgpvAf9qvP7G3ZjW61BJGBF4FWupFnIWVITu3w1Lq7DGoGyvbYdktfSvHfI/NQxcwB6CB2XyngTnYpkCfv7AHMaq2PU09dFqeFkon7pvWXs1TZ/khR34D69vvZ/OewFIltWE16nuGG+4j8KWHsycUCAH8qzzdB/fphj2SzyXHJ4+uhN0gWUDV1ayuqkneRQ5WkNDCO9r/dwuQ1k84SrfbVVLQFaRPUq9a55YOP/EC/2HgTOf/qZ7BHzkqxiUGIvxtyWnei23u4kwtVV8+VueeU07giYgLDGkqtbx5+S4pn3N1xOeSTYxfg9zTA8WJutKYWSAE+UI2ScegqSqNwmswUrWFt5zey7HuYsuD/0SVBs7ui3HpcQJ/+MzIfsJtCnKYWGUphGdZ5d7QLy9lTARBWt/aANByQpmTKNpikDD7MeSe5NqbdFX+B5tbZ3QicDUtvX6BLu1nVAlOpUdVzPU=","authorEmailMD5":"26f1a4766077cb8c8816d616799ebee7","authorUri":"","authorUserId":"disqus:jacobstrouble","authorFallbackAvatar":"https://disqus.com/api/users/avatars/jacobstrouble.jpg","message":"What better person to ask than the evangelist for async/await?\r\n\r\nI have a class for running non async methods as async tasks. What I do in the class is simple and it works  \r\nonly when <add key=\"aspnet:UseTaskFriendlySynchronizationContext\" value=\"false\"/>\r\n\r\nI house the methods by their address insides a task list and then await as follows:\r\n\r\nawait System.Threading.Tasks.Task.WhenAll(_TaskQueue);\r\n\r\nIn the end, I add a hard wait by appending to the above list of tasks a dummy task, System.Threading.Tasks.Task.Delay(0); as  \r\nnewTask = System.Threading.Tasks.Task.Delay(0);  \r\nQueueUpAsyncTask(newTask).Wait(); // hard wait\r\n\r\nThis mechanism seems to deadlock when <add key=\"aspnet:UseTaskFriendlySynchronizationContext\" value=\"true\"/>\r\n\r\nI can share the class if you would like to take a look and advise why it doesn't like \"TaskFriendlySynchronizationContext\"","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"e102ebc2-9b8c-378b-94a0-589071e1aeb7","date":"2017-08-11T20:10:35Z","timestamp":1502482235},{"_id":"2f9cbae3-4ad3-3d94-b7e1-468d703f188e","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Unfortunately, I don't have a lot of time for large code reviews. I recommend you reduce it to a minimal amount of code that reproduces the problem, and then post it on Stack Overflow (and send me a link to the question).","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"165f92b7-442c-31f7-8a13-fbe3b904adc2","date":"2017-08-11T20:55:15Z","timestamp":1502484915},{"_id":"761692b5-11c2-35ac-90cd-3de60b3d19be","authorName":"Jacob's Trouble","authorEmailEncrypted":"LjEOfYy0hWzVFBMoNDF1Y0pasUA5xL/5gA2MI6LKNLQfW4/CaBJ3EFlCOOXenjNF5XLoxy/B0+oLc1L0ELeSU2bMYzdirPHabzMnHGxPXTH7Afn4sj0X2h7vtH1YyIH0RN7nnFLZYDr4MEnU92GPuucoEeOt9DYCtpkGvm0t4E/UJrjr0s0NPU1uqg4f/RAvrEmAeeu4eRpemsxD4WqHTSxtr9dKzG9qA3KjzKXY89+e4nHrVKDs5okolOs0fjCXR6qi+9aIB8IYrV9AYcVLWxVZFxfLMgde3SUd4B+IJzhTk24yEk16uik0/9ddd/O25p7yRGUKQ9rhyJ2lYnqfqMfrTytFIfelHXoB9fEcehFiNp/TENBEHyhexeYf0abQlCo8GmQFKn4LfzTyxJWPxZ0jW2vDFaWkjFur4xMTyhcmG80nL+3TOBy29Wk4aNL/148USPT6fCMslsbpkfIi1qrOuU3OgxKdEJRSPN/b98NLfzj+QBNe7CBpykMnv2cuW4rk+iqdCpwTInKP5FMu/K/77yZdlO4A786H28u4oPFUR2pIpBVeA0wLsV9tkMHfATkhRTeprW5FwSsfJGvS4+ga9aKx2NvOfhRqihv1/v/ZfM/E/8SBlwKsVAov4LyFkhAOmzFsQd7uy1AU3DMv4XQOXGYNtJ37sBv7z/P1WaE=","authorEmailMD5":"26f1a4766077cb8c8816d616799ebee7","authorUri":"","authorUserId":"disqus:jacobstrouble","authorFallbackAvatar":"https://disqus.com/api/users/avatars/jacobstrouble.jpg","message":"I sorted this out. Looks like Task.Delay(n) engages contexts differently. The Legacy SynchronizationContext implicity treated it as ConfigureAwait(false).\r\n\r\nI made this explicit and now my class works on both Legacy and Task Friendly configurations.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"2f9cbae3-4ad3-3d94-b7e1-468d703f188e","date":"2017-08-12T17:30:56Z","timestamp":1502559056},{"_id":"aca5bf9f-62a2-3887-b4e5-ea00ede69059","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The behavior of await on the legacy ASP.NET context is undefined: [https://blogs.msdn.microsoft.com/webdev/2012/11/19/all-about-httpruntime-targetframework/](https://blogs.msdn.microsoft.com/webdev/2012/11/19/all-about-httpruntime-targetframework/)","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"761692b5-11c2-35ac-90cd-3de60b3d19be","date":"2017-08-12T18:27:14Z","timestamp":1502562434},{"_id":"22f55df3-6b62-3154-b57f-1fdbbbd19faf","authorName":"zuaup","authorEmailEncrypted":"f+a4a9rMxjubpNL5f7EGVRnWFOONgQxeDQQMayekpi6KSs34+U17U6UUqZiTcaFwe81xeTQM5aqA9opnWcXhxS4sQdfoTuE+WSh2Rg57T1iMCpTSgekd1BP9fTgonYhi/mnDZulSzGvacslHwviRWhCrOj+m+1eOzri1z+DgQrAE3FdC0m3kGKoqXPAbJfWBsIJwTCkdMQvAuI0P/Q3+pH3g9Wz66dNBCFD0SlGsa7rAUULRoamfqkohhyl6iZj5ThJ18WjYU2Hw8CXJLole/FLIq6FHCf6aO817KDAJ+kbHgw3QfaQIodKfOlOL15XpIfD/iYZEz34fKjwezHKpqaqtHFvCRbFj+qrds1TmDu1nzUohm7325beZCIVSdXHdUSs2diYBFDuds/IvHRz5HmnYDlT80Wvrmbry8BLMy54S9Er2OVIGv92dcJ+4OYYxvfzw9OZp5BJEnFFHN9RT7bjCCLNBBJB/33N1IQ55ZY9ZURs4eEVYmHnXq1wlMT7iVxBYlxHJL58ro2ZnOUTSzYQtj3xVsz9mXoI3l1vFgBoJpf4IoH8ExV8ndCyVr4Y5Khp/oiGboZRhpqtdOq/SwSbE1JDFp50fKR2H7tpLrFBVgHrDX2Mycw292Sa5CioUMJ/oIQEDS6mKAtbI6c2zXDb/9G/lO6EkNXT4rX5pDNY=","authorEmailMD5":"d70bce79c1cc5c2c9ee7dec0e129b2c0","authorUri":"","authorUserId":"disqus:disqus_12TyowN2h6","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_12TyowN2h6.jpg","message":"The most important few lines which help to understand what is going on, especially this one word: \"returns \"\r\n\r\n\"If “await” sees that the awaitable has not completed, then it acts   \r\nasynchronously. It tells the awaitable to run the remainder of the   \r\nmethod when it completes, and then returns from the async method.\"\r\n\r\nTHANKS!","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2017-08-15T13:01:23Z","timestamp":1502802083},{"_id":"ba88f19e-2049-33cb-8737-de9c13a2cf63","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Glad it helped!","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"22f55df3-6b62-3154-b57f-1fdbbbd19faf","date":"2017-08-15T14:33:06Z","timestamp":1502807586},{"_id":"886d19d3-cd91-34d2-be88-85f7f97a8305","authorName":"Hussain Moiz","authorEmailEncrypted":"aIpCmhJmqHwMWvLxiQi54qByPaXlWwvBZNXu/KYICjwGvhMgrqh2XzDK3K8zi0QldhK08RFR5aHbZOn1ceRNMgEG57fz6+hrADri6OcddFuzdA65l4k+Q94llju6JljsQX5f0mZeneF2+stD0x0+t9O9WjDtXxNDUG+8Zh2PLc7WOPZegHaNszHExcUibB0hSHDsRgW7FhVwiqIzqbyo7RvyRQEtTzpmZvTlLUQj4gorQtMwpJSCsETvD+owtiUYDR3Uolg1PSVbVSWx/9BIY05bkMUxSl+SUx6aBgXkBD3crXX+do1VvmiF6PFxP1Kr3Xferrz8cPRLjZ5MD044HwZqjliUv7q6I4UpZaKIf9SHVQihw9vZmPRAAgg0gAYO+3WezISJYW1Nhtzfe+cDjWuHhdgIKtllwBewvUKIFtIccbqngFqyQQTu8SKYubJdDY56FE8aEUj8+crNYWOSNFD1yjrS9zoMl7vZ9nNmfTLKKOT2+bhiQF3kf3L6e2TSiw3Kyt9TthUrOaQt+9sfXFU5aGbAAUf5PefKHWk0emqZhpkgaeHG6ww26Kq5dLHi4dzLXNI5+V4ne+tzhYmkieM7k8DUWf4UXteKroCXPe3K3hpmTgYV7MqdqT/6sQo2vbQjjbf4NgERD4s+7/cF0dH3ogfjll71D8kpGYNGCpk=","authorEmailMD5":"983f6fe55770100c4ee124320703cb3b","authorUri":"","authorUserId":"disqus:hussainmoiz","authorFallbackAvatar":"","message":"Awesome explanation. cleared so many of my concepts.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2017-08-24T21:07:10Z","timestamp":1503608830},{"_id":"a17b4652-e3c6-35c3-be14-d752706144de","authorName":"Leandro Cofre","authorEmailEncrypted":"qdEDg+QwzU1C2dikbU6MwOZzAhHXnGI/sedjI7sNiu0V0342i89Qd04LgJF5wlgjtcVdoJiK1onG4kJBRt6RYzZ9aky9uFr+z5eQ1UbbHAoTWt/LpHYc6YRvXqv9mzcf+B36C9zNS632asScHwGXL81TE5zDhY1TBpq8iPKN7CFj5a4ZZ7qKiMpmA+QS9jKA7cljWWxXcPqd5Ak2TmdWBrhFnU4kwO/NSWlOdANUY8Smmug9obqAmUv24jMVCjgdCsDgnSVOxPX2bI9c2ECK7h4DYPGMM1e+eEye+EoGaleJt/rrVIwKZ8nUhgomxEXQp4eSVd4jLGaPXeiIbTcd3PRp7lIbsS3VfgZY1IK+v96awuqgN/fooU/IkoNNpdAwMYh22Se3wbZHCa5mzg0xjdYq3VgDL7IuAJoluHlx8lz8K5IT9qtjk2egQqXoAV9Lh3Yx4QCOsWKc193n6x75Y26eGgYQzJxj4WHj4D9LXQT1z7luEEJacP978rwweHfzTLbba/AwngNRuN/XjG8x2nA+ZCD008fqzy4TYCG2Oab7jeY2yZlnWxx9zmW7GYNI7c+m6VwOdtstmY0nFsESanNTwhMI6igMFhnjcM4wbVBlBYP27OOGSllPLaH+baPc7fkoYTIJQkifOB+LW804qhmAfC0tM/FhSvrFUSpg4fA=","authorEmailMD5":"ad3087843f042a74865471b113afe004","authorUri":"","authorUserId":"disqus:leandrocofr","authorFallbackAvatar":"","message":"Great Article. Thanks very much!\r\n\r\nI am a bit lost with a particular problem on a web api I am collaborating to. It wraps all endpoints in  \r\nreturn Task.Factory.StartNew(() => {...});\r\n\r\nInternally all endpoints behave similarly:  \r\n1. Through the Web Api, an action is \"queued\" to the database and the request \"waits\", by periodically querying the database for the queued action. When it's completed the request returns the result.  \r\n2. IoT devices connect to the same server asking for pending commands, executing and \"completing\" them.\r\n\r\nThis whole waiting does not seem correct, but to change it will take time in this project. So in the meantime I would like to tackle the Start New Task part. Is there something I could change?  \r\nThanks in advance! I know mine is a pretty general question. :)\r\n\r\nBy the way, the project uses ASP .NET Web API 4.0\r\n\r\nThanks a million!","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2017-09-04T15:25:42Z","timestamp":1504538742},{"_id":"5b227ecf-de0f-3bb9-8d24-2743ad96c31d","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"From what I can tell, you should be able to just remove the calls to StartNew completely. I don't see how they're providing any benefit.\r\n\r\nThe best long-term approach is probably to make your user-facing apps poll instead of blocking a request.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"a17b4652-e3c6-35c3-be14-d752706144de","date":"2017-09-07T18:21:34Z","timestamp":1504808494},{"_id":"f34fa19c-13b1-3b99-b68d-d70142e28be5","authorName":"Leandro Cofre","authorEmailEncrypted":"u7EhR/9ocivXXX0tl17Kg08vd6TVIJa7dzrTz1nMDxrPX0qjWGiinbBlxDmwQMVu0FPVuTxbGixTfyy0ynax8vauJO37atF3337jyZCCiw+AS/YjpiquWWAEtHbxDRFfkY9v5AbcqIxKUaXFSINbks7PpZrSr9UXBF1FatYgM+7n1IQthBCvlftgwJLm6zWpIidx05AbiKzuCbPIuACBxm9RyOapt21Vlxm6z7yaFpQM23ey2EJki/q21aI0eK1zTjvCPsLPfv44RB9TjNDSch5W9p+hUWBvU0oUdl3cwC66Y61N7wmkc3qo2YhihJ4a30ecAdKvY8eZ3Gb4tP+koBcvp/x+owB8k92b4CoAaDsT/syvQtUzGcd5YbScuaIwIM306cEcBgEAunwJrw8qaaYb6S3nwNcphChBIDkVinwe5pRDTQw2/gFgCjOERAKC9xs0UeDaGzYzJXIppSWQT3WWpGvkLbieYbE1WRxQPZLXSQSasQh0MvpkyPkQMLNAEJBg+aRgLk0iA5dC8iQCYaQn/SXIJfOB3kyM3Z7UPjT/K79uxNj8w+bZuWV03GLuKIcY7hCWuoZfQ5SA4en2XG5gucawGcbl49O/abF9ihaVM9tAY2TUvr8Zoiti/hHIVQgWpuT9qWmOqUm4Hip4eGrin2t/XoZtAuYWioNIIEM=","authorEmailMD5":"ad3087843f042a74865471b113afe004","authorUri":"","authorUserId":"disqus:leandrocofr","authorFallbackAvatar":"","message":"That's great Stephen, thanks very much!\r\n\r\nBoth advises are really useful","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"5b227ecf-de0f-3bb9-8d24-2743ad96c31d","date":"2017-09-08T09:39:01Z","timestamp":1504863541},{"_id":"1419a1f7-ec0b-31d4-a6d4-b19f31c8af0e","authorName":"michael walmsley","authorEmailEncrypted":"oiPjbCspyQ/z49UDUhOM53sjClm94bTezm5xwCJz0fHLN0hT6ffXDzLBOpIwsfLm0o5nY3mrz2ppJe5Am40Nw1KWw+x7cATDSxRtKvbBDrN3JvGXo43M50c4F/2rbSVWOLEbe5cVGPcbtA1S8W66iMKnMprI03SSVDEoA+AjkvhJeTXsbBCeOh4iuN0qGwWKVdx87rGhnseMajA9F+/NfBRZcz4TLpWFaZY6QFS1LWe1aIGrDWPA1/WgfZZAc382M53AEVlK4heDdmULu5sYwrjaXYXa2/oCu9CedTyAG2zG5ifBMI3SG1dMtqIHsMqeQ7btkDw/6C8tow/v5tHW9c21Za9rueZvMmxxdMVlkeu1KbjCbUdLhAC1pV+fFMy/bFf9+iAWaOh71FjQoWrH7p7aG/exruvwmAFKl8GJPyHDMkCKouQlQn2tPnbuepuJ3ptDoTOJvGgB4kHK1DdwDfwle1gZR09vo59sNc89iM6Z8WPot9Rl6Y5s4Xtad2RaXMsIS/5oDljDj9LQmZLBWopMwacqyHhrj5GdHO7TOooISMTfYKWNG4ZtuNUiVqok+LZZw7dbUfk3zVylXnvEdVm24G0vAwmyQAOFfhufbeCwSeg6c+f5q3N+aLUHcQOzy2Uu5coZQYl3GBRBFpCY+aTqMCTPXMh1VACDN0ag5KQ=","authorEmailMD5":"ea9701d5048841d9bd8fe567875fddd7","authorUri":"","authorUserId":"disqus:disqus_a5MT7oNxkN","authorFallbackAvatar":"","message":"You sat:  \r\nAs I mentioned, “await” takes a single argument - an “awaitable” - which is an asynchronous operation\r\n\r\nSurely it is not the async operation but the result returned from the operation.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2017-09-26T02:24:44Z","timestamp":1506392684},{"_id":"5c914afb-ae1d-3a60-b168-2c6eebbdff4b","authorName":"michael walmsley","authorEmailEncrypted":"RuKo5lns55aULtWDD9WR2KsKjshS0TTndb0bMaw5LeaKi4u0sJDYg19JTkPG4H4PWkVnx6CwuvRX5gkYW0G276KWz6Wgbrt6L1xcMCni8uPVcy/Ews7g2pzlZNJ2t9sgFi/ztkC5rwzDngm/XkMTrDlwoM+qnne70jERr079E3yQTHPKbJ9QTVU4N+cMupySyYk/yKK5kR7OxwecCUWQfQ06/Ipt6kKHa0Jt5rt/SctxuNYYIsF26giMO7l7zWVJzug9sNOoZcx511g0tPsL4Mti0qTp6dBlXgF/Fi11+yCaQ/I/39MLGI0UjdquQlQ7JrgA90GJqSA52r8d+uWuQvIrkE09eMw75T3XkaMxjSnExg3A9bBDb8Ukl9f0DWqsaguAMhiapAwjA1TNnTAgHegGdBKJWTEcffXrNQPCwQG1ST/sjNIPq7KXjCmyVfyLxhA9lqxgir1KECFgh0NoNJ8VQ+kcMwCo5jLc9PAM7Nde4xAnGeunnaDrC7IHVANv0qTafJrbzeELvF+1POm8xHb+kEg2EdakQSn9JeW+jV16hRdxL++udKYUVVGNXzgew/3iifkgwhY2cnBJOf8biUp4oPffzmQO1EGPGD0Ln3vuPR6H63mvV+lFejLuom+hCtaMI8yj7i8VdDJwrBqD4tGgrAc36zxkAKfbE6p4dBw=","authorEmailMD5":"ea9701d5048841d9bd8fe567875fddd7","authorUri":"","authorUserId":"disqus:disqus_a5MT7oNxkN","authorFallbackAvatar":"","message":"Please clarify what happens to the calling method when you say:\r\n\r\nIf “await” sees that the awaitable has not completed, then it acts asynchronously. It tells the awaitable to run the remainder of the method when it completes, and then returns from the async method.\r\n\r\nwhy I say this is because sometimes you are deep in method calls and not sure what happens some where up the chain of calls. Eg, some where up the chain you are probably in a non async situation.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2017-09-26T02:30:10Z","timestamp":1506393010},{"_id":"7daea88e-9804-36bb-894c-eb3ce867fc22","authorName":"michael walmsley","authorEmailEncrypted":"IMDFNBfBvvfz7ja1fEaDdPBwjwaLa1jgBFEQdVkEMJ+d3+gLt/VsJCvkDO7OibevZaX/kir3soOjE9efJf1zdLPi4NgOsk6KfBgV9gLEMAe9+9KEv40us4mv0HS5brknCeLzA6k4AtBqndwxYPmXsNTjjy0lkJWM9Uplgd5Q5meIrLLlKbqCiUoJ7PcQja3kGa2nXhWBoGbVZjTCqxNpmBtJf5AhU79Mc+qzqCG7E0jsJXhXy0Dt61kw+bz2pa/T6lGL5nKeUlSpXZ3P2CrBL3zRi/hkwVqG9SK6Af1CJlxBv79UVakNQD9d80CDaSHwTQQ+RRV0rQgMJsql/wu7fOipxoOsOmUeceUmDTe3ADmoa2AWgjiW/1wUg0x+kLkMGnYSR94ObR6IGxhjK3kNvtpWcKrmIr1zWcycvp+vlbUyo8RA3mIcqOPDN1fDoNDko760f0iWEyH6MkqjF88LOokaKIWACvSAeAJpCCHpc9rVPCwc4jg2r0nIH6eq3YThgFlGsEvfWeTqTT4g2hzr8cgrKSNK023jtF5EM3lp2IvgAKb1y/1SKY4Dm0cWB+UvpdFlJIrdqayef28FTHAETH9RXL/sHB6m1wgdG5IStbDzNHVF+0dpHzeQXVcDANHy6yn+0Oz1lBgAVdTjVnVywFlGVF3H5U3pikZ7+jOMzMo=","authorEmailMD5":"ea9701d5048841d9bd8fe567875fddd7","authorUri":"","authorUserId":"disqus:disqus_a5MT7oNxkN","authorFallbackAvatar":"","message":"You say: and return void only when you have to.  \r\nBut you cant return void. I thought void meant the method returns nothing.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2017-09-26T02:36:38Z","timestamp":1506393398},{"_id":"42c27b66-abe1-30f1-9b1c-78f2abbe4882","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"If this is the first time the async method has returned to its caller, then the calling method receives an incomplete task.\r\n\r\nIf the async method has already returned an incomplete task (i.e., it has already awaited and been resumed, and is now awaiting again), then the \"calling method\" is actually the runtime and never your own code. You usually don't have to think about this.\r\n\r\n> some where up the chain you are probably in a non async situation.\r\n\r\nNo, probably not. Ideally, you wouldn't have sync-over-async. You do have to do it in some situations (e.g., Console apps and Win32 Services often do this), but in most modern applications you can go \"async all the way\" (e.g., ASP.NET, WebJobs, Azure Functions, WPF, WinForms, Xamarin, ...).","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"5c914afb-ae1d-3a60-b168-2c6eebbdff4b","date":"2017-09-27T13:37:39Z","timestamp":1506519459},{"_id":"80da77e8-9a3f-3092-9d75-9aea5f3a8cbe","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The \"return\" here is talking about the return type of the async method. Async methods can return void.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"7daea88e-9804-36bb-894c-eb3ce867fc22","date":"2017-09-27T13:32:44Z","timestamp":1506519164},{"_id":"985172f6-c9e0-31ad-bb23-8eae68f20296","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The awaitable represents the asynchronous operation. An asynchronous operation may have its own result, which is only available when the operation has completed.\r\n\r\nAn async *method* returns an awaitable. But that's not the result of the asynchronous operation - that's just the return value of the async method.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"1419a1f7-ec0b-31d4-a6d4-b19f31c8af0e","date":"2017-09-27T13:31:42Z","timestamp":1506519102},{"_id":"1626b1ae-1046-3261-ae1c-b128b2a56600","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"There's no semantic difference at all.\r\n\r\nSome people prefer configureawait(true) so that the choice is always explicit. Personally, I rarely use it.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"c0121dd7-9cde-30a8-865b-6e4c23f56b1d","date":"2017-10-03T17:48:15Z","timestamp":1507052895},{"_id":"c0121dd7-9cde-30a8-865b-6e4c23f56b1d","authorName":"Vincent Yang","authorEmailEncrypted":"J+XYjSGKPr5UMPDm5NBsps5EGD1S79tHeeB0gsn55/J3huTKry9VAZwYojJzmEGI/3ioGwhD4TZlvXj01YL5t4WKK84rl11IrTFqvBMak4dCMRQBQ8x2q+wAewmVJOVni5zC4dSFHZd58geJBKBCW4LIALEbtXAi+miXokFaCVCjIMtRbLOQtv7Jd+8jvINHMh9NQ0paVJRKmdmIIftErzft75yKw6KKfnLai4TOU7HEndKD7bgATs2aDmZQYznfrip4413gpH3otbwLCmjar/1cJxKeeqClPRQxSfriU897RDfGxSwCgCM6yWh4ZJrkKN5FSfSQZmZV5Rco7XA8YVFi0AhXENe0fHtZrJ+d7DS3xoKYT11db4MgFwKf858j3lZv/PTfg5zW9wJKZzAs2FQkLG289J3J3xAl1+tPmTZ3sFzS9DiPSuUm7yhvIPWJhSQsc6Uueg4NkMBYg24oSdg5RL0F4FFkH9zOKD/7ccSMbjji2s/s3kZORW1js4eIYb49dQxIC9rHcrCfSxqVkdKlhkzIBn7f/EOYHAjBKaZvRsFdzbLdG4Q0DQSB4DSISysUoIOmFGFBVcbV7hnBUvCEiwlOgh7SvGZl8pE7pYbQi4fbF057wDeKrPtTTkTXflWKwfXKn2xVJ6p/5D4z31q0DzlcK5mSDhLp7vQBvYY=","authorEmailMD5":"86050cb167bef2a650de158b9cc97f6a","authorUri":"http://itcube.co.nz","authorUserId":"disqus:disqus_plkWhrFB79","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_plkWhrFB79.jpg","message":"Hi Stephen, I really enjoy reading this series. Every time I revisit your blog post, I learn something new.\r\n\r\nToday i got another question from my colleague and couldn’t find answer anywhere. I hope you can help to clairify this.\r\n\r\nWhat’s the difference between calling await something vs await something.configureawait(true)\r\n\r\nThanks","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2017-10-03T07:57:38Z","timestamp":1507017458},{"_id":"fc036e52-7e59-3f3c-8f2a-f43bb17375f5","authorName":"Yonatan","authorEmailEncrypted":"nd/io0mCJK4u2NPGmAs9a2IbBntktVNKPv9eejSxfcNEMJZ3GY6QVcidYm0EXATqcQZ19bEu4NE+o1jLHPRaYk5F5YVClE3xvYMCroiU+JXGkMj1il89+QF17zRU0pd/+C4g9eXvh7uxE6SUGAsfpyD84+r+cSfFCnqjOT+sWF70h7V28eL23nCTSrHkIAQe1uvJ0FILtgyt/sd9DzqTWz1jmBREFrbEF0b19gW3gFF/XdYQUmi80FGx/d1nIv63INOi12rv6xfcujpTa1AxSKBXotnBCiDEfyOredlMobi26iZGHY3djdtadnuMGFtNGi0tmwnnXd+mBzQUiwUQm+5zrA6J/62/jA3YN6Z+Mm3jsa2Y2U1sxeOjNanIAO9Nul6ILWJs5O5A0GxROaUXgOhfRRjuABgahNCUBClY+LMmutilEtZ3fuTEdDaR4sjIGvtcb8tCypUevu12urFYqxFj4XutmkQGr7MS8MHEqUVNdfNqzzkrvus7BIe+dN9oMHS/T6cVexru5SFb4oSJIru/DjLm1QHIQEIxdaWbft5oaGMFHXFyi+wPa31B2qlsrOgmLkeFkIR/6gynmdChHLxPdtiWOGD9ZrFdwfRvP2tpCfkmY7ug4gwaONB2VKVOfm2zW98e6NPXK8KRJ4IzjTHWloIpeKlz5x4q97dpht4=","authorEmailMD5":"dfb9135bdc0eba97dc1d62fcac150136","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Great article! There is one thing I didn't understand. What happens while we await for an asynchronous method to complete?   \r\nHow the program knows where to continue to other (because the ui thread isn't blocked) while we await for the method to complete?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2017-11-17T07:38:51Z","timestamp":1510904331},{"_id":"8bca8e06-cc9f-3a74-90c0-ed75e32987d2","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"There's nothing to do, so the app just waits for some event. Eventually, the asynchronous operation will complete, and the app responds to that event by continuing the asynchronous method.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"fc036e52-7e59-3f3c-8f2a-f43bb17375f5","date":"2017-11-18T11:59:18Z","timestamp":1511006358},{"_id":"0b02443e-494d-3ddd-ac59-4bbed42be0b7","authorName":"esmark2479","authorEmailEncrypted":"e2J+/yfCOiiG7jDuSu5r6n4UY06iIiu/g4DoUzObP1pUkx7rV8eRs5v2O42rIlvoJ0Ip/kwji9w14V/IYRAd7jf98PmiLiCpIe6+ED2D85xWjdlSZvXOU1giH2pjaOK8Ttjuf/tdWzq/GFLE2hbEiSM7mpXMVKRypMhrr2wkM7ULL9IdTlt47KLf7AEpN2OD8CSEO3PgFYshJo624460e1aPLPQkW0OjgCNbw5IYxhgzNewmGQXVzNieybaD1ClQpXRykCyVC25R7y3CIBffpDJEDeE7YAGyTkZUjlS7OnK/2qp2egniFcOu33q7movIU5WGTfadN8cWpQfMt3V5Apnv4v4GMVgQSVQILCHnlkD8tcBSDw91Z/Re88ZAxoOsYc+SnmCXRL3dLoHrjkEngM2GJI55U0xfUdvzlutIj/Xd4UdBcaDmNwiFlgotd1+rEv8f5kVyniIFJO22QpIVw1t4nsLHbjyEBfV3ZaU55qIJlrxGwndGBpag4nyh+jH94DZX8pwAyrDH5l28UOLRQVrEOra48HKEoRE9Ub99UyHu+nmX7vkAyjWjcE1T1gQkXsh+0si73AugcXMLWtxcBF8qzHyORBBAt/mv4RP3VGWxXDbtj47nOoNXvWVLKWsROH1DTe54yjqRdk96y9VUMMkgo4GqHcLPBA/6tsWyhVs=","authorEmailMD5":"a4bacff0e3fcad6ce19e387b4ed7e745","authorUri":"","authorUserId":"disqus:esmark2479","authorFallbackAvatar":"","message":"In the section titled \"Asynch Composition\", in method DoOperationsConcurrentlyAsync, suppose you want to add a try-catch block. Would the try block need to wrap the statements that launch the three tasks as well as the line containing the Task.WhenAll() or is it only necessary to wrap Task.WhenAll? I would think all of it since one of the tasks could throw an exception before Task.WhenAll is invoked, but maybe the exception isn't propagated outside of the task until a Task.Wait or Task.WhenAll is invoked.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2018-02-20T01:49:39Z","timestamp":1519091379},{"_id":"145cc428-6595-3894-a13d-80cabe1abd83","authorName":"esmark2479","authorEmailEncrypted":"KAd6UzlYhsqmNEhuPv7QpNVNC1VIO5f2UVJ19FcReyHr8sICQMmOEnP8iWAWHuaAvFZmxrRCTTfG/8NfDmG+rCJ8Kpwq+085/S/nYntv5baZN0rkIpau1EDbCJX/I1bFypq74+iJ9bDhq2HpNOaKpf5JKS0rzml1aa3UTur9UmtqEFkf3+X3eHF+2ruZuGKHR2p3rs75nDaTN7iDr2XsKXGYZDdOLZQqEYqpyVXTrOrGT0BLYwNzYrJWjV3but5JvwbMEYmnRJ1aT9nVTrrs1Syh0apgwUH4nIPe79FIcBB4xzHKfxrlZzKhOcChCx0hruAZ9J10FveAFITWjU7x4tuuCSEFNVVXAhHYjttVZt2/hc95y8wejJ2a1t7AbJ3U0D1z4b+KgUQKOWWIJqQ3H3eFUCXm6RvzVzweC2Yightq6jidsivR/LM/uvHUEOtPvC7YHTgU8bRRRH2ayBfRBac0TUlQE8JVx3u67CHa5vSy2mrFo+3DMzvvwlAH6ATwBDFbM+ql2pwbka4fCaLo07IwPgCiWTZRV/csREHGyTce1h1IUZzv5bEfDJp7+VSiNoiIFQt93znwaJ5Aagw104DPox+tTL4eNhHBXSpVHuiD+prh2nDzCFMZEd2dReBrKpXFRU55ZW4fXn8GkcuvdV88UVXByi157Mf5suX6NgY=","authorEmailMD5":"a4bacff0e3fcad6ce19e387b4ed7e745","authorUri":"","authorUserId":"disqus:esmark2479","authorFallbackAvatar":"","message":"I think developers who have worked on client-side code that makes ajax calls are used to (sometimes) seeing application code that executes while the asynchronous operation is in progress. But in the case of these asynch/await calls in [asp.net](http://asp.net), the idea is to simply return the [asp.net](http://asp.net) request thread to the request thread pool where it remains until it's needed to handle the next [asp.net](http://asp.net) request.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"8bca8e06-cc9f-3a74-90c0-ed75e32987d2","date":"2018-02-20T02:54:14Z","timestamp":1519095254},{"_id":"6b31d4a8-fcd4-3bdf-bd13-bea3a6c7b3f7","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Short answer: you shouldn't need to wrap all the statements, but sometimes you do need to.  \r\nLong answer:\r\n\r\nThe implicit meaning of a Task-returning method is that the Task represents the execution of the method, and therefore exceptions are placed on the returned task. If one of those methods throws an exception before Task.WhenAll, then that exception would be captured and placed on the Task (not raised directly). The WhenAll then observes that task and re-throws any exceptions.\r\n\r\nHowever, it is possible that the Task-returning method has a bug and may throw an exception directly. So, e.g., DoOperation0Async may throw an exception instead of returning a Task.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"0b02443e-494d-3ddd-ac59-4bbed42be0b7","date":"2018-02-21T13:55:59Z","timestamp":1519221359},{"_id":"81f50e8e-1c8d-3b57-a668-6c25cb4be043","authorName":"Bernd","authorEmailEncrypted":"jIUdfwTbiD8Qd6Zxt4VA6vpZkDeILYZG4Ecx5KB1bKWsKo7/efzbD1Fh5O7YKxQwPJyZc8cmIn6ApNikUKECnheaGghQmX33l40QXNQW4U+/RFQMiQ/jexwm4MAKZJidqA0uOZiAIqcboO4YdF1gu+ZLsaNdS67vdBtQlV8cMtqK17p1JOzImILLG1IzkfwIpq6vi6RvDqzuli4oPsOv/CYWOU/0aMA1lGjOPfWkVBGRnHifdOIi8oInVdtar0DdGms0oZ1KKPWCOfaBg+967YPq0UXPQsVRowKhqbqmL25r6rQmnKB/fginCeUVU/2GZmjMJIm7X45ihtIKSTE6UZaCIn11ZIU7EqVvoLZvvGDY5KTakYRCZgEUMwp8f2HUpMxsXipuzv/D/BCwdBUvrYZfvyNL3qDrDCk0P2g26++XKQsD6jx382e4Bg2XUNkAFJRFk3Go5Es9Ia0urZfvRCcVkCfD4ArwnrgiBVlO2XdBaGfHCk9SGZeqKlgqaJ1MV4mascX9dDiTs0bupKeUo9L+2RzasMe8A/I2BqvNb7W+HUhCWP6YG2HRAz9BgFKdTEy848NXN+qSjWjp9ZWDwoaPr+2U2CHFRVPAQApwPaWliL8obra2XbmEeGJsWGrWcU6JCG0vgNFP7dWUKt2OqWmdFntDp9j5wYKrWrZWUIk=","authorEmailMD5":"56f27410aaa496bb97bdd1c431076eaa","authorUri":"","authorUserId":"disqus:disqus_ITw8EUwYqc","authorFallbackAvatar":"","message":"Hi,\r\n\r\nfirst of all I want to thank you for so much useful informations you post here. I tried your samples in an usual form Project and everything went fine, but I want to use progress bars within a tray application. For this I use the following template from codeproject:\r\n\r\n[https://www.codeproject.com/Articles/75822/Create-a-System-Tray-Application-in-VB-NET](https://www.codeproject.com/Articles/75822/Create-a-System-Tray-Application-in-VB-NET)  \r\nWithin this type of template it doesnt work with progress bars. It freezes. I think it has something to do with the context, but I am not sure.  \r\nIs there a possibility to explain, why it doesnt work there?  \r\nThanks","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2018-03-22T13:23:06Z","timestamp":1521724986},{"_id":"9f22f72b-1371-3b95-9ad3-8b739896ba14","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The code in that article is unusual in that it starts its own UI loop. It's easier to have a main form that is invisible.\r\n\r\nMost likely, what you're seeing is that the Progress<t> constructor is being called before the WinFormsSynchronizationContext is installed. This will cause problems, as the progress reports will not be sent to the UI thread.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"81f50e8e-1c8d-3b57-a668-6c25cb4be043","date":"2018-03-22T15:01:51Z","timestamp":1521730911},{"_id":"2bd586f0-f2e8-3c7b-a28d-37b58589fe8f","authorName":"Bill","authorEmailEncrypted":"QTzNrZtl8MPbji77YF5LKCXGBN6byd0wVb4cRk/ErsB71vJaZtcNU6hjeJV3bRaZtLMQ4XXBEV+B3tTlBvtyj4EpDw3AnmhHck9zQANj0YGClKe2Pj1y4eF+XLRceI7W/Ascey6dkHBweYaPlBiXw/UQkPWh9CPEd8zsQ69lLLvCXTU4l7sqo0JrAkQMuqd/ujY8+eXln/HrkDwmcFfUgh0/zIlODdoY7a8UCxHdtp+m1il9vuUnpOcipejQ4gvz+CZ5Vv41331AxCTx26wf7WR4g+YOJjimaiktENPYlZUBXhiffjxkw/bkOFnJA+5bnJYuWsDsdjmqYSS361a2lkXDLALaSaDXmKJxNkknlwbd0yINHPZFNA9o1WxKqyvUg2WhvhcVOnuraNSlalRcceYj7uxGO7bXOpJnIGKL71UJx1+XNjc1v8fe9ABJXOFG+oW3HA/tzl89B3XPfp+RqWPHiW8ed807Ux1qzJpmIM8/2AF/0lGmnLyiZ5/PKRWRZiN73NOE/nJqb7mDFBgnpr7Vg83mc518gYgNPk1A+OmsYnEb/2AcsU228G5+nx1F8RnNhhhdih5CAS+3pLwp+VdGv6thGUyxtr3AdXVbRlHD2Wx+k9Qhpk7GO3rMWkKdI0y7QnBOAy6oA62TcqoKpwycPxjekC74E30l/eFBJyA=","authorEmailMD5":"6e83241c5e0831be58808284f82ceb08","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I disagree with this part of your article: \"... the async method pauses until the awaitable is complete (so it waits), but the actual thread is not blocked (so it’s asynchronous).\"\r\n\r\nIf its not blocked, does this mean the calling thread is spinning in the meantime when it \"awaits\"? Effectively, it still looks and acts like it \"blocked\"....even if the thread is spinning on a polling loop...  \r\n(Its that the definition of \"blocking\"? Its async because you can start the task at anytime in the method without awaiting by saving the task variable...but as soon as you call await on the task variable you enter blocking mode...assuming the calling thread hasn't completed.\r\n\r\nThe calling thread blocks on the \"await\" keyword until the task completes. Or if you don't like calling it \"blocked\" then the thread is \"suspended\" until it gets a wake up \"signal\" from the task to resume...\r\n\r\n]","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2018-04-30T16:13:24Z","timestamp":1525104804},{"_id":"0387bef0-4d4d-3d2d-b976-a14644b2cbdc","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"What eventually happens to the thread depends on what the code does upstream. When the async method hits an await, it returns an incompleted Task. The thread can do whatever it wants.\r\n\r\nFor example, a thread *may* choose to block on the Task (e.g., by calling GetAwaiter().GetResult(), Wait(), or Result on the Task). In that case, yes, the thread is blocked until the async method completes. Please note that this is **not** recommended usage! One of the key async principles is \"don't block on async code\" - not only does it prevent the code from actually being asynchronous (obviously), it also can easily cause deadlocks. Instead, you should use \"async all the way\". More info here: [https://msdn.microsoft.com/en-us/magazine/jj991977.aspx](https://msdn.microsoft.com/en-us/magazine/jj991977.aspx)\r\n\r\nSo, how about a more realistic example of how threads behave in an \"async all the way\" scenario?  \r\nWith \"async all the way\", each Task is consumed by an await, which means that method returns an incompleted Task, which is awaited, so it's caller returns an incompleted Task, etc., all they way back to some kind of entry point.\r\n\r\nMost threading scenarios fall into one of two styles, depending on how the entry point works:\r\n\r\n1) Message loop. UI threads that use \"async all the way\" will eventually end up at an async void event handler (or what is logically an event handler, such as ICommand.Execute). In this case, when the await is hit in that method, it will return back to the message loop. The UI thread then continues processing its message loop normally. It is not blocked on any Tasks. It does block on whatever GetNextWin32Message API that it executes in its message loop.  \r\nEventually (when the operation completes), the continuation of the async method is queued to the message loop, where it is picked up and processed by the UI thread like any other message.\r\n\r\n2) Thread pool. The most common example here is ASP.NET. ASP.NET threads that use \"async all the way\" will eventually end up at an async Task controller method. In this case, when the await is hit in that method, it returns an incompleted Task to the ASP.NET runtime. The runtime then sets up a callback on that Task and frees that thread back to the thread pool. In this case, there's no blocking at all; the thread is completely free to be reused by other requests.  \r\nEventually (when the operation completes), the ASP.NET runtime grabs any available thread pool thread and executes the continuation of the async method.\r\n\r\nThread pool threads without ASP.NET (e.g., via Task.Run) behave similarly: when their await is hit, the thread is returned to the thread pool, and when the Task completes, any available thread pool thread executes the continuation of the async method.\r\n\r\nThere are some more rare scenarios as well. Sometimes it's useful to have a single thread that maintains a queue of work (similar to the message loop), but without any UI dependencies. This is more rare but certainly doable.\r\n\r\n---\r\n\r\nIf it helps, you can think of async/await/Task as just a nicer syntax for setting up a chain of callbacks. Each await registers a callback with the Task it's awaiting and then returns. So when you have a chain of async methods all calling and await'ing each other (which is the common case), then you end up with a chain of callbacks, starting at the innermost Task and pointing to its caller's method. This is how they actually exist in memory - as a chain of callback delegates.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"2bd586f0-f2e8-3c7b-a28d-37b58589fe8f","date":"2018-05-01T14:47:32Z","timestamp":1525186052},{"_id":"37302d2f-ea93-380b-b0ff-39fcf76f93bd","authorName":"User135711","authorEmailEncrypted":"i00dZQ1jHd4xwcVoYNW55PUPQFhf43JGTrR3L1WP/sWCCqnkvhfhP8oY8zGTZU7PPM7FtuaBWqCHMTd19X9UGH6Paa2UGi+n3aa7n/sHhtljX9n84jg0X5YS7YnNgwiOTPs8zXM18V4x19hWDAB/5Y9ikMhTNnyZHkXT1upIwIX/12DbbeBExQcl+pt9UF/0ZyePLoK+52/gDBDQXckPfayCWnBg4xajhnXxI9nalpXRKesZJsNtOKpeUlUPzX9TwRGTlyICB/VKEVXfy+MauUn0VWwPQ1vpU0oEm2kUEOosqyuGF21sTcfeJJdfJh1DbHmzwLUifTuclQil/e6Fsbnop/HZwhZgrekCH55fklXZCyhvB2NieloaHKZBL8/W1kVmICLlRTYa3JDPm6nj8HNFk+o5IHg5VPTIKDHm6ESbFH0d0cn34/QixdH/+WaDTXB2+rSERxV2m2VOlRKgLfeDw+6HQhA2s7DwhAzHpt+qCgYyFmgPXUfdiLWMvss/O9275o9baSqIErS2eWEsGEz/cThHNuxZFABRUEU6VPxBzcbYnPw+kV3yYuFpYWQmEVKgjdBPo+3rtEL+sUeDFGHYPJzQktU/OA21SVNdu5te6qXlbQgaA2I6dr+1QBohZbVEGsasHZ+AD6DReieHJ8hhRtewpfV8hMGEjq/fLM8=","authorEmailMD5":"5550d22bce46229d78b139d795d66392","authorUri":"","authorUserId":"disqus:user13571","authorFallbackAvatar":"","message":"Are the methods in your example above (\"DoOperation0Async();\" etc...) started in parallel by being async task and you didn't await them?","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2018-05-06T08:31:56Z","timestamp":1525595516},{"_id":"20d625e0-cadd-3af4-83be-caeeded0e21f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"That's what makes them concurrent, yes.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"37302d2f-ea93-380b-b0ff-39fcf76f93bd","date":"2018-05-08T20:43:42Z","timestamp":1525812222},{"_id":"4d0ecad0-9854-11e8-895e-cfa8b3c1d787","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","postUri":"https://blog.stephencleary.com/2012/02/async-and-await.html","replyTo":"2e3bddb0-95d8-11e8-9ace-75653aad6cc4","authorEmailEncrypted":"s7jap5snR4n62A4hClbcB0yCGMYF1s9l4fNQW5RzvWJAakQkyOXNg+z5GQ1A/T7Hw6nIMmAVXzIbX0l00cqnZpNxmoITWdlv9vazSwOnL1beCaoRfGk7BtC2grZ6frKuf4J0+u4YZqRyI6MOWTFpUUZrRtPkFHypd5krTu1CXIxlRxJPnJua6HWjcHps3SxrVdQdBDAwc3oek3DGtekmoVQTOePl+OufMI8xGVsSYHYLezWB0UV9SIvQA1SO5K7A2IgNh1+78FSu6SUsu+4RO9nOm1ADlOCzsNMEiWIwH9O5Gf6Le+q407MWZzb5433wHHNc5HbySnRkUGGCzXFdf1yKRmhwr3lpYjIWmNMQYCORhx+BNHkkHa+D9gk2xX+OuRdb28xSNENaNVbuXTKafJW/MJ6KiWiB5TG09uPjwdYOKLZf3+ViPB7RxWGMycxFkN9PyC/Pn4VUMoKtWU974cBvByTustP3OR/UicPA7ym0WId2wk/r3xWFfjPKPVqOpyJrkn2TCS/MoqKCr7+e8nxVJyBR7Ni348iP7Tsl5OY/OClG3byA7WeV99sU+x96fmCQwSm/r+AgrcdlXHUxfX9wtk5bsWkgVcxeUuh/TRHl+fqK1XGj97HqVsTX5L2ZsA8SmhIIa/0gVTVloK5nh3ICYQsnnAJ4ZV6KFZTFlQ0=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Yes, exactly. Using `async` on ASP.NET allows your app to make maximum use of the thread pool.\r\n\r\nThere's also a nice effect of faster responses to sudden changes in request volume; if your app is synchronous, it can't suddenly scale due to the limited thread pool injection rate. `async` has no such restriction; it's \"always on\".\r\n\r\nMore info here: https://msdn.microsoft.com/en-us/magazine/dn802603.aspx","date":"2018-08-05T02:07:27.865Z"},{"_id":"2e3bddb0-95d8-11e8-9ace-75653aad6cc4","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","postUri":"http://blog.stephencleary.com/2012/02/async-and-await.html","replyTo":"0387bef0-4d4d-3d2d-b976-a14644b2cbdc","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Michael Harper","authorUri":"","message":"This reply cleared a lot up for me thanks! Being ASP.NET specific - the advantage of using async then, is that you are freeing up thread pool threads to handle more requests as eventually these will all be in play and some requests will have to wait for one to be released (especially if the app is all synchronous)?","date":"2018-08-01T22:13:55.977Z"}]