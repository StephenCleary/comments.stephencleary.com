[{"_id":"8ed8b3f2-8d8d-359b-b217-bcb9906e22d6","authorName":"Riko","authorEmailEncrypted":"UN5QaiR/LlCKp+XBAMV8KNhsPOpcUdXcp0O9e7XnAF8qUGzO0M2T+sV5oU/6TlBC4WuFf7ogtssoJk4eQcqIbTyIU5hANt7Kn4tEySPx9HSlW17Ay3bdc7kCHUOFRC6iAlIrEZGjP8J2gu9nu15YGxMgj+l/z/39e5frOaL2XqkZoHA/Zu5Gcw2by9fNqBSnAFhHrsIQ1gcqJjd+s+APSQtC6A2emM8JbC3ZH/DhZ7687D/Xy8MIoUtqPKLevBntFLYF2YJ/xEDXrVQWDkysNCg60TiRPqZZv0dp9NmBdHMmrb5KMWv1Yf1pt0lcyJ4SDdsHM/VN4B5Cmffa5xDRENhKq3L0qLivMbviw7ICFNlU7uBTglR/QbIQ9JjQCE0bUbWH3FxJu2uUTF0GZofgdbqIuHhizxDMeUcvXpYpcgcqNBaT4ZOrtzzMQXZCUcwUr6NzEG0F3vyoo+5Uzeh7mVPbHrkBUXmSJNztAzfozdIFQ+as/7kyIyQOhAWrtpThSCy7YWwQTDKaK9+R/F3d/wsmIYqJYcP5nNTxKedafjZzJoWNt86RO+e6I6yvGSSp5qHOTikPqy8LGN1pmN6CwOsp66G8pxs7wQUy/NNhRwT1jID2YPDceViJ8TqTxVnLpVVENM+lrHagng6FrYp/XqSDDUoq7sE7CD7+2gncW7E=","authorEmailMD5":"c1b99fc51717f507f13d0e2297a64fdc","message":"Thanks.  \r\nNow I began to understand what the Task.Yield.","postId":"2015_04_a-tour-of-task-part-10-promise-tasks-76cdd5a7-1909-3432-9e00-8acd3cd4350c","replyTo":"","date":"2015-05-07T09:34:29Z","timestamp":1430991269,"authorUserId":""},{"_id":"71a6bc62-58e7-37df-b550-c879b97de736","authorName":"AlonAm","authorEmailEncrypted":"tE8ia51m6RGE+EWuhIzxn7bD8BQncGtpBzXq4UUUK+lsvfg6Y9C6b8hJmchaJYiNJPe2rjaUfHfoS9iihiZJq7o9MF4N8twPsO7Pe2LKbln1fsoo54IF1uHR5mKkFxh+WSOs5zDKUR5sB1kefvQqvFX1rsXpYZHu22p4h3f2BnOeixqJP/FJbZ6Sp6hbJTwgo+nJmLblAZoFN+HLjS7z2wPH7X3acjVidiX8l0RiBZh4D2um2V1QrMdFrQN6WkncgFwh/SJQvb/UIXLxl6nX5MdlVbnRpXU+fig50Bd0vc8zI9Gewjl/C6AwiGGK+Na5v273EZU/i1PXyLQXPcILvkOyNzMYkg7tghSbBw9LzEMxo7fZkDFcONH0CGj0SeqxPwCIpa/TDOhDRWn/IxVS4xsb4Xs99zwAz38XHu6BsZNUw0pwXEFhOsaT8Chjoh1j/juUMUFA81qvl33bOdHAapSpGk7Xza8nkxHxL7FGHuUc5XI3nV1/xJs8uy0+raLDZXHsMXWhS5iqQqrsDevauJ2DNtBpshObTSu1djBc/OwvVpHermJ5bYVgWSQqL2Qn3gI9IJG9IqhXz2/lz4EWDlCN5a8c0q+Kna13Abjtzb1p0GJo4Q5pHWAWUxH3M25eap2M7/0tlyk5FEwom8/23fI/D0FgjC+7KY96mlx3zcw=","authorEmailMD5":"31c898b424867589fc97fd62f85efbf2","message":"Thanks a lot for sharing :-)","postId":"2015_04_a-tour-of-task-part-10-promise-tasks-76cdd5a7-1909-3432-9e00-8acd3cd4350c","replyTo":"","date":"2015-07-06T12:38:49Z","timestamp":1436186329,"authorUserId":"disqus:alonamsalem"},{"_id":"9ac62bd5-08cb-31f4-bb7f-d8369483976c","authorName":"Stephen Cleary","authorEmailEncrypted":"QFNZhHyQqXP64eTZU1EE87PsE9t51KASWVru/cgGkQq4VvC4lAC7bZPfXkiP8DSAQ8hCWTe75edNyOm7wi+DeASo3+57EaxvD1j63tnDKAs1Al/hED27VGHT/YPvXBNCzBnLHvmf7au+C4LSTtOM+vUjKCByZtzepLMAhYcd17cwK/qxgFg0Z9dknlyQGbzXXuie8QzK8R5CkS80eIBZKMn5KHboNXWrzge60nuuRh48yb4oEIyqeHVCuJubVniuFNHTR5s+vW+Unn2BGlBf1tYEDPYRpp17/FfHQJaY4wfQM/o5z02ZUrlmyO5euVwxtGwmUkwX6f8NCUETQyKNgYavCvIiS5pEcewsettaccXA8f8VU70G2s8VyTPkafLsxiyWbLdGQcfWoTb0Hy2Hociu/eqCIYynKITbtCIDZsWkU8ZMQwbvWGtwyy/2Lir24VKTktFDf+jXuYIZCXzur99ntdQ8zHQOQI7s2MiExcTlTeqfUwRNPuWwH1dHrmvAxNuOGMtm9tN0IH/gDR3pbiP4EoQJwMObpeVn4vpDDLiknGW/hu3dOEw09PIbw2d1l3GopzkjIhodniKVdDIo9sU04S0xp5qzNjLRDp8cTjAzTt/gH2xIPkcC6wrhLycmM1nXEmHku2yI3chu/E9dkYA98Ep4Wib4y9WtGJiVaW0=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"If you run that code in a UI application, you'll see it resume on the same thread.\r\n\r\nThe point of this original blog post is that there is not a thread executing the asynchronous operation. In other words, for Task.Delay, what the BCL is *not* doing is kicking off a thread that does a Thread.Sleep. Instead, Task.Delay is implemented using a timer, and the task is marked complete when that timer goes off.\r\n\r\nThis is different than how asynchronous methods *resume*. I describe how this works in my async intro post ([http://blog.stephencleary.c...](http://blog.stephencleary.com/2012/02/async-and-await.html) \"http://blog.stephencleary.com/2012/02/async-and-await.html)\"). If the code you posted was in a console app or background thread, then the asynchronous method will resume on a thread pool thread.","postId":"2015_04_a-tour-of-task-part-10-promise-tasks-76cdd5a7-1909-3432-9e00-8acd3cd4350c","replyTo":"e88a34fd-5569-3315-a5c2-aea44881963d","date":"2015-10-02T18:28:42Z","timestamp":1443810522,"authorUserId":"disqus:stephen_cleary"},{"_id":"e88a34fd-5569-3315-a5c2-aea44881963d","authorName":"modernsl4ve","authorEmailEncrypted":"e2vwdw4rTU81+lR3KBEp/ep/dZug+ylFh/LbBmTD3NJpS7EEihiCqPurbniaP0EeLWzMDcQKsqdC/EI4eqIVmMC69vSPn0dXRWfpxjTD4APHNh3tV+vKzDQnuL+2hA/olP4aB/Ft2F3QF/zNzNOM5SenpeWipoA0alE7QmOOUBDRyWiOcdUgxnr6g0xRPYr+r6OmQc9JHewOvMKUB4Z0ICK66oV0nUtAsgp8ujnZK5CPfJnYqG8kbkQMVQ/NoYCDiPiRQnw17nkdZ2gRJvc1/mfw0avqmQd0l5wzuBcPMm2HZd7L/j7FoIXqWzyZ4MggV4uoEXG94HfkkwD13ct8WmSbmFrfny2yjyKb8fozz6AGJniZaLnjUWm2cjHQNjzzgi4BaB+kZT/XMj69wo9hK3C8HVOU0aklSjCHr2/+PlGpIyR3Qx7iT75I/Ufg/xJdpZb+9BoKbfLfpbecu5EYgnF5O9QC7SlPhAQZdxPKhbJGEx11cw24G92ClSfrkhoy7gCd1RU8zIoucBDOpbZWuoXJuLLfmXwgH/qocum+RNxQQ/vsWfOLdwDOBoIuJeXW/C38mO6ZA0lQvrS1NGVUEyoGdPOQysNYChn3RXEKKtbx0dkYd2NLwdLGmjAhssLSFJCjjKrT8t86fhGMtLbszKnFXGakX/E76uNgMmj/aGc=","authorEmailMD5":"10f9bd50e442b17ae72c098e7d3a1486","message":"Super interesting, as always!\r\n\r\nDoing a quick test today to show a coworker how await does NOT spawn a new thread, I run into a small detail that seems intriguing: Task.Delay DOES spawn a new thread, as shown by this snippet:\r\n\r\n public static async void AsyncTest()  \r\n{  \r\nConsole.WriteLine( \"BEFORE AWAIT: \" + Thread.CurrentThread.ManagedThreadId );\r\n\r\n await Task.Delay( 100 );\r\n\r\n Console.WriteLine( \"AFTER AWAIT: \" + Thread.CurrentThread.ManagedThreadId );  \r\n}\r\n\r\nThe thread ID after the delay will always be different, so clearly there's something that forces a new thread to be spawned..  \r\nIsn't the calling thread just sitting there waiting for the Task to finish? Why can't the delay be waited there then?\r\n\r\nThanks a lot, and keep up the amazing work!","postId":"2015_04_a-tour-of-task-part-10-promise-tasks-76cdd5a7-1909-3432-9e00-8acd3cd4350c","replyTo":"","date":"2015-10-02T15:20:28Z","timestamp":1443799228,"authorUserId":"disqus:modernsl4ve"},{"_id":"1be8eaf6-d6cd-30b8-b917-a141cd69bc07","authorName":"modernsl4ve","authorEmailEncrypted":"fNq3Iy0n9acvRofAdkoQFA8quKH0dcsS+rpvJIdglyHhqxfSpalAb1lCBCTRB+C3Qqe3XxOrWxvXbGoZzHXit61TsRASsNAHxgQDbc6GhIZUjPhzox6aH1/tM9hRK4+Osgu3jtSVbw4yk0gvOgab565d5wd0b72WzjR7tCfdY5L4rFD7B6y8ZtC/8SyCSLb6hdSnH+Li/XOlfJgptOY7PxbDvpP9JLsdFsqL6ubirUtdXR8RW3guL4ABZqsbpS1CDKhPuxN0KUO2URPmhGox1xXzrMxp1HgL68S7H3Dgzx23YRVQKlpbNcVyZ+VwHflc2y0QdBm3ABpD4BPDk9TzbBwl43WxICuZ5q6cjSN45nj5FgpX/Bqi5XzfjPvrnAz336xKtBAMYhPJv9rHLQvEI5hnc+7fcstlyMyH5AG8Zy0FKm81ryEosbXQfST8Gfl1PFj0+maipnxslzBEaNrFnCmVx+mUnJVk1JnOyCE1fqBkHMVXykTp41mKj8bqYL8hMsFThb1Nhao+WB5avD2VaOP7vd195tsCR9nfKt3RRvsdPsEQ+LV0bFV4l7NDwkO14yZAMdI/AGa8656a10nOnRZ+GWYEyYkk/toy6Wfqai+Jh879nYKsnsW9LeBh71XLBGU1Pgq3vOiC9Gabi2wZTT8K1p/+9Oq3s4ZoY7GaSnk=","authorEmailMD5":"10f9bd50e442b17ae72c098e7d3a1486","message":"Hm interesting.. why the inconsistent behaviour though?  \r\nWouldn't it be a nice feature having the assurance that by default you would be back in the thread you made the await from?  \r\nIt's these kind of little 'glitches' that always keep me on the fence with C#.. :P","postId":"2015_04_a-tour-of-task-part-10-promise-tasks-76cdd5a7-1909-3432-9e00-8acd3cd4350c","replyTo":"9ac62bd5-08cb-31f4-bb7f-d8369483976c","date":"2015-10-08T08:36:24Z","timestamp":1444293384,"authorUserId":"disqus:modernsl4ve"},{"_id":"75323c44-4a83-3eef-a0de-6ddf036a2aa6","authorName":"Stephen Cleary","authorEmailEncrypted":"QNIPXzFp6n9ESGfsmOVlHgq61xIyI/PcnVnrvP6eg12ttSoBEd6Yul0XsG6ajdNYb4sVzY8+Pq5reqo6jcWlQkzs8BXhw22q5w7hw6NUZLf1Wc5HQ1fDia113CFd4yiHjG/puA3x5msdPNL28J7xQ89nVFJ1uQ/JmSxX2U0ViwSnBppDMPclKiuRogPKVB39HdycxSU7twmut8tXycjBqtpBbfLwLGTs2rm0VYcfGJb/AHKX8imlmrnR8f314fmwLGS2w2OyhTwA4FN1knjKEbHZznV/6O8BShV3EsXi0/U1Yy0P0dnaXoEKjREceeFR5slqr3aFaIJYbyapfMF0U6mj5BPlhNhkYxCCyGDeDBAu2K1356Pz0qdX926jVnA0qcDBaCUOFTjZjbl/VcjTBiN6Z0vqtW2Hqe6srHZjRCCL2s8s1XdpJdXOiUXMXvALGLdvkwEiTF2n3EaweIaSI4eBI/1Q8fZEwqMFqxtEGBQFe1nVADCU2O4Zpdkg91Dpw5+F785m1eK3CsaRVhEQWDsFqX4rzJz5drmrJgddUlu1k+1VONNRf2b9jlzb3NDDgz31gZItbxhohISikUZ9itx24X7ARyow9S9YvmCUPYLZbOMRwd+gtJPZkUt3kD8MWFi4ndAnufRj4d7gWL+qjB+4E20PGKtVkCWvU7WVyTU=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"It's not actually inconsistent: await always captures the current \"context\" (SynchronizationContext) and resumes on that context. UI threads have a UI SyncCtx, ASP.NET threads have a request SyncCtx, and Console threads have a thread pool SyncCtx. So it is consistent, but with (deliberately) different behavior in different environments.\r\n\r\nReturning to the same *thread* is not always desirable nor even possible. If you're running on a UI thread, then it is both desirable and possible, and await will in fact resume on the same thread. If you're running on an ASP.NET thread, then it's not desirable, and await will in fact resume on any ASP.NET thread pool thread that is available. If you're running on a Console main app, then it's not possible (there's no way to \"send work\" to the main Console thread), and so await will resume on a generic thread pool thread.","postId":"2015_04_a-tour-of-task-part-10-promise-tasks-76cdd5a7-1909-3432-9e00-8acd3cd4350c","replyTo":"1be8eaf6-d6cd-30b8-b917-a141cd69bc07","date":"2015-10-08T10:16:04Z","timestamp":1444299364,"authorUserId":"disqus:stephen_cleary"},{"_id":"fa96b3d5-fd4a-30d1-88a8-938ade30336b","authorName":"abatishchev","authorEmailEncrypted":"sgRhD3uMZgfc5MGbiSOqGRUu6ucW+RTgUD2ZFTDe5aDUlRZDaEMxngyp/ZAvrs4wnNDPJhS1y0278kTpNX88WD9863btXaGz8oU6b4l/Gv4E5c8s9o3QJtQwTmAFXh0WU61VOkQOxW2NZNPtMYwYJVy/DVrZzek3VKb3xiiiA8OTXtUIFW3xsvb6B+Plv3lmJa35gMB2Y/k4Bi9ZXVlwtaQDuEgqxfZcuxEYqi4/RQtXCFXIxRmsmJ5nybOcefQE1+5kfocF+XcutVY1N8vJQSch1vzRZBS+rXjVeJFfi3YlAc07q5iZHvwwldoNJPMGD5Fi1cMxCVJHAnJdlEuxER3jH8N3QYX61YVhdnvZoovq99pujH0ebbRtqxIB/LVOuQ5DKktbhasJ2D91+Srpb7nqIaMqDqaDhF47BloyJxUSscN0A2mg1EwN+P1IxJ1FrMpvG6KG5ZpMmPSnY5L8/Yvb+QpiJXIEdMJB6Cyue3ZX5Q3wn4pVRu3br3//9mn8hCLPb9ooYW+kre0wOlCFwGbINI7Rk7T+5h1EisdDUG3tWnaS2Cl2DINJcPKZ/Eh0RSHxrYOxHO2NruJV52gi9zinqg1uij5qSz9ib9g0+zyeIJSqGPvPyH2oQajX+NbioCmDIVX1ftl81f8jFyuPJpcE7oXR8MlfkUXbtAVrdI0=","authorEmailMD5":"b9da2ca6abf3a1e28fb470f2b3ae2c34","message":"I'd disagree on caching Task rather than T. One should actually cache T, otherwise imposes the way how value is retrieved (asynchronously) on the way how it's kept (cached).","postId":"2015_04_a-tour-of-task-part-10-promise-tasks-76cdd5a7-1909-3432-9e00-8acd3cd4350c","replyTo":"","date":"2016-05-29T23:42:49Z","timestamp":1464565369,"authorUserId":"disqus:abatishchev"},{"_id":"c3ff8ef1-9af4-3daa-889a-81b4c7e27982","authorName":"Stephen Cleary","authorEmailEncrypted":"PS30H6Mq9kTl4uwLKjeUU0YKtqoVF/mN9/geCvX8d1b/QA/iwGrST0BAoKcgtu9wtx4ooi9zhAyIhyWLPnmTKULZVA/ik36jtxzUwd1szJH2+997VZgr2J3Zviy/p26+RmdoTdzvWNDTYu6n/iZESswWNg4yDjAKAetdoQw2Y+lass5JWXerPRYpm2QHKacxJDGSNm77VhXcq8tvpDmRDA+mMvI7raq83qSaMlx3aChRJLFd65lVAVTImTc4PMWsMCMVgx8RVNwbmXu/jxxXf4DaQzA2tpmiGC3OKt2+gX/2C2FVUfoMx/rHKbeYP/g97fuLPprc7IFwiLmojWCOWf4HXPBLury4SHNpUtnctuN8svj1xR+zHu2tH23uBtIxMj0Rrh2Po78EoLDX+rT9qmL/jJ4a8ex9PD4Zc+XRFm8qk/9bIOoD/VSVCrBOUl3vko4yNaU9XE5t8+WX31nXRntDEx3FoI8SI2oZ6QH7lhiURPXxeupfFSd0ckbwA0+seAEBoh77vAQ7bbCGXLXpb2WsWz0kKvIDsn1VMsYM+zvd+sTcq7dcNsNxRtw7bUYnHuHVcSf4iD5e9LYeAG0QUKEjNM2dx6F6Q1IO/tk1xzYNrQKx+Kg2qVv++o/EI40DBzxmCAI0NBjHNSy8xuYQ4nYb+MCMfhPNxMkVc9ZwarY=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"I've used both approaches to good success.\r\n\r\nThe main benefit of caching Task is in situations where you will likely have multiple cache hits while the operation is in flight - caching the Task allows all of those to be represented by a single Task.\r\n\r\nThe main drawbacks to caching Task are that you have to put in special logic to handle failures (to avoid caching failures), and that they don't work well with out-of-proc caches.\r\n\r\nI have been meaning to write these lessons learned in a blog post, but time, you know...","postId":"2015_04_a-tour-of-task-part-10-promise-tasks-76cdd5a7-1909-3432-9e00-8acd3cd4350c","replyTo":"fa96b3d5-fd4a-30d1-88a8-938ade30336b","date":"2016-05-30T01:57:59Z","timestamp":1464573479,"authorUserId":"disqus:stephen_cleary"},{"_id":"4bbc17a8-d527-3b60-8856-f32f0cdece00","authorName":"Krzysztof Maczyński","authorEmailEncrypted":"MDWLib403ID2is1JZh4iL/FpD3bg/rlTtGDefDmH4i/NuJRyWGgXFDM1eYL5683cL32LWVpXb0G7L5bWWszeQ6r+T4TpVAp/7eiJf3jwSQVi6ebMlxQZ931yXguV3BaTXfGQE6rA7QHVvrFhiN55oFo1G1RyEC02xiSqR5xiVwl723iVhQ037MHqzV6jizsxTlHNMxXidMPSUQdTaRaqL809ab7dSIcyht/61L+OfYKU8Bl7tC1dPmm/dXJQ8WKZs5tgQc+HS7DnwJiT+J+TdHjSaatoNjar20VXMq85wTip+JvDxPK8QrtaIWfay+X1qDC26bhW0peyKRAUNKUWUZqs3vXqkzG3SQ0nzOfYhUmCUutW4RZD/3YDl9ql4NfPCmDdWuPI3sYpETgH++0CBZx2piH5CWP757ebkoMZ0dxR7FH4BOFDlu8Y52J/w6VuFVkwF7QMEo47Zw9WoMrEm5hLT6RITo9HiO8NCR9v/IQVZdLexbH6h/u61U6BaQfQSDz6vmTSR3fInMc9h3bP87Z2TZXmBcVaHgDbhupBpPfKVyIs05HkSfaHpYNMfEynnhM0JMvEua7fV8eVp12QVhM7xLJA0BQ1+qAkcD/4uHekeqJXj2oS8ZMDZBZujBpuR+4/HCbGINBbTTElkNwmC7k8jpC7JmILyaOhH336CAI=","authorEmailMD5":"d5360532e186762fa684e2394c3ec919","message":"I wonder why Task.FromCanceled requires an instance of CancellationToken. From what I can tell, there's no way to get the token from the returned task. So what difference does it make if it's some token or another? The documentation doesn't say and others discussing it on the Web that I found are also silent on this, except this guy writing: [http://www.codeproject.com/...](http://www.codeproject.com/Tips/838284/New-Features-in-the-NET-Framework-Related-to-Task \"http://www.codeproject.com/Tips/838284/New-Features-in-the-NET-Framework-Related-to-Task\"). But:  \r\n• If it's only whether an exception should be thrown, why not offer an overload takin a Boolean? (In addition to the present one, since I recognize that it may be convenient to pass in some CancellationToken at hand, possibly even with IsCancellationRequested not yet statically certain at this point.)  \r\n• It seems that what callers want most of the time is to definitely have a successful cancellation, not an exception. So why not a parameterless (nullary) overload assuming True?\r\n\r\nOr am I missing something? Is there more to this CancellationToken argument than just a Boolean wrapped in something fancy?","postId":"2015_04_a-tour-of-task-part-10-promise-tasks-76cdd5a7-1909-3432-9e00-8acd3cd4350c","replyTo":"","date":"2016-08-19T21:39:40Z","timestamp":1471642780,"authorUserId":"disqus:krzysztofmaczyski"},{"_id":"35499f60-373c-35e7-b61c-059b68e25c38","authorName":"Stephen Cleary","authorEmailEncrypted":"Vn2uwBosNrc9EDg2VwHhHnIFXO0/yytMzfeV8naIFxunfVigs4zigiNYzCe/fKTSsFQSIp/Xd4OU8Ld0En0c6dOTSMKzw02GAfnN41F4q+TkG71fHwN2KhaL//t0yeIiOvscixetYPjzOOIRU3C18qfaDRfFfNmzCDT2OQUs8qE+DKem8fR7YAT3ic6GhLPlQX+lrpOcIc6IXsuLFKS263Cs7uvFMLxLuA4BhsBWodcmCT4uERCdXGvGPBGB0KHL+UqL1gMHullk5LhBnGnstNxgsV8lbMlxg5V7QYkMUZx5MBsVmX54GtzfgcE+Q1/fx5DAfQW1BOXk23vPDJmXURL4hQDaUpruZBodKmLIAlbBU66P+k+x2YKpRcMi5Gw1SmN9Hs8oU9GRgY27Znxwji9MUtlj17wDJeWQMzaqv5PuZo03xGK2VDQ9vnt1UorrqnM1L+PzodUQFFjGk/CnRPRtGR93p7mUn82uJ8xPj0A3PMeDagE+sZ/7Y1R7D8oW84lQwXvfUV6QgsZ367gGIqpPkdVaAlYA9sP0oo+xZSiNecfN3Qle963FN7WE2RkofxszrxStqyAEYvy8kGTWEAdMz4fX20Ph9IvwlFsdPFmeRpMfKIyCUZSH0gpYiP9CybVQe6LupX8mpfTEt4ww3p+qZ8YFvmzV5zANCw0prDk=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"There was already a way to create a canceled task that did *not* take a CancellationToken (via TaskCompletionSource<t>.SetCanceled). The new methods *do* take a CancellationToken because technically, that's the right way to do it.\r\n\r\nThe CancellationToken is observable if that task is await'ed - it will throw an OperationCanceledException whose CancellationToken identifies which token caused the cancellation. The use case for this is rare but real: when calling an API that can be canceled different ways (e.g., a timeout or a user-requested cancellation), and if it's important to determine which one canceled it, then the caller can examine OperationCanceledException.CancellationToken. In most cases, just checking CT.IsCancellationRequested on both CTs would be sufficient, but sometimes it's necessary to know which one *actually cancelled* the operation and just using IsCancellationRequested would cause race conditions (e.g., if the user caused the cancellation but then the timeout expired before the CT checks).\r\n\r\nIt's also just cleaner and nicer to pass a CancellationToken because that's the standard cancellation semantics.\r\n\r\nI think the article you referenced is a bit confusing:  \r\n- The ArgumentOutOfRange exception is thrown directly. That is, if you pass an uncanceled CT into Task.FromCanceled, the exception is *not* placed on the task. It's a usage error - a boneheaded exception, as Eric Lippert calls it - and is thrown immediately and directly from Task.FromCanceled. Code should never call Task.FromCanceled with an uncanceled CT. That exception indicates a bug in the calling code.  \r\n- You would (almost) always pass in a local CancellationToken. You'd (almost) never want to pass in \"new CancellationToken(true)\". If you find yourself in this situation, it means you're writing an asynchronous API that can produce canceled tasks but does not provide a way to cancel them. That goes against the common semantics - a more appropriate exception would almost certainly be better than OperationCanceledException in that case.\r\n\r\nI'm hesitating using \"always\" and \"never\" in that last point, but honestly, I can't think of a single situation where you would ever *want* to pass \"new CancellationToken(true)\".","postId":"2015_04_a-tour-of-task-part-10-promise-tasks-76cdd5a7-1909-3432-9e00-8acd3cd4350c","replyTo":"4bbc17a8-d527-3b60-8856-f32f0cdece00","date":"2016-08-20T01:05:47Z","timestamp":1471655147,"authorUserId":"disqus:stephen_cleary"},{"_id":"76e7adce-41a6-372c-84df-27b3c2147ae6","authorName":"JullioSanntos","authorEmailEncrypted":"EUzcqQsUGjJXxitH2mqhlb+bMnboe9ztemPaSNrR3YmCMwLpCyEDzU6uCeRrTs/yAlsBTz6fQnnr4CuKmH0Gs71UUAieT+2JFojPmIZvBgTd5sfw2KqLr22NFWtOTPcdjxNkRVlbx0iiACIYLHN0Z0Vb3ufvrVc1TP6gF6sHmtqWrlsb8BdI31dxooxxqWBVAo1c6NPvjN6FHiSrwrxR3s2VuNy8p4D0PBirNTcczo3ndpMhr3mLj29aZyiracvm32EJzNTMdpSyNstuvktbBSMmyjYt8K0l52L9hQ76318ffvig1TdYC9x5GVLFQCy7DzBcJ9nb5m4q9Cm60+AHIlaBn2podNkRb3cBQR1cz8LxWjPdm6D8keiR4Gqq3tw9MTxcMOJ4B2XY/YojB6u6tORO4jWa9nPJwMyH6cd5NoqNpLJF4rtutdD2vwXvqzgvnYTdR2hyutpnxRUUkv1zUyO8SVvDlp8FbmPl9e7LvV6s1nprP6MMByZkt71mpN7sLRVMyFaGkyK5UUWJEkHwXmHyThKsP56FH1vLnQF65WlYSo8ZX0k0ay0Mlxzk80C/HHB+sXsKALoEJzFhXiS41FrRlC0xLWOLmnPTmb9VTd36STqxwWtJdA8iQSLYr1c4Z3o0rJqyadrFriu0j0Ai2gqn5Ba4O6RkmXOJ69LBIZU=","authorEmailMD5":"bfbe92bb4f239103a9c038bf4d0572bc","message":"Hi Stephen, I was wondering what are your recommendations to create a Class type that switches the mouse's cursor to a busy/waiting image when waiting an array of Promise Tasks. For instance, an async button click handler starts a Promise Task that will take an undetermined time to complete, therefore multiple clicks will create multiple concurrent Tasks, potentially.   \r\nI'd like to have a generic Cursor singleton that indicates when there is one or more Tasks running and switch back to the original image when none are running. My initial thoughts are Task.WhenAll and a Queue collection to cancel/adjust the WhenAll if a new task is summoned or an existing one cancelled but I don't know how to get the Task object of a Promise Task for searching the Queue.   \r\nI can provide a proof-of-concept C# project, if necessary. Your thoughts, please.\r\n\r\nI neglected to mention that, naturally, the async code that is awaiting the Task could add/remove whatever object into a collection to indicate concurrency (or just a counter of concurrent Tasks) but that throws the responsibility of resetting the cursor Wait status to the developer, a dangerous thing and the first step on creating a cursor that never changes its status back, specially when an exception is thrown.  \r\nI guess I miss the elegance of a Cursor object that relied entirely on one single component, the dispatcher thread. ","postId":"2015_04_a-tour-of-task-part-10-promise-tasks-76cdd5a7-1909-3432-9e00-8acd3cd4350c","replyTo":"","date":"2016-11-28T20:04:49Z","timestamp":1480363489,"authorUserId":"disqus:JullioSanntos"},{"_id":"b1d6830c-f678-3a4e-91b7-f31d5973d951","authorName":"Stephen Cleary","authorEmailEncrypted":"Tl/o0kH3+vO1RsViqYGpCedZyqqIV9ML7W23/WUgLjziXIC9IBwBP0pZB3zxzVHyKbEh4/u6VpH/vEr8HHy8TvxsBF+xIdNWvkw7pkdliqoYl9n2AEo6JKlg7yg+ZnMQBYI5ZLotc4iCfd5U+GmhEceCMWBCATpg2ERLfDguvKqgcZJd9fqH9dlCQkZum9EWkRuheQldDbH7dI/llXrh46fVxsXmm75sgO2EwbB3BRrH5vBtbMaO61XF3WhASZ+/3jJLa/VVJmkypbJHMsDmLVDhxnsd8raHx4I06aa6bOV1r5VR/8K/17T1qreEP2mH94tlIGf/PalqONwCKTCHpZAFksn+qYm4DHBVL5HIrnuPfD08JF3O2aJTPqTY0s8+VT5756HAgiWktEaiIy8sMfNDMf/IHgDZVOG9X41EII7YD7FuAn9L4El49Z3kbdzRYqX83/gYAlUihh7cxUkAfSmMuYrg/wog3YmXonwf4ITd9hH+XL3oGmOP45NycBMPn198UYlh86cZXe6R4I1PBju/zxm8PhSpFukD+XWtL4s8gXHoOreZI9zI8KjcTTLFG7tprlcqECj05KYM8SEi1CWK4qy95W7h7d2XMekCjUzXysdy1KKgIXgktPzKZaINILdnfL4ztPEbfbGXU2fXtbQB0/Pth9qf0rAXNSloNxE=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"A simple counter should suffice. Since your tasks are added from UI interaction, you don't even need a lock:\r\n\r\n[https://gist.github.com/Ste...](https://gist.github.com/StephenCleary/5e02e043a9febf245df399e1d26380b9 \"https://gist.github.com/StephenCleary/5e02e043a9febf245df399e1d26380b9\")","postId":"2015_04_a-tour-of-task-part-10-promise-tasks-76cdd5a7-1909-3432-9e00-8acd3cd4350c","replyTo":"76e7adce-41a6-372c-84df-27b3c2147ae6","date":"2016-11-29T00:53:29Z","timestamp":1480380809,"authorUserId":"disqus:stephen_cleary"},{"_id":"092f1823-57fb-30f1-8aaf-5178ffae8884","authorName":"Stephen Cleary","authorEmailEncrypted":"XO6jY4MsSqJIitQzQOpeLcud4sLF5Lb35+ELEsv4/sNp2p0mX4V3O0psgID0f11o/ycBzhEYNdVwjHkhTHz7fUOMP4KXagJDrwnc/Ts788WtuWjo7VyWInesgtFrS+zRoZOvMqeL3VzDB0IVz9VRQD6v2L1hUBp9DJYslsf4ENIzRIEE9/AE4uHC2PSHNG5V+8mlqUBShQ/x+/FfE/L9jpzJCzVsB/K7bZaWiu3NrXuu33y5NoEKnEAQpl9vmcRju5JxkSlYXQ0NSS89FAjdInL+6E9F2x/kVxu/ceiqvNjPVYiBkrGpabxW80IVMsPBPG0QCXgCdPYAgmiKkBDsd+2aYhHBDp7J/RIHGUKmBdwGkE229IgEZv0LZ+v53Rr39UjPhkN14+/tdttR3MkNm3fZf7z0VNhMGx2wra+s9AbMDXdAqCqZeM6ZsUvb8Ri6m8uxEiPBJPz5tbxVwFju7ZKxvb37dWAgiAJiYaYBZV3PS+KjZgNGdF3PZ+eT7AvDV9BR02LIaiDK9UKF0+JSkrEPb99+R1C4Vml75pDOeW8YlkEGO3mZ/j8hUXjjOUXzGhQVbyXgORnRkDoH7EGqtZvT7TVcoSgD9zs7FHiXeawIGQS+i7QcGf7C3H51D3RyjcnphiJtJkAKEhxQw7vHL+84lIGQrqXODNBwuRvoFCQ=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"The default for ConfigureAwait is true - that is, resume on the captured context. However, Console apps do not have a context to resume on, so it doesn't matter in that situation whether ConfigureAwait is true or false. The default for ConfigureAwait is still true; it just doesn't have a context to capture.\r\n\r\nASP.NET Classic does have a context. ASP.NET Core does not.","postId":"2015_04_a-tour-of-task-part-10-promise-tasks-76cdd5a7-1909-3432-9e00-8acd3cd4350c","replyTo":"691212f3-a053-3910-ae78-c40ed2dc0dc5","date":"2018-04-18T21:54:40Z","timestamp":1524088480,"authorUserId":"disqus:stephen_cleary"},{"_id":"691212f3-a053-3910-ae78-c40ed2dc0dc5","authorName":"TooMassive","authorEmailEncrypted":"A1sSUX9ZD7tTPWM1IoMufQ8/ZraajNfAnZzmsj2dnvUIYD0H7JNvdnIMLiOc0GHwYe+TG21IxrlyhHWMf8YNVZzZ4aMmfZby80JNsmL08owUsYKUQ2p84lgXNJBfb6R8ZPUn3A5h6IeF/69DkNlxpkf/QVsm01G2wyx+In8TFcvfrgMRTPWt2qBRfAzt44EyVv2mhfgFlwqptet0HANR94r6xXBzEvQ3W4eYjg7ZfM0xzeopJ1kpQ+1VEldc0wIAgvQgxV5HvmJy4HzI4uIuwrtYvPMLUdnM36t0VcWuXPj5rsjQuQ+O2ZT+8a6v7yNZ6FHmIGdGSMgUHOchnMqA8y2NgaBJomRh39gIYQqm4bhMcClv7wbi2Y4VnJkQj/y0JQpclam21TaTgn97pPo2khP3EC79KgBgpQpDGlRa2ZoBfsYcOUA1i+DfMX8QiEtmM+/ujYctDfH5Weq8fxylh7nRtQIX4k8ExKxjHzTubgRalBP0XmG8SbkMV9AVQHzSTYduTCEd5nraay5POLkxMdPpk2QQlA5SPeJGpr0SaQ3J+XNerNgcx0K4tJtyLjVM82HXrkG2hNi2qzsm3XKcZjE5kPLae+uiccYEhMVUZ6l4+qiL7o9srX+PuDVEdvQ2Qks/aKstYeu3RAjlqKaB4g3K6VybWjMV/1hBDTTXEYY=","authorEmailMD5":"9370c615486a06afe173ac839806474c","message":"I'm assuming the second part of your answer does not use ConfigureAwait(false) and is the default behavior. Why does it behave like this for ASP.NET and Console apps without my asking? Does that mean we don't have to worry about ConfigureAwait(false) for those two scenarios?","postId":"2015_04_a-tour-of-task-part-10-promise-tasks-76cdd5a7-1909-3432-9e00-8acd3cd4350c","replyTo":"75323c44-4a83-3eef-a0de-6ddf036a2aa6","date":"2018-04-18T19:06:34Z","timestamp":1524078394,"authorUserId":"disqus:TooMassive"}]