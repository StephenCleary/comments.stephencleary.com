[{"_id":"b9026e8a-3504-383d-9766-da15badb13ed","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","message":"Umm.. WindowStationHandle does not own the handle but does close it by calling NativeMethods.CloseWindowStation. This goes against the recommendation in the 2nd rule. The member this.Handle is just a reference to the handle.","postId":"2009_08_third-rule-of-implementing-idisposable-832d2031-f442-3138-9c21-3930cda700c7","replyTo":"","date":"2011-04-09T19:18:03Z","timestamp":1302376683,"authorUserId":""},{"_id":"e863d6d4-0e7e-3479-b1be-bad04d39439d","authorName":"Stephen Cleary","authorEmailEncrypted":"RcZcRTVFoAyonpBWa4W5kvI88V0JDvLDnpKOoMJiiunO/0AOc0MgxVq/iT+KNGBMzivciJupdJgxFcyzzRf2VI8LU2A1o3G5Ds2ngs0c5GDpsEKlN399snelBBrNjh1I0HQ9ndXVSaT5BLYkqNigYjZGnGjJY+5bsQILepEjV0jbHar9KeYQtCZanY0B7zBSjjjqwBafyd78pVQfGXfzeJogKjgYVxwcEkTdh6d6o3beiM6NBNVcEDnzWkIpMLCorO26ddVMboXzVC5q3lPrssHk4OZQagJMU58YZcwizciY6J6FrRE4/HrVF3zt87t9aUiHaJmozDSegs4g7X57wHlaQIo1istdtBEMY384d1+BXAfwKq2epox1k9a5qtZpQf+b0Sr0r/VwC3041wDE0mp2ZbmbpiGHHCIePmDHdBumM5UwMws4q9yrulKcuKDvSkVP8izkfCx924jWumTM7juiwnWmttSovFHXWAEQWGOkDuFswJclpCMmJKNC65y08tlfzLGpe58MyCVYuYuXo9aGI54t/gMfnFA/cd804dqdkRhVKj+7/EswiKLzQoi/AiGZg/7LRLCmvNYDHlcXR4qRPt4iloZgMcGnArpCtMmme2prZA+Cu28btxLALgftEimN7vJ0eI9NPVHUk89v8FaWrEhr0QV0cTiyfBw9vMw=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"I'm not sure what you mean.  \r\n\r\nWindowStationHandle does own the unmanaged handle resource. The Handle member (normally provided by the SafeHandle base class) is the handle itself, not \"a reference to the handle.\"  \r\n\r\nWhen I wrap unmanaged resources, I usually have a lower-level wrapper such as WindowStationHandle which owns the unmanaged handle; and a higher-level wrapper (which I would call WindowStation in this example), which owns the managed WindowStationHandle.","postId":"2009_08_third-rule-of-implementing-idisposable-832d2031-f442-3138-9c21-3930cda700c7","replyTo":"","date":"2011-04-10T01:58:06Z","timestamp":1302400686,"authorUserId":""},{"_id":"faebec67-9fb9-3d37-b43f-8acdf3371ac5","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","message":"Most discussions like yours of rule one mention database access as an unmanaged or external (to the CLR) resource. But the MySQL .NET connector has a Dispose method which, according to the rules, makes it a managed wrapper. In fact, the MySQL .NET connector is listed on the MySQL site as fully managed. This makes all my database work fall under the simpler rule two.  \r\n\r\nWhat I'm really saying here is that the statement in your decision matrix that a managed resource is \"an instance of any class implementing IDisposable\" is much more valuable to understanding managed versus unmanaged than indiscriminately saying that a database connection is an example of an unmanaged resource. This was only made clear to me when I searched and found your decision matrix, which you intentionally split into a separate post. I really think you should throw in a link to that article in every \"Three simple rules\" page. I don't see it otherwise. Very valuable.  \r\n\r\nI've read a lot of very long, technical articles about the disposal pattern, most of which I didn't understand because they all seem to be written for someone who works in the MS OS development group or work through the API exclusively. That includes your own \"What Your Mother Never Told You...\" article. LOL. I work almost exclusively at the managed level, and it took me a while to really understand that. Your articles here have taken all the low-level obscurity and made it accessible and concise for application programmers like me. Thanks for the great work. It's really appreciated.","postId":"2009_08_third-rule-of-implementing-idisposable-832d2031-f442-3138-9c21-3930cda700c7","replyTo":"","date":"2012-03-23T07:07:44Z","timestamp":1332486464,"authorUserId":""},{"_id":"d0207921-4c1f-31c0-ab92-0c9f78f3fa6e","authorName":"Stephen Cleary","authorEmailEncrypted":"Txf5+EHEXnwO0ZyIAf5XO5sk3zghpxAowA3vsdG9LHpl9YUXyhKQTr7KNv3ZpeF+5ukmkXAYdGjFKPUOjGJTH+TdMJOCXJmVPb2/4y8lsTFJiklf219AcE5O5q+sEVazW5RhX5+eU78F6BlOrolBh9L2RJALzr1BUstBt2gdwML4i/T/1PwIqbBhjOtaELTZd5GdGjw6CIGCluKvXeu13Obje9O5N3RMOYbLyCgp2hrIajMrq1OcfJK3p85bPr9za+0T9ggppb3HhE1FznKkP559hsRwIcc3IpujJS5Iy8IrZ90KYZeYfdPNInIhHEswYS762DH/7JzZUA5T7FyDTcJSDnO1AwAdbcG/oqHcGh1FVcILVkq2PeFX+Z5TMB75X7JXDTqesCk+l3xBmsRZWWJUSOv/wmmHfTh3boIJimA1iN/kgcUWf7QPYlox4zHQ901mvW6rE5ic9B+DSJ/v79wzN2UVR1xjumuL3kHkEYAtXaOQOvBkPqq3DFZqk69THGSLU3syfANdeqrsWgbELd220tNGB4tIzUUMII/4bJ4+0EbvdX+axwGZ22pvAzr8WMLcYPQQwYDyY/bZ/cpAzLOoa6hlmOlalDAtLDrZKz1xGPwgrr8s9eh6RgstRnBDxx0vikhVwk21KtO3Amm4s6+Zk12lPO/dSKENgDhisAY=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"Thanks for the kind words.  \r\n\r\nThe Official Authorized Recommended IDisposable Pattern was designed to handle every possible situation - including base classes with a mix of unmanaged and managed resources being extended by a derived class with a mix of unmanaged and managed resources. This dates back to .NET 1.0.  \r\n\r\nWith .NET 2.0, Microsoft went through and changed all that. They still implement the IDisposable pattern just in case anyone was depending on it, but internally they split everything into \"unmanaged resource owners\" and \"managed resource owners\".  \r\n\r\nWhen I started writing about IDisposable, I was actually just documenting what Microsoft's actual practice was rather than their official recommendation (except for unsealed disposables).","postId":"2009_08_third-rule-of-implementing-idisposable-832d2031-f442-3138-9c21-3930cda700c7","replyTo":"","date":"2012-04-14T02:28:23Z","timestamp":1334370503,"authorUserId":""},{"_id":"b4edf360-cb7f-3912-b85c-7474fb081ff0","authorName":"Bombadil","authorEmailEncrypted":"","authorEmailMD5":"","message":"If the intention of this example is to be as fail safe as possible I would avoid calling a method with unknown performance and (b)locking characteristics like Trace.WriteLine and new Win32Exception from the finalizer. Whatever is intended, we should always make sure that the finalizer thread just does the bare minimum of activity for stability and scalability reasons.   \r\nI would also avoid the string concatenation which would cause a new memory allocation from the finalizer thread.","postId":"2009_08_third-rule-of-implementing-idisposable-832d2031-f442-3138-9c21-3930cda700c7","replyTo":"","date":"2014-03-21T12:33:10Z","timestamp":1395405190,"authorUserId":""}]