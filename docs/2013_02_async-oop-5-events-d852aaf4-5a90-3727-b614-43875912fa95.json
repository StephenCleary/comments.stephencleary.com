[{"_id":"2c5dc456-f748-395c-8c83-2533ae9d6ef6","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"This is further evidence that async, as cool as it is, will never be on par with sync code when it comes to productivity.  \r\n\r\nIn scenarios like ASP.NET, when there are no long-running handlers in play, the only sane advice is to not use async if there is a choice.","postId":"2013_02_async-oop-5-events-d852aaf4-5a90-3727-b614-43875912fa95","replyTo":"","date":"2013-03-02T17:33:40Z","timestamp":1362245620},{"_id":"6e5fed67-0abe-32b1-b5ca-294c1905a341","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I'd venture to say that almost any real ASP.NET application does not have the characteristics that make async necessary (and that cannot be fixed with increasing thread and connection limits to insane (but working) levels). The obvious exceptions are SignalR-style apps and apps with very-high-latency backend services which still support a lot of throughput. Very rare and in those cases I'd just use async for a small part of the code.  \r\n\r\nYour comments regarding events and Rx are true. Still, async has fundamental debugging problems. For example the logical stack is not available and you can't pause the debugger to see what all the (IO-based) tasks are doing. It is actually quite awful if you're used to inspecting a running system.  ","postId":"2013_02_async-oop-5-events-d852aaf4-5a90-3727-b614-43875912fa95","replyTo":"","date":"2013-03-03T03:16:39Z","timestamp":1362280599},{"_id":"77f55974-6cf2-3e32-aba4-878974270492","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Synchronous code is the easiest to understand, but it's easier to create *better* (responsive / scalable) programs with async than sync. Event handlers were designed from a sync perspective, and that's why using them with async is awkward.  \r\n\r\nMore modern approaches like Rx really reveal the drawbacks of C# events. I think if events were added to C# now, they would look very, very different (and naturally work great with async).","postId":"2013_02_async-oop-5-events-d852aaf4-5a90-3727-b614-43875912fa95","replyTo":"","date":"2013-03-03T02:46:23Z","timestamp":1362278783},{"_id":"e9f68741-2925-31fd-89e7-662350263c5e","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Well, it depends. :) I think asynchronous code is beneficial (maybe not necessary, but beneficial) to most ASP.NET code because most ASP.NET apps are I/O-bound. Sure, someone can tweak the thread pool if they need to scale, but how many ASP.NET programmers know to do that? And even with tweaking, async code can scale an order of magnitude higher than threads.  \r\n\r\nHowever, I definitely have to agree regarding debugging. FYI, there are ETW events that were added to track async/await. They're not documented yet, but they're in the runtime. I expect that we'll see some better visualizations and debugging helpers in future updates that build on this.","postId":"2013_02_async-oop-5-events-d852aaf4-5a90-3727-b614-43875912fa95","replyTo":"","date":"2013-03-04T08:22:20Z","timestamp":1362385340},{"_id":"1edb6290-c28c-304c-b34a-62137ef58b42","authorName":"Thomas Levesque","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/17821784613704879657","authorUserId":"","authorFallbackAvatar":"","message":"There is just one problem with your deferral implementation: if a misbehaved handler gets a deferral and doesn't dispose it (e.g. it wasn't in a using block and an exception occurred), the event producer remains stuck forever, waiting for a deferral completion that will never occur.  \r\n\r\nI used a different approach for my implementation. The deferral has an associated Task (created with a TaskCompletionSource), which is awaited by the event producer. When Dispose is called, the task is marked as complete. If the deferral is finalized before it was properly disposed, the task is marked as faulted, with a DeferralNotCompletedException. This way, the event producer will be notified of faulty handlers (well, of course it will have to wait for the next GC pass, but it's better than nothing)  \r\n\r\nHere's my Deferral class if you're interested: [https://gist.github.com/thomaslevesque/7325901](https://gist.github.com/thomaslevesque/7325901)","postId":"2013_02_async-oop-5-events-d852aaf4-5a90-3727-b614-43875912fa95","replyTo":"","date":"2013-11-06T01:55:16Z","timestamp":1383702916},{"_id":"31a24989-3167-373f-af76-1043439edae6","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Thomas, thanks for your critique.  \r\n\r\nHowever, your implementation has stability problems in the general case because it accesses a managed object from a finalizer. You can play some tricks with GCHandle to (try to) fix it, but you'll still have problems at process exit.","postId":"2013_02_async-oop-5-events-d852aaf4-5a90-3727-b614-43875912fa95","replyTo":"","date":"2013-11-06T05:32:01Z","timestamp":1383715921},{"_id":"a7819b26-b40a-3366-83f5-7ebbc31b5a39","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"If by \"async event handler\" you mean an \"async void\" event handler (which is completely different than any of the approaches in this blog post), then no, those aren't testable. However, they are often useful in a UI application. So what I usually end up doing is having all my async void methods be exactly one line long. They all look like this:\r\n\r\n async void SomeEventHandler(object sender, EventArgsOrWhatever args)  \r\n {  \r\n await SomeEventHandlerAsync(sender, args);  \r\n }\r\n\r\n async Task SomeEventHandlerAsync(object sender, EventArgsOrWhatever args)  \r\n {  \r\n ... // Actual handling logic  \r\n }\r\n\r\nThen the \"async Task\" version is unit testable, composable, etc. The \"async void' handler isn't, but that's acceptable since it no longer has any real logic at all.","postId":"2013_02_async-oop-5-events-d852aaf4-5a90-3727-b614-43875912fa95","replyTo":"f1874075-76d5-38c0-b84b-38b4cd980f29","date":"2015-11-08T23:17:23Z","timestamp":1447024643},{"_id":"f1874075-76d5-38c0-b84b-38b4cd980f29","authorName":"Yehudah asher","authorEmailEncrypted":"T6Du2Rg8Q9IA3EY030U2+uPIr6sjy30FjdwhP2R+E+Z+oKeAwFxvAACpqw2Q++hwURV/8uiSecNb01WsMz+LCuoQ4+0M6VSQp6yaDIYqyEHoK2FTBpC2ZLBu6vN2ClKvVZkmG8pOafJ9vE4F4NE0j5/lQ5j3bRZ12rBQw/DtEj48+j656g5tGS944LW+OmH4ETypPn1TU4uhwjWuwjcEAlAt1KY3VVGO8vAEbHNRxxVPckwZ5/xH5b7dpRFbBKDPt0XQoLioqZssYzUUc8S/zM4TTsuEpQp+YPqSK4ocbLkZCUx8737Bb6yTi2tsLvihRgwDhTfH+HYAQhm36dDlYopCbz2BJBtBakZrC68102I7hhwZpCCIJ3J9rD+/V0uq5iuFelKSmm8PlkTW0kUfEGKS9vzdE41Li3rvtYsotvKCwUth0zOn1SjLl8qlw7wSI1xB2gGNJxR9Y9TqvTuq+qa3hM73eGQe0dEW52CwesUR3f2DpkHC1aQ0cfFIBGVXAd9umCABhvvmV9IbJVERY7tBt5vJhO9P6xUtp7aog5JY3xAoIte7KJJJC5xM0i0pVzz5OJE/3J6p5BLFQPAGfPrIoTChIC3+YkXtz8g/e3uOw+bujbM7wHL2+g4bwRYurF+wm+iHPhEQTW8HWt+PDE/iRh/IzkJoBwmV2vn8B+c=","authorEmailMD5":"71edfc7956fbc58d379e0ddc2942b923","authorUri":"","authorUserId":"disqus:yehudah_asher","authorFallbackAvatar":"","message":"Stephen, There is a way to test async handlers?\r\n\r\nFor example, in MVVM, some times the PropertyChanged invoke an async event handler. Ther is a way to test it?\r\n\r\nI asked this question here: [http://stackoverflow.com/questions/33563587/mvvm-unit-test-for-asynchronous-event-handler](http://stackoverflow.com/questions/33563587/mvvm-unit-test-for-asynchronous-event-handler)","postId":"2013_02_async-oop-5-events-d852aaf4-5a90-3727-b614-43875912fa95","replyTo":"","date":"2015-11-08T11:28:55Z","timestamp":1446982135},{"_id":"d1a5dd72-bbff-3888-8c7a-0753db42b8db","authorName":"Yehudah asher","authorEmailEncrypted":"enS15Dm1+MBTDNZhVGP3Anfclkm44KYyPak7w16KCrembG0nJdTpBRUc90CeEnXwngLI1cNhROn7qE7MRhsCf/veXrR9b28J6OxG0BCjPbRdGTShLIYaohA2rqPFhYshac69hDEj5D+ju60pAiNJf3wLJfCvZtbKZ3V1pIwk2pMeNxMp0KiMhiug4Amn+BKqJSqxAj9yC1RgC4UtI8s/yhOeXdqU2lBlvGckwsTRDUse+KbTW0fnTJHkGkZJ7tRUBUkrPepMPPPqEO/GtB0wpDoZ8Whz6YLm2UxZRCQxbZJ+C/BpZyK0Hl45nq8nmLGY9pFLoczCP+QSPDTOJ2+W0S8BUr4HqTWKnxa5GO9pupZzr7saeI1P3/SY5okX7Ez5/C9YtAs2srX/EZgZMm7/r0AYi21uypXEXsLbfiIc9ihYdiH/KXXeCBBMKa5YyRhKHTPTDy2Cij89StEH//ArTXdRzuMSE/1M0fR5UC8XPFs9K9yLt1Axw/PCmkynKAAcisDM81b5r+0TPozDntBBGI854RlM/eIRHje1dk6gPHk9yMyIeLU995+BtHbqbzMzgc5OBFW0K/aNK4OW7WM5RqcZTrWZ5VBgtLIUL5FVma2Maa9i5DKO0ThBSxwXJTNRgo16Gxbea7m4frPHHW7k62wunrL20NllbMQ508DvMWk=","authorEmailMD5":"71edfc7956fbc58d379e0ddc2942b923","authorUri":"","authorUserId":"disqus:yehudah_asher","authorFallbackAvatar":"","message":"Hi Stephen! thanks for your answer, it's very helpful.\r\n\r\nI suggest you write it in my Stack Overflow question, or I will quote your answer.","postId":"2013_02_async-oop-5-events-d852aaf4-5a90-3727-b614-43875912fa95","replyTo":"a7819b26-b40a-3366-83f5-7ebbc31b5a39","date":"2015-11-09T00:18:08Z","timestamp":1447028288},{"_id":"27a97a50-11fa-3da3-9f1b-27798ed7f05f","authorName":"Nehm√© Bilal","authorEmailEncrypted":"AyZqosNFHmeV2UnAB8s4HxTEhXy879m/UJCw7zdBumG9Fhhf7mX6/gf4A7vFNVQu0StrT+m6myklN8XlbQyzx5AfPAXO0Aw4ad/ttHimccmCDTcmg5feSv76c9jdpgcJI7O+Yk3PjU59kEvP38r4IzBPXNubpugDI9kly65VXihYXmkduby+Q86VLssFqoGew+7hY+XOrVGvuH9a8B2Or0fuxgmA1IJ5+NYTBMJWmVufdOqm9pS1XQ138oq1ScMK8ssvAl7n+9ACRKVVMYqYWcyM7J8HHo8IDefbkpCMQDxTVmpFCWvO548V5H2+BJKOhmOcoicdd0s6hFIz+viqIHoJupY4wddVBRWXX3u3/77U90f1huRvJMH7qQ09e06m7Paj81dKFjBWwSVhlA6vIH+mFt0jbRR4K2Em2ZjCAjvHRbkeIjYTPM/fGpVaxUJAurvyfHKvseOdAAox0MpDdnJOFuDi4ueywaLi+XOBrjMXVNtU+bmsp4fUineJy2WeT9Qty1Gwsgvo0SCVP9UX/rEWyluTJihgdmbnQjQy1qfk1OTaDT69+E1tDFa5Rrusom2i4c89lDCXPgpRTIDMfyKi5DouR7x1SU8QgzYxrv6CD+NJNsDcjF5ELsTnPMF2py21V5myORq3zmB8xKbds7Gwe2mLwfG0hEjbnrHuDKY=","authorEmailMD5":"05804d9e1c904e2b8c17d9c1be376fc5","authorUri":"","authorUserId":"disqus:nehmbilal","authorFallbackAvatar":"","message":"Wouldn't that violate the encapsulation of the class? Typically, SomeEventHandlerAsync is private and is only called from the event handler. To call it from the test, it has to be made public or internal which is not ideal.   \r\nIs there a SynchronizationContext that can be used to make the async void event handler run synchronously? It's not perfect since we'll be only testing the synchronous case but at least it'll allow one to test an async void event handler without making the event handler public.","postId":"2013_02_async-oop-5-events-d852aaf4-5a90-3727-b614-43875912fa95","replyTo":"a7819b26-b40a-3366-83f5-7ebbc31b5a39","date":"2016-07-20T20:10:07Z","timestamp":1469045407},{"_id":"2470c566-e828-3348-96e4-406039c84440","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"It only violates encapsulation if you consider the event handler as private. This is often not the case, e.g., ICommand.Execute is not private. So exposing an ExecuteAsync is not problematic. If the event handler *is* private, then it's probably better to adopt a more async-compatible approach (I prefer deferrals; others go for Task-returning delegates), which allows the triggering code to detect when the handler has completed.\r\n\r\nUsing a SynchronizationContext for detecting completion of async void methods would be acceptable for unit tests (note that the async method still runs asynchronously; the SyncCtx just gives you the capability to detect when it has completed or raised an exception). I have a type called AsyncContext that can provide a SyncCtx for you: [https://github.com/StephenCleary/AsyncEx.Context](https://github.com/StephenCleary/AsyncEx.Context)","postId":"2013_02_async-oop-5-events-d852aaf4-5a90-3727-b614-43875912fa95","replyTo":"27a97a50-11fa-3da3-9f1b-27798ed7f05f","date":"2016-07-22T14:34:38Z","timestamp":1469198078}]