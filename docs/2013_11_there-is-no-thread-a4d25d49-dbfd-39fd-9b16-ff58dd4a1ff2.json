[{"_id":"a9c681f3-cc6d-3c00-85e6-08c26258bb1e","authorName":"Alvin","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/03892201689252059476","authorUserId":"","authorFallbackAvatar":"","message":"Awesome post! Thanks for explaining it so clearly!","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2013-11-22T05:48:48Z","timestamp":1385099328},{"_id":"73a45221-7016-310e-b8aa-7f4a919ff779","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Amazing explanation in such a difficult and complicated concept! Thank you!","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2013-11-25T17:52:40Z","timestamp":1385401960},{"_id":"7ee10dd0-b43e-38e3-b875-2aed2bffd3fc","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"really good post. Thanks!","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2013-11-26T04:10:17Z","timestamp":1385439017},{"_id":"0f8f14ce-b74d-3ff6-b38b-3df24405c9a1","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Very enlightening! Thank you Stephen.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2013-12-03T17:46:41Z","timestamp":1386092801},{"_id":"53b9d541-3641-3632-b7b3-7d9774023b2e","authorName":"Noseratio","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/15542702475870519357","authorUserId":"","authorFallbackAvatar":"","message":"A must-read for any asynchronous code developer. I keep linking to it on SO. Thanks Stephen! ","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-01-22T09:22:29Z","timestamp":1390382549},{"_id":"62b1b4e0-4952-3372-a59c-feaad71d6b97","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Thanks for your comment; I love the \"message\" description!  \r\n\r\nBut I'm not sure I agree with you re DPCs (not that it really matters; the details of semantics aren't that important in this case). My reasoning is:  \r\n- A thread does not have a DPC queue, but CPUs do. A DPC can be scheduled to a specific CPU, but not a specific thread.  \r\n- DPCs are executed (at IRQL DISPATCH_LEVEL) when the CPU IRQL is transitioning from a higher level to DISPATCH_LEVEL or lower (e.g., PASSIVE_LEVEL). So they execute before normal thread code can resume.  \r\n- While a DPC does execute with a thread context in the narrowest sense (CONTEXT), it does not execute with a valid thread context in the broader sense (able to use the security context of the current thread). So, they may execute in a thread context, they must be written to run in an arbitrary thread context.  \r\n- A DPC is still very constrained in the code it can run as compared to code running as a part of a thread. In particular, no page faults are allowed.  \r\n- Interrupts are masked while a DPC is running.  \r\n\r\nAlso, these quotes from MS:  \r\n- \"The system schedules all threads to run at IRQLs below DISPATCH_LEVEL.\" (\"Scheduling, Thread Context, and IRQL\", [http://msdn.microsoft.com/en-us/windows/hardware/gg487402.aspx](http://msdn.microsoft.com/en-us/windows/hardware/gg487402.aspx))  \r\n- \"IRQLs at or above DISPATCH_LEVEL are processor specific... IRQLs below DISPATCH_LEVEL are thread specific.\" (ibid)  \r\n- \"Code that is running at PASSIVE_LEVEL is considered to be working on behalf of the current thread.\" (ibid)  \r\n- \"DPCs ... are always called ... in an arbitrary thread context.\" (ibid)  \r\n- \"Before a processor returns to processing threads, it executes all of the DPCs in its queue.\" (\"CPU Analysis\", [http://msdn.microsoft.com/en-us/library/windows/hardware/jj679884.aspx](http://msdn.microsoft.com/en-us/library/windows/hardware/jj679884.aspx))  \r\n\r\nI came across these quotes while trying to find out whether a DPC actually counts against the current thread's quantum. I was unable to find a definitive answer. :(","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-01-26T22:18:32Z","timestamp":1390774712},{"_id":"d059f9c3-04f8-3224-8b49-5289000e88ac","authorName":"Paul","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://blog.paulbetts.org/","authorUserId":"","authorFallbackAvatar":"","message":"Great article, though I am compelled to Well Actually you on one point:  \r\n\r\n\"DPCs also execute at a level so low that to speak of \"threads\" is not quite right; like ISRs, DPCs execute directly on the CPU, \"beneath\" the threading system.\"  \r\n\r\nThis isn't strictly true. While ISRs don't particularly have a concept of thread (a kernel developer would call it \"Arbitrary context\"), DPCs specifically *do* execute in the context of a thread. Now, *which* thread, is the question! They are run before the next scheduled thread has a chance to do anything - they are part of the scheduler. Since kernel memory is mapped into every process, what they need is always available.   \r\n\r\nThat word up there, \"context\" is super important - a thread is, at its simplest, a context in which to run code. Async operations *jump contexts* as they are being processed, they're not tied to a specific context (i.e. a thread).  \r\n\r\nIt's better to think of an async operation as a 'message' that gets passed around, and that message changes forms several times (i.e. from a system call => IRP => APC => UI Dispatcher Queue item). Every time this message is processed, it ends up changing forms","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-01-26T09:42:39Z","timestamp":1390729359},{"_id":"42f4bb1d-3d19-34c1-a1b8-98ed81ff3933","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, it's one of the I/O threads in the thread pool. The ThreadPool keeps a number of threads registered in its IOCP; these are different than the worker threads that most people associate with the ThreadPool. The ThreadPool manages both worker thread and I/O threads.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-02-28T05:46:02Z","timestamp":1393566362},{"_id":"77fa175f-daf9-3772-85f1-ca51cbfcd0c6","authorName":"Eric Lemes","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/04209337471330041525","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen,  \r\n\r\nAwesome post. I still have one doubt:  \r\n\r\n\"Since the library/BCL is using the standard P/Invoke overlapped I/O system, it has already registered the handle with the I/O Completion Port (IOCP), which is part of the thread pool. So an I/O thread pool thread is borrowed briefly to execute the APC, which notifies the task that it's complete.\"  \r\n\r\nWhat do you mean by an I/O thread pool thread, you mean one of the threads that are registered in the I/O completion port?   ","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-02-28T04:01:56Z","timestamp":1393560116},{"_id":"134e36ed-3980-31ad-93ab-0a06967de74b","authorName":"Keyse","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/14078171403075259352","authorUserId":"","authorFallbackAvatar":"","message":"Instead should the article's title be: \"There is no (worker) thread.\" ;) But GREAT Article. LOVE IT.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-03-15T06:30:02Z","timestamp":1394865002},{"_id":"90633b22-3a06-3948-815a-e9ea52c0a78b","authorName":"Guest","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"What nonsense. I suggest you read the following article and stop posing yourself as an expert. [http://www.drdobbs.com/cpp/multithreaded-asynchronous-io-io-comple/201202921](http://www.drdobbs.com/cpp/multithreaded-asynchronous-io-io-comple/201202921)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-06-11T03:44:31Z","timestamp":1402458271},{"_id":"2a20288d-f510-32f6-93f5-2f6dcb9ca8a7","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"OK, I read it. Not sure why you think IOCPs invalidate my post.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"90633b22-3a06-3948-815a-e9ea52c0a78b","date":"2014-06-16T20:39:14Z","timestamp":1402951154},{"_id":"ed864178-7dcb-37c3-af34-6345965278f8","authorName":"Rasik Bihari Tiwari","authorEmailEncrypted":"RHuevm7QTh8Jmm9Leh4ya+NvzwYZb2hHZ5Cw1u6luPZ2SiijeJTEg4X2/g2kRgfjkk8Mx1yxE4ogDld8olrJbQquwAQYeI1UysNDKVQw6TjFvpFyXK7C/BS9TiXrL4bkEkT2XH0UjR0ZWjVfwS7iwAItAILai195eAkfA4cygtramPvWpBotTH0ByqotQiU7BaJDwXf/ffi86D2c7xt+r98MN9FUk9pBajHTbQZXTJH2sd5s0Ku5VEH9zrWB/6ziwyHDYm8zMPczhEYOzqDk3Kv86jw44r3meJcnlxx57MB3nYEG4lgMTOamEhAo9cvx2jm0zvFsjuOV0wp75DCUNOPKrNDgCHOQ+PUOxybNYwE+tDPLI1/fbfLtoEk6Y33i2mCG6ALNn5RjcB8l2IvBL6N3nHtr5q73KTuK1AXMYnos4Oul7srNtted/D8Tgo+n+lC/wGz8mLdNd9YKpKpH096SwBYglBmcyaVFcGT54gQyGYAJegL/rEpBw7rOOy6+mmmcoGQdkhwqFz6/n+pZxA7exjn1hT8hcTqpK4UwqTK9hu25TRObxtUd+My8swUM5X+jRkWV7z3biQt4ZhlNJMO4ZMGdUngxvgPY8Ji+l8g0MNtI4XhU9pfdR6qv9Cp5xb4Av+VrzorUxe+1VkkZ8obuaZC6J7F1C7WYsgEhjhk=","authorEmailMD5":"27b1f6a2716cd1f8159480eb91abca66","authorUri":"","authorUserId":"disqus:rasikbihari","authorFallbackAvatar":"https://disqus.com/api/users/avatars/rasikbihari.jpg","message":"Nice to know the internal details of async operations. Very enlightening.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-06-20T12:50:09Z","timestamp":1403268609},{"_id":"0f4118e4-3ef4-305a-8b7f-ec2c77155ca3","authorName":"Sam Penn","authorEmailEncrypted":"USjWSek8b0Gn8+fTF1A64ldgU32hUssEW+V83JSRa4VMZ4aJnrFRU46/YrGj+61WLSh2E0yzFIczHgbiFntoNtA3rtLXAJR0gAsLCXOJn/X7KYxgp6boWQookcuFKRcVrt5tmM5d67Wp6IJ4tdvsizTUyArBAR0lQUmbki6YDnmSkULoovseW8YbsfNOthSIzWs74HcdzI+j0qKBsgdDoLyE2j1Lcbw10yx+D+qoVju1Ir38wr2XrjoNCc4TfWHuNPPslxBivlBBqgu3ZcnWuUzFoxEAxMA4/k9RUacU4KDZseVIRdJ6R1jeOyu69W1MP08yWF+t+blMDNMg7EjShhmTjd7pY5IUha/eK8V7zevUqgiJUiNu9SWmhNh7eY3LQ+yKRDiAXa5GfYfHYOj410wRmhhHscT6tKApQRB8sLfImy0odJYlxva43XNj5pa+tnyEXPt8gLB3lTCTEcyqi9lxL8wFyrmWHVG1useoDBuuNRPKV9bCaDhx1eOyTdqFJLkdh0vUrTe5egoj42YXz1S5TozEzZCfpU2siMz9rC25ak92PlvCJ7q6Jz9RlCDp2r1C7TW6yzFP+Kzl6eY/BLD7LWWhSEAuEjwXMkjqk5VqeTFW9WdA6cQndm7Bjuoe0h4q6vJriWLviSjKthUImoJgFoxitwanTSif4WP1KiE=","authorEmailMD5":"3c66282a10af8908ad315d4247c63f14","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"nice post, but what you were talking about is only limited to async call chains that eventually pass down to IO operations (or IRP). if the async function is just a long-lasting pure CPU operation, say, very complex math calculation that can takes 1 minute to finish, you will inevitably create a new calculating thread(Task.Run or Thread.Start?) so that it does not block the caller. do i understand it right?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-06-27T08:11:55Z","timestamp":1403856715},{"_id":"82a4ab2b-b9bb-3c6f-b048-ae7ee169f98f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes; this post is specifically referring to I/O-bound operations. If you have a CPU-bound operation, then that code must run somewhere.\r\n\r\nCPU-bound operations are inherently synchronous. One thread can *pretend* it's asynchronous by offloading it to another thread. E.g., the UI thread can *pretend* the CPU-bound code is asynchronous by wrapping it in Task.Run. From the perspective of the UI thread, it appears to be asynchronous (i.e., it can await the operation). But from the perspective of the other thread (the thread pool thread), it's still synchronous.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"0f4118e4-3ef4-305a-8b7f-ec2c77155ca3","date":"2014-07-11T13:24:53Z","timestamp":1405085093},{"_id":"d4692f6c-c3fc-329a-80ac-4cbb7e3c4403","authorName":"John Peters","authorEmailEncrypted":"SyPyPJ6COevS+xrjCetwZ8KxbgxybULNh+7iCGSam8G+vzyhvUmWJyY78GVLbD+IEsPj1tzNHyHFBsVQgVAq5pM/4sZ/TrQ1DiYtaRA7evXJsLyAJfv3BUAeVhzpF8OGAK089yE7mWT9hIyNO3PhNnftMz6dODzrUSnWm8wOyVLhebO8v0OL4VkcOkyWJPQkiLomAuJx5cqkEHd82WLZlJZsLwDhVg+wPrEwWlc9DXJN/LGQT0b1XIT2bDGpw+/Z/WvySrjiMGOW6lJNX9Zinmbg1ZShT2nBADqdGWNOtzuXyQqGwg5PzFztsWkV/n6TlUIFgtm3s9DbIT8+R5/35y37TVfzWHf3M3rkz0n5ZgMj9i6k+WtMji3OzgwxOM1wuy9Z1JyRnc1mNVGdsAYYuFceOJp40BLB2B8FK9piuaWNxeQ8z8oxgJPB740u2rq+XSx4riU/ErOGnkXGbLzwCLZrKjOlD0/uwJkHwtNBQLWMFztXdkyhF9sd9cTnJgt6JtBcQuuYtPHi+o7HOjVNyapkGUlWzr4MW8loUlNgOPh6nH6dOEARU3dOz5/ukeIsLIkXyD3LAZ+x/QJViOFbKAy79UVAeFLUn9SEDIlcPUArzu7umNcB9jMEpEdQHr1YJ2s/yGJcWxyAry9ZrMGceJs74ljkhzcXH3PrbDOpRLY=","authorEmailMD5":"b3d0b8f681ed398a28c9bd288d7c1f96","authorUri":"","authorUserId":"disqus:disqus_TOgNSvWnKm","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_TOgNSvWnKm.jpg","message":"Interesting, perhaps this is why MSFT claims that TASKs have no CPU affinity rather than saying Thread affinity. But I think the sample is too simplistic because it implies there is a BCL equivalent call to the .NET statement of WriteAsynch. What happens when some simple .NET statements like \"var a = 10 + 12\" happens? That code must be run on a thread using Gen'd IML code. In fact, when debugging Task.Factory.Start.... in the debugger by threads, we see a new thread for each start don't we?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-07-17T20:03:53Z","timestamp":1405627433},{"_id":"8b34bee4-7c15-3e92-9d68-c7c9be9bd10a","authorName":"Tejas Vora","authorEmailEncrypted":"sQg4J9MiaoAghcq4gQclMhDbSUrxnG+hBuO3gSdqIhjF0aFvssRG2W/8Ov97VierVNgN0ltNhNBbAdGjRwkcK0wi+TQDXZCRYffOttoA2rm9iq2KK5CFZQGvEK8s/pnezTskyL339Pa3VSGsobcCejKYh1ITAni6W4KTCb9rx5dD4d/IghfBKT+DpP6zioeWi1NDPLDp9yo453KvEGnhEVgIA5LJkP7BCUgyEc5FxWYRjFE/TaHczBAAD41yaZPOrGdPkITfmU8lRBiCU7cmSNCTqTz+H9sy8G97GT93OkrN+DuG0D/IAITq86kEGra8D7RQ8xcqfjQWaFHRcRmlxn819f2dKy23xaPT9krJbF3nJFH/Avtr0wCLGzyFeH10LQVrhdAhr33so6BCMCw7RFTFp9amTmHBRuY8hknv5RKK/8ThfNiWQPjcGoGMkXY7wyOJ+OSwEFaiASUg/w7dwgrN15Vc/9KHYfyfhR3yWDnPgLUs4YIhNNTikkdHCJoLHqG8aYqYhjtkMJlkPKcvRL2U/POePae2I9a3zxACkedEJkgsyE8hLZPBFWj3HOype1IqBp8onVADqWDTN+fVi9Q1QVYzk+LSlqIDAuUVFl6xDdxAPQ6LKfuunnsvCcxT9kqwbvQOwk8qUJKyKPAq9TfuoFo+r+AjX7Zogo1h/Uo=","authorEmailMD5":"69e47bbeae22b8dd9cb37ddcca94f6a9","authorUri":"","authorUserId":"disqus:tejasvora","authorFallbackAvatar":"","message":"So the question is: Should I use `async` and `await` for the computation-bound operations in UI applications? Or I should only use it with I/O-bound operations?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-07-18T19:11:32Z","timestamp":1405710692},{"_id":"8971cb8b-776f-3fa4-ac4f-20e38e50fe45","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, in UI apps you should use Task.Run to push CPU-bound work to the thread pool. Of course, the code must run somewhere, so in this case there is a thread that is used to execute that code.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"8b34bee4-7c15-3e92-9d68-c7c9be9bd10a","date":"2014-07-20T17:34:52Z","timestamp":1405877692},{"_id":"d8262ce3-d34d-3559-b894-7ba8ae9af286","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"This post is about tasks that represent I/O operations. If you have a CPU-bound task, then yes, that code must run somewhere. You can use Task.Run (or Task.Factory.StartNew) to queue that code to the thread pool, which will create a thread only if necessary.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"d4692f6c-c3fc-329a-80ac-4cbb7e3c4403","date":"2014-07-20T17:31:41Z","timestamp":1405877501},{"_id":"0524a472-b549-3281-918a-716fe8834378","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, as I say in the article, \"When the request completed, various threads were “borrowed” or had work briefly queued to them.\" Completing an I/O operation is not CPU-intensive.\r\n\r\nIn theory, it is possible that if the thread pool is starved, it would prevent async operations from finishing. However, this is extremely rare, especially since I/O completion port threads are different than CPU thread pool threads (the ThreadPool class is really two thread pools in one).","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"13b84301-cb0b-31f3-8b3c-79e2088f1ef1","date":"2014-09-05T11:52:20Z","timestamp":1409917940},{"_id":"13b84301-cb0b-31f3-8b3c-79e2088f1ef1","authorName":"Cole Thatcher","authorEmailEncrypted":"U3ZUNXRkcDV/GmijLx9548/BdXFqUVCMwMKc9XxIjO6xINXz0AHghlmG95En5+hMF6Zu2EzrulEzRPUkaCZwPOfqWQHbprvQwoAmSn2FugHKfo7YjSemKXqvrHZiG5ByCK1g0t2PJV6hMpnbc0eyBhVTCiEeuDyD0KR6snz6nwC4riaH/kFZ5Q7LksMF1Sv2ggEBofF3i5BXeKqXBBPiaTiUIQRdqtdlziIdZs7NcZh6bmx/tSint1OG+LJVfyj2pzAlwTOHMwR27tr5VEWAectdK91BW4HCcY3eFvOPBkl4wEn7hiJjUXQEfjGR0ZFpw1yIfBflYAkHGmJfi8RN8scK387+CRVxIrbXITADvmN71pE/sLfw4qxQUyJinC3ysjpWrs8TcJDJmAeurfNCpecw4ft55FhK1aJeauVYpyI8JTCwbZVoQNPPTCYUKlp1rMOUUFAbZfSgxC/2w1waSSTG7azNtM9e881Kva8vVnuBcfZQN2XjtWjthJPw0DlzOQyAN8Ic7nhkXPv5z+O/rVeiG5QlkEoOkdgYjezMCJppVDjqe6fKJhaoieZkqAeplItQoVQ0VLesA3tElIdgDCdIEdQAilJrhfEhuXsAVNWtI06oinhKU0QAMiD99STJysxu75NhDfAjCzAs1eWJyGVtweU14iP8ncssThGa70Y=","authorEmailMD5":"9f28cf5977385aae254f6d12251b6745","authorUri":"","authorUserId":"disqus:colethatcher","authorFallbackAvatar":"https://disqus.com/api/users/avatars/colethatcher.jpg","message":"Aren't you still posting making use of the threadpool threads though (for continuations and servicing completion of the async call?)? The point I'm trying to make is, it's not safe to say \"there's no thread\", rather \"no thread is blocked\". Developers should still be aware of CPU usage and make sure they don't eat up all thread-pool threads elsewhere in the application and automagically expect async operations to finish.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-09-05T07:48:51Z","timestamp":1409903331},{"_id":"0ab6974d-0896-3a5c-a067-a2f780792863","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"HttpClient uses the exact same principle, except it's a combination of operations. An Http Get is just a write followed by a read. So it's a bit more complex but the same principle applies: there is no thread blocked waiting for the written bytes to go out on the network, and there is no thread that is blocked just waiting for the reply.\r\n\r\nRegarding resuming async methods, I cover that in detail here: [http://blog.stephencleary.com/2012/02/async-and-await.html](http://blog.stephencleary.com/2012/02/async-and-await.html)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"d45d2368-4bf6-3b2e-ab4a-c5a3dc43a343","date":"2014-09-17T15:00:48Z","timestamp":1410966048},{"_id":"d45d2368-4bf6-3b2e-ab4a-c5a3dc43a343","authorName":"quazecoatl","authorEmailEncrypted":"u4QHkkqlh+cV6TCi3VvQ7i7g8Kh7DWyYAIJm2l3KyKqDV8C7HmfGpbRw42Kt2UGJR9xTh+FUhXG3hyXwTD+kxc2hcPSELBCDVpJxggu7wJKfpmliapC1JA5wWWxQGrDVSsrCjMRChIgWHNvGriZrwfirhJAwz5KsjPsCI/V5zS37ysyFpL3RiVZnaii47Up4gGCA8Yi5bfketO73pbMgAj5pMlEkPguE8XUdcPmVWDPOJ8S72iKn5Gz4kfJxyqcTzTy+vTUzoCoO9ycCKHuHgv47oXRIEzu8AOVbzd8pxrxyWeZ60Tlby/M9l/YshdonowmfZA/zesCn3S7haQeYyF1j9KsYxBTLy2ceBeLD1af8qbvRUb660qpNSEsA92UhSR7/ZXJzp9MqWsXsoxUuBWLRc9Hy8a8s/327DlUgrBdCloPsAWOGMuGys1vgdaZHkqrBlcdwurQCDziRP7H+/3RtNYYn7DugwfKfPIg4yBa8eitOvO7WjE+PvHj5buRkwS0pD2+Gcs0suxGc77cLYw4VXStptNUAMGNXIOMMTlGc2dSdcfR9OGP/AEiQjzEM/BppexI+qEoe5cnAGEP6GiYI7pOmA7UHDjo7n7rXdZ2myCym0iXexd2D+jRsS8HRJ5FRgHBO+DtgFMPTX72VuJSDMO86wRw+ySTOjQZojpQ=","authorEmailMD5":"02005278d93e3927c061d5022e68c1c8","authorUri":"","authorUserId":"disqus:quazecoatl","authorFallbackAvatar":"","message":"Thank you for this article, great info.  \r\nYour example is for a generic 'myDevice.WriteAsync'   \r\nI wished however if you could give the same example for a much more common one, using HttpClient.  \r\nAlso, I wished you could give a little more detail about how the resuming on the async method is done.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-09-17T14:47:43Z","timestamp":1410965263},{"_id":"2ec92642-9cda-3f30-a0f1-3b33272fecfc","authorName":"Flemming Bonde Kentved","authorEmailEncrypted":"sljNeIS/3H3LrLcHHeGfJ6esT+g9Zs0Kd+iZN+4rv22fGVFrQ1bjReWCSEnhzqGkRNxuHiqqhhz5iPSZqLhdq4tcLIpU9OX8Sc85bKx5WjEI6yZDPK2mMPmSN1b+iEjFwFInXlpILQWDjt+qrHSxRaCeVNLGnjKlUsxhKEAMcYv8aeWrjkCl1rg4wLE6zZE87vD9b11kHqLQIxxKNCkzSpP20TnmLSbHO1aoUgI9V0T9B5Spk5Kd8VoD9wub7vFSwK5/T2jVm0q9JZT9DUSUefjeXPdIUzgQv/KSISBnWmpdoSevlHWdxc7xCDgCRBVWQdJajEnL2uZUeh/drM5Wc6Ktx2h2veQoCtlZ52g7xQkuFOXI/kD6fK9DH5hP+hXVDpaOIp1qqgb+b9L3g116JwRAOEih4yeXr/8KLOzF/E0h6P+c4V6LU9LRUWwYs+sxf+FmJ0O6DbO95trJlJJBVitpObmEhN6MpX7WlWOOSeoAMtElIa+dV0VlpeiGATi0t15o9LQiE65jnxmssf1zuHoMX6pINtr3KR0y72oRe0cAfaYe4SlB/0AQ1qGmnJHITTVF4us4EcXq0KpPcUD/cmGrS4SAN7KCWZBGBUcWiFJUZNSBxbTN/7aadXXvHEESw5lf4h8gkoPeSAL1W2LxVnu2qOXxqiikOgxtsGS05to=","authorEmailMD5":"bb69b61815507f213ad10e182710e91d","authorUri":"","authorUserId":"disqus:flemmingbondekentved","authorFallbackAvatar":"https://disqus.com/api/users/avatars/flemmingbondekentved.jpg","message":"Thank you. This had been bothering me for a while :)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-11-27T14:51:29Z","timestamp":1417099889},{"_id":"16f3f266-623d-3eb0-8b9b-be0a9f347dc4","authorName":"Andrey","authorEmailEncrypted":"hWRxHIfvQmYmJRWFy8OjRhy9qkmWnUqzX76tYUWOm6XnlGTP1ro8CQOjqhKIrcoXLJtJOWrN/NfOYQ5+BCL5q0IpteDEplqnK0KCvccTGuq1gzr9YTaFisPSDeLdPm+/3s/qhpPDY5cRuAhW8gfMc+LdBMf+Y6GldS9XR7mscYHhiJKakjyA6AnNn3nF3PvX7qDHviXoUR5cEx84upt9K9Fuy4NU6tzO1dAu/fyoqmvnhCrsFnxvidoUidWQrxs6QhegUpkbr7eOXOcqucoUuHHgDoYr47nkdjlDJ/RDlEXa3RGAiGEqbj9oT3wDe8YZTkn2xEQOztx2J7cA572cHrgZjlY7vVoqVZWBBcAkti4zu93P34DlSlvVxsQ6kPL07OeqmlZWRZXy8tjXGnr0tIJkK2vUa/Dcvku6/bdqiN/4u6uFEegYrD9WXxq6fvpv0EA581WjIvvSZcNs+cky/HnH70MKwYe9HiphgtoxO0O+qBLPs36CBCJgs88FyGs2TroPbGIXb+fH7ze3wQAZJi+q1iPEWnbfKEkCt+CtBjC9BEc2hNZpPKCkND/omyP4toZK1sjdTP7xknG0NhA11cszd3AmR9MWLpYLwhpM+uavTVa3aEx3yxgy2IcVXH2VX4iZjdZt4HmzIYQXQ2ibi9qQpzTkvJkq3L6In219oL0=","authorEmailMD5":"34a7ca7a417b590cb4d11bfbc9613c61","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hi. Thanks for the post. I have a question regarding I/O threads (IOCPs).\r\n\r\n\"Since the library/BCL is using the standard P/Invoke overlapped I/O system, it has already registered the handle with the I/O Completion Port (IOCP), which is part of the thread pool. So an I/O thread pool thread is borrowed briefly to execute the APC, which notifies the task that it’s complete.\"\r\n\r\nAren't those I/O threads blocked while waiting to be notified to process I/O callbacks?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-12-02T17:25:40Z","timestamp":1417541140},{"_id":"d2dc9613-abe7-3ec8-a17a-4fe185bc7ca1","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I/O threads are blocked, yes - they block on the IOCP itself. However, one I/O thread can handle any number of IOCP notifications. The thread pool will inject I/O threads if they get bogged down, but a single I/O thread can handle a *huge* amount of I/O. The IOCP will always exist for an application - it's used quite a bit internally by the BCL.\r\n\r\nSo, you can think of it like this: the BCL already has an I/O thread(s), and by using IOCP you're reusing the same thread(s) instead of blocking another one.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"16f3f266-623d-3eb0-8b9b-be0a9f347dc4","date":"2014-12-02T21:38:15Z","timestamp":1417556295},{"_id":"5e64b4f3-00f2-31ec-ac78-14adcc352b51","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"You could think of it that way. Another way to think of it is that an I/O thread is waiting for *any* I/O for that entire process (or AppDomain, technically), and it'll do that whether or not you start an asynchronous operation.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"df81868a-30e0-3410-b1ed-7a739fcb2494","date":"2014-12-03T11:35:45Z","timestamp":1417606545},{"_id":"cc8a2706-ceaa-37cb-86fa-52a7f52fa29f","authorName":"Andrey","authorEmailEncrypted":"Nm/qPZPAUljThVs6tW2pYMoUStJE/nhBgCawQuy27bMM/rUTOE/MAhK/vF6E49vDydFuezVsLoC+zFTEoNLxaaNlV5OjGtKeSNxNpBQgKm/EH6TV24Bm8YDpfWZWvY2FcKNjiLfjUv2gkjlHtdws6JDUDuQ3szxYz0VqAbCq5PpOsidatvgW0uaJ/2M+RWzUnLoLhP+YuyQYiAJQO+/pWfUrwG8R71qJs6yBJtP/jN4TOp3wtDdGdrXJRrFu6zASlicOuGJsL0OdcSI1TW0uAkRtSSKdJSuIh6EsmStVzN01tUTZFm8o132kEopmXgoF9dMYZjDTfVMXkHqMUeXNgBXeyRNbAPHvNw/Os2o0WBgDk6VPD7Jvy0ojv7Ebk/Z0YqX11sfoi3BZi2r1jGeFWim8knh7qFBkqD6c9KVeWactu3U/ejiTq6GLg8cO+qaPTkSsoem7CXBvikMu6KBwe2bpv+j7no9HrhfHQv83mImcxfJnl8d6XuhD66wDhQVr692rUF0oaazlq9C77H0r4ErmgFVNEBMRKndMt80RmSrkbZ2C00N7I1F2lZiMMSddJbWldLiPuusQ0L5lPYdnk7obAVAkP1yRHmTFZlAxuYK0dk+sqzATxjrpSg/PlOdh2+rlHMLlpOteraHb182xkBL4o91V8LjuDlhJI7mioS0=","authorEmailMD5":"34a7ca7a417b590cb4d11bfbc9613c61","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I see. Thanks a lot, Stephen!","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"5e64b4f3-00f2-31ec-ac78-14adcc352b51","date":"2014-12-03T22:39:33Z","timestamp":1417646373},{"_id":"df81868a-30e0-3410-b1ed-7a739fcb2494","authorName":"Andrey","authorEmailEncrypted":"kIobK/w7DBKqy4qYFq8WzO6tYr7UzjxFRc21nrvfpC0XxjEa4PNhK7lcPym5HaIKOZh74rQi0ji2w9RMxbeeOKllRR0he1vyX1ytB+wTSrvLaGu+meLN0efAiKDn+uahlzpNTwdakKGV0byNcGt9HvIZjzRZBPRqtHDWYoV+cl9DGU6ecLJcinyXroZQdbMX/5MnwKzeSxHc5aMzo0NRDQkLI8TOdThE+raR9eI0xlkdGafYj4gBigq8XD6Y71/xeOx+t0iYvYYIMNzZZ5+Cd9XyxAQ2W+8dd8l8Z+JE0gfHdMKqep/mD1cIzNRS8T9JyW/nCMk0J4DTubbuFXSkBKQ1Jko+7BsoiIEZG48vLFUDOyXlaCSVaLlTih+WMFZ5oyE6SbB5Jge9GDKHBh7NMDpQOt4/ml+RrIA54l2c9ALfB+zkKq/WoYfknxNdvOnOONXcAE/MFsjqbNUo5lgkeWMsEH36ZhcVQbB+aCsAJMhLk1SU+JEKj3uwbeNDG73RFViE6prcwzXWnnukgxXszGK1yUzBT+8hgPKXOz9IaiwBlOerbDAP/kePlv+Nx1PIBSDosr6f/RNEDE1oB+ScV4C7ED2eE1nVYewlvlFaNTKt2lO7v3635wvOFq6dIrBkcS5xdAW9NuXP0cHZB3nzlQ27H9xGvHV8D0X/wauUpvQ=","authorEmailMD5":"34a7ca7a417b590cb4d11bfbc9613c61","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"So, in a way, the phrase \"if I am awaiting an operation, there must be a thread that is doing the wait!\" is *partially* true, but that thread (an I/O thread) awaits for lots of (I/O) operations?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"d2dc9613-abe7-3ec8-a17a-4fe185bc7ca1","date":"2014-12-03T10:59:19Z","timestamp":1417604359},{"_id":"206b600d-4804-346b-8a48-2f0b7fb90a78","authorName":"Joe Messere","authorEmailEncrypted":"ta59He4h0ow3byuq3MYIpK6DfTP6UyWlfEIxEHhZ1e6I5jzuPhW9HRAc7y0shthCQJyR3CaWwsutktbIlj9gm706t9B6ekwonG7BTuqm5kbFH3798aDZIsaigxOHsPAnbelqu4YKPIjiIsAyWjGCyyLvpOsvyIp3BMRb3gtnaJQ/N5URO6jO+tCtB8bbWM7fwmT6uyn0k+oCImKy6eprZIpDCQ/2ID1Eia/rEIAiXngYUqurbXSHv0IUDs9PTQroplvBTOmniHdm9lCUQUnWMk2xrKSheAsSEeKV/rxlsdtf3jcWjndcuFhC57TmCIw5pF/7EonzmofWyiZtREoeD4+JI8BeUW6TWZ633YXNZSRcROjm+qwz+J08mH0yAbxrUgqCTvQZ67FbiXPLKEQfs0GndEjHWEeDviNNMNIaAkmfYxIAiqgXnBH9ze6P3LFEJRITyEJqXX0v2/lqiSN1/6dBj0Tc3bvn3fUdeltha7mscjkR8VtXL0NLsHLf/aeLCukdg2iEoqxyOIF2v6z1oUgreSS5Zg0paoIwGub1gl4f60upPWlpdkMXtxEBt5Fw+FxAdlPUxWPfPl4JNpdp58oVwXTerI+Ds/n035ZzqZ+I/p6P8WTqsnisABwpgu5h9uoGiUeI9MPbqDZ7jSi1V+f9JDokydsgBxjtv+hnE5U=","authorEmailMD5":"6528723e3bca2d1b8a97f93ba1130c11","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I just ran some tests and it seems this is in fact the case. This makes sense as no new threads are created to handle the work. So internally I am assuming the tasks always return as completed right away.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"f6883af5-6da0-3dd0-9cba-ac5148b6758c","date":"2015-03-12T14:03:34Z","timestamp":1426169014},{"_id":"51d36361-6345-32cf-a840-ac49d5368b8e","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes; a method marked as \"async\" may only become asynchronous when it performs an \"await\". I assume at the end of your call chain, you'd have an async method without an await - and the compiler will warn you that it will execute synchronously.\r\n\r\nThe core idea to keep in mind is that a method should only be marked \"async\" if it has asynchronous work to do. If the method only has synchronous work to do, then it should have a synchronous API, not an asynchronous (Task-returning) one. So, in your example, the entire call chain should be synchronous, not asynchronous.\r\n\r\nNow, if you're in a UI context and you want to avoid blocking your UI thread, then you can *call* synchronous code asynchronously by using Task.Run. Task.Run will synchronously block a thread pool thread, allowing the UI thread to treat the work asynchronously. Note that I recommend using Task.Run from the UI layer rather than in the method implementations; this approach has two advantages:\r\n\r\n1) The method APIs don't lie. They have only synchronous work to do, so they expose a synchronous API.\r\n\r\n2) The methods are more reusable. They won't force work onto background threads unnecessarily, i.e., they can be called directly (synchronously) by code that is already on a background thread or from an ASP.NET context.\r\n\r\nI have more info in my \"Task.Run Etiquette\" series: [http://blog.stephencleary.com/2013/10/taskrun-etiquette-and-proper-usage.html](http://blog.stephencleary.com/2013/10/taskrun-etiquette-and-proper-usage.html)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"f6883af5-6da0-3dd0-9cba-ac5148b6758c","date":"2015-03-12T13:36:05Z","timestamp":1426167365},{"_id":"74e51b75-7b88-3391-a65d-025f569f62e6","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"You might find my async/await intro helpful: [http://blog.stephencleary.com/2012/02/async-and-await.html](http://blog.stephencleary.com/2012/02/async-and-await.html)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"206b600d-4804-346b-8a48-2f0b7fb90a78","date":"2015-03-12T15:39:50Z","timestamp":1426174790},{"_id":"f6883af5-6da0-3dd0-9cba-ac5148b6758c","authorName":"Joe Messere","authorEmailEncrypted":"vMJsPbcDoQyiGPlSERjAewiEZ1GcgSAzi/nHPW1RyeKLhg4Exbj42XM/N+D58rqvDl4IAjpPrl+qG7VkuM7igYhnXe4KEaZA0dfOgrXztVFuINp/uX9Ev3mgBZlkzjF8fKZiPqZ6D8Ayen1Sx3Yh7Zm+jP9J9PbCF0u5vLWTCeJfX0BYHCO0O5t2V+3MxknjyiJs+FyQu/pyhg1x2A9PSgH5cqOAkDqb5xeBnTvJqnF2rheT9FXe8shXGahpWX9Wbg5UWZZSDK44r2unLk5hYKkvr0/4Z0/6gjOhRTagTBd1nlUnjfjII2zUtuq70889Vj4cWToLqTJpQpY9rISmPzNtZ3puv7HcFwkDd6bN9NSAcDb850M7WfmM+1cws5zloef3YI9HakRd/r1tzWiFXCPoGPP22OkEYUAswseekpK/RUAFOcmXjnc1pLDmtvXp0OHb//eCHJRX9Cuh+nh05Z5Kq9JFr0ik2vLnHYrwD7e1xM0qVTmKIUW2JLGe6/vp+enVzcAuSkvXThjDvRbr14T+785Rf85OPLw8Et5lwSSBWNUDBuX5bkgXsYuTP/ZK1Cyl0nHiAyWqCWBPQ+rXiT2hksKcwRkFOHzDMbymr5oBDy24prkJmGD6k2k04GOLcoLZwoSm753xRS5tBl1/b8qhlHSBU4PGdb1ZUyqNy3g=","authorEmailMD5":"6528723e3bca2d1b8a97f93ba1130c11","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen. I have an extension of this question. Lets say we have a call chain of 10 methods that all return a Task of some form. In each method an await is done to another async method. However all of these methods are simply synchronous operations that perform basic logic. If there is not a Task.Run in any of the methods will the entire call chain execute synchronously? Would this just then be a \"phantom\" async method that you are calling?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"82a4ab2b-b9bb-3c6f-b048-ae7ee169f98f","date":"2015-03-12T12:43:07Z","timestamp":1426164187},{"_id":"731c74e3-f2a4-3484-a394-56a4ca97834f","authorName":"Borzoo","authorEmailEncrypted":"nzEm055eADKlvTr9xZIFEn4ZhSE+VS9Sef3wG/oWAmFC1o//5MW1lbmocrZp5plTE8LWxDI/M/A7gmLYHqRd6xB1TNpcQOm7EL1Isq0Pc5A8JloIAJaFhqMs6S2mXb2M2f6u8pABA3Y2iFsup/OqQU1KNaumdyNneCYQHHqETn7mAPiRT+yWFCC1EB0FBWztkj/g+j0gbWYkV0OnEkFqdEIqUr278JMnisAd3fjKgh/e29R/G0TLhGOqEWgi6w2hhxGLb/Fo/EXqCZnMH2ZU0vxlplZYZzg8uvAZZAy/hVn4pUltAxDnx5X3PS5cdZ4qXsMCKgjTf8ZJhSbyQDRYefifYxtKPt9TmPefLszhoisloKj3u9IxR3Zl56HHagscOTFiQomEcAMm4nUIZKtD3K0bbmvdgu6tU9zMiDAo4Cj8YhOotpqiXLvd68Lq5xJV+SECmS6MJbb83Dp3S903dfGDGWfx319teGNztgqu2P0OqYcRrsrBm/Sw2AeNd4s9QAl/vSrFPvJXvnP+VPHvUL6Jd19kvukzqIitr/ThC7apS3CPtKgE8YNmVLb0A/khuv6JX2eCHlHU9n7Q5pvYN32lSJoBxsTUjP3lg4nHPJjLNRJK6RSJ79rO9HanWBgebCp9ZL6gjlgZg28d8O6KC6RU7z6xMwGqI6Zgx/1aU88=","authorEmailMD5":"72159be3de5ca75a9d077acf5b80508d","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"This has been bothering me for quite a while. This is the clearest description of this complex subject that I've ever seen. Thank you. ","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2015-03-17T19:29:07Z","timestamp":1426620547},{"_id":"65415d44-a506-3348-99ad-5ad5193bd670","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"(Copying from my answer a year ago; the blog migration messed up the comment threads, sorry!)\r\n\r\nYes, it's one of the I/O threads in the thread pool. The ThreadPool keeps a number of threads registered in its IOCP; these are different than the worker threads that most people associate with the ThreadPool. The ThreadPool manages both worker thread and I/O threads.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"77fa175f-daf9-3772-85f1-ca51cbfcd0c6","date":"2015-07-27T16:34:33Z","timestamp":1438014873},{"_id":"a8dd8eac-88e2-3dde-b645-4a475a8dfb1f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"(Copying from my answer two years ago; the blog migration messed up the comment threads, sorry!)\r\n\r\nThanks for your comment; I love the \"message\" description!\r\n\r\nBut I'm not sure I agree with you re DPCs (not that it really matters; the details of semantics aren't that important in this case). My reasoning is:  \r\n- A thread does not have a DPC queue, but CPUs do. A DPC can be scheduled to a specific CPU, but not a specific thread.  \r\n- DPCs are executed (at IRQL DISPATCH_LEVEL) when the CPU IRQL is transitioning from a higher level to DISPATCH_LEVEL or lower (e.g., PASSIVE_LEVEL). So they execute before normal thread code can resume.  \r\n- While a DPC does execute with a thread context in the narrowest sense (CONTEXT), it does not execute with a valid thread context in the broader sense (able to use the security context of the current thread). So, they may execute in a thread context, they must be written to run in an arbitrary thread context.  \r\n- A DPC is still very constrained in the code it can run as compared to code running as a part of a thread. In particular, no page faults are allowed.  \r\n- Interrupts are masked while a DPC is running.\r\n\r\nAlso, these quotes from MS:  \r\n- \"The system schedules all threads to run at IRQLs below DISPATCH_LEVEL.\" (\"Scheduling, Thread Context, and IRQL\", [http://msdn.microsoft.com/en-us/windows/hardware/gg487402.aspx](http://msdn.microsoft.com/en-us/windows/hardware/gg487402.aspx) )  \r\n- \"IRQLs at or above DISPATCH_LEVEL are processor specific... IRQLs below DISPATCH_LEVEL are thread specific.\" (ibid)  \r\n- \"Code that is running at PASSIVE_LEVEL is considered to be working on behalf of the current thread.\" (ibid)  \r\n- \"DPCs ... are always called ... in an arbitrary thread context.\" (ibid)  \r\n- \"Before a processor returns to processing threads, it executes all of the DPCs in its queue.\" (\"CPU Analysis\", [http://msdn.microsoft.com/en-us/library/windows/hardware/jj679884.aspx](http://msdn.microsoft.com/en-us/library/windows/hardware/jj679884.aspx) )\r\n\r\nI came across these quotes while trying to find out whether a DPC actually counts against the current thread's quantum. I was unable to find a definitive answer. :(","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"d059f9c3-04f8-3224-8b49-5289000e88ac","date":"2015-07-27T16:36:25Z","timestamp":1438014985},{"_id":"3045767d-a518-31c9-a77a-dd85ce6fe9c9","authorName":"Chin","authorEmailEncrypted":"tyBsBm0mHNUtV1J0fHjQbmTCKuKFrrgrvkxVM3bLS9ME1ZzKfptBztiXF4YC9RL3erJT3qjoYAE9BpXh9wPgBKeQOjORC51xKzp4ov994jPB6rVPk9XCkorlzuQ8K/KEVEuzxQYtW+tSFGV2uhD3PzTiSAvHFG0cKd89XT1lmFUkmGGvdOxNEmTNkW8ISZHESJbGfFXWzTYJg+D9Q9VVX5Wh+12HJ83SKuLvoxf/rTPyy5C3lUKlTGszkIoltVEU3IUa1b3DCTYwmKmnMv9T7IB22UQxvYmys5m5toqlFAAczENsDsOI8bWNqkWW2iFJmhgR/OXzuwsJAl3xumf3vQTNCQEAOHaPNm8w7RUL6qa4Q/OQGGc75ZPJPOZlXj/YRquNkKLW8CXRnQP2FFyrroltcWkEFxM+nC9k+6mZJFFbbjyYAm7OMDxBJNDe+wlCYvEmthIx5+dQ5YMeBhqc13vXYr7PD55CdohY6bpZ8yxcqcrlO7WFEqKdIed/+w1ZJeJbjzdwCGA8WGZa/g53TdFUl6emWx11ojj0sKciU9WaI7buIAUHY9RBHtVQ6azkvCz9QRQ5k26/9wlSquYXmTWsHMt45SXj8fS3BtstOEYptmYjQ445y24rtw29f5qAYwyu0YPMptpb0mMpJuAVvlJwPMvY+1x2tDs+slPU/KA=","authorEmailMD5":"3decb53828ce2c77a7fb28f7fd987234","authorUri":"","authorUserId":"disqus:chinhodado","authorFallbackAvatar":"https://disqus.com/api/users/avatars/chinhodado.jpg","message":"I have a question: as you said, a GET is a write followed by a read. But for the read, shouldn't there be something that is there to always listen for the response? Like a socket or something. In this case, if it's not a thread that's doing the listening, then what is doing the listening?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"0ab6974d-0896-3a5c-a067-a2f780792863","date":"2015-07-31T04:43:56Z","timestamp":1438317836},{"_id":"8f1aa188-5516-3a62-9812-a9c5c0579dcd","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"No threads are \"doing\" the listening. Reads and writes work almost identically: a range of memory is set up as the read (or write) buffer, and an IRQ is used to signal the end of the read (or write).","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"3045767d-a518-31c9-a77a-dd85ce6fe9c9","date":"2015-07-31T10:50:11Z","timestamp":1438339811},{"_id":"e0f087eb-c5f2-3981-ae38-44042689b1cb","authorName":"d87","authorEmailEncrypted":"HCRNYt15z9/xFVA4EljcIt+ijU+0NdJE80YulcnCplnfCfY3zVIJ6/A9ZwSaITf0XwXRGv+NXN4N4FVW/PVk45Lt3ycQXrjKsu7H21z8jNcuaoFJXbFI+N88xOw3EiyYvnjuetrWBeoX3XfyvioV/Mw6MzB6Dx48P7p5UVMu5Y1t9djDbgjr91uDvVo7KQWIqV1SFxmwW/+TQRRAb4YGOJIk2Y/hVJfxZ7vSY5O41IiX1fn23nOdoERg6t1e1V6DeLPW2wWRP1Z4ICw9VLozDiiJkUmS6dqtWziCnnqcA61Sndor7AGeW9dJitRIeSfKIvjGwo9doByXDBzn5k5fwO8wWA9YgYi1pZCCjVsdcrYuj/sfpwf2odyj2Ml4+gnSCh8QnWkh44TkqbaqRNA9u3He3/HPNTP5H1its3yPxsSTvXe+YKSvFs7AwFCGhL1IFlgzKMSoC4ehUup1pdeu1/7J8Pmzwqw4a6QCo+QF4UKdH6FoVKEEHdoX0E7lKPGBXSV1B1T8RepANhTn0hLXv8sB4inxha2urDzfnmVz5UFlnVuOd/Nlpz0ZjrMs9k6qJ3W6+MWYSX4Ug4mLGf5/kzMJCRf3PaN3/FyqogRyKX8yAKgOEq0okpDKBc9WIb7KOikkNm5OdBq+9czNLFqKqBSqWWuFadC1eWIK0wzxPw4=","authorEmailMD5":"344364fed44a2fe2b4aca232d6d7885b","authorUri":"","authorUserId":"disqus:disqus_rdMSX7CHEi","authorFallbackAvatar":"","message":"I've been confused about the implications of async/await on threads for some time, and this is the best explanation on the web I have found. Thank you! If only MSDN were half as clear. I believe the explanation could be improved even further by explicitly pointing out the distinction between I/O operations and CPU-bound operations.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2015-08-24T09:14:08Z","timestamp":1440407648},{"_id":"b0566718-e448-3753-8346-7b80be263f9e","authorName":"Ghy1237","authorEmailEncrypted":"CvuuTofKR3xyBkQ0EGK80o6dt0vTmyPsM5MrNxei6A5QC9QpfigJrkDfzSOumNmDUNEmOI5SvGS/KmpRPxyZhzw1rkof0BXWWUM4e3nyJQwGoioFPQJEE2cXDmX1vBzyUA9LtU2uDd3KHFXvNfPjgwiMxNHeeYPEkuq4c34H9tT7tfqlQkbIrYkMuCjRLI3N2BAh0Zk7+9pgr2Ut8hRIaZXGNh8f/thGKZQv5bqvZFKHOzEO5rLMuZArgxjW90gStY2iz5fiyE0OdYrRl9vOFe8I5ewDj3NLf4noT98UIk8y/KkIQyUyBSTVZDXFPZ4KIPsBZuv1FFytGFiOGYcTSg9K44NY+s//cPT4LVhyVfs0q3+fL+VgzZ1Zj9vKNjGRR2pm58zVL6LuR/tzDzmsJai3ZlfDnJUzlUsMlxbLKG3EkzREMTjKocbZo45HDP+NbVUHiVDPtzkpW3WqxacQlozZ/oGdKAETMgr97QI+8rqg036clx74aBi2NeRFuiRtTvbpkI8Bpti23f7wp1w7HWRHb3l7+ZjXi0pEKrLUC0gYGI1nbCJQqLBayXpjyyOHPFQzT3iwcNTOQMgXoKRMEVQCoNUfi6AHpB1HF+GZ3IYHBsdIQlHXqn0AGxr3d8jS5WyUl5cvKj+BNJaoMCvleXaspjhQGb1mkCT8rDg87hc=","authorEmailMD5":"5ea1d4416410a7d4ed972e2ce9cb8111","authorUri":"","authorUserId":"disqus:ghy1237","authorFallbackAvatar":"","message":"If so, what are the differences in the implementation between \"normal\" IO methods and those marked with returning a Task? You said that the underlying work is already async (using IRP markes with \"pending\" etc).","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2015-09-14T22:42:36Z","timestamp":1442270556},{"_id":"9e6b735f-faea-3ec2-8b6e-346ca8c0b5ce","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I assume by \"normal\" you mean the Asynchronous Programming Model (APM), which follows the pattern of Begin/End method pairs. Their implementation is pretty much identical (they generally use overlapped I/O, IOCPs, etc); only the end notification is different. IAsyncResult is a pretty close match to OVERLAPPED, and uses a callback method to notify the application the operation is complete. Task is a more modern way to notify applications that operations are complete.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"b0566718-e448-3753-8346-7b80be263f9e","date":"2015-09-15T11:52:39Z","timestamp":1442317959},{"_id":"6ec9797d-39a2-3dcc-ad29-75f5d4a843ca","authorName":"Anton","authorEmailEncrypted":"q85HaHvSpDK0Pujj3/7+AsW8Q1ZBh0SHSeh+L8I21N+GBV/kE8DEFNZl8mKs921f0hf1s4lIcfbhG3RH19/om1V0fmhU+J6q9b12OF1HOsTHcaHYBQrlFODBjm7E0u2MP90c86zKBMnc4ZHilqdAueLXwlrMtMcd5s7Sm/Uy6ptu3ETu9MMoAaXnYxqXEd2x+pOVsVcfd2047pU9PVsxLAQNcy0wc3YuBJndMh+UDiz+Qx3xmS2+w9M814RLY7Yug1GIWr/q2eBPg40k0/g8eOdw2LMIFasl5A6TxI9/BUy9uUE4TmZtc2swB2izv2OB83moiDt3szZ8uRzjWtsyfAEVxoKtg32tWiYTZ1H7FvIgxF8wJ7q2hmEwmTmFFfo05xsDRFZuZc3IcVFEBvFxs0zkkp3dQ4vLcDpOUIiUyP0D5iBu0N4zk3Tgcix56s9bTky2ndmn48ojVTmyOIJDoDJmydtAJUNvArqj/oKmQhP69n+FJv12m6hM/IVuxQilBVTSt3rbFeqtq7Jv3gm05wX33xmAHcAQUAind5y+kL8lVl18dnYP95yQGEbTW/KjRmWHBXR7SSQC+Y8af7/zr6Kc003/GNOlPu0pFiaaMop06YBhDClKpewR8lVchC4PbYWkcncaXleynj+R3X22QaO8ekWnqXS5mqmvAktNJ1o=","authorEmailMD5":"d770c004f15102ff6d4ba80bf2f1bd9c","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hi, Stephen! Am I right that callback in case of APM will run in a normal theradpool thread? Not IO thread.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"9e6b735f-faea-3ec2-8b6e-346ca8c0b5ce","date":"2015-10-13T19:58:27Z","timestamp":1444766307},{"_id":"ca3ca8c8-6379-35d8-9d1f-79a85e1a9c88","authorName":"Anton","authorEmailEncrypted":"hKsF2Tlh0LgirnWlnDwya6ouuz9a6Za3CLKL8a88lTayJOzeptz+rIvTchV2YAuY+gGnNH0prI9yTbFlAuznybrB4BJKiP015PFG5vb1IZA7HvhpLJizOMcP4TCdmgEhBetLDvrBoq6TGkfOwwDJXvdNRWpL8qwMlLv0WIZH9XE6nNXK0JErgc014vf2ImmVgr+6eP6y6CVPlFV8FZcC2fKISWoE+xoI9zrFK0yA1ZvZMXiyk6x2w+5wZXpAE+E5YnAjm0YwghFXOXRcRHYo+0r4yZ2nIrWd+LaYP8gLqNdqnolFDbtOBs4sIfvEHEuNvo7SUq2Loix+OFWRi3Vm+XzJlpz1laisR36HXbMq1AHdGcvss+WjZqveowkDEqSXFfh/vOIjh+m3LgPbQyOgNi4KHQMlS/vj2gokQ2tzRke9+j7/+NC3nJu28xZagLK0ywfDXDeIDaWFpTaDZevcu9g6Jb+JjK1lXBkhy870fppFKypRBLgnB+07TI83y21Qv73HjjM2v0UEI5oVaIrhS+8Jv6PXm+LrHyXdkTUabEAtPRz9DSbYX43qhhxePNkIyQQXC7TBNVkMSoO4cUzRG0Vu6LeYdtZ2VY/a0UEiRQ9M5sqQN+9FKesTu/uyfgRafy4uezYT8dsIEEJ3b0WccwbcsQShGyBi+Za7j2ze0Wg=","authorEmailMD5":"d770c004f15102ff6d4ba80bf2f1bd9c","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thank you very, very much! Now async programming and threads in .net looks more clear to me!","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2015-10-13T19:43:44Z","timestamp":1444765424},{"_id":"ed3b4e74-6139-3533-ad5b-f57a1e5a61c5","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"It can run in either kind of thread pool thread - normal or I/O. It depends on how the API is implemented.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"6ec9797d-39a2-3dcc-ad29-75f5d4a843ca","date":"2015-10-13T20:58:01Z","timestamp":1444769881},{"_id":"c92fa5e8-d3be-3f04-93fc-1587b8dafb20","authorName":"Fiona","authorEmailEncrypted":"AQyCmB/wVy6/kFEHKB7nx30aleUOiUtUFeFI+GJ1+UbQzJ0vLnbGXGEoReeneI02L+cbB4bk7IEkD+kOsZ5S6CjCx96o0I/iUTBF++ArvSzA9gNFin1g6rBJow4JvNUjQoCfqejJhkUTWTXIkrzWfBBz/r3XRgqGEa56dhZK3lzThBv7EHIriz0hXGLADJqp+N8ue/WA1TfZ+JTnYsaOrraBdFSeGZ7FQNGrIZWUTktig/+CuF7RGWRxfyblnEqtd+50tP3tHJWVmzQVqJQVq+fCO441ts9fmbp0TyvryzVCWdxE3dS8DjjckKrnwpWd9toJtpyQrjp4HVV3im+W5JTWA9BM+WTirw2V5g6XNejFwQFn6kyzlFCguUmJdpeQarJ8ed/I6hYUpcgDyh1OrR9UQtluFj2j7DxZ0bbKXLVVqNmLGmPQFnLXhDhBGaK2NAns43nt9OFGSik2LwX+2BLO0niZ/T3LqUREAIWRcOoLB/2MtD/ZtRCJUasFMcRU+Y6Rf7RgE6khjluJ5Q1zxik0sRNpRrMIKaskonh8D6rk25d1sgBiMfN8dEi3t1klT2JO/2+0iFMCIqRS69kOOc/lAasBFAjN5NWYpi5+51lua9FICi78uvGBZ9TbsqdK2SSqirl/xt+ij/6Fw17beX5/U+qItZRJLYUMKFd7uIM=","authorEmailMD5":"2acc0293cdadcda24791c0fbd8be6c50","authorUri":"","authorUserId":"disqus:disqus_4WnuRt9ngP","authorFallbackAvatar":"","message":"Hi Stephen,\r\n\r\n\"The task has captured the UI context, so it does not resume the async method directly on the thread pool thread. Instead, it queues the continuation of that method onto the UI context, and the UI thread will resume executing that method when it gets around to it.\"\r\n\r\nHow about Console applications and Windows Service application? My assumption is that it will resume the async method directly on the thread pool thread, correct?\r\n\r\nI couldn't find any article that take console application / Windows Service as a main example. Questions that bother me all the time are:   \r\n1. what type of synchronization context it will be for these two types of applications?\r\n\r\n2. Could any deadlock in async code be there for these two types of applications?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2015-11-27T17:05:36Z","timestamp":1448643936},{"_id":"7ebec3d5-2ef4-330e-8311-1a575a27f397","authorName":"Jim Balter","authorEmailEncrypted":"sKkjOrhcPzU63pBUuqee34yZx+cGVgC0kSvKOC6VolsBmsYQtW/dKaYIslCbDl2bwV9u5bWiQXyrmP/yVGnfmnjgwORSiBLm/WPwqsyiNgppKijDaqxJ8sF9+B9hU+Mu79S8jZrXx5ZZxotD5obJaTOMKqfMcZXuXJyRoJ1RQTaGJ61oPGR2ttIPetdHhKn8JDHqiYUMMMaHsH/UVFmzoNO0omldPMgNMM5srneXvEgDZthJYMImmg/9XoAPMv4b6LoqnS1xPY/UUHSjVNiASfuab4gbwVAwNOoAsvQB8Gt6fvfvUUD7ptbluHr8gAv0fYPBnVLq7dZ8mdMrBK0eZ61OFbu5uFFncDs2sgA24g/uOAwcJChIhCnZ7mLkBvtspEGRdXwLEvtRYLpwNP4M+8kurPLjsTvtVy3iAk7chnShUvoTmjsjpUE6QNjlvfLDYdYzH6QoAgySpSQEPv2pNwk30k8z3PSB7k3EfYGzwbQO4kYACmb8mpLU9cHE4NL/yAswSdLP9zK4Fjop2//pbKs0rXm61KY3rTrHXA9IgXE0/6sjT5TZdEbt3hOBy+x4XowIJqocLbysm0KRDWf5EWMeH+Ij3kXKDfu5VWYZAV13VbJH1aLEjaqhbOhK+i2FfCktrn1BAz6+v9B/hIdRqQgIYjybum30Qkr7L8FylVs=","authorEmailMD5":"ad1df76ef4fab96ec67b2afa080b3a0c","authorUri":"https://www.facebook.com/app_scoped_user_id/YXNpZADpBWEYwdm1Od2h4SjlJeThCVWY3OHIyTzc5N2pwek0yM0t1RUhQb2x3VFJqN01iM1hjZAnpVRlpHSmRwMFRMSldKMGtYRHQ5SFA1OUFhNWFueDRSb1dYNDBqTlV2b2VpZA2ZAZAbERY/","authorUserId":"disqus:facebook-1026609730","authorFallbackAvatar":"https://disqus.com/api/users/avatars/facebook-1026609730.jpg","message":"What's it matter whether there was an actual thread? The suspension of and resumption of a method is logically equivalent to a waiting thread.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2015-12-30T21:08:43Z","timestamp":1451509723},{"_id":"3fabd9e6-0108-3fe1-bed5-238eed5b953c","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"\"Logically equivalent\" - yes. But not literally equivalent. While you *could* block threads in ASP.NET, *not* blocking them allows an order of magnitude or two of web server scalability.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"7ebec3d5-2ef4-330e-8311-1a575a27f397","date":"2015-12-31T02:28:06Z","timestamp":1451528886},{"_id":"923aafa7-8632-33b7-8034-5667f92234b8","authorName":"John B","authorEmailEncrypted":"OJgadD3pJRGosBuUKJI3+rL2mkVlSJ4h+jt+ENKFGKeBNOaXAHRrSvw/vXanoOpa8Uhv5Ua15WbJYlW5B6VYhCHgcN43BjW7fP0OYYGdEFMwKth8I7j8Axqsc6TRLRClrz0bJH+O7VUpAoU6IDim92qsGCVt3IdCC0s+c+MO2aXQYtjVbKAk7iCc4VI1oai3DEGhGsHHiTBqGIuy+i8VM97mY6IhQjirlZb8pYqtgNnDwfU+VrpqAk+C07Wbbc8JA6/35cNTyeoVO/cweXkJMzOnRlsZA9ysFtvEiqGJwkJGetkpYthdQ66oXaeAjR9jGbNlPh2swHOwf6g05t4QSWsTFqFxgMSwlp7bAjn2D3egt05gs4tp3LpxMInnynZ8CFFCeAY1Mfop0cEVz3NTX0DVv7fcVG6uPWae99dNs6tI7ZwQUGsr/79TGaJ22lBdUmxVwAgIv6J+C1CS5s8AMAY9WVkY3QD6FGHAPjATzLr9Ecj20nHAIlOKqYtZdR6n+doOXMleSpLSeQwGkKqdRt3vchU7F8YHNqAh7Fi3LUvWE1xuuP500kpK0455Km2KOqEeUl0xVfntxKhGZYfcgRg1uz42ssKJ2DOEDoxAWp7AePRl0wsO0dtyQIjyp9FDiPMv8X5ibpShVXyJ5nucVJHGYRqua8UDLi48HaQu358=","authorEmailMD5":"481d70341c9faa90e85885faa2295f47","authorUri":"","authorUserId":"disqus:disqus_BXp0qg0lUk","authorFallbackAvatar":"","message":"Really appreciate this article.\r\n\r\nDoes this mean that it's essentially impossible to write something that's truly async in C# alone? In essence, for a method not to block any thread, it must call another async method, which calls another etc that eventually gets down to an OS level call which is inherently asynchronous.\r\n\r\nI know the \"top\" level of those calls are available in C#, but say I were writing against an existing library that blocked. I could kick it into a background thread (which would block), but I can't see that I could somehow magically make the codebase avoid blocking altogether. Am I missing something?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-02-01T21:29:56Z","timestamp":1454362196},{"_id":"c3a25ea0-8bc0-3da9-b1e1-795f2e0e6134","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"It is possible (though rare) to write an inherently asynchronous operation in C# alone (using TaskCompletionSource<t>). I use this to write things like asynchronous locks in my Nito.AsyncEx library.\r\n\r\nHowever, when you're consuming an API, the situation is a bit different. An API method is either asynchronous or synchronous, and there's nothing you can do as a consumer to change the nature of the API. So if you have a blocking API, you can't consume it asynchronously - that doesn't make sense. If you're writing a UI app, you have the option of pushing the blocking to a background thread, but since it's the actual API implementation that does the blocking, you can't entirely avoid the blocking.\r\n\r\nIf you would like an asynchronous API, the best thing to do is let the library author know.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"923aafa7-8632-33b7-8034-5667f92234b8","date":"2016-02-02T15:04:30Z","timestamp":1454425470},{"_id":"628a3edd-4ba1-30f4-881c-1e0c4fd05c51","authorName":"Omega Point Singularity","authorEmailEncrypted":"s3pC+d1O8wriafdQLzmw3s1W4AztViIz2mZo7k1vk6fE6XvsCSjsIv1nokNzzMnaZNLZpgeK7yt+OSicw6Xk6Gd+JkPxJXJL58yU0kQcd9PEpoEoYfmWGOzW30RqVRqen+9KJBZs0QytNRXG/hlzud27joMFdHomzIO7buC8OkYVmfAvYEn6BXsAlSnSECmbcbQAgAXYGP744nBeHhqgh8rtCRZdSZcxAa/5cX5LfV3mnhpdfCJyfepwRdXDgXU5IniqPyzyxleyBbaHrCtuHxp7a1f87xsOfRyPodxFRj4a1XEn13VLBobrgfKA8PZLclVG8MUdXkOLgb7eOKucKzN6eKC3MsxbqxBvuWrvtJ4xB6u0XWrBMRGuK9k6DU2y7U/r1mRnFIqxIAELfTNxGdN1DHPWTp87Zy5+0fk9ZtXgss/NURiAh7MxtmLrff0KggC7VuqOVIJdZ11xbgRtHTv3tI60t3Nsgq3EVJO6+lS19cfgaYHoljAf5vVaviKm1AZCexFSQC+/Io4hS3LNnq/Liqf5dWWuZjeM97EsF6Wl2y1EqpZryzF3KJ7yoniXFB4QFMbGQ67bY4YLRyTECUYmCfaQ8IeQhGaBvYVRqk9LipOrQmkA59YbyzD+nfhTlOIvcFl44+vzconX0g2/eCcO7PVDzGZgsqVF3M62m7U=","authorEmailMD5":"95345f59cd3f6a28ae72bc99843184b8","authorUri":"","authorUserId":"disqus:omegapointsingularity","authorFallbackAvatar":"https://disqus.com/api/users/avatars/omegapointsingularity.jpg","message":"How did you get so much knowledge? I aspire to be great. Have any book recommendations?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-02-07T15:17:11Z","timestamp":1454858231},{"_id":"f6e83335-08bf-35e4-a5b3-154063cfc2c2","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"A lot of experience. :)\r\n\r\nOne of the best books I've read is Code Complete. If you want to know more about windows, then Windows Internals is one of the best sources.\r\n\r\nAnd just keep learning. :)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"628a3edd-4ba1-30f4-881c-1e0c4fd05c51","date":"2016-02-08T14:08:30Z","timestamp":1454940510},{"_id":"ccb4471a-1436-3c15-829f-730bbb168c07","authorName":"Ehsan Sajjad","authorEmailEncrypted":"NvapRE3A1k5+oHCA8so0X/XVRZ2KQedQJD5RWtNonoJy0LYSQ1yMnWz9vXrwf8m7Gs54ZIN+AMN8Sj48rWZbhQ/0CT11orY68CllWKRN5VIIh0HjICKMFwAgS/JuoW5xkbej9fixMosUeg1g+97DUtMhqAru0NEY+AlqX5GVI7gzBs0qMYSqINS30rOeh8GuPvSiAv7kBgJ7G75U13e+8bJlg9y0SI5KifQpNaYhlyclnRJ0bbQQ8CmfP+vU5DrVHiDa3DvDpluzSCmNbbYo212474A4Odx6JJGOD/BJe+e4V62rLWcjPZgE8lliz8V5sej7k3f0p6Hgg7ZmoKfrXiP5RbftXEH+0KDlElrXcL/iGFh3q2kWMRR+2ItEpjgkGq1oSTH6LRXqzqu1odaaxse8cqu5MJGpvkGrxW4Ue/O2vhnYJMqd3nLqC3opTBpVIGX8ZzSDvWIx0KbTrD7p7lVXPBptx9Dl5KnUy+PSHW377IT31BWWxBkEWmthljBmyOSxTjsdZwPCtXURXRErz8Zkiq7S1AduYoXzFBbzqItAFRP/jY4Y+FnCkUlAUwvBEXvX+hTBwSu4dw0HsBVblTAvomYHPcl2ewsM92isdSPOnkEup8So1OQjTX3oLb+jZdzuUL2nd9zW+2LVCYHU+m7ywC6eXh3PknavB1M0EdM=","authorEmailMD5":"daacb17064e6d03ddd19ae1930bec563","authorUri":"","authorUserId":"disqus:ehsan_sajjad","authorFallbackAvatar":"","message":"Thanks for clarifying this mystery of async await","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-02-10T13:12:45Z","timestamp":1455109965},{"_id":"02b35c6c-7c4a-3226-86c3-8139c1f74e5d","authorName":"Empereur Aiman","authorEmailEncrypted":"kiIlJ67jF9+Z0AKy68/OPplpu/9CIh+qUUnHI0+77JmBnyEDxZ852t+zGChnJ46OpZa8hrRAZc9EX3X484Dw9dOyCMHpE7Dw8iftlm41xC1/CrIzW/yoEJBNWeIVQms3n3S3mHmKTR/FsfMBG1Lb6QYLszYSJLBNpasY1LSF+3yARUuzc3eLxeoGUf2Gtlj/537Tc9JAoSaKSOeIb5BBG2mF2RPgrHI6j/4/d3Nb614v8dTa8tuLRKDvqJBq9ABqnvhvMZOL0uG4LrQU1630C6Z76dqBv6jj9c/ZHMzbvxQn/uFYfyshxS/Ro8Z+vp9mSuIInohUXjBPyy70HPMlJ2aWPYLNkMjzjWj4rs4ZgziCuOgk/hy9r9APNJbIHP4fhLC0VrLdF4k5PM4Z1/7XVkU1GWK8Fl4MZvnRFzcm4a33pldAo2d+ddleclGyn2Vg4BunyseDmNnG8C0RIW0TaX1wRhSypAEJi0QW5z2s+TRH+CLXC6GWp/PzAbA4bZeNws0eanLMoMwQB74lqXUz00v/uDcx8uL9m1B/LlFabXlmha5ubQa6D1xGC/eI4mbjCCBPTuAFeS1z0FPAvbZb6uai6tQ3mbuCcBBSYiKSwQS5sTqWXTNoa7zqccae3A/YMEWA61VCo07Ail1mQ3Z6/opCPqTepisgI2UwStULbAY=","authorEmailMD5":"fe585c62d5b87f7172d4e2d0b5968e3b","authorUri":"","authorUserId":"disqus:empereuraiman","authorFallbackAvatar":"https://disqus.com/api/users/avatars/empereuraiman.jpg","message":"Thanks a lot. I have been wondering about this for so long. This cleared up everything.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-02-15T16:29:45Z","timestamp":1455553785},{"_id":"8b152c93-4374-352e-98d4-49fe8390f2ab","authorName":"Ilya Nemtsev","authorEmailEncrypted":"DEIKtcNADcUcgSNZUz8oqTc1XiigXxl+GTcoVMvofVdniva1z2GBNGd8AN5ABv3TXdHRWoOPir3/um7s2oeKHizwPF08ggM8H4OXnSMDCypDQtQe2YittfuYMCODfOGTI7mXxhlsxu94T2pcc8A2Bvwr7+s+lSZ71KP4oo2ABFrA0EirPNjWtw+DzttKaCiv1pTr1cQ+OMpVfqDIGnu/qLYYJpc+34ohm4seoQDQO8kOAbdzPN3fhI+XhWkZgdIK22d7lgH46U0CW5gDwkQhXuQ44q6fef7QGamCYYxmEIlPoiXsaeVUoLZntM5fA/pErSilhlDw4LjeAE5vdphomd4ni5aLO8XcpC5LWd67BH3wkCIaPVDZZ5ShgQUh8u8ZsQG1asoqU1p2vjTceH71N7pUUC1xUiNL+jXZ658slFQjY/2OFkb8s/NYsCm4Psg7PW7Nl/uTOZ4lh9ZvWYbee8yHqIkmw24cchAx/G8Zz802s4pBtzf2Tos1p2KU7y8AIis0lXwCz8GxqgSayKS/1K1s1Wa6YAa7b5EYH09sg/Rp+NENgcPMA/5BRhmh9r4TeVivN1P0NyRlcH29ZbWwFuK3j011gMPIn/Gcctn0gchsnpUp1GuiDv9gJewj1+ZwSbAN+XwxSXyi6nwQ3W9HfR6nVZKORN1lh3pVYENfgXY=","authorEmailMD5":"b37ebd4f61e3359655e42bcc1ad3fd92","authorUri":"","authorUserId":"disqus:ilyanemtsev","authorFallbackAvatar":"https://disqus.com/api/users/avatars/ilyanemtsev.jpg","message":"Best explanation I've read so far! Love the prophetic writing style.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-04-08T14:08:32Z","timestamp":1460124512},{"_id":"70f1f479-2026-37ca-b72b-c04531e07d1b","authorName":"artelk","authorEmailEncrypted":"dg6H9q4SueXHsI8Xug2e7FBDXv2bXyp3uHPJBcIlCXNvqe6oYLc5zUdZTmbKxP/VVugr2rCGLZZDf1trLWwQI9ffu+Hvz5L/3xSXIxRQ6S9IH5RBgqq+HXKt08S/TLfRKqoD167sut2NLizk6jghz9rkZhHnTsv0gY9hCbDvHqHQUJ3kwgMaYxWaig01iAQTfOIBKbMe7hjO83acVIkcrZSzsyZ0Ohsab6fVo7G38nm8AjAJA3PlZD9g7MD4ZAr1zdjstuZM0nmg92E6dYn0wGW/K2JTpkoNLi8k8y3ZtTKNhdXqLP3jSUf0MbpmZdA9mUdi4wotl2wEU808jX8bEADUxStuPZGDnKLyVy0xUbdZbgiH4gaL3hhTlSwG9P3jRioOUd6tXE5FaQPlFdWQ3Ch4Vqc0/wu3nv54F1DsTCFBDzGqqudhV/37o3OUEyPMRqpZ0060eXz0tBRQuxnadKASpVIydGbQDBjbmvxaPw5kucEFpKaidQOLg1KJ4RJ4TqEGLYKV/cKyZarL/eA76U2Zq6wehwRJd+uwXmSAcWnjlEYQRoPsmXklazc6jbgWFWnfL57U3bMz2YWB7yMQRFqOBueja9WnqQqSNDmSPqzWqVVnZGIzkz+NVelerxJzamJT6HNc1VwI/B/M85ohkIBhMMJIcHTiKaymm1n/qjY=","authorEmailMD5":"985fe39da7f73dd82f717764ceb17fe5","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"\"There is no additional thread (to wait this additional async IO operation)\"\r\n\r\nActually sometimes ThreadPool can create new threads to handle IOCP completions. But the number of that threads won't significantly exceed the number of CPU cores.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"134e36ed-3980-31ad-93ab-0a06967de74b","date":"2016-05-06T12:10:10Z","timestamp":1462536610},{"_id":"6625935a-675b-3d3e-aa17-db5949bf81d3","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"CPU-based operations are not asynchronous, by definition. It's true that both kinds of tasks (what I call Delegate Tasks and Promise Tasks) are both represented by the Task type in .NET, but they act completely differently. Delegate Tasks have code and have to run on a thread.\r\n\r\nNow, it's possible to, e.g., have the UI thread *treat* something else as asynchronous, like \"await Task.Run(() => ...);\" But that's not fully asynchronous code, so this article wouldn't apply.\r\n\r\nRegarding Mono, I haven't taken the time to research their implementation. They have recently absorbed large parts of the .NET framework regarding thread pooling and tasks, and are currently in the process of moving to .NET Core. The real question as regards this article is whether or not they use asynchronous I/O *and* whether or not the device driver(s) in question support asynchronous I/O. (On Linux, the device driver is aware of whether I/O is asynchronous or not; on Windows, all I/O is asynchronous).","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"f5f7916e-aaf8-3ea3-8f4e-f04d7352e160","date":"2016-05-08T19:48:37Z","timestamp":1462736917},{"_id":"f5f7916e-aaf8-3ea3-8f4e-f04d7352e160","authorName":"George","authorEmailEncrypted":"RgxOdDvIGeOBjaOMVK0DxeW3nNJmeN1JFXpxS/GQ0Wg+3rLJuAe3h8Cy4LFbdLP/f6kLYYsHYGHaYE08q+NSmcdNBA3A5VOSlIaCoLIUi1Nrei3HG/Cy220UI5QkcrJyYF20EaVdcomFuKOLJcrdbxGNXzC3y9V7i6VhEhoqxfRUpnXhNFklixYc0ZmfeDdgbgCJtyPhnnl1hK2TJcPgR43QOAPYTZ5HbbV69phuxzhLiKKYgpSTAcHAQbMfPYwAcVDFFH0Q00iIdly9EvbhdZjVLc32Vv3AkzRks+CFydFPexiM88hGWZRo7G/9A7By/gFPYWZJDVIL62UoG+KYJ3oXvAgNG/apW+lj8BEO3TYML0nX1HlhQPU8thQtkx6p59iKOJawgrcQ0VffrUyTgvV/hlygyPe2dgVUwar2/nijG1Q9OiEYYjLGo0bSkVBNUNDhPZM6x4OUfNCSZvGCksTrFJU2QQQi9aG2/c8kJtFfjYTPQ7fyrHvIivynU+Yr9bC2U4/WV4PN8InyQRn9EmQWGR3TT3QvEAJZNbzh/PP8wtWxV0H3EtXT4zGUldz25mnCaATS6EF0IYuYPVrCTj9n0IT7xMFzCTu8cx0LB4bt5A3stmMrdqriVggPBkJ145agZE8zmoW90Lae9HSMnuTGXwhKoBNmyPHMfpHsESg=","authorEmailMD5":"dca6908ca4a08b9c090990a094346305","authorUri":"","authorUserId":"disqus:disqus_YWGzSJ0SsX","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_YWGzSJ0SsX.jpg","message":"I'm not convinced. What happens if my async operation was one that does NOT involve an I/O operation? Let's say a complex compute operation. And also; what about other implementations of the .NET async/await, such as Mono for Linux or OSX or, Xamarin.Android, Xamarin.iOS?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-05-08T14:00:44Z","timestamp":1462716044},{"_id":"643a9b01-0dea-32b9-9ba3-a65fce4aed84","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Not really. I meant that asynchrony is a form of concurrency that does not use a thread. If you have CPU code to run - regardless of whether it's in a task - that is not asynchronous since it requires a thread to run on.\r\n\r\nParallelism is a form of concurrency that uses multiple threads, which is completely different than asynchronous concurrency.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"858e29c9-3fe9-315f-ac46-acc918336aa6","date":"2016-05-09T20:41:15Z","timestamp":1462826475},{"_id":"858e29c9-3fe9-315f-ac46-acc918336aa6","authorName":"George","authorEmailEncrypted":"EQa+KUHE18tNrYDFIuSN7CmIMTeVMubYno7Z9D3Ks4gcFJaiiAN8bRW1XLBHtV82F2rFzj+OvhW9ypMzc7CuUWo3t6Ij4DUqMPJ6IGbalMqtBFw8MGI9bxLvVv7/m8k5jJCk0iomCYCBiW2LonYl42WX6bdVB9LKY6EFN2p6qGUgZ1eVJUuyOzzsjDXTHFVra2GbyU3pZhsZTRoR4uSEwEs91DgMrhHnGOLFXqVArMTRltVIOjeox4Jffk5qWmQVv1Jh0p+chHtJTuabPkZNAEoxJ56D1do+84QYk4V8h1b79Rehq2KZOKwnTsAvdulCsc84KrjPekORdMoRBEeMCh5eW4R1se8nPtrHik+KuUXyiPdRFo6Dpy45L0F7MC2KqKvBH7tB2onDJCqMtVrHGu/51BHJV95mhPxIFpjXeDR1HQLNB8QVQi9PkQYHNmM/8Wp93pref441AKuQ8GW047yhhT0mqFo/yrYy8W8OwhWHZAuhibJbYPTAkLvWRS4wQxkTuB9m9my3Puc/kdM6L+EdPTDc0gqR2OxQn53iwZImR3hxtsAiKsE/EKPjPEbTXgpSUjxWCCs/y7XWw6c07L2nMsQJSZNbOjQ9fMAV/NXAQm8WknrEwRXQncAs8AF9NHurMQOyOjVKAh6JSbjT46HZAvTyorZQWa66dY7aQMo=","authorEmailMD5":"dca6908ca4a08b9c090990a094346305","authorUri":"","authorUserId":"disqus:disqus_YWGzSJ0SsX","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_YWGzSJ0SsX.jpg","message":"Hi Stephen,   \r\nThanks for your answer. But now I have a question on \"CPU-based operations are not asynchronous, by definition\". I suppose by this you mean that the CPU can execute one \"task\" at a time. If this is what you mean, then aren't you forgetting the multi-core CPUs? Each core can execute one task...OK I'm not sure now when you wrote that article if we actually had multi-core CPUs...\r\n\r\nThanks again for the article and the answer...\r\n\r\nR,  \r\nG.P.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"6625935a-675b-3d3e-aa17-db5949bf81d3","date":"2016-05-09T14:12:07Z","timestamp":1462803127},{"_id":"ce21b9f8-233a-32de-9a6f-41248900c901","authorName":"George","authorEmailEncrypted":"d/J8e8xH+MM362VJxupYh1Q1SYf/Ac0zNFuE38Wtlz0SjoDzSZBhnEVPxQZgDohWJ5yHpJdQMgWthHDNU/ILCvmljO1VoOJZWQ6UEwnk5V6hVnpkEtrrtJPLgqEBOK5sdNbeF/lkO6J5MtER1MfX0q1wc/7n/ceQoCNa+f5ewvQTrhk3/rhYKHW6uZBmmI5Uo0p/cKFIwTrZwSnQAWWZXABbJf5tYDmIKDiNjC2/HALpXm4lldSu3m63wEGwrE1AvbXqxOPVcpjRSet6bbFpQVxUpAeKx70cOHVn+oMvTt3xy3SlrVE7vkW0mtiOcReuSbmQPiUSZiMUX4E7EkPQ1kUD++yZU8XtsZwIlFJdz8pAUzHszHN5zt1O70Xapo99zDOHZYhRyUoxD9492Se98FvcAexnJBaly0MSPNCgvQSPbruOm8pdS55CGDENlx1oa7Ox5SGC44ofLz8rcvXnM6TWi7+JjTmKzxQbd/mjc3JJnxjZGrPd/b2PFv9PLSI95hAaNYNP3L2AOxbYWoJLFu4TEyGaRaKrujFNu4FNc/ZDZCrK2n3Akw8R7qczrah/NPKb0f57ClQgvysTn9iZb8lUCtWFKcWtKVXFCNC1ugKHzNteQHSwvUtiiqFUq20RntOrmjZCHKDtbSTv6eQDJR3iIiYlEIaFigRK5KDhd7M=","authorEmailMD5":"dca6908ca4a08b9c090990a094346305","authorUri":"","authorUserId":"disqus:disqus_YWGzSJ0SsX","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_YWGzSJ0SsX.jpg","message":"Then how does the UI task continue execution while an asynchronous task \"continues to run in the background\" ? You mean that the asynchronous task will not actually continue to run in the background, but because it's in the same thread as the UI, it will be suspended instead? Therefore, what we'll have in this case is some form of task switching? Not sure I understand...","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"643a9b01-0dea-32b9-9ba3-a65fce4aed84","date":"2016-05-09T21:26:30Z","timestamp":1462829190},{"_id":"5017bf85-ae7f-3797-be25-cc3d31d0414f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I try to be very careful with my terminology. In particular: asynchronous operations do not \"run\" or \"execute\". They have no CPU code, so it doesn't make sense to talk about them \"running\" anywhere. However, they do have a time frame over which they are active, followed by a completion; so I do use the terms \"in progress\" or \"in flight\" or \"not completed\".\r\n\r\nIt is confusing, because the same Task type represents two completely different concepts.\r\n\r\nI think these blog posts of mine may help clarify what I mean; I'm talking about the difference between Delegate Tasks (with CPU code) and Promise Tasks (representing some future event):\r\n\r\n [http://blog.stephencleary.com/2014/04/a-tour-of-task-part-0-overview.html](http://blog.stephencleary.com/2014/04/a-tour-of-task-part-0-overview.html) (especially the section \"Two Types of Task\")\r\n\r\n [http://blog.stephencleary.com/2014/06/a-tour-of-task-part-3-status.html](http://blog.stephencleary.com/2014/06/a-tour-of-task-part-3-status.html)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"ce21b9f8-233a-32de-9a6f-41248900c901","date":"2016-05-10T13:38:30Z","timestamp":1462887510},{"_id":"fcc0f242-2b22-3065-9fa4-eca43a8e4ff9","authorName":"George","authorEmailEncrypted":"kec4EajmOq5KR8vqc9IC4RZxfUa9pQJRPxyMI5/TCQ47dXFRD0hdHJCecNNc4AdfeciSBh8wT0COo+Fa8PWLezBGkacbG+Rv6m2FQ3niZdb0JyKhu+t70Q34BRmAmRyPHU+xG43zAud9mGwFbUFk8gThs3q+bAp5u+BSd9ee1+7L3fFqTIPLzufoRmbHbFSZGfDxUaQW9XgD7w6OAc9AOR7cbYI091dEDF1D0exJY9bLc/scpvNDF1zOeLxCkyPr/Xt/Nxkfgp68eV1gXQ+Avv57I3fLHNtHv+3fRyypqdpHMcPxpRoQAypnQyv/LtCmrAhI916/2DwwWNTEQSBTCa00s4Tk+3BsViewekqhi+A2HbiUtc/sJvfJ2PLwMSEU3WhsV5UoxAJO+g63Y53FHUVCJ9ukAYd0IDkWApzP3OX8mp6v8Zn6Y1cuoePSYVRQyrHPDx0ovL3hpIBUtZK3kZ1xMVJ4Npa9WSsLn0vG0769517bC7z5rK2WGqdtQxJrBrFODOwz6hlkBcIZrf9aPLztJWIxmoXR3vbtOixyQ9XpA/1CjrDIuBU0Ykh36puGLzXzvthzxQyKEj0lv/fFC5iGdDvoi1UmQR00NVdHmY4g3NIczrN8y/+cicVy2xs+YSG/v+lzjU3td8G1yJWuWjPuZzoaX3WLGdM5pn+zUPw=","authorEmailMD5":"dca6908ca4a08b9c090990a094346305","authorUri":"","authorUserId":"disqus:disqus_YWGzSJ0SsX","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_YWGzSJ0SsX.jpg","message":"Thanks Stephen. I'll check those articles out. I'm curious about the part \"asynchronous operations do not \"run\" or \"execute\"\".","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"5017bf85-ae7f-3797-be25-cc3d31d0414f","date":"2016-05-10T13:52:23Z","timestamp":1462888343},{"_id":"61f71b33-e69d-3944-8750-11c57ceb9b69","authorName":"Avi","authorEmailEncrypted":"XS3Fz1iz21Rx4bb4cWA3I1qeURKk1r/dcF9TNIyQVBO+rmHItid//xsow2cnxRluXGJHz7uzV10DlmxwFsRSQZlP06FfFKY7XDtIBEdLg4fPEl9BnVfDWOo+MQedCUwDLZHOVQMJhveWDJv3yNS3/AiAiBIDhFAgB3DYNcEIB9skk4ITG/XOcYemE5C+8giA1mFfhPKvjaxw2d7vaX+KBc/JiCO6FuxoEIj4Anh28AdK7MUbthRdxyP0L0iSEpaTshwtf5V2g+/wM2IDMMMmRMNa9ZW6uUbkha0I+l+9aYbCh9PIPtxBF2QVkQPHlj+bNVAzUl+zRmC31xlCzBjGZetUokeik1jKcP1i27WjwXUBcozmV3CaAyCwfPlyEGEBVrAyNjhRekFUU1FaZSIeO7cfwOIUPM7Q/ZnWcghgbf8YQsyBLwOhYGRrz3pjyZwUB39mWOF7fh3Zzah5L7cCj9D4yL2SvvNV1/UMms6ZitYD/RdJhj6MER1rv+t8TvaSUK3YXHix7ueLMzgni6TkDw0tU1zLTOcjVvckfS47yG2GhYmTrlfA9I17UJyRsx9XLuB940KGsECVvGOM8fVqLFlhvh85FKd/alIs9bWQzLqVmZCyDa/bb4KRyoMWjTH1XnPRXWnpruGZwGHZVKdG2mRbkOJ0/RAF96l4EVIDK/U=","authorEmailMD5":"98f19d70948a72ca4a5a99b7afb49494","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"\"We have followed the request down into the abyss of the system, right out to the physical device.\r\n\r\nThe write operation is now “in flight”. How many threads are processing it?\"\r\n\r\nI have a question here. Who processes the operation which is in flight? How come there is not a need for a thread to take of the operation when in flight, the physical writing of bytes onto disk, does that not need CPU time/thread? The actual writing of the file must be executing code surely?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-05-23T23:45:26Z","timestamp":1464047126},{"_id":"a10cfd51-6d80-3142-bc0b-32a272ec3d17","authorName":"Avi","authorEmailEncrypted":"LGuKEty6AZF0KoJEQwExynwsiRgLYGQirQx24/vr3AAmo+DbrFsdpWDdArScDlu+ZCIvGbnotqG4HHAuPtsIxRdaOVKtk/x+GhAoyVjigxpfll7W/ZaIPQtzbd09c0tTprR+fxi2Dw8xBQZXkBg0BSqvARFEz6bGHD4XUaeITKJI1ZbffVwQuDUTpix3Xla7D+wzRDh2Zpsn8ybrB0lOMLy7iSWBN3G1B1apbe7xdu2JMyYYRFfYGMGZhsa4GewH1tXExCzVDc0uUT9tFcYxmnkN3H+0eN0n3tq/VtVGpMwNPg7adecTNLueMZ/nWonnICI3xPZ3JY6nPYGto1Ag1K+3VvGXq5sWLsmGQDTMmhOWtVJNCzC37E5v08dmvuni8e3BhiOQj0kSJh+PdttZRs/UibYFNSehfyLMeNJ1EiTqC/JeYs0ybW5J/SThRklkCPsrwVUAwlaQ2RR5mFMHkINZXAVYwN4MhQZefzwViJco+8ZfUf1R+OerUWLVYfAgjYDuDkADcdOe3g2ATDDKju5bFtW0zGUoGvAzyMo9ryKHpFUbguN1OeXeZU5ZF1oRu2v4k7Q/elDxFcczZP1Rg+YvmVyEcWvKWjLV3GbfW6LJjtzuSNpZmCUpxEF8aSfw8Wy0TtwVDRb4dNZxTgqG9WD3A0IG+Ww76GvBAfijY+g=","authorEmailMD5":"98f19d70948a72ca4a5a99b7afb49494","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thank you very much Stephen. That makes it very clear.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"e9bd4d27-c6ca-3b1d-bd5c-03f537cda357","date":"2016-05-24T19:00:43Z","timestamp":1464116443},{"_id":"e9bd4d27-c6ca-3b1d-bd5c-03f537cda357","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"No, it does not need CPU time or a thread.\r\n\r\nHard drives (and other I/O devices such as network cards, video cards, and even serial/parallel ports) have tiny dedicated processors that do the actual copying. The CPU only places the data in a DMA region and triggers a signal to the device. The device then copies it out of memory.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"61f71b33-e69d-3944-8750-11c57ceb9b69","date":"2016-05-24T01:37:57Z","timestamp":1464053877},{"_id":"4513612c-028a-31c7-a1ab-feaf5b1fd590","authorName":"Gyozo Kudor","authorEmailEncrypted":"LL5cTP3OBykH8e967r+3+CIieRnZFq/KZxgPY+W/HGvHu05EHsuJnUp7ChsVwPkzdCOdicam77pazmLtfTH89aYKdxw3LRQn7sKRWkxy70GiwQfIsIe4EZAFIqHJRrnd6BGGhkyjL20JZ/LpCehWgZVDumDHTeg0oRDzWytipVOqc7m2AtTuNGkTXLrwn6N+RMHfDhqgwidtk+GqhNzMgbFqylyZITKFyu23IGCJNdjRTliZhY2NAGDJNFidWW6N1ezHux2563PyX7Xqak0HXg6vDnPIlbqdsBQvu7L4e6jxaB0UmGEz/+khMnbOHwrgI9l6hyYcxNuCJNQWjwcZNbxCyQNilckPx7ZQHGruokxPF6EBovEE8u85mgSzhUR/3RPwfZT2huceMwtDSWrPSjG97+EHPwjojFfdD89B3XHLLhKWoZyB31LxhU+C9T6dawCzd6LTaDFfd5hLjkIXwlk1wW7cEP+qb7RXRIl8JVtRzkSJSi3Q3nLj+jsRN6y9hqTNJ9zHJr907QiUvEh+uJXZpWKnr71SsgEvndOPF2oE+OwRgBmWJ8COJ42DbODdonI04wcvM4pjGoArB34hZ/gvseDcmJsGVK9a8vUanF6pJ4JHcgCRmYNrsnPb8Yj1yKqL5KDZsD8UVfXh/ZkSj7rylrwSWaFYzEMgT0HpQYE=","authorEmailMD5":"b4be580397a862506e2e256ca80a368f","authorUri":"","authorUserId":"disqus:gyozokudor","authorFallbackAvatar":"","message":"How could I be blind to the truth for so long. Now I see it. There is no thread.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-06-03T17:07:03Z","timestamp":1464973623},{"_id":"15d85c39-b4e5-3df2-8714-3a718fdbdee2","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"If you're doing a truly asynchronous operation, then that async work does not use up a thread while the operation is in progress. As I described in the article, it may briefly use a thread pool thread when the operation completes.\r\n\r\nThe thread pool creates threads as needed. This is normal.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"97014edc-d197-3dd3-b7d4-5d09522f3a3c","date":"2016-06-06T12:30:26Z","timestamp":1465216226},{"_id":"97014edc-d197-3dd3-b7d4-5d09522f3a3c","authorName":"Gyozo Kudor","authorEmailEncrypted":"HkuXBZH5gK7AXDXp3t6L29b8PdWeWw3QN7mCoj/Iq189il67vEWdKrRxDkxAZM/XJ0lhvWVWliYkxgFNPdH+bGTp8QhUhAGMJd+HBdNkanNourLOOtNkldejOC0SPjf5gcjqM6OrU+/yI5FfF7h5hVRfGxV6keNwPbTnmD09Yj5/81qYqA90ChK0CK5J8/DhOrVXWdrllNpiY2cbU1Uc4vqVSYFPxY+8p59XbzqkDYdITP0OVMXs0Mhf1FnhAX9DEGpbQhbiSBTBXwvhcz8N4WquM1WODgllN5UVaaNYbtbBIB31S3dronVNOS156E8vmoICCBvbIx9NJ4iRquirsf1VvE8HAS907A5p98y+wQGnS9SNlj3yueLl9/tFMTlbG3Ncyg/9hz9gjOyivkvk6ZM9/q9CVuG2Bb7uoMkLyw5AxHoNu/K1lCSYpe3Np4bFopJIkP6YHSuyEkhUhZFM0OXy1/JmzAaagperAJO3YWFBbCaRpsxENzMnFDLI3QJp4j74Wnw+dJ0Y4tcT5quOZGb5TyxXw9ML8/0/zUcw8qr60VPR00Nz19qZO8x8eCXtWnnWZBVdKkw6Mf3hfj2OjJK8QYteGzPom10o8GknJ7a8ZThZCa3vwnWqYI5cpwDwSZuRj/+k6xWM5+QJFyOCwxbiIA9Bsklg4XE4SPMVlfE=","authorEmailMD5":"b4be580397a862506e2e256ca80a368f","authorUri":"","authorUserId":"disqus:gyozokudor","authorFallbackAvatar":"","message":"Although there is this thing here, attached as an image that shows that one thread got created.\r\n\r\n[http://imgur.com/tb7rsb2](http://imgur.com/tb7rsb2)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-06-06T06:31:00Z","timestamp":1465194660},{"_id":"9572473e-4ff7-3551-92be-614b308d6ca3","authorName":"Foo","authorEmailEncrypted":"amR/nQJg11zIFAOqgqbjN2xJQ4GUrjdaXwHX9Eb3FtIV2uFt4rdueZj/4W2l+bllH95JXGjaGEgm0OKALetH8JW5lL+rjkPWY3qcdY4+clxGaZsyD2D2wKcFZm+GVaYhUp5j1tQ8kRShcIUvTsS2bwkkgSKC41guixfyfBBFvs9tzSzMqnkTlGK3IoqPVHd6b23sYWeTrtCrwOcuafYsomQsYdqXCjykjto8hynvY5l1obFW9kZ8m+UlIF016Q8HP4peDMd/JkqjoYJRYpIDupNs+BUaiG4DQ896GEzV0sb2RQZZdaVYEbGyUTx3nj1rx+nKCZJHV/ioFoIULcji1Ktr89ZCAx5p0lI9rTiKQwa0WS2HPf5BDQjSmHflocUIFX1xQ+A0vw2UPDUyMOrSyhe97ijeZHGsiFoBVoAXLUW00BqJQM07th6WsEsXlXS3iuq+UFg+mQ/w+e3uviRy6EbHUY3+7gNnJLnDMDUbx+f91sN2s3RdwV5ZDTdX+O+E9LdlDKwQXOKu0z+ZwP7mJC9EKKXSAjIR1C22dbRY5J2o1qgr32ASeWBLuMtzK/XWtYTdQxW3LTt9IVdshd244Cd222UMXSRF/waejUstaKE7b4Uo5eoK2D2JiJnjOrIU6Wxr8rsN49C35zKPYxY2b//xnagdFU4tu0L4Hx5zRjE=","authorEmailMD5":"2b225b0dd03bd728a5d1e51c031a34a6","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"There is a thread. There has to be a thread.\r\n\r\nThis was an interesting read, but I think there a few inaccuracies in it.\r\n\r\nFirst, the quote from Windows Internals. It's wrong. The driver chooses how it handles requests. It can ask IoIsOperationSynchronous(Irp) and if it is a synchronous request handle it synchronously. What is true is that when Windows passes the request the the driver it has to be prepared to receive STATUS_PENDING (even for synchronous requests).\r\n\r\nSecond, a thread is needed to perform the special kernel APC which copies data back to the user memory (assuming METHOD_BUFFERED). This is either the thread that performed the request (if you don't use IOCP), or any of the threads associated with the IOCP if the request is associated with an IOCP. Note that if the request isn't associated with an IOCP, the completion must happen in the originating thread, and if that thread is terminated before completion the I/O is canceled.\r\n\r\nI'm willing to stipulate that in .NET IOCPs are used, but that's just lucky. If it weren't for that, you wouldn't be able to terminate a thread that made an asynchronous I/O request before it completes and still have it completed successfully. So threads matter.\r\n\r\nI get that your point is that there needn't be an EXTRA thread for every asynchronous I/O operation, but some thread is needed - those thread that you say were borrowed had to exist so they could be borrowed...\r\n\r\nAdditionally, there certainly was a \"thread that was blocked, just waiting for that request to complete.\" If there' was nothing to do the IOCP threads were blocked. They weren't waiting ONLY for this specific I/O, but they were waiting ALSO for the completion of this I/O operation.\r\n\r\nIoIsOperationSynchronous: [https://msdn.microsoft.com/en-us/library/windows/hardware/ff548443(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/hardware/ff548443(v=vs.85).aspx)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-06-09T23:27:11Z","timestamp":1465514831},{"_id":"7003d7ac-f514-3215-b38e-245d3191a169","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Oh, yes, this article is quite incomplete. Among other things, I completely skipped over how caches influence this flow.\r\n\r\nBut I think we can agree that the idea [that there is a thread blocked \"doing\" the I/O] is incorrect. In my experience, this is an *incredibly* common assumption. When I talk about async to .NET developers at conferences (so these are not even the dark matter developers), it's always >50%; I'd estimate around 80% (or more) just believe that programmed I/O is still how it's done. :)\r\n\r\nI was not even aware of IoIsOperationSynchronous! I knew that Linux drivers know the asynchrony of their ops, but I wasn't aware that was true on Windows, too. I'm having a hard time thinking of a real-world use case, though; any driver would *have* to support async (the hard part), and it *can* support async-only (and most do AFAIK), so why have a second path? Seems like it would severely complicate the code for no real benefit.\r\n\r\nI also didn't remember the details around APCs and threads. Since .NET-based I/O generally uses a single process-wide IOCP, that's the only case I covered in this article. In particular, I did not remember that it had to return to the *same* thread outside of an IOCP; I had actually assumed that *any* thread in the process (sharing the same address space) would work.\r\n\r\nAnd finally, yes, as you (and others below) have pointed out, the IOCP itself does have (a) dedicated thread(s). But this would be true even if the end-user code never called any I/O methods. In other words, asynchronous I/O doesn't take up *additional* threads that are dedicated to a specific operation.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"9572473e-4ff7-3551-92be-614b308d6ca3","date":"2016-06-13T18:42:13Z","timestamp":1465843333},{"_id":"3f5eac21-523f-3618-ba24-1079bb8de4e8","authorName":"Robert","authorEmailEncrypted":"UybYxF1sGhQq+kBqgHXPVntfG/a0nx3QeiM0T5OoSHMxTmsqRReSl6TMSpwYzx+qEFLC0W1VKCXgYxB09u82zavscuz+ehmNl5bw7641IjACU87OZ9v/c/ohq/9Lk8lLlaFOHOwF5AQhwd4c1B9MX53a14TZP04TLMsfUDXephv8had/PijOp+eRRbptRmQd9ePBy2onFNc1kknDkJfWWmsfrPq/WZngf0lBg1jqxyj7D+xbMbU5MtbQ8wueh/PHzh9u6xjXVhL0ROmkhC/PIQJDp+y3Ed2GhnroznNUMhAlhXdK4XTevDat8m3nmuB9OaN6Et0KdrhU8RkM26TYdelLkPRpW5QcvDRO1Z5bHzqTELM1EDxIVWpm9sW7sCZ8kod6XHY3vwfemvIaCNsU64v9DEgT9cR+XlIFm8fjllMG/1HiVbG6UoMvkrf+ddLkLr0IIYs56Dt+rWA13HS10Vpk+P6ZNlIbpYSHg++aRwK0VacH7hE+Ia8wjX8Id1V9XY2XkI/7WB4Wmz8fzf7BKShZGzOQCfEesIhzG7AyFirDpgpSo71XlwIY9klAoEbl0CWX055h1OGL5iHp2Rr6FcZPzQiee7Y6q0m0Flo6k5pJBnnbxPxSSgMGpDXtSRy7e+oxnX8P/p1bJ4pJHOlLi1efXQmZZSU/1VjJ3AhDelQ=","authorEmailMD5":"9f9e018ec475cccb9da53d14305ac50e","authorUri":"","authorUserId":"disqus:disqus_JzQbO5CkOz","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_JzQbO5CkOz.jpg","message":"Great writeup! Russinovich has an excellent article that takes it a level deeper (helped clear up for me the details on how the calling context, in both thread-specific and thread-agnostic cases, is available when the I/O completes): [https://www.microsoftpressstore.com/articles/article.aspx?p=2201309&seqNum=3](https://www.microsoftpressstore.com/articles/article.aspx?p=2201309&seqNum=3)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-06-30T17:20:38Z","timestamp":1467307238},{"_id":"b89eb870-38c3-39d1-9110-33dd38da8efc","authorName":"Andy JW","authorEmailEncrypted":"N4ZyxZDaGBC90wOXxLesj0zMz2nOjKDD9wIQAnzZqKKi3ZBJUGc15XH/CxW3V8DHahTCTVlz5bMCH5691a2/uhiYUKrOJoFiAcSEgRH8TfwVwP1+JWMb2EB/ExoRrBYSoPhfPsQjZ///hGFJcE/5zTkQuLvdb526hyUt4Mf9yr4XtTLuJvKIq8NyLXtDjFu+b/6Q6HbAZAF1UBfVFYBB8ohSKz+Ak4f+a1AG67M6BaknMvCylEtmXWvx0wyT5n0x6p5G0vH+/kuHmPEIM6+h7j6EJSfe2gfl30+fYlpcgwiInyA5kTDrj5NskKFQjUkF0Mi1OVjslOQPE9mHMYxV1G90q4wGG8tn5mUXgkqN7K+Tlxo5qwdkQf6sR2muctbepnKSgKswA1iyeewJJSVyk8YCv5s4Cbbn3oyxYW1jrSeMQpgLi0pND0PgFT6wncUoVoJMhypmWKFuwmgJmRddCOB/zlTAW+Nl15YzzZ3CFKwf2m//19zgwa5HqmKc+1t1Q9aEgQesQIg1Kixbx6du7XWF7cnrKC45y3sBl1ShEpM6bd3H0qB8mUvkBdUS6gdTpT7t9PNltd/sQ1HQEizKHyRHAeNGRbUy3eoX9VcYKDtiCXT98ZjIXXGaSKVLvMMsXrgWoU37W3Su8npP7AReVmXRzOZu6tqCxgLgTTvi10E=","authorEmailMD5":"7a2c32431708704ac32f2e2637ef6b48","authorUri":"","authorUserId":"disqus:andy_jw","authorFallbackAvatar":"https://disqus.com/api/users/avatars/andy_jw.jpg","message":"Great article. IOCP's are a kernel-supported concept in win32. I am (or was) among this 80% naive you speak of because my conceptual education in EE/CS was the traditional model wherein the thread (or at least a fork/clone somewhere down the line) is blocked and put into the non-runnable state by the scheduler until the ISR is ready to toggle this. And we're taught that it's perfectly acceptable to use a small stack size for these blocking threads, with the only price at the end of the day being the context switches. I would make an argument there is nothing really wrong with this, since even with APCs you need to have one of those I/O pool threads get around to you anyway. Now, supposedly, the only equivalent to IOCP in linux is the epoll. The critical difference is that you implement this yourself at the application level. So it sounds like the exact model taken in win32 is the same pattern as what I would do if writing my own app-layer in posix. I might spin up my own pool and loop over epoll, and I might use the results to feed into a compute work queue, essentially achieving something very similar to .net async TAP.\r\n\r\nNow given that posix epoll is a user-level concept and IOPCs are a kernel-level concept, I do wonder what the port of .NET to linux is going to do. Will they basically implement the I/O completion pool as their own layer on which they will build their .Net I/O primitives? hmmm","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-07-06T22:14:30Z","timestamp":1467843270},{"_id":"84f59f19-b19e-3c5d-856e-292a331fc58c","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Good question. I'm not sure how they implement this on *nix.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"b89eb870-38c3-39d1-9110-33dd38da8efc","date":"2016-07-07T10:36:14Z","timestamp":1467887774},{"_id":"579cb753-63b9-3665-8f9b-5ccbdcc96f58","authorName":"Benjamin Holland","authorEmailEncrypted":"g+zEKJrRXhrqIAWevuNhCiXDIuuDAjSxPip+bNw2r8jgAJ6AU6eSr91BkuYUeQ/uZUCL37ognjpHVfz7hMv92lgh1TwfWG9SPvlBovEYvoBGIbJHWMQL4F8UWBqan3g3AppnMZ2IM6elEHIzWFLvJayogWBcq+RqY5VmuehbSPkaMzup3wS5NqtMfV8omOm6mvVCxKEVsBOCRNXnvBargpUE5KHSORd1aTZl9Qr2/zm9Mim6QSzKF7+QNYBq304xj8uPo8hhYNWCkxXgxYtbilGPfPRNOJeYCmGs60GBbV717eVNvz9UppsJn7jFb36pFqlsR0OY6WEeeZ70JiR7zxFwFCTwytp7ryh1n7JI9Bt7qkWcKrL2mf8OHJoBFcu2qXaJRK4TM30ROh9GevEmNLCnzB8ZSX2nJQL6I2NGvPCDuYhHiafpDfc385r0m3Oz2SOoWMCR0XPVZK/WDTYnL90Kdewl+my4/w5bWnI1C0B8C3fvNMhHpiXeceHUtoc+WRPZ0qwrQ3bkwhnZg92KRzYPBcih2MpM4Km+jotenrF6Ty/ds3zO+ds56JDxZXgJ5LSX0NSTODV1IAYOZmWyzH6oOC88JdPqZp3TngIDfUOPA0xW89PK7F0s5FB1vIegW/leKtkkKl1K7/zNYvV02+MLDiFRf3dw4l3cAQ9nGE8=","authorEmailMD5":"ec08164333e909baef436d182e7d8c0d","authorUri":"","authorUserId":"disqus:disqus_ClNCtMIgGo","authorFallbackAvatar":"","message":"I know it's been a while, but this is still a great series. It definitely helped me understand tasks better.\r\n\r\nI recently have done some work that led me to a question about the chart you've got. Why aren't there better mechanisms for turning Overlapped IO calls into tasks? I managed to do it by closing over a TaskCompletionSource, but it seems strange that I have to do that when the basic concept of the async-await style task and overlapped IO seem so similar.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-08-09T20:45:47Z","timestamp":1470775547},{"_id":"eda8e557-9f29-3fcc-b80d-5c65d3b21224","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"It's going to be awkward due to the unmanaged/managed transition. OVERLAPPED is an unmanaged structure that must be pinned in memory for the duration of the operation. It also only has one callback pointer with a single data pointer (though you can extend the structure to include additional data, such as more callbacks).\r\n\r\nFrom a high level, they are similar. You can see a lot of OVERLAPPED influence in the IAsyncResult interface, which is implemented by Task. However, OVERLAPPED is pinned unmanaged memory, whereas Task is a regular managed type.\r\n\r\nIt may be possible to create an awaitable extended OVERLAPPED structure, but I'm not sure if you'd get any real benefits. You'd still need a managed type that you can return from your asynchronous APIs.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"579cb753-63b9-3665-8f9b-5ccbdcc96f58","date":"2016-08-10T13:58:01Z","timestamp":1470837481},{"_id":"37f8ee4b-6fad-3ea3-9710-05e1c9587a96","authorName":"Benjamin Holland","authorEmailEncrypted":"mFBY88aohhrJd5sVRgue6FnrSuPJKY1l2t+NGLIx5xKikUdgXqoHaxNtWd7SZowxxIRnpLqLPGomuhIp6tzhHIO0tGkwxx+p4os2azL8/dEgLPsR6rR5naTmV3mzZfyibA5HX2qhQD/LO4zavj1KLabJf2RThZEv0g1+xtbLCH0L5iDWr548+O4pfsr9pcxlK2kZMJ24nW9AZy/xZiW2fJfxh+L4thtCeWnvPwSu/fFHagXfwQdiY7Z4zIw8j08qWulIBtjNYDiLChpWCvMZQ88uom48d/A1/nphCCEdpTkKTBDhLmp/kkVVhgQwiG1TeFtpUJUAofOqUdRKsf9cWkyN8KGv2v6J+cUYNGM8Qc+dSPAdCLR6vNJFHu4Rwnh28LlX7ljBHzx3IbIz2KCZbkwB5mKksdMqRSad84myx95qNQGr3DsGl8aNr3ZWd4BJbdkbGqqS/76tSXbIiw6OVpEyYazuH36pKHNJv/G9jfHz3/xh/RB+jgAMaHDDmrqyxjfDeqmkUkOevscF8+OMdo41bXwu5LD5AQOGTPngssg0gfi9ZsuGrcEd9zXXY2MNQ/LjWAEv36iHJgCEIZixlwI7IFkRBvGh1yvCQKSFavKjC4jEEzet5eeex22FBL4LAYb/SAu9AsUCU3q/fr/Ip3kKc7zibafrZbO1+Ghc0ds=","authorEmailMD5":"ec08164333e909baef436d182e7d8c0d","authorUri":"","authorUserId":"disqus:disqus_ClNCtMIgGo","authorFallbackAvatar":"","message":"I can report that it is extremely awkward. Aside from Overlapped and IOCompletionCallback using raw NativeOverlapped pointers,each call requires it's own TaskCompletionSource and a unique managed delegate, which seems like it's a bit heavy for handling IO completion.\r\n\r\nI just thought it was strange that MS decided not to create a better managed interface, given how ubiquitous overlapped IO ends up being under the hood. It's not \"hard\" to do, but the intricacies of overlapped IO seem sufficient to warrant a bit more assistance on the developer side.\r\n\r\nI hadn't thought to extend Overlapped itself. I can see it helping if I don't have to create a new delegate for each call. Certainly something to think about. Thank you.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"eda8e557-9f29-3fcc-b80d-5c65d3b21224","date":"2016-08-11T23:16:52Z","timestamp":1470957412},{"_id":"0082d642-dab6-3005-b23f-a2704b585f5f","authorName":"SharpTag","authorEmailEncrypted":"RN7ebZmQJBCWBHb+F5scsCFdPU5Ds9pPt2g7xD86g91LBHy15X9xBTUUgybt2eoLy7uJwOxEAScGfVAr+zA8lwwX5hMuS1q9++4l5uiED3sIp9qblFIVeCUXR6G1iA2wl9/XviyU0ALOpMjEPWgvS9Rn8XQrbeCM+0XyPBtP1Xgq67drj0PIviuoNqFeP3f/qr6j77Ki7QF2I9AyrpWiVaq0/IxYasfjKQ12tcrkWisjyxVpOAMyhN3YUHNOW+7HhBFmOpCaI6k9kz7DdYa8GDuuGZXThGJGNk0JM2Zic6FUSuzvHve7NjnZJ8J6eOhoA3CSU4H3jOf4D7AyNfdKiRqBTDQR5UednKQflSTOTa6IaO+BEDAqQRiAk0c9Mx3yLFdhd9TrG8yxylqD+2iixKlNBCJlFXj8Ol2KVjOONrCYvvAAz9yCSj13om8T8bBZs/mF3OHbjrDByJ+JRsuB0SidzEdOTa2F73jqVnEvC7h/XjXWZmxFVEB7uzNi5fC7FnITJSYtDkk2QMzOaNS1uVwl8F1xImmYU90DyOdoUlsc2u8OhZ13NcduOPktrG0SIrXpUDOl0ZVe8CLW3UCcUzYw1vv328Aad5RrTS+IgII5CMGdlFL9LSkg1SQ14eW3mu0nDgkbxnb6EKEX5jZgH5rENM1iTnRnk/5NFqYZ9i0=","authorEmailMD5":"5164af4f96639d26aa14d0570108de15","authorUri":"","authorUserId":"disqus:sharptag","authorFallbackAvatar":"","message":"There are lots of devices that don't do DMA so just to be complete, people can still visualize it that way since if there is actually a byte by byte transfer and it's more common than you think, it will be interrupt driven and then handled by the DPC so again no (extra) O/S thread allocated for that. The device driver just has 4 (*) pieces of code: Load/Unload, I/O API, DPC and ISR - In the I/O request, the data is stored in RAM and then even without DMA, the DPC sends it out or receives it when queued by the ISR. (*) giant bunch of other stuff involving Power States does not apply to discussion.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"e9bd4d27-c6ca-3b1d-bd5c-03f537cda357","date":"2016-09-06T03:05:19Z","timestamp":1473131119},{"_id":"0a5def96-9136-341d-807b-496d18c7f85e","authorName":"SharpTag","authorEmailEncrypted":"VsAk9zasqz5erewhD/rNpAf+2bE7absKJP5QoxEA2T4lr4nFLOUete9wTcQ+ZAR9e6YYqTxdYU3Ce5oOLoXw0VDTT5YMIzw04MZJ9LZMntYBBfhj4aoJAX0lHcgwdysDwUBcwwnuLpqpjAp11VUliao/ZAfwsXr4b/EpG9dv7vsl49ktb9pS8V9akoXG+D9riNny6uwq+WW9u2HB1GaoiWh4DX2TNKnOskvfLDRqoqj4ZIFNAUyhNwPBBSQ6FK3RWew9AZ/Z/g5XT273f5vKLOSe3zPylHW3IHO4qaB44D+QD+J6RuigUFcVuXsnOagBvRSUrdWjUhC2LXTP9H5Poo3RETZGaOj+8S2rK4CVv2TWYew5O65EWDFXsfinK2fWddt9WLJMmt4C0XTrwnjPOsVgTacTNDLgqKhEV0pKilRv+l0ocaLzwQ2SiMEfBlLVfprFyhXbnxlE/KgyK3RkY5rW7+hzKuX4jJVSjAWV+tDq7mVPlSfAKbtlIZyzgBm9r+yiQMf/7cnUvyZRvIiDJIn9P+hOG6ViatTLyaSXRWbBGd617fk53zGTRnUAcacui8xnWVuDs0cpod7d25ibFq3c18mmA7TvQrwhYtTYZg0fnXi++AdYMf69FWf5tz5DZqBT8NfF9EykgCY5Mua1A2KgRBh8UVWA8joGcIkVlfw=","authorEmailMD5":"5164af4f96639d26aa14d0570108de15","authorUri":"","authorUserId":"disqus:sharptag","authorFallbackAvatar":"","message":"In case anyone wanders by and starts to build a mental model of this, just think of the DPC as part of the Windows Kernel. It is just getting the next available time slice which means it runs in whatever thread or process the scheduler has running but it has no interaction with the thread other than the ability to clobber RAM anywhere on the computer. Although it can only be interrupted by NMI, the fun part of the mental model is that there is a DPC Queue for every Core on the CPU. So the next slice could be on any Core. If the device has another ISR which most often is the case you now have more than one DPC servicing your Async request. Now everything is at the mercy of the Device Driver programmer to SpinLock the right memory locations and coordinate all the literally non-time sliced but actually simultaneous DPC's so that I/O completes without incident and starts the more orderly sequence nicely described in the article to return to Windows Userland. There really isn't any analogy or sense to be made out of the DPC system from the perspective of a C# programmer, but it is awesome to visualize your code running simultaneously and that SpinLocks are executing constantly on everyone's computer to make this system work. If you have 8 cores, they all stop completely dead doing absolutely nothing during the few microseconds of the lock. Not elegant at all!","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"a8dd8eac-88e2-3dde-b645-4a475a8dfb1f","date":"2016-09-06T02:07:16Z","timestamp":1473127636},{"_id":"568d489f-1075-3c3a-8fca-3a20c845bc49","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The context determines which thread is used.\r\n\r\nSo, in the case of that example, the UI context is captured, and the UI context always uses the UI thread, so in that case, the task will resume on the same thread. Not because tasks *always* do this, but because the UI context is tied to a specific thread.\r\n\r\nIf you run an async method on the thread pool, then the thread pool context is used (technically, there is no context captured, and the thread pool context is used if there is none). In that case, when the async method resumed, it would run on a thread pool thread, which may or may not be the same thread it started on.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"df732c96-74c6-3893-9701-0391b60436b6","date":"2016-09-08T13:31:11Z","timestamp":1473341471},{"_id":"df732c96-74c6-3893-9701-0391b60436b6","authorName":"Ivo","authorEmailEncrypted":"IzDYldOB7ej4Xqg97r2qIAYykLFJgBjGanvz78I+UHKHZstwHAMniKTNQl0wnk5Qcc99nUaCe+6d+etrDgsopqxbmnVyWDgY6Sm9cWMvBK/zqMM+coXvvoN5Cb9t4q1M1iOrlLWOJ25xOH2bZhdaUywyn5c2niII+/1oDU8KdiHA7ewHG5DvARLK/82uXFhXl5OAYc7O+zdRd3OtpJq8N24Nb3Sd76+0XxIIWn11yg5aFrEplYWKf8Vz7p1nHls7li2oTR3Jx8vbb9QSiTcXN4sImyHHQMN56KbDequ4a00+VtHglwztUx/8035hOh92UFNtP3Jc3zkvqaKYSjaB07xzp34a/zGk6S2zTdff6m5TBhqcHhElMa7OCP28c/KnHhK0lCF3ekodw+s4Uj+vFqB7mmB0mOvpwwkeYuPPpKAHjd+A/TpwVhXmlVs5P/D86mM9BHteuFonaSHG6YwuygUbk+qJ3FF8xbFMmyf/RWoySBlekAlO/qwmj7t32KCqK1iCaHy6O5qFaAuNvAh7M6qBqacfCJucFNq8UxCRzwMpj2hA6R7zgpDjBpX8TEQ+YvBIDtnguFPz+B6cU6MHBzWZWoV0LP5F+S6e5KcvK4K6+zHUpsyIRc2aP+upae1WNUJI9srlrsXy6QweTm9ba76/nu3N+ZQI3bJBsm2IhDY=","authorEmailMD5":"dc149b2884327314254ee8a0b447e1ec","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen, excellent article. Very clarifying view over an obscure topic.  \r\nI know it's been a while but what exactly do you meant by:  \r\n\"The task has captured the UI context, so it does not resume the async method directly on the thread pool thread. Instead, it queues the continuation of that method onto the UI context, and the UI thread will resume executing that method when it gets around to it.\"  \r\nIs it that the very same thread that started the Task will be resumed to continue the work or is it a new (different) thread that will be randomly picked to continue? Or I am not quite getting it how this context is manged.  \r\nMany thanks!","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-09-08T08:21:43Z","timestamp":1473322903},{"_id":"54be7a0b-fb1c-300f-94cb-78c38c8bbb35","authorName":"damn_right _man","authorEmailEncrypted":"PPGTKD+yiFeXCo3uujD9YJkTTvaO8gFS41MeklgXoO2pdnnsZpie4Xxzq4VyBP3oYXcmMLQEMKQZjo5mh48vyOPBT/scfVgmguPG8RzrzY0IYGrhA0mo8MbOLCSOyh47gGn4Xpm2mj57XIjgs31vgwm4EdiZypF0rrwO4IxAiPlHVXK27pwSa1pB3YS/WM3MI4ps812AUmSZRa8jeirn7/us4kjb1ZgcI7aWDRiCrEaYRJ77yRVB+tFtIZa4wzrljd/SXBV4Tg+gbL1dPdNCmlyVwsHILU1OzsN20DzgK5zqqi9Brctb5ozDAs6etj0rhSNUhsdvXMQFsDX+ydH9V/W3pkAoDEZqpZLH+aXPpPngTCbg2r2f2tdBC0Getmq8TSooaTfQ9KwI37FqPYPRlwQeCgrSeujQgMMNsOiEsbyz47LGikdUS3czqAqmCKSz+elnTe6CQQHPr9KLdZ9Ome/oPG3l/nHpt/UfOoUrhhfHlzTkyE8GqevXL3SFAkEABWoaaYPwDfoX3SUpC9Ugo/ZS8JefSf1MqTs26blrzpPE+ny8irNfWB9BfvKR8asVYMn2AhlRLQ9O+OyfyiK6EYRA/1/SAGHI9PFwAJkrWBzC8QOYCYZVX+AAZtiq4reE9ZUBaWmhvBc+422c/nUmhZvlWXyr+4L+6UVt5ZZhu4E=","authorEmailMD5":"e27d0d968a30bd3ab6fc056fc5065bf0","authorUri":"","authorUserId":"disqus:damn_right_man","authorFallbackAvatar":"https://disqus.com/api/users/avatars/damn_right_man.jpg","message":"I agree. Nice comment on that topic.\r\n\r\nBut wait, and, sorry, that I comment that late. Perhaps we need an explained sample code, which does not involve io at that level. Let's say, the method, which is being awaited to finish execution, simply calculates complex stuff like matrix multiplications, whatsoever. Where is this execution context present if not in a threadpool thread?  \r\nTh UI remains responsive. The asynch method is re-invoked at the first statement after the await keyword (continuations allow the recreation of the context,etc...), and the callstack now changed dramatically. This can only be explained with an additional threadpool thread, can't it?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"65415d44-a506-3348-99ad-5ad5193bd670","date":"2016-10-02T09:37:35Z","timestamp":1475401055},{"_id":"837f091a-f954-3af5-8085-5b04c1d6058a","authorName":"damn_right _man","authorEmailEncrypted":"TmhP06/WL+wAEfWU0oMWJY4oAynau7NVrJIYZy4QGuNzIrCjZmQukfdv91LBwGrHnOdMmAcSurd8W9ejNmDHJRKWQlQc4yx6/Zno/AZJkBR2iZoWX4TjjHn4XE04pCsDYVQbuTDa4YCDWufjzP51h6FrfeB/80IJn3RWF9CKRgNpM+e2UvcYTMGD4hTVpPbLyI9ijgtn/iWMxvOIagMsvovLr8tKpdwD1/esAvfDosPw70iXj1z5XS1GImFbcqfqXkbuvBqDkiQOHlrxmZZySDbMjNyOLPWwWBK1s7iHG7yFJ0A03bS4BvTXc9oQeiekXFOYhkOsw1r3IrKI++BsfvIVTA6fhfG2RYMm7Ir/A90JtYmzho8qpEP9QXU2hDkFrUT5DKuCwnJD3xIZRnS7WQPf6g2EAjz0GCkbsAXNG6BlfvyOTtefZ+KMxiuVKOndAR7nh0ShRFlCtxUjdCslNAR7BdXSWWV3gGa5iLm0q5VrA8O32XWv3L9c6wuiXDIScaMHEir/V0WlmmTyVcp+E63wUFowR5H2irOaANE4gedpGPG8Qu/GEKqHvCbJnyHpSMyhIiQrT63gkLQDuyrcM3s2hE9B4kl10beAo9xnokpiGaMnhAFnm+RxyFgkR5tvZf7LVQp9izngDu6MIlSlg6iYLdzXxzuKMq5/ukivFyo=","authorEmailMD5":"e27d0d968a30bd3ab6fc056fc5065bf0","authorUri":"","authorUserId":"disqus:damn_right_man","authorFallbackAvatar":"https://disqus.com/api/users/avatars/damn_right_man.jpg","message":"I know, that spawning a thread makes the thread itself being executed synchroneous for itself, but globally, at the program(process) level all threads together run parallel, and therefore asynchroneous. Ok, one thread, which awaits the results of others, can only proceed with a logic, if a thread returns, but, still, it can process other code, which does not depend on the said threads result. ","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"d97855e0-b7c4-3f65-914c-d5acc5c4f23e","date":"2016-10-03T17:26:26Z","timestamp":1475515586},{"_id":"c1ed4292-d186-3d4c-a3d4-184f2287b1aa","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, you can think of the term \"asynchronous\" as requiring two points of reference. A background thread may be treated asynchronously by the UI thread, and would be \"asynchronous\" from the UI thread's perspective. On the other hand, I/O is \"asynchronous\" from a much broader scope (it would be \"asynchronous\" from the perspective of *any* thread, or process, or the OS, or the CPU).","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"837f091a-f954-3af5-8085-5b04c1d6058a","date":"2016-10-03T18:41:55Z","timestamp":1475520115},{"_id":"d97855e0-b7c4-3f65-914c-d5acc5c4f23e","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"If you have CPU-bound code to run, then that code has to run on a thread.\r\n\r\nNow, you can push the CPU-bound code to a thread pool thread (e.g., `Task.Run`) and then await it from the UI thread so that your UI thread is not blocked. But that's not an actual asynchronous operation - it's a synchronous operation on another thread.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"54be7a0b-fb1c-300f-94cb-78c38c8bbb35","date":"2016-10-03T14:10:34Z","timestamp":1475503834},{"_id":"ee9053a3-1323-3b33-89e8-47d4f8b9ca69","authorName":"damn_right _man","authorEmailEncrypted":"TNrixeR92+DKqx1U6hqM59vBVnx+d5coDc+5aLl6MxcPOpSqiQQ221BxFhylbmUYotZEawCbtBbTiegAmerM7A0MhV+r77+8LjrhamzJwi0uCfUUm7wR8l+upWyD/CgxUMSvlsSRTzYGl3SA281Pw3UvVBWufOJaxLKyKLlzb09+XD2WnDse8bZalFHJCwVgJMiNZx/GpjtXg87AG6lPmo4OLpT6Y1NBGBC7lzOdyi5jNN+/gRPiQEFpu/2Zz8GEWpCusdkiEfls3hYCFdHybCR37M6SDcf4Sn2mtjcKwSRKRFE8rh4WblDZjwc//oP/ekzYsV4C5/EKOS8QTWx+PvT3xbF4TSWsD9emTCDTHkKoCTwp3B6q9alTQhJdoS+YPhavIkF5Kbp+Sx3gLP25rpptwhYWirFwxNzotPB7G8vY/rMFP4x9Rz/BTYjCwmCx6aIpaRFed74BjoT6RO+696pQF5iI7o2CB9LS4LPU0JaCN3Exlq3X4bXtzFTc9QUlYL59yX2ZzejGn7uWz/VfX4f/eHtkM36xfQE46egnUhqBGWBHkqZD5YlWoI3W0mT4iyTvBiXLxzlNyF7va2IX7juhxLOVe0y6oGUbL57QdPsLxw4gOhHb12L7BCvlF6CLt6PKW8J21i0Wgkg8EJwBeAQz4dahnpinautx37c9q4M=","authorEmailMD5":"e27d0d968a30bd3ab6fc056fc5065bf0","authorUri":"","authorUserId":"disqus:damn_right_man","authorFallbackAvatar":"https://disqus.com/api/users/avatars/damn_right_man.jpg","message":"Hence the request for another explained sample without this io. ","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"c1ed4292-d186-3d4c-a3d4-184f2287b1aa","date":"2016-10-03T18:45:00Z","timestamp":1475520300},{"_id":"f4f38efe-a439-30b7-854a-eaa677a09d34","authorName":"damn_right _man","authorEmailEncrypted":"hXYTTK/ybKbXtBfseZ8ddv6pHBEBuikSmrPbWzR8ThuKiIu2S1f5TJtXIJTKGYaQvfg69mHEdKca6DKYxoMl8IjsUcm/45/sQvzM6Rbll0C0aTeD5QbcEmk4s5Xbh37tM0PiNu16x5rhrmli036M92BnpBpmC0bp6DzV2GKO93zRFzjn9e2wZ4lSA5u/NWd3x2ZlW7NDJVuZo/mwQRsBfJ2rNCD+qh1Dj1FKUH0MmQDdccrkBPBNagvyIUPsvgc5IU8r8ch4zsZ+kE5g2iIIRUvBPf+PVGHSRNGCnu3VJlJvdZldORL0kSd5sv/UF43Gr07Dv+WhD36YyCe6W3Yet2ihgWsb/oXnuKQ4J/y9WEo3Em+eIvjemxCKJ61axk1JGed9eNOsnHGyVLfdlXdzATi6oA1as5/9VMyRWCRmRT5z1D3VHPUEhjeMxtOlxsS/LY6T6IxEVoxroEbeYVMR9i+uQBPk5oSkMswyDZIbKaeQcPpzBjBZOBjo3ixEx99d57hdg4EMwQKKOKCnAglWSk61VVoi7JxA+fDzX0U9aP2FVGZKsMmXegAJRqsFZ8omQsv+MGy8xAKbDNMeedv5zdclHD5zZ7WbDdrc45QlAHdzl848XomdsBb9JM8sfPuUKtCpkTIaniuvJTEkM1MnGS4yrEdLQx1yUJtc6ghl3rA=","authorEmailMD5":"e27d0d968a30bd3ab6fc056fc5065bf0","authorUri":"","authorUserId":"disqus:damn_right_man","authorFallbackAvatar":"https://disqus.com/api/users/avatars/damn_right_man.jpg","message":"Hence the request for an explained sample, which does not include this io. I think, You get, why. ","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"d97855e0-b7c4-3f65-914c-d5acc5c4f23e","date":"2016-10-03T18:43:54Z","timestamp":1475520234},{"_id":"6c3a31ea-e886-3621-ad39-d126aee909ca","authorName":"teoman shipahi","authorEmailEncrypted":"UXvscYhPRLxxycjNDuEwxmRCKTe7XUpwzRZuuTECGMFJnNK9zpCXtM/zHxh1o/IaEaLVVtdgvjeKztKm0ajdpmnjOzghsr07k5at2Pp2Wonsh7Gai0NdKHi+tG6A8E3zcryC6Sx8YdbXdzyvZ/3KWQ6d1zOkjcdO22tI/FDtlsrQ1f0dxqhdIaoQiqAdmWarexBl1QwU+HPrjryubycBeWJPfwiHv0DPJrsQq/Cxv+QYp7OG7PJsOzAARMYJFi73WrnQqL792SGp0uavmYHUE2/r9itlqjlHuDn27FtlULW9yJ67smqvxgE2KbVWx3cW7JMEdpHiCtbr2jJ2yZvZpC2KR29eYFNFJ6Z37DUJuaH2RWg2QDqlF1jpF9QgGbIV+bwQtFV9oUEPI1eht1o7dU/uk5COJ/S9Z0QM5texrESbJ8V0hzsQvcuZE3m9UD6xAx1AqDmK/YViQ+L4ed+isZafsTNK7VWszR5M+WttyXyYhXmaol8NBUvNLJWtWCB/PdwGn2y1YM8r/Ws1xA9LOL/Lbct8VOyqtqrkOKJfGxLSc9A2S1XWZH57hYUeDRfArZkHs1ddLMMd1TPsF6bKdXJQY5ARz0jOVWieqA8ANrfMhYExDAytd3AomHp8tbN+AodRiH8X8yHKoqMCSIENZOwm0uVlPzxIYDdPEB2063Q=","authorEmailMD5":"d7d0a9abf32a790bbef91e3f03a4154b","authorUri":"","authorUserId":"disqus:aytekinozdemir","authorFallbackAvatar":"https://disqus.com/api/users/avatars/aytekinozdemir.jpg","message":"Wow, I am enlighten with this blog post. I am feeling myself that I was in long deep sleep in matrix, all surrounded with async tasks, and for each, a brand new thread is assigned. Then I am sweating and worried about there is no more thread to assign for upcoming I/O tasks, I am looking into thread pool, but there is none, so I need find more threads to run those extra I/O tasks! What a nightmare. Then @stephen_cleary:disqus comes along and wakes me up: \"Shh, no worries; THERE IS NO THREAD\".","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-10-24T19:55:59Z","timestamp":1477338959},{"_id":"b03d0956-b5dc-3c0e-b680-01cfdf5ac4e5","authorName":"teoman shipahi","authorEmailEncrypted":"mkIuLA87BN2LZhVKuPmCjVI9y9w5nDDPCiif11Py/GvCdgIo5lYSrmM+r4g836Y+UgwXQRike2yrARu5kSfH+xEHsY03sZS1SwZypLh/bA/RyGPqTbZhYLZP2R5nPmmaqxNRHcxbl0wl8BWbzK5t2iZLb74Az6I91NocGP+ja2d5gI4ZjECyOGY8U6p20WjM2rBIGTA64D516Y0/hUGlsaXDx8zy/4U/8nZo6m+dzhs1VH3J4EEVs+nmRdXK6HnQrMwLZCULqLOMpP0JOLk0dWa4qeI0sZxzSKfPZBRR5Nf+tblV4Xy265I0EEDqNbviTey06MM2+jV1QdU5w5Jn76bhOfsaI+Tgo6je6754N7iGf7ksZy7yB7OeBfnwjFb5Kj89ucLjAqHhQYlcnxkrXMRNm95gLNLMHLhPnoFekE/0vbDItVbe42eu+evtIbIe6FfD5axFYpQTZvw0IpHh3Fed3OeOhLLChAiyyxxlreneFHD1Xg/7em17jPHRroPxJJrkqq20dCDlEy7h/B5MDsHtSsTK5dFCsRt9rjNHCdXMdFZTMqm63NHsYsQAAweg/AhxoK7twDEkneQB8tLm2TirR9xFV8dVnxhBwvcq8GToOU1dxXr4+oihdS7GHgL/OZdzHXlrfP4aQOuNJpFwUX04mhW+Rvo5Vac81gvIsMo=","authorEmailMD5":"d7d0a9abf32a790bbef91e3f03a4154b","authorUri":"","authorUserId":"disqus:aytekinozdemir","authorFallbackAvatar":"https://disqus.com/api/users/avatars/aytekinozdemir.jpg","message":"\"In the general case, an asynchronous call does not necessarily create a new thread.\" [http://stackoverflow.com/a/600804/929902](http://stackoverflow.com/a/600804/929902)\r\n\r\nIf you are creating multiple threads to simulate asynchronous operation, this will not scale. You are limited number of cores in CPU till you max out your thread count. So, your 3rd party API s or your own I/O drivers need to support async processing and they have to respond DPC fast.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"837f091a-f954-3af5-8085-5b04c1d6058a","date":"2016-10-24T19:07:17Z","timestamp":1477336037},{"_id":"4117516c-5210-337d-83df-b6943da3af75","authorName":"kandamrgam","authorEmailEncrypted":"lOTio28MkWJ32cyftW3+EZZmgsuxwmNlVD/Hm6/UHqawjCH1zBoKRHBskr5mEiRToVLzVcUK2W5q/FKQNKcFUR53/vz/+UJS+QWUcO+xR37acilZdvjPFJCRgDzC2ZP81lKUEz8aLNWCDKlHU7ykQ4eX/+gyoqNo3EUuvJh6s5IF9JdMDvgbRJJAtm4ABBLQTR4ertOaBA+hAtWVA4dC8pDN7rq7B6p6iNp7JzWAodtYNStAZN57K6z1X2vH3y2VolqKxaT65HmfYoxNSmKIneImpG8KIFvA/qgz1a+6BTw7Gmnw1jJM398WbZj7mzgnivODz8wg4H65uqdEqpx7OnVH6W3PMKuG7e90+SJPQ6ikjSK3f7t3BwV3wnBm7yD0/wMhN9rFt5xckLUQYTOMmT66uFe4tc+DndZPaPLv+1vd9DlkNXZWLbf00wB3pWGJtSFRr7HcZwIbtPeAG/tB6jPsgm0y78IWUcXhzSnWr8ehSsk+DipDUZ/KkdgQZDaGqP7n55zRHDGo55mIobvDI79m9wtb1xnmTnJm/ll/obcSNnTneO5511qX+AMq3GImoLQujwYrtGs4r3lv8WMO8/GrKPeGPgkIgYFKJw4Ya0caFeup2oMZmdjJnQZi7lTsgyWh8WvnBOuCB5ySDFihjZ3OKmKu/B7wd6odCWjfSvE=","authorEmailMD5":"a60e16ef8a1f18164882bfbc7d1a1ea1","authorUri":"","authorUserId":"disqus:kandamrgam","authorFallbackAvatar":"https://disqus.com/api/users/avatars/kandamrgam.jpg","message":"\"In particular: asynchronous operations do not \"run\" or \"execute\". They have no CPU code, so it doesn't make sense to talk about them \"running\" anywhere\"\r\n\r\nHi Stephen, some of your comments (especially this one) actually cleared the concept for me more than your post itself (which is also great). Thank you.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"5017bf85-ae7f-3797-be25-cc3d31d0414f","date":"2016-11-21T08:13:30Z","timestamp":1479716010},{"_id":"0e90fa6f-2303-3498-9218-93866ba61777","authorName":"Jeremy McLain","authorEmailEncrypted":"GtKOV/52I7lS/Dhjh/tmSSiO6O87e7QKSkECFFeTAhMZ481s5Y6ArVEDEOUpN7rdRGQamhCsU7cmB9URWAR+ZUJE3ABNrYft3181HlsWxYRGdi2JSgmRO0qkxOePPmbc5XKVjOz5UYCM4fzXWIfNCl6PM4K0yGL/vDKnScybvfzLZ1s/hfOgjXTSFX81TRwP7NjykkUyxxtFpQII8UD8/MJuRERmSjoLGwmBAKm5yZNfJRQMVtfWS1zitMCkoW2B0HQin9emPeqbZBS1qaVW0QR1LRXdNkuO0p0JniFgmrkoIjxiM1mj3wHajRn6Gmlt6IppqZHryxzmRsAqPCwiO6mClzg5+UaXe2xgmpUqw9S1S+doI4PuZvTk/n5KkJ0xiaVo4iYg7HaP+UtokuSzE1BvBGCRowUtnArmmPhJ7aLz1fGRstl616Qf81z0q5gJovenula0gtt2irWECbke9L9FUCrNMRrNKbiSjqL1ZUo1u2Nvq2+97qJGw7IIToCsrqClih8RYYbycEZOVyjHx6+K9a+jQSrzI1Ul1mnv1q0KYBpVCyNpeuf4Qc7JoN/lJco/yPE6zrEukWok/SjhGEgBcDUqLTdkRbt6DfUY7BRhtEu4WzjMly1JmFSsYMLHXMjVsFBe1/oU+30e1dcy4Kqe2CSxydaKw9MCcBDiUiM=","authorEmailMD5":"d2c9fd9e44004124f3eea85564113812","authorUri":"","authorUserId":"disqus:disqus_yw7A34vbfk","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_yw7A34vbfk.jpg","message":"It's not multi-threading, but it is concurrency. I think the confusion about threads is some people think that concurrency is always done with threads. With respect to I/O, the reading or writing of bytes is done in the hardware, concurrently with the execution of your code. So yes two things are happening at once but the other thing isn't happening on a second thread.\r\n\r\nOthers might consider anything that causes the context to be swapped out to be a separate thread of execution. While these may not be threads in the strictest sense, they are context switches.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-12-10T05:46:49Z","timestamp":1481348809},{"_id":"1a2a9bf7-2708-3682-b3e8-70f0fceb8f15","authorName":"Rafael Nicoletti","authorEmailEncrypted":"h+G/1JKShzH5afNSzwiJQktSFIH3KyWzawMXJK/Vlt3mY4HbPlrA0jtDvl66y+nHn4M2z/gBll9mhN8W4st8VUMNfTLtlqYoZeOYZhQ8ff1I0n/fAr3rXIljIPFJ81RL4yxmOEyUONk2sZP73RXgSZ4fnxPOLXzjatNbbnUFMHTbLITMDTB8OG73Hz+2ZVfX7jI9EV58kQ4rN6GbGxZLJI36lDVfYsoIHMRS1Jg8smssxrN1vAq1PnLFrxMAtusACZf5GXADvZKiX0SIiZn98wrl7Ysk8DlVqTJu9h1xBFIHKlA5K7WMsG1qoIlP8tMVT/ekmEUvuY9YjleapsBcFzziicYmishf7TMLxdsY2kO426E7XSFvAYcG5pkYmVR7xLSGphwAWjiTL6BkMr/HBqoa6uJBoefMeNr9re7NtzmkrOpMLhhJ+0wTQ7ZvkobIKqshX7y58kXFR0QZEeMAh6ozafFasCbfRlOxEHVazt+Jp5uDsFfXUya7J/6wPszbHVqP8SBgVFzFpgWXH3ydB64uRf6pVAiNVP0SxYx4/nzDlLxFqC/XQ/NgGU316/cVYGksccE9eiDHoOI48qgKpVxs/5N2cYzxFEpNWXAnjloJsJknMaRKCgehEGWC/BHik0shUJctN8Bzoiwae++J4Z1zXvGRl9kOZEB8Xioafrs=","authorEmailMD5":"fbff5199443cb5ba1600a2068af03964","authorUri":"","authorUserId":"disqus:rafaelnicoletti","authorFallbackAvatar":"https://disqus.com/api/users/avatars/rafaelnicoletti.jpg","message":"Using IOCP and ACP, you have no threading mechanisms working on.  \r\nHowever, that's not related to Task Library directly. You could create a Thread inside a Task action and make that Task \"wait\" for the thread to end. In this case, there is a user thread that might be awaited.\r\n\r\nUnnecessary to say that this is the worst possible approach to deal with \"asynchrony\"","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2017-01-25T11:43:20Z","timestamp":1485344600},{"_id":"3bdb1e74-f918-3885-831d-4f28c51c5b6f","authorName":"Rafael Nicoletti","authorEmailEncrypted":"vb38GUbJ8GrFwG8nz1hBGkv4wGqAB0Hjn7PZhbs5LD7/wTQqKzIzfIZ5zsCDlZb4FPoGyqKpooduq7WzJSzFlX02ukW9EW/quVCNkz8QXn1EM0EVO3bGAPYussqcB+sdbzVyE29OIDeLDueQdBavLQCHwmEOIz0N1bOWJBLsJCqAkRGR1vrUyKhX+iKYNIeq6cm54p5mxUaClIomAuBK0Fgoa+F6rP9WTLwVFcdGlRGmyMn2HqeEVlA/Qe+0E15l175w1QyXsbXbvk1tvgTl5k/qRyJpl9Zs2Op9HpleCKZNV7JIOuXz52x4+WKh+tQwNnuLgELL5xK/5nz9uPhy+skQejdS2mGJp+2519BExLSkjqY0ufZhmzmLOseCP1fPcRnA1SthBVYZz/A9HFEH4khF6welpKAlvBq5krutP4lEYb+NGEiMsjw1eLZlFRa1blvC3xZdH4jvVcPcf3hqjRwTGi6Vs/kmw05cVCQeDC6HMXkCWIrMVC9KaYfDYGjZQnpQ4DWaV2HQs3OxEtjfi63W+qERVgPX7vNrF8PAL0IeuyifUxZCdpoBjCCoHhcQF0YBGPqNH7S/TOU8TxboN60DSirDAeMvm48S9td52TWoRTPacBafeZuiN9qO5DQgW9zkl4rrRBrJ0g+nqy6sfnR5c9yA6bIkLwnWg5CeFIo=","authorEmailMD5":"fbff5199443cb5ba1600a2068af03964","authorUri":"","authorUserId":"disqus:rafaelnicoletti","authorFallbackAvatar":"https://disqus.com/api/users/avatars/rafaelnicoletti.jpg","message":"Let's suppose you have a tcp connection and issues a ReadAsync\r\n\r\nWhen you execute this method, it issues a read operation on network driver level and signal the driver you're waiting a completion from this command.\r\n\r\nWhen the read is complete (at network driver level), the signaled notification you sent together with readasync is signaled. Behind the scenes, the \"callback\" is scheduled on thread pool and eventually called.\r\n\r\nIf you do something that block on that callback, you're going to consume all threads on the thread pool (supposing there's a lot of tcp connections doing ReadAsync simultaneously).\r\n\r\nBut the ReadAsync will continue to be issued as the thread pool is not being used to send that command to the network driver.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"0f4118e4-3ef4-305a-8b7f-ec2c77155ca3","date":"2017-01-25T12:02:38Z","timestamp":1485345758},{"_id":"4541174d-bd4d-35eb-a22b-9174c01e2dc0","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes. Since Task in .NET 4.0 was originally developed for parallel processing (with asynchronous as an afterthought), there are built-in mechanisms for this. E.g., Task.Factory.StartNew will queue a synchronous delegate to the thread pool and return a Task that completes when that delegate completes. It wasn't until .NET 4.5 that Task was extended with full asynchronous support that was much easier to use.\r\n\r\nIf a method uses Task.Run for its implementation and returns a task (i.e., with an asynchronous signature), that's what I call \"fake asynchrony\".","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"1a2a9bf7-2708-3682-b3e8-70f0fceb8f15","date":"2017-01-25T13:16:36Z","timestamp":1485350196},{"_id":"1b5adb1e-72ab-3a96-80aa-35d657a281a7","authorName":"snielsson","authorEmailEncrypted":"bSS3D6QPtlfD8lXWztyz9efOGIWC8wa85FAqRwvSl41G7eOLEs1Ea2PiFdOLvR0i3SvWIiaNL/nve045+U4HagII3LtqE4mVJkpbwHhN3qgcxzynr+56gnGpIOLFfT+yw1Xu1SIMLVbl9Er8P0BsL2N8e8/plbtAd9AelHxObwPsf/uunWZSABsA4LB4dl+yu1fpESU97yBQkWVepgpVYes4Qzq6eWVs9+t8v4SHeh9kXpDmbYW3JMDqX2HAMs/ZVxSNz+jDYi3o8mZV+l5Nj/zo4r+fAJZs9sSHmH9XPEtXoJ6cQsrAOxgpPT1v1tDxBrOu9Bl5HHqSess75MVJRfgOOb1VtlWLbJ5j7Yprl4gco2dIhV4ObNg1pI83TTIF/LveEJP5uLDGBs7r6fltUIT892fEZk4QjefVj8WlomjH3YXk1ataU1MeE2vsRFySBv5pGdlB3HsxP5tzZ+WLJLLx+Vuuc9Wi0VWfOlXkzRcK/N8e0XL+us2E/VU0ZnEhaTY6T5rMYkqu3LoSxDqH8CcT877KxrK3otg1xH9RUa8Mxa6kAAhgskAgU8DnZE26RqeBT/ZFCXwl1Q9/lQboRn26sp0yOPgpOB6KzG2kDLMFn8WKc7qWj8ieQQT06KuEUVASrxj+OdmtOA3JIAl6yWRcaetkQ0lDP8/WdIKtAqc=","authorEmailMD5":"5f54b776d334bc43e497f50e28e5cd89","authorUri":"","authorUserId":"disqus:snielsson","authorFallbackAvatar":"","message":"Yes thank you. I also asked this on stack overflow and added some sample programs ([http://stackoverflow.com/q/41952687/193414](http://stackoverflow.com/q/41952687/193414)). It looks as if there is a limit as to how many threads will be taken from the thread pool to execute the async task continuations. The answer I accepted indicated 1-2 threads per logical core and my tests showed it was more like 3. It also did not matter whether a single or multiple threads were used to start big batches of async IO operations - the threads still maxed out around the same numbers - off course this can also be due all the tasks have been synchronized when waiting for access to the file system, which was used to implement the async IO.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"918fae56-7374-3f26-8e03-47fd4ea9005c","date":"2017-01-31T14:13:23Z","timestamp":1485872003},{"_id":"918fae56-7374-3f26-8e03-47fd4ea9005c","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"If there is no current context, then the continuations are run on a thread pool thread. There is no synchronization of these; they can all run simultaneously.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"e9009e56-72fa-3e65-b6ee-0c5c569c503f","date":"2017-01-31T13:56:49Z","timestamp":1485871009},{"_id":"e9009e56-72fa-3e65-b6ee-0c5c569c503f","authorName":"snielsson","authorEmailEncrypted":"dxONtePI9xUPGb+CWja+3WadcqBIV9YWY4GOuR4GM8e7jj8+xIsYOBBVbqHO9mc8Mq/OV7Do1IvgaRFmiAfIIHtXF6gcVfxgSjgcaPCtDgfSOIgP5yd+ExnWo+5FvxOFqrbyLkysacJbpwy+IlLzk73wI/O++AHbkop29X92qYa2tFs/SJpLBISrSsk31mkSnSyO/DuKe5rwqPEWs3vYp5UZmm8bi36npB72M4G2DIGl7ITubmqFrxOuYPSFqKjQh33hQCf6OUjIVaiEJpyuFdySO76PFAKkLw0gFCRdgMd+YjAQAv35uA4AHokLZw2lkwsG8L5ZLyETjbI36Tg7kbtecQno/0K3HnOzUC0+kPJ3rLYOxUjsCTELo71sCOTRbCyIoY0oo6sNHbcGeMw4t5+uHjaNqjO3JCNx6zbHkTIRGEYbjqN4MPMwsuIPGXryFhPywkIzDHmw3i7Uwhqaz2warOoUaIRxUkX72TS7DSsvP5i42tzOh4LHUwp8lkHTPICTxYnV0U+W/VWyYhtiI9Buf/56LW8xLsalypo/LBM/YxhCDHxr1HhfJMQrhqA3OxDx7cy4bkU9P6MDF2q2XSWQHD+/VCFBnJ6ijh7lAKVjoRLd7mFdvRA1uZfY99iP09eYgnsKiYNvMnnCVM8sNy3c/APQx7piCBaZxKoJyWA=","authorEmailMD5":"5f54b776d334bc43e497f50e28e5cd89","authorUri":"","authorUserId":"disqus:snielsson","authorFallbackAvatar":"","message":"What will happen if I on a single thread do a\r\n\r\nawait Task.WhenAll([items.select](http://items.select)(x => SomeAsyncMethod(x)))\r\n\r\nasync Task SomeAsyncMethod(Item item){  \r\n await myDevice.writeAsync(...);  \r\n do some cpu intensive stuff...  \r\n}\r\n\r\nand say there are 10000 items in the items. When each of the SomeAsyncMethod continue after the await, then it does so from a thread on the thread pool. So when many of the SomeAsyncsMethods return will several threads from the thread pool then be taken simultaneously, or will only a single thread execute \" do some cpu intensive stuff\" in SomeAsyncMethod at any given monment in this case?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2017-01-31T08:01:34Z","timestamp":1485849694},{"_id":"64a5513c-1616-33aa-a9c5-010f2f52da28","authorName":"Harold Chattaway","authorEmailEncrypted":"TjoCKRltfV+dZIeFErJ7LGRS/j6gw4jjR+2D9SyQxJanx3qeQAaoqXI+cPEhzDuZ3xfQk63ZSncqOEbqDGcvngOV149H1+wFPCYIRVk2T6p0AAzGVSiqjODVpTqCmTTyZC1hbNbgyhUCgFB3yr49Sr7xBuj5szHTd720Z3vg4FLoNVYO8avcFCZ6QGjx/gZG7oJtziry1RWhtZ17mY9jguxICY8gRudkhldGNU5d2iMXDxHSQJd6637id3bYxfGlnFs36OCn5JM+cdD5M8LXlS6y8rMj5HROmnQ1mpqOj0JT14T96KjA9EqL8djdazOWNf9yHQ7PFgNXF2tgY98WtEEtDe/bBSfDjDJ2dwVqpbvl33TzCNF8pcjfKcrYZs7cV/MT4V6GF8eejXO/+DSnZG+vPMlv72808KCbKH3VF6usrfyA2HvQXS1giP5pjUhi/dGyndU6hWJ1sYXv4/iZAjBKNvz/qyVYIdQYNbDJUUOnXgIaohNAJpWT+dq1v5n8Ia5ZhCJQfjXLN8KweHRim/7UeCtt+EH15CZsf4yZhRzcUC9dR+zEl6pw44uAhHJVXo2TUApg/NXn083OnCpO791bha13ONXNd2sUiLJha0jqDNToxq9RHB1xnoud9THKyV0pMX8HlhAlS8TJ4BxQLr3sg3EAUz+VugVZgmCsZs4=","authorEmailMD5":"f1490ab8bcb9f131f4defed453afe577","authorUri":"","authorUserId":"disqus:haroldchattaway","authorFallbackAvatar":"https://disqus.com/api/users/avatars/haroldchattaway.jpg","message":"So it's still important to use an actual thread when what you're doing can't be handled by one of these other I/O type processors?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2017-02-13T20:39:07Z","timestamp":1487018347},{"_id":"6783cd89-d9ee-31b4-81c7-5742669f95c1","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"If you have I/O, then use those mechanisms (e.g., Task.Factory.FromAsync).\r\n\r\nIf you have any other kind of event, then use TaskCompletionSource<t>.\r\n\r\nIf you have code to run and need to free up the UI thread, then use a background thread (e.g., Task.Run).","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"64a5513c-1616-33aa-a9c5-010f2f52da28","date":"2017-02-14T03:21:08Z","timestamp":1487042468},{"_id":"1a588009-cc96-3fdb-a2eb-b9449c0a9df7","authorName":"Dave Parsons","authorEmailEncrypted":"mF/OOkmAnoXPw9cJJ3/9C6Q5bBhITca+ED1qhiI4/XrDJ2hPCMJCVwqRfnyIHBecPfr2JST6jUpqON2T+z+5TN+cN8lWjRyXav5drA9f1m/88ou+BvYvhJlQI8vg3/XT56BqPa5/DOEL3m5PgJq51lJjJEEGWopI++GVzjOZo9MI/0y29cof11rB7l38DV+q+WZeTYQLtrhX3ZHTaPrw25CNXZVj2HeEgxwU9y1QihxTDBsIfBwVEy23+2yqBuQlUAdrrdvHf0wleDl2inKarL06JtqI5K7XHntg1G1VTY8dH80Dcy1892kU0LVw8HFNnlQEI+oxnYHNjVR8zr/O1uplpG4ZJWRY+J+hq0wyPFOrLzQK0gOZbxmhXzVVtCv0tsikl1AjEhrOc33+zrYJv7Cl3C+01qE92y5J1BxgvuMIXAiDUZdAOMQNFuf+mZVL14KmO8G0idrhZcsVC8f8TI9SPtNCw9UP8NN/jTRMAytDDiqGn1KM1rrNYmQ6rR9s13T/ciQr0GFrnN+F5cvTgYkiZH5kqFxE15LL9nvXIpVsTrs3WPtL0gWlvpeTb7rYmpCIX+tqyqiTb0irHPsK18nM9nzT3ZFWenWlhWv5yP91mb4Lvk+La6JDtFp+Zdlr/feFtwqFTjbco1+ZMDplgllqdnRzvitb6xu8Rsz89no=","authorEmailMD5":"82df17885fa751600eac9fa114cae9e8","authorUri":"","authorUserId":"disqus:disqus_SjnQZZNqZA","authorFallbackAvatar":"","message":"The I/O completion port is said to have a \"dedicated thread\" that tracks the thread at hand that initiates an I/O. This port also provides overlapped I/O. Assume a thread that is doing some work then asynchronously kicks of an I/O-bound workload ( a disk I/O meant to read a file from a file system). The asynchronous call permitted that thread to return to the user-interface, and thus avoid blocking, unresponsiveness, and overall window freeze up. Having returned, this thread then resumes to update, resize, handle events, process message in the message pump. If such is the case, then how would it process the data from the I/O request Packet?   \r\nThe thread pool uses I/O Completion Port resource, but how would it obtain this data to either queue or process it?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2017-06-05T17:00:01Z","timestamp":1496682001},{"_id":"e3ec4322-493d-3689-9d5e-f3d563e06ad7","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"By the time the IOCP is notified, the data has already been copied into a user-mode buffer.\r\n\r\nTo use your example, when the read is started, the buffer is already allocated and a pointer to the buffer is passed down into the OS. By the time the IOCP is notified the read is completed, that buffer already has the data.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"1a588009-cc96-3fdb-a2eb-b9449c0a9df7","date":"2017-06-05T23:46:07Z","timestamp":1496706367},{"_id":"d9bb392c-185a-3416-8233-860a4f140fcd","authorName":"S2RaL","authorEmailEncrypted":"Mx7ydVD1d2a0CLniGu+XbgGdUQi2ZQXlJwwN9L/6Oe3o7cpAnP2pXQO1tMjejl+D7NGWvGK7HJda3X8SZE6/iATpU30CJRo0NCaGNZ3Cn7izjN7paa6DzquRsSB2nyKbzuGKHJ4vsJkqSFAEnqYIICpOUEJHeZY3mEALWp4MwOhi8FwcosTwsMpjFKfJwikTj6QldEMmXwLNcVqur5WTpezwCrcTCQHIBETSa7m2m1PsKedez6VRfLyLPbBJ03l1GEmzouuf9B1GKp8hq/ShhCsPFOCAK1uFTSw4jN08SqcLN4n1gLECafJhb1ZLaPsoZbG8rWjOcvBZIqSaNZzo7MNlfwGmOf1lhd2A2mCGQh7Sw7c7Zpi0vV7BNY1nSLk1qhkDdTB+/FMGOsmLgfwiGjYWzdvyhkKG3wl8xwu6mluLOusK9Ff3mmrPey0yQVFNdvkZsy3HOqcYBYsHEqzouIIVOzp4do1+0+n6rN/NwJZax0TmFjxz7lMZqZegBNvxXn3UReoXYvRBZcBk069i22+Uxsgn/RX50hSowaPIeDHO5HEWLyhOaWYjlp1jZCwxo4tZt/S5rV4XkmPalemXIO5f5P0rBpZjExmETJBMInTOgnAWkLty3v7iA+pL1no7azl+e/i5jq+jJnSMKt7ci2uH1X0yz3FqecUlE8jmRpI=","authorEmailMD5":"1404bfd9442ce20ac0c2e08ec022fefc","authorUri":"","authorUserId":"disqus:S2RaL","authorFallbackAvatar":"https://disqus.com/api/users/avatars/S2RaL.jpg","message":"Hi Stephen.Thanks for such a great article! But if there is no thread,Why Visual Studio shows that it creates a new Thread?Every time when I call for example WebClient's DownloadStringTaskAsync method,it creates a new thread.Even all microsoft's async methods behaviour like this.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2017-07-04T19:42:05Z","timestamp":1499197325},{"_id":"d4ddb043-e5ad-3af4-8167-c7329c0999ff","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Thread pool threads are spun up as necessary. E.g., they're needed to be \"borrowed briefly\" - used for a very short time and then returned to the thread pool. WebClient won't block a thread for the entire download, though.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"d9bb392c-185a-3416-8233-860a4f140fcd","date":"2017-07-05T17:52:02Z","timestamp":1499277122},{"_id":"b6ae0433-0d51-337a-8a85-980cb6f50c53","authorName":"Harsh Maurya","authorEmailEncrypted":"e5txX2hPi/wCsv2blxNkgFrI6TQxOOJG6m1cWuoxccp9BZ77gaBH97B91Xg13DY6M1iOHJMnjUDArwj/VLR7bPomXxfNirZeK0Fk7aZ9nKrcVvPqIV3Wr+xw+7r5Yn6u++8Bc+bGI2+lbp1tsFUTF4MPPO7XLa9fpnmLwaUQfNSFhwDfPpW/NORjoOuVQEL0VzpawyJzdLKm8nABJ6O1/oC8SpAeLzGf8QJeBRPK6HN7bU9UmMxTwdZeeDhLn1x9qCbH55XQnvr9cwVaCVbFFrZHcSFhdMR5dd+pejUr08626+0waXbxp043wM5cnhbnnLmbb2tW/TiLKzpIfyutYs0mBuBn53zJtzvv5HZ1TLOhOLJiLmwpbO96VCdGsWwks+mpid/6nXpT83+Y0I+eS7EwnJjnsR4Ept2YZtO1ft0uIXyrgxZKiZt/mZN6H7tEQtblP+cBtaxQg9JDsHgBqPDHLCHj0tT/DXBNmMCeRQ8HKrt8zAOH1TjZTxwQK/EfqynWDgx1Aisvwq3yOP/9JAuet5zLPbPElwXiw6ZAGMQ2jlRoEERsUKRns9cY2qxjd/qUJB13xKn/vfGWIA5WlR1EFdztt29hD6LlKdJlYf0e/2W9+ph+B2UfeRB/nr+wlhgGmW39wZV3S+a6clOEk4j41qvz+OfO63hRVkTGFsE=","authorEmailMD5":"501fdb8376d6474f00f4dafe84ed5c12","authorUri":"","authorUserId":"disqus:harshmaurya","authorFallbackAvatar":"","message":"Is it possible to have the UI thread poll the IOCP instead of an IO thread? I know it is not useful but just asking a theoretical question for some reason.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2017-07-13T18:06:45Z","timestamp":1499969205},{"_id":"b6c5c522-b6ed-3eec-8be5-6c9f533fa71a","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"AFAIK, you can't poll an IOCP. It's a notification mechanism - an IOCP thread is blocked until a new packet arrives for that IOCP.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"b6ae0433-0d51-337a-8a85-980cb6f50c53","date":"2017-07-13T19:05:38Z","timestamp":1499972738},{"_id":"01c13727-850e-36d1-a4e6-603651c24376","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes; I've done this with C++. It's much more difficult in a managed language, but it's possible, e.g., using APCs instead of an IOCP.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"0cd5ca18-270d-3730-b707-e2f2899ef0f0","date":"2017-07-14T11:41:39Z","timestamp":1500032499},{"_id":"0cd5ca18-270d-3730-b707-e2f2899ef0f0","authorName":"Harsh Maurya","authorEmailEncrypted":"XKgg+eGqbrAT3yNfB+0QAPAjLEu3FfRepT2vvrAv/6vAnNSFuFbL4+J9guOjKZYUWdwBu7yDT34dXpAtsztRiN6D7syUTSUGeUh6Q9m78DzO3JEIWXaorPI7zEEAO09DyBvHL2DMZvW7VdmqLW4oKVGi773iiR1tHQIWDxNQos2QwapNx1EbLd8TOWxJJAi5rWC2QzCj2avVEaP730hV6V/cIOF0Fz38e6MJon49b80+2/hd+k9/tDiHIiaR8b3FQAc/zaZmqdNe34hMqwqC2XJeyEnWphOnhto8rOmI71KzClHP5iHX6ikOeCD0w9LDeL3vKCfN5/mkkrSd5y0ZLzl18pAnkfIKY0ICxT2jO4FwPxknHeYp3Kw6ADycp2V9Msjagov5Or6cwwC4iemPygyTOPb8RursZPZlnKleh7cjqTpfXsuT32en1vmkpMde/QUBdlx21s9C2amooQTR4Uwjac0n5X5ktsK8Pzq2OdoCt382Y33IA34OMd+0aNxfiKlgIy+z7INy64WlwgXQloDKWP/5ZPUW4D6JNQg5AOk8PurKCSxqDes6sde+0K1yhEKhpv5rke2Xdkqtja7/+TC8Lv7q4RjS8ewWhSy2DRqeu4FPshiK7JVdt8yeTdRLQQ96zxaM5PzP096nVjhX9Zd1nnTk7OM5JA0po5kdm9c=","authorEmailMD5":"501fdb8376d6474f00f4dafe84ed5c12","authorUri":"","authorUserId":"disqus:harshmaurya","authorFallbackAvatar":"","message":"Thanks. Do you think it is possible to write a single threaded program with async behavior? By single thread I mean, not involving even the threadpool IO thread.   \r\nFrom your article I understand that this might not be possible for an IO operation but can't a single thread's time be sliced into mutiple tasks so that client \"feels\" that it is async?  \r\nSee my question here: [https://stackoverflow.com/questions/45086555/writing-async-program-with-single-thread](https://stackoverflow.com/questions/45086555/writing-async-program-with-single-thread)  \r\nThanks for your time btw.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"b6c5c522-b6ed-3eec-8be5-6c9f533fa71a","date":"2017-07-14T03:29:20Z","timestamp":1500002960},{"_id":"73e28f7f-d003-39fd-a079-b211570134e4","authorName":"yue shi","authorEmailEncrypted":"gG6dUbGlr3eMZb82nsjRw1xzQgmDW5Y1YK/rV10tWzuqrJTymfNQfrbcquO3cIn1zCVHORPi/7LhKh4rPRsNibGgTUxp2BS9k3vAZZpBgIOhl3Zm2xrbGY8MmBa3OiizZFolOLzWRC52XQBlhY+HFpA6Pg+lwakzDZT8PGO0gdBqu4zMjlJoSMcZIZzeFEYT1NbcUl/mXR/3fv+lPHPpL3t1BPnjtMCnlQQznVZP5CkmfhHDhlRo+h35ikSS4CLtp54VoqMcaTa+T5mNfS9xUqI6BTTlRmkc+zZWYV6DPPFnlTmUnazOAR6cjh30rqmHwlj1XDhATatvjzcV9OZ1nXbPDTLIOLQpHCR8XC/F6c9r2dKUb1eROKI1svD7k2KGDRdB4AS0BFE0bSApZC3kHSrE7Ny4KQDOTRDYz1syCJzRzIdc5toZWpE3E3N/Pl/MYUnRLHKcxoANzNZIUAgQRoDlSI4GmCom0CtWxvMHNvcWFUEByLxNLVd9+BknFGMNUomQ2majcpxgi4BMAAQhK1wJe5dCyrIIPh86ERsLgKIxMLBAVrJqxvEhxdU+5w8mmHCJytn6A3jxDiCkRGJLulGysltmS+vQH0cmce5swcO/vI8ukhFD62V7HuCTmAeMHzWTZ9WLrD6F2KSQOQ6Ez/jQ9Ymv2dh32P/LQEApLss=","authorEmailMD5":"37511e0a682d90aae2b084830473e006","authorUri":"","authorUserId":"disqus:disqus_fPnmDglC7i","authorFallbackAvatar":"","message":"Thanks for the great article. I still have a question.  \r\nImagine we have another async method in between UI or web api controller and the async IO operations. Who executes that code?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2017-07-19T23:47:31Z","timestamp":1500508051},{"_id":"10f80821-adca-3491-a000-35c74f2d5c16","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The code resumes on whatever context was captured at the point of the await. The built-in \"context\"s are generally the UI thread or a thread pool thread.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"73e28f7f-d003-39fd-a079-b211570134e4","date":"2017-07-20T00:04:23Z","timestamp":1500509063},{"_id":"c51892db-596d-3cce-80c0-a11285a19ffc","authorName":"yue shi","authorEmailEncrypted":"qHR/w/ifsBOqEa6WVvDeEZeGAfcq/sixktz8iCVrylUAwZ6T4+i9HARFn0V2EhyMTA31VM2cgHBaSxH6egzKJnxzc1W43cxa54/fua/+Dfiiw8vz1XkCYPbjT3rwcjfS2424oveq0nU2FAS2NGd00kcn1YSkmz5nJAuf5heYny2ZOOnNqV76bOBZJspz0qO1yZbrLSkNPPH2svNJdDm6t6/ezTcGqFBat5OY413jy9Tvz8xrgyCmCkHNjMrh5kkW0Ft7ANK/Pgg1uYSXzf6y6KMkrGcmGn+lD0gF/VtLGXQiegPb/+M+R1hJWPp1grCyTiP/coPK9lrTHEWm0tNrq4/q8oGKiINlSoxtL2rkipTGMrT5MMuI1giWsGT4cZo3LlaYZSqTzuzgkzkcP+2ajVzWDCTGlNo0K3kaENJ8YGrj1AI0ToBSbtUVlohkxFIL/19Hp+KQ38a2UeQJ1XqQz7V3V5MAR4Lvh+pCLDJytLxnS95XJZ2ZTzB2gqLCULF2nIFx1+95Oq0GWdLJ4tN6yHem2y6cuvkmb0YVqovqRlTWZtfmQ3I5xoT6zlfiJigQlO/Rbg9G0ugDQ9W9270jDp8V599wVMlRk+mV5KOZJBjtD3Ey3MzRYPEF1APjEcUmPNTPCW2SPgNQTPqu2GKdO5qj/gUxnLY5981HK41rApo=","authorEmailMD5":"37511e0a682d90aae2b084830473e006","authorUri":"","authorUserId":"disqus:disqus_fPnmDglC7i","authorFallbackAvatar":"","message":"I got it. Statements like \"await returns control to caller\" from other web sites are over simplified. There is state machine generated when compiler sees \"await\". Thanks.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"10f80821-adca-3491-a000-35c74f2d5c16","date":"2017-07-20T22:37:58Z","timestamp":1500590278},{"_id":"02580edd-4ee3-3531-8954-eb31ac1c00a6","authorName":"Yogesh Dhongade","authorEmailEncrypted":"wUUzQbZJ41ADmOPYLW/g3Ygzhfp/asUn0VjJ8+NreUQYEDL5lxwkMdnoqwH3Ds0mFuTdB/EkI8ffhePMgEWkE/zUYmlKZNFGuI6JydOKtYhjfkQiPHkT0C1+9zF7T5d1/Djs3cmmVBRlcim2I5dLFpMZaDGZZ7LkRFisxLxgIeHhFO3CWPfbFURfF9wrlJaglRl3uh2BuMaYPbA02JxCbFbAUw58ELb4mA426iR77bt7TrYo23VP8m3b13d7cbNJFoHMgz1of1AzcUm49lCcyUfK7N3s/CrtL+2fNpuCSVvQR6Q3GYjm8gZkNKHGfXfMefwJUIYJ+xcuPUdzzjpYNgiqpR2RyQTE4yz2o8Uv7Y8vzZKL1bXRpMvfqMhapYmx6HS0STmbu7DKatLIr/yynJwmSO9YE5Q91v3ckJIhCUWWFT4UYaZH7R79eJYTS1dzaI9FnyhGnBZiExG/dS43CagQnZ52bJVIWVRaBVAB71wapqLAJCLPvqdgYD+Bx6kbzWCeEwA7QomS940uNZgN8apOkBoQZR4CYIpSdCiqhd9ARHfqnntqWs3sbcvS8dcZYqwQnsaygGVfmrb40a5wYAoChKSC7JalLdYZ4JYtoWL7h4D375EMMTKvyd+fEtnDHPnlc5msUCRhj4vwNGHSq9CfgoZKJGH9SqzixejMPW4=","authorEmailMD5":"a508eb724aeca6e480e74289ea6bcb9c","authorUri":"","authorUserId":"disqus:yogesh_dhongade","authorFallbackAvatar":"","message":"Very nice article and liked the caption and the explanation. Can we extend the functionality of async with pipes and sockets ?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2017-07-28T11:46:04Z","timestamp":1501242364},{"_id":"3bd830a1-cde0-33a4-bedb-b7779faf728d","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I'm not sure what you mean by \"extend the functionality\". Async can be used to read/write pipes and sockets, sure, and you can create higher-level asynchronous calls that include messages and responses (e.g., HttpClient or SignalR).","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"02580edd-4ee3-3531-8954-eb31ac1c00a6","date":"2017-07-28T11:54:54Z","timestamp":1501242894},{"_id":"69f33e10-dcd3-3206-b2c9-29576e5ef9ca","authorName":"Yogesh Dhongade","authorEmailEncrypted":"n1JXgQRoCdmyfP59N9aWtuHvcNEl+UZ3uTm9jhSXsyG0PzkHe3PPb4tkjndqUBcTxA3/3vaobbwnrUaTpTncLp4z5BhN77ROJzg5gDECyrDNgTG7prVL/Ct3txIIv/ew+CDAjjRPv4bBviYHlN1X79/jlIhSKOAAlW85I8VqxzBG32Oy7KO0sQhWfpBNNdHa0LhV26fragbX7qE+mSVwANqGYZcaitrKrE9WAnLz7AERCDpCaMdWJMpjOtWZyLpQGhi2TM820AoboTcqA6yVjwhbGZkUJ4AWLYL/8qAkG0MIWdkOE/MJjmw2WNxwtNdf2Uiillamp7sAtn0WtvHohZKl6CguQOl3zvbmWNs144NoAEqi5E91tfdgapp+9kZUSsI1fOAB54aC0Y7fN55//oklwzA8P0PzCHWsMiQ+Fhox3L8NieZnwRdblZy75XEj+mLggj91nSQZFr8tOYE2w0MNWHq5OYBN2FKSv/jGPyrDVY9zm2NJQjEgI1IDExmV98S1i1GQshnuKFB44pf7uTIPNN3xxlRWg4Yof/TI0UptJok8bd3XEi1LuYoqk3KxdDYoFmyFeU8XWqE+1280zZQ2ZJKvqIjlYpPsY0zoSmUY/GqhDQukqdzEHOkCLq4HH4ZaA4z5Oqbv1VRzJeHgjth1TWRiax/HyKzyBJ8gt+k=","authorEmailMD5":"a508eb724aeca6e480e74289ea6bcb9c","authorUri":"","authorUserId":"disqus:yogesh_dhongade","authorFallbackAvatar":"","message":"Thanks for immediate response. Extend the functionality means there are some implementations which claims that some .NET asynchronous calls are using IOCP internally. So I was not sure about the same and trying to use IOCP & OVERLAPPED IO in .NET for best performance. I stumbled on this article in same context where I think it gave me quite good idea.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"3bd830a1-cde0-33a4-bedb-b7779faf728d","date":"2017-07-28T12:00:28Z","timestamp":1501243228},{"_id":"3293c452-a66f-34ff-aa17-c9f3fa2f98a0","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Sure, you can build Task-returning methods around OVERLAPPED APIs - I've done it. It's not exactly straightforward but it's doable. I've been planning a blog post series on the subject for a while, but it's a big undertaking and I just haven't gotten started yet.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"69f33e10-dcd3-3206-b2c9-29576e5ef9ca","date":"2017-07-29T01:09:27Z","timestamp":1501290567},{"_id":"7dcb012b-eeea-3c6d-91b8-a985bd767cb9","authorName":"Machine Learning","authorEmailEncrypted":"dlDq73CSbbzx/qvybSal1MNu9lvuxnNqMa50BtyaHmlFQW0TUlhTnfz4rb3bLsyocLU5IMgXor0DCWg0JgFjNd4sT3cW3mHmvwbgm0XF8jRq+2mJ9e3xUPqhoCZRN8xiGRiRU49oHCt7pWWhfIsmpnuJ9IqBBpu/b+49rR58ceRpFpmVLDdF+l/MyiVeZaNNWY+CpvcR2pb2OiXxJH3EIbT7qLEGM4OzVImAXc2xTFEwUf8pmJCWFccyDCsCJ1SHfDB4uTWpcxdStb5SQOM04rk199mxtxDe1DJDR4QIyPS8rObrVA9ln4m6onOHdl/AsS8agOTWmlthD5zM0S3X6HUKy9sg9bGTOkVIOITtgEPdflasHavuh1UriAKrzWvhYqImq0ZFaQq2SkA76wqNR5bkD7hYL4aJPWXcWWNIMjAuTs4QsR9H8LaLgB56xza0/y1BpQLqXqZRd87OuW/2OoUVQU5/yoq0l/izSVGUzvxJNzp0xGMHoAp1y8b6JUb3hWRaCFKYd8S/17w9kVhdkYXi4qqq08qgIhQYcF7ViaeGxslD+wRfPSh0QwCUcN00JoLR+Vkyjhe9uQ7ZzvDbFOUIBn71Nr/wjWhnkvlBTT/1a2j4SrYWeNE0Gzo1t4Iy98Q6XQsC/7Wn7O11eoXx5fgL3g61gHP0WXfRK9sh10A=","authorEmailMD5":"003df623d728f783fdca0e70ce803069","authorUri":"","authorUserId":"disqus:machine_learning","authorFallbackAvatar":"","message":"What's the equivalent of this mechanism under Unix (Linux, Mac) with Core CLR?  \r\nWhat happens to Win32 classes like the overlapped I/O and how do an \"I/O request packet\" translate into Unix?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2017-08-22T05:39:44Z","timestamp":1503380384},{"_id":"83c0b411-2e81-3bd9-aa3c-20f31db9b426","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I'm not as familiar with the Linux kernel, but AFAIK on Linux, it's up to the device driver whether to support asynchronous I/O.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"7dcb012b-eeea-3c6d-91b8-a985bd767cb9","date":"2017-08-22T11:34:32Z","timestamp":1503401672},{"_id":"bcf69c86-e2fa-3b89-99dd-b124049f870d","authorName":"Machine Learning","authorEmailEncrypted":"hWjIA2DsqwXv/J3il24ag02mYOq9AzHJcyrTHCx+74Jeuxy9EqfKOSqGdDR2PNmg4/BdHN/FsP4bdZA4lRJevet2mVaGpYUSNc6i9hhqAMDEwxjeE0K766J6kAIS5L54q4UMM09IO5tQzdxnnHt81kWosqgLJd/dpUAAPgfe7FAskcj8tJt+sroEe87TI268IPUyLNgq6+kn8i+IWdAegh8GcTPc67UYFDQkQ0a4TRS3d3ZoEAynqKBP5E8oX6LkIDjpDjlDPIKfsUY3bKEZ0ZgoFm00SbY6ScZ086WpyFcdmAUwQBE9zHC1vycwmSeD0kB6bC0WShMFZm/TRjRWQAxRctQoYeWcOIF4IO0hUWlWTT8jXD89Xt4fmHXFObdp11UYmI7drFGDAYaYv9Vr0r0wcQmWgtJLhfaEqdxaaQIl2BCweWfU5j/QS/6xINE82yRDUd49frqSgqMIKYpFL4aSpKbhj41vA7x6dqNKje8p3lb+iJRPYsJ7AgUTrXNzjknJ2i3DcQLfXY/jyi/oVVixJ+/gwnKBuL5LrVVsztaTkmNg51927/4dQ5VxmQjdX4u2NGYCdMfsQ5Y5/8UWxOOgo24sx74tvFP3aiwd+0gKNR45kevUCvDtzPtw6QYrmLYHcUYfnaTV/OFpzXa+08Q0VSHFKcE9fs/D0UvloN0=","authorEmailMD5":"003df623d728f783fdca0e70ce803069","authorUri":"","authorUserId":"disqus:machine_learning","authorFallbackAvatar":"","message":"Thank you,   \r\nof course the device driver has to support asynchronous I/O, but what about the Net Core implementation of the async call (I assume it is the BCL library in your image above)  \r\nDo you agree that the .Net OS specific part is likely implemented in the sync manager of PAL in CoreCLR (or similar) as per this answer? [https://stackoverflow.com/a/45808571/6996876](https://stackoverflow.com/a/45808571/6996876) Thanks again for your help!","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"83c0b411-2e81-3bd9-aa3c-20f31db9b426","date":"2017-08-22T11:37:22Z","timestamp":1503401842},{"_id":"281fadd1-662c-35ed-9354-8a4279e863e1","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I really have no idea.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"bcf69c86-e2fa-3b89-99dd-b124049f870d","date":"2017-08-25T21:09:26Z","timestamp":1503695366},{"_id":"66589d6e-3555-37d0-8097-af3823ded819","authorName":"Machine Learning","authorEmailEncrypted":"sMcSp3D18zeDgqIXvHb2BxR71ur9GriakYF+mSk63Jf8IBSaHl83ONfRzJXMlTCzKmSMhlD2JdoLrN6ed5Tgod2/k3kWAHvC5ix1/7KNKIg1U0khRkRzfNQQCzhGacGBuf+imTlFeZ/L8+OZ0ScRlKrbOmM3rQHsUhHrOYQvQq9J26W/RTni7NEyV7zbdHHs3pMtQXw0DLyQCDkzQ8Um3hMV3qP3dA9DOuEB4ur5Y3io8xF3QOc76ckd6i2Le4+pR/VrXdeyrMtfSHag0l1Ofpq3/udvNtKF6m5iUzbtPuXE9JFXfJ3xJbnIdQw1HsbPJBKfp24SlGPpBfnPiYgYSMrdMmln+B5R9jyn3uok3g1B8WsR1uI7vBL42ao8Y/hReEg+yPRjWyrD0mYTsV+0I37iy3kF3nZuH3zkcxGKju5Z00++Gyq1WXvF12irGYqvF6tk8FCmkAYbrsDdgf/5fDRO4yD2gy2OPoZuIyNrL7svZTIuPPQ4Et+56C4cOa244F4gEyR31AI3sRP0EUoDtwfC81sbIBZtksm/u+ZOT2FoMa5oQZ38Limwp+xV6Di4lNaFn6e97VpRwt2XMq2JFahVD08Xo5kfqoE5M+VJs6vbQKY8TAND664udfJVg071Bt0S2EmbWHOO9OSFbufRRyawHeZ3s6TqElRGcPJOnWU=","authorEmailMD5":"003df623d728f783fdca0e70ce803069","authorUri":"","authorUserId":"disqus:machine_learning","authorFallbackAvatar":"","message":"Ok, let's forget Unix for a moment and let me ask a higher level question: on Windows, the fact that \"there is no thread\" is not an implementation detail, is it? You assume that the correct usage scenario of async is not a cpu bound but an io bound activity and that, in such a correct usage scenario, together with other truly async driver/kernel/etc... io functions, this dotnet \"async/await\" language feature - as opposite to a Task.Run - results in - 1 thread, correct?\r\n\r\nP.S. In other words, maybe more explicitly, do you agree with what DavidFowl writes about async/await in this comment: \"The basic motivation for Async I/O is to boost performance That doesn't have anything to do with async/await though. AKA it is NOT the basis, nor is it required for async/await to function. Async/await is just C#'s represenation of co-routines.\" [https://stackoverflow.com/questions/45808446/p-invoke-and-overlapped-i-o-in-core-clr-on-unix#comment78756598_45808446](https://stackoverflow.com/questions/45808446/p-invoke-and-overlapped-i-o-in-core-clr-on-unix#comment78756598_45808446)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"281fadd1-662c-35ed-9354-8a4279e863e1","date":"2017-08-26T09:03:43Z","timestamp":1503738223},{"_id":"ff3b0684-14df-301b-8d37-462f44674dc0","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"He's speaking from a language perspective. At the language level, async/await has nothing to do with OVERLAPPED or anything like that. It's just a code transformation. So, sure, you can use async/await to consume a lot of things: asynchronous I/O, CPU-bound thread pool work (Task.Run), timers (Task.Delay), combinations (Task.WhenAll), button clicks ([https://blogs.msdn.microsoft.com/lucian/2012/11/28/how-to-await-a-button-click/](https://blogs.msdn.microsoft.com/lucian/2012/11/28/how-to-await-a-button-click/)), ...\r\n\r\nSimilarly, you can achieve the \"there is no thread\" scenario with any kind of fully-asynchronous I/O. Whether it's async/await or OVERLAPPED or IAsyncResult or event-based asynchrony doesn't matter. I've written a fully asynchronous I/O model in C on an embedded system without an OS.\r\n\r\nIt's the combination of async/await with the truly-asynchronous I/O implementations that make the modern paradign so powerfully performant. All the other asynchronous code patterns are much more difficult to maintain than async/await.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"66589d6e-3555-37d0-8097-af3823ded819","date":"2017-08-28T14:16:50Z","timestamp":1503929810},{"_id":"02dcf8c5-c964-358c-9213-0d54e927c1fa","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I describe await semantics here: [https://blog.stephencleary.com/2012/02/async-and-await.html](https://blog.stephencleary.com/2012/02/async-and-await.html)\r\n\r\nYou are correct in that Console and Win32 service apps (by default) will resume on the thread pool. There is no SynchronizationContext in this case.\r\n\r\nRegarding deadlocks, the common sync-over-async deadlock will not occur ( [http://blog.stephencleary.com/2012/07/dont-block-on-async-code.html](http://blog.stephencleary.com/2012/07/dont-block-on-async-code.html) ), but there are other deadlocks that can happen: [https://blog.stephencleary.com/2012/12/dont-block-in-asynchronous-code.html](https://blog.stephencleary.com/2012/12/dont-block-in-asynchronous-code.html)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"c92fa5e8-d3be-3f04-93fc-1587b8dafb20","date":"2017-10-04T15:51:00Z","timestamp":1507132260},{"_id":"51bf0412-2e1c-3676-a17b-1a28b04adf70","authorName":"Dave Parsons","authorEmailEncrypted":"Nl1qlwc6HEKWGKJBWybsRgxyRG072RtXsYGXI677Nzwn3jKZOod58H047+TKYS3bSODQVzv7/ilmWa9E7mZRKWO+pXoYDYGfxVElS0cz+vOSzOZPq1AEeR/QIjfBoGwuY9Nt+mM4M3KjPbYCD5/gRIQZzhFRp4XZvna1eU+sCK2loFGpb1LoVtwRaxAwV2a9p8G48HjPaFmHEuQPSW6UZo/PCdg3ay1kXpHQVlyQTDb8A/ec9PNkgWtmxqxcaQSOj/ZxzdM7X56L0QeNLn44V03r68fPwvelJ9MleWZHOvOYp3nOkpAJdCz/f9Maz24vHf/cS6K5aT4wch+hkFc4uPdws5N3qVe7A3kGZAftX3NiJOX5cjCOIidLDPbxQKwt7agUQcyWFF6xVq45WOXEOUEaT+6oZe8CT2uVl4vdnLNfDhAxQe0iRWAV6ZqHQygwg8jEAgwnLvmSFcgWz7IdnLl2EUFMG6mcoaLLsvaamEDhd7aY6tCcHLnKUwSYEDzMKIfTJLvlea2hcbwdNksgRgBBD7UUGDIxDTP/Dph27YXlj94UM4b+TYs9vmRMMa1NMoRc6XvxYuAj/5xINsJm9/EIY+3052NeLYcG+YY0cdaBts33i+ccLXid2nW94vL+Xt79AKz5mRP9sjr0ckGrfUjMnOLDaZ0lMOJfY33rcgQ=","authorEmailMD5":"82df17885fa751600eac9fa114cae9e8","authorUri":"","authorUserId":"disqus:disqus_SjnQZZNqZA","authorFallbackAvatar":"","message":"Dear Mr. Cleary,  \r\nwhen I rears your series of articles or your book,, I am reading the words of a both a consummate professional and a man of God. As a fellow Christian, I say thank you sir.. .Please keep on fighting the good fight of faith while continuing to contribute to the rewarding world of .NET Development. And by the way, unless I am misunderstanding a slight movement in technical documentation, there seems to be a slight trend towards message passing architectures and even the use of the Message Passing Interface as a standard in a managed code. .","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"74e51b75-7b88-3391-a65d-025f569f62e6","date":"2017-11-07T02:22:32Z","timestamp":1510021352},{"_id":"6d18f128-2d15-3264-bc46-948e435c1340","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Thanks for the kind words!\r\n\r\nMessage passing architectures are definitely becoming more common, I assume as a natural outgrowth of cloud computing. I haven't seen MPI in managed code (or really at all for many years); that would be an interesting combination.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"51bf0412-2e1c-3676-a17b-1a28b04adf70","date":"2017-11-07T21:14:26Z","timestamp":1510089266},{"_id":"8736a9c1-67d4-3c05-9f05-103caf95f5fa","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I believe ASP.NET's design (in particular, ASP.NET Core's implementation) is better suited to scalable web apps. One major benefit that Node has is that it *forces* developers to use asynchrony (it has to, since it only has one thread). ASP.NET only *allows* developers to use asynchrony, and a lot of devs just don't take advantage of it (or can't, if some third-party library doesn't support asynchrony).\r\n\r\nIn the Node world, if you have a multicore CPU, one common option is to run multiple node webserver instances, and tie them together with a load balancer like nginx (all on the same box). While this works, I think it's more complex to get right than the out-of-the-box parallelism (with asynchrony) that ASP.NET provides.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"dd8249c7-5dd0-3542-a3bb-30c26e02ab14","date":"2017-12-26T18:20:41Z","timestamp":1514312441},{"_id":"dd8249c7-5dd0-3542-a3bb-30c26e02ab14","authorName":"Zubin Rakesh Joshi","authorEmailEncrypted":"Uzbkv9epbvg0Kjun7KJnI5aUSBXVnaFvAgsDY7JcPvZLYk6kO63Uwj1fWGZlNlkczyMxS9eqlo5aLAnJa+H88+NhZg7L+2KhY/A6SghXNY0rru8R6QAc0Z4+d4CI+xbdsOP6s44OVTn0L6vCf5O8Mfx7vdh+AjHnNukvQEVuhP4g7LXnOVae7K9C1FKf1FA8QgCg+lLLbGvUpJWIxRYzouc0MX0xdS55b+d6k88zgkLoAGuLVVEwhCArl26LTsJG5yqOSOUx9ZxsgYwBw1POXMqOFB3Mpfg94Z6pSsStAYCIhjY9UzWflf5jt4neMWlK3WIbtkZoHxIh86IhVpM2DcGF806nPqH57fA5wgH2dAccFBBru01wAcLpLhiaCYY2W6t8qrsUTP1BRbesF9GnTH3QMODpayR/05BX+HL1QSXIa89Y9MaA0jfeeTRffAa071LTTgQR1/nZdTm3DS9oURZFfkKunk/DiYRCbgKjdPXG/islg4NdybYAPB0L95tPRuE6TI6Acr9IwX3JvI6K7N2luhZeXaMa6grYMV3ecmC2oQS0h+HSi68KtDvvjSvtfidNrKZzKX4XRaysMfkgHUUUZMm+OLHRbYb6OC0rn7no+9OM/Z5F86jz++j8qI/kTjjSTvhHlmCwtIw5ZBWp+Q5BRfoVt0NYY7JGrHnr2OE=","authorEmailMD5":"f9305ce7b205cf5211f1b6a4aaf34c9c","authorUri":"","authorUserId":"disqus:zubinrakeshjoshi","authorFallbackAvatar":"https://disqus.com/api/users/avatars/zubinrakeshjoshi.jpg","message":"Great article. Have been searching for the concept.. thank you !!   \r\none question - I find article of having node js getting much benefit writing IO bound tasks with one thread and non blocking IO. I believe [asp.net](http://asp.net) with async/await features uses the asnc programming with multi threads is more beneficial . since it uses multiple thread it might be using multi core easily.. pls correct me !!","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2017-12-26T17:13:37Z","timestamp":1514308417},{"_id":"5645380b-1849-3ce7-8b78-22d3788932ba","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"As far as thread usage goes, both Begin/End and Async are asynchronous. The major disadvantage of Begin/End is that it makes your code much less maintainable.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"57f6a077-4ce0-3b46-ac53-4a9f96499297","date":"2017-12-28T12:54:21Z","timestamp":1514465661},{"_id":"57f6a077-4ce0-3b46-ac53-4a9f96499297","authorName":"Pradeep","authorEmailEncrypted":"ltvDGLzLl48j8WMlJtCm0FShKTqZhfQhKvs45JnstLb8teiOEl0qZgU+L13HUhlqb5lq2vi64bZxL/8cS1es2AmG6J1femHWd7H733CFHkWDOg1wLYUo7pB7FZlLx6PcaiV0vi4Q5T/QIIISi6jm4aS+plHBFdUp9dHZ14Utl/Pab1KmWNSjBD7EyRwnVw4du/cfi32r5t2DiH9ECNvNoaXVqHi/WTib74eFX5Gpt/nUqz6+D/QtF3YTeEXLPX5Dn6buGEZS6FmS74AjX5DEQCvbY8nFYQwFF41DizTu1llWUinVmiq8L+sV++Pf80B/cR+P0ifKv/NMVCJARslpn6td/oHlwcB87OvrA2LzeeCMIqRN24vtwMXnlIm/DUG/9c7XUkACYdrHHWkjpFj10Bj/YaJfRg2P93ebn8osns+t+c4ZSC9tfQt7CiGFuha2o/zQVkQY6kzdu7+gVzzzt7eLWLaJjKFg1eugqbwQ0hKeXBrCwGBYmT5o2v6tHTXM0wDH6zSYmXW08xs0EmOrF8T9jv6v0jitUKse9zS+n92xeQJDX9EyHkW8CEx6lBYiMKriPwD8Gd8N85mPmuO4Kg5G6FFgyqt8tDpZvfDtvX5BT8zC0m1gI7IGcalIZyZ2Wth0yyO+HJZoZommTnS8i4vAYSCm8zG3UkPqIL36qys=","authorEmailMD5":"c9fff93b0975f41010ae13dcb1a948f3","authorUri":"","authorUserId":"disqus:disqus_j9TS7gArn0","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_j9TS7gArn0.jpg","message":"That made sense. Imagining it that way, it seems not using IOCP or async operations is rather a brutal waste of the I/O thread(s) which are already allocated to an AppDomain.\r\n\r\nOne small doubt. I understand all this discussion applies to XyzAsync() calls. Is the same also true for the BeginXyz() calls? I mean, I'm still with VS2008 (.Net 3.5), so does using the BeginXyz() methods also provide the exact same benefits as using the later XyzAsync() counterparts? If there are any specific drawbacks to the old methods, I'd love to read about those if you can point me to a link. Many thanks.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"5e64b4f3-00f2-31ec-ac78-14adcc352b51","date":"2017-12-28T11:51:35Z","timestamp":1514461895},{"_id":"07c0d627-54b2-30f6-a7b3-3c1794aeda61","authorName":"pwee167","authorEmailEncrypted":"TS62CPynP0YnQGnCwYU9RmDg6WJXkQS1wnnV3/bhTB6lUn4cfDia3at11Z8Q523PeBtzPpN8yWZLTS3hiFh+HocSxGMIgD0/lgPxr/5iX5lItNb0bjIYoAB/ZLQ4JPdz9j27i1KQn73PZEo83LnkUcbOzDl+7v1fEq+ZhGD3uAxOAjtpYKdXIW5NAnOpgDpHQfawQRb/hUOqvJ9H0Is/JgFQwOPgrJ6u3NLvmLhVmSNTK5Rzo1B7utKP4/aw4+Kn9idwAlvBCkM6GzwGBahlhA9MZ4UNB8Jt17LP/w/R7eAwAXKngUh1rON6ldRk5rGq8rb4DS2faT586lgIgsY4DqtyaShVKrm22JFhzFFDJGDGJJYOlj4ICjA7NpBFSDOtn1MYVSd+kl66wtE0CNhbNPqZpKQp9PtPa425yj8V2fqEZwxbrUmVmx5TCoitD7Pi50qZ42qo7XIO9N1G0yJEsU75NL3FcrL8uRmQvkPqi+YQETLFB0A2piAMVVVkSnbJTpK7TrGA8D8Zg1Qw0DUzRek8Pp6jugu48YXqb8yNfcYtWb3A7fkyC/hI8jrqUlZksCWRShxJTe7RohR2nrDVgP4fYiDH7x9xqvpVsZaVZO3abSkeLcWDNgo00m3EDrqUfYpN89hIQrYc5ZPyc1riHPR/kCuCLMdYg6LmvOX6DbM=","authorEmailMD5":"1d071a2559b38acd23991885bfecda38","authorUri":"","authorUserId":"disqus:pwee167","authorFallbackAvatar":"https://disqus.com/api/users/avatars/pwee167.jpg","message":"@StephenCleary Where is the state of the state machine in an async method stored before it is resumed? I imagine this is important to know where to continue the execution and also to capture any previous variables.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2018-01-25T23:44:15Z","timestamp":1516923855},{"_id":"aa0a4b72-d3d8-3c9e-b468-9f3e8b599920","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The compiler creates a struct that holds the state and local variables. If an await needs to yield (i.e., return to its caller), that struct is boxed and lives on the heap.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"07c0d627-54b2-30f6-a7b3-3c1794aeda61","date":"2018-01-26T15:30:44Z","timestamp":1516980644},{"_id":"9432b305-cdc0-3ee7-8f70-95419d5b9476","authorName":"pwee167","authorEmailEncrypted":"h4Ps8nU1cG9V4pcNGK+dNQG5Wwxkv/LtOUkcM/rA5Ue03OKamOaGI1rb2x/1H+T9sqAMVG4h1KgoT6vac4ezngpeWJTGqYcIA65xWjK2uCC7p3zdbniHpZeX3w5TJlJOEUtRruxlDkuNDrM74zUUStsAYcMVLfN4Th0/cU7FYaBnKhdssrKjZ5Fiy9d7ykalniDxQE3U7G1nqcacu5j84KBLLs2H0cJn9LNfnTd4x3l7fL3V38cFeZ6cHSeyBHqEqHS8M/uYJgrE8ZsoPGD73ibO8VggBhXDegSkgOD5mabTz7mi7x+j7vgc1n9gYSJwAH4z058FBIuA+jxizNEs2McqKUAlc5G0NULJvjQxR9ntjX/tk50CapLpMmopkpwZYFLZvCPiFfxCUDQDPLR5kM0jPwPr3EnIaDbfb3CcnL5E3rT9wwOyuIcitdW6kVR4sFXeCsDiEaw3JKTgtbYrixCMStkK4XmVCA2sxJpNo9EHbKg/Vc4mXFXgfa8hzGaUwAzDcb0lKDdw2mvmTPhVlKOva0lR5DAYrFic13J/XXZGTrOTwU2SuPnIYHPDHhxkXsqBED4M/QNk6UeqF0PiL1FyPcB/nSYU7GaPL6W8yKzD/BYZnAzBlo+69TDqF6sAZToqj02FUyySs3kW46Kw2jEp4+RgwgLKq+B9nO5DnAg=","authorEmailMD5":"1d071a2559b38acd23991885bfecda38","authorUri":"","authorUserId":"disqus:pwee167","authorFallbackAvatar":"https://disqus.com/api/users/avatars/pwee167.jpg","message":"@stephen_cleary:disqus - Awesome. This raises more questions for me...hehe\r\n\r\nOnce the work is done by the device (e.g. harddisk), my (novice) understanding is there is a task or some sort of request queued up against the threadpool. A threadpool thread then picks this up to continue execution of the next part of the original function (i.e. past the await).\r\n\r\nHow does this threadpool thread attain the reference to the struct you mention to resume the state machine and continue execution? Is the call back information/struct address passed all the way to the device driver and it keeps this information for later when queueing up for the continuation?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"aa0a4b72-d3d8-3c9e-b468-9f3e8b599920","date":"2018-01-27T12:18:32Z","timestamp":1517055512},{"_id":"889e71e5-f786-3c7b-8328-390733e5e63f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"If you want to dive that deep, then think of it in terms of callbacks. The task callback (a.k.a. continuation) contains a reference to the state machine struct.\r\n\r\nAt each level, only the state at that level is referenced. The IRP contains the callbacks in the driver stack, OVERLAPPED contains the callback in the (unmanaged) user-mode process (processed via I/O Completion Ports), and Task contains the callback(s) in managed code. Only this last callback references the state machine struct; the others reference their own similar structures.\r\n\r\nSo, when an asynchronous I/O operation is in flight, there's no call stack in memory. Instead, there's a series of callbacks that all refer to each other, from the lowest level device driver up to your own managed code.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"9432b305-cdc0-3ee7-8f70-95419d5b9476","date":"2018-01-28T02:46:37Z","timestamp":1517107597},{"_id":"50443b21-769f-3b9e-99f3-b4cbfd9d449a","authorName":"Flow Bandit","authorEmailEncrypted":"ZurvT/mBW1bVoyNH3moZGghdM8FJCS7ToNE6ddkixH/Grasp7NAIte+3sdFdTf6jjSTpMqtm/ZZDh7Yt0jpF5anBzoQycg89Z7mF1k9EOfBu0oYD4BFNTr1KeU3ElOpib+IQU5cYKZcw/m7a+VN+WZj3hewjuQXaS9LgL+E8Gby03V48CdKUvd5Kj5Wot6edK84k+ZiOc7YxGaiBmspzqp7rtOiMYnQaKl6pTvCp3w1yvEWxqROD5/HfcAhKvSi7Qs5RBKSNZIVVf4jRIE9rOOV02R8awzND5JSdIE0mGCZhcXU9uNryVPdWdtwmTIqMVNc/ZNxz7V9xRSSFj93AHtziVhL6Vplh995a09CKSbco24c82mZ6RyyqyB+NHOCt3KRiFJusT2Z1wTa/peFcbzkNzfTeRp7kQI2X7d6q5zg7I5dSObnTE34Wk55AQ51At7QnaI1ekmTlKch1PGXDKIHklAzB6SQfZGpudUukyx07mM/PAdrrdJYVji79s3KhLMAFBDhsJWOizLjQz5U4okalVcSTE4HHb7q+7vC+FJinGVGGGuVGA6vVxG0uDmwMBclOQc5edS8d+CHTTJqpC3cubFjGTW73U4mIfDcqzk/GYXNgEi+CAPmXXgGijXECYRIqORVK8Z5RJnJMt7TeqLkMZTYydrSmPcCtSbHWrgQ=","authorEmailMD5":"ab366570c646860ad1011a4c0868c000","authorUri":"","authorUserId":"disqus:flowbandit","authorFallbackAvatar":"","message":"Thanks, This answered so many questuons I’ve had.\r\n\r\nOne of the only qyestuon I have left is.\r\n\r\nWhat would be quicker on a single core environment, asumming the burden of the task was network bound:\r\n\r\nRunning synchronous for a network bound operation, the thread should be blocked, but the cpu doesn’t not wait during the sleep it periodically checks of it has return correct?\r\n\r\nOr running async and having a hardware interupt signal back","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2018-01-30T23:58:11Z","timestamp":1517356691},{"_id":"4924d195-1e4f-3693-8924-a5ea735dbbef","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"As a general rule, blocking code is faster, but asynchronous code is more scalable. This is true regardless of the number of cores.\r\n\r\nWhen synchronously blocking, the thread is in a suspended state and not scheduled onto a CPU. Once the hardware interrupts, it completes the (asynchronous) I/O, which then moves the thread to a ready state, so it will then be scheduled.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"50443b21-769f-3b9e-99f3-b4cbfd9d449a","date":"2018-01-31T00:34:59Z","timestamp":1517358899},{"_id":"38b7b886-2a53-3900-bd7b-6a2588f633b6","authorName":"Grant Hoffman","authorEmailEncrypted":"sbrWum9TMzeiSz28aAHj0w8fWfdpU9GgR50Gjn3akstJ7QnwAkU9wv8KpO6ogqpjZ64tm0GNgVTWSuoW8WEm0TvXz8ddUncX8ho7c3viEzcN7W9qydkKJWdzWYxd7povbWNarpFNYT+8YAM+n3eJCpeiD1/Osc30tE4p92RgTx4U+MgB63/cI6wdCWfPx1tbLF0Ev0J/zm6t5gmq4qa4DgTMjtpT1SoXFm8qTgQ0AxOy1E3i25asCnSdzspNl2pOx8gaBdvxgsJSlg2oatjvG+gWbl3AeLv4ljaFR5JtT3cRWDyFx+6NLBX0s9ax47071LzF8Cm9zNz/uHjxWb0+sEUwjcanVpkRkHfU31sXZnvWE1xUV4JG7HONzYSIwMx8qjPkOvCjJw66YR/rTGkwGwCGhf12k6FFuWXB0Pldlj4F1fpzMx/qE4IMuKQ4yN/WtuVX3NyXBHekTRsT4U2ebA6snxExmLPU2Q3gMbiOcQTJgdxSIBYrN1eXVIiNKFO0rxFeqOG6Wpw/MW9iWXEou1S9cmEVNMTGbrpYqNef8Bva/DaFUjYTyM8t9lZI1TdQqIAT6P7h2xnlFM6LfBYCSVsXPOHyT1+tWrcM/DBfx6YGCcR0H4ALRnSPK4Rvu0SmHS18xKi5yfd1WOOekwvo1363yyggY3gk3QQ59Q6KF1M=","authorEmailMD5":"f55500eeac346a343ab1aebe3d734201","authorUri":"","authorUserId":"disqus:disqus_mKJKzNfDWl","authorFallbackAvatar":"","message":"Good job on the article, I'm just left with one question. I get that when operating ASYNC you do not block a thread, but don't you still need an additional thread for at least for a quantum. Say I'm operating on a thread which manages the UI. Then, I create an async task to do some background work. The thread then does a context switch to do the background work, What happens to the UI at this point, am I blocked until we do an I/O operation? Or is that task picked up by another thread in the thread pool?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2018-02-07T17:11:02Z","timestamp":1518023462},{"_id":"2f309c8f-c1b5-364a-862c-980332c3d6a7","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I think the disconnect is here: \"I create an async task to do some background work.\"\r\n\r\nTasks that do background work (e.g., Task.Run) are not asynchronous. The UI can consume them asynchronously (just like truly asynchronous tasks), but they represent synchronous work to be done on a thread pool thread.\r\n\r\nRegarding thread switching, there's nothing special going on. Threads and CPU scheduling are handled at the OS level by the preemptive scheduler just like always.\r\n\r\nThe key behind truly asynchronous methods is that there is no \"work\" to do. Thus, no need for a thread. If you, e.g., asynchronously read from a socket, then there is no thread that has to periodically say \"is there data yet?\" Instead, the task acts like an event callback; the networking layer will tell *your* app when there's data.\r\n\r\nSo there's actually no switch away from the UI thread at all; the UI starts reading from the socket and then awaits (returning to its event loop). When the data is read, the networking layer calls back into your app, (eventually) posting a message to your UI thread, which then resumes executing that async method as a result of that message.\r\n\r\n(the details are a bit more complex - there are some threadpool threads used for extremely brief periods during the \"notification\" phase - but this is the general gist)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"38b7b886-2a53-3900-bd7b-6a2588f633b6","date":"2018-02-08T18:47:40Z","timestamp":1518115660},{"_id":"f73cd44c-c2b6-3ad9-98f0-e160a38b127c","authorName":"NetMage","authorEmailEncrypted":"mrA5o9dju4/tjGYcgiy3iAgBe8H/XhVIYP9yhSiRy+dWBo+xFTwKglCl6qzaQosjMBCIQG0pRUebc7Bt3FdjbH86/prRCM3D4MwqpFQkX+Ii7Ro02RCuV3I2ZythrCGm+bwbX9mU1nGsCpNzQ08SdyqtFlOh6tYRT2Ay1Hc67vJbSg59f+xHStlXculUPaHLt5GX+J4xWSyf5t/jpXmQgvY1r3kfYVQhUGQJFn/n57It99vrDjoJdlrR6dWKqcvGWn7V1M79NxCdl1utkAFVB6a7mkwyoYsyyAi7zqagvhl7MD5s8LYk6l1HM0JYIlm4N+sjVZNAwSUE40/g2cNgdVYLeVmo0wC2VMtFY6EUVIapSmQHCnJzSo3x+l9e3UgbmzSQ6YQVX8lpY+MX/ytByUGyA/WvwnJGjAhVtVulCLg4NE2Ex3B0J1lve9FJeKvjRBph93G5Bif0rL+S+9wIddHxb5UMqGKI02FIt4pgY9ry9U76MlVwNQkydKtvbi1gh5f/650au3qxlfS8efzb2bCHmTubJHkjzMZxMF1Qrj0KhttOt0wbYUyTzypcOWcAfNDXi2KE5D001jwdW9PTkYVixG0/xvt9xTr9y7C0s/v0oVqD1kHf4gYqfxnxg5mpg6KmsUAevY5SQyMJTKlhYTXDVxBsgOszGKxlQOYLiQM=","authorEmailMD5":"f3cc7fed3c952511b85cfb1c822ecb75","authorUri":"","authorUserId":"disqus:NetMage","authorFallbackAvatar":"","message":"Now that kernel memory is no longer mapped into every process, I wonder how this changes?","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"d059f9c3-04f8-3224-8b49-5289000e88ac","date":"2018-04-17T19:17:43Z","timestamp":1523992663},{"_id":"eb69372b-9186-3195-be40-68e194c091c6","authorName":"Agshin Nabiyev","authorEmailEncrypted":"CrWtQcitJ6iDBqVe0bdeNWipdAreGoWx7q3bLWD9ZUthNx7w2+8TPYIR/YIWhSX6JvODLm9kDLfpX3Er1jnnmM5aBHglwJ/8S7O8KcN7zM2h56Dz1EOU2+8BNK8wF8K1YJumJIjBzdf2Ky0HeA3cMtPs26HY/bl+DcZ0gMNYWMpx7oa6ebp8QCf3zzlF8GgY8jCt2yK1HaHsdPcwbDfR13k4JT4RD/O7EHBwjmKzqr7K8YnEYD0S66LnzFcF3Nd0NCXgyPyn5X6v9dEbEXAoPebUEzpu4nRTBs6rwSmWHVK58ahDvBaVv1geP2ZASbbE0w6OIsd6ocYjCYejhAyat/o6dFtPPhhPq0m2Om6hf0bZriXAiJsZsaQ+nyIImtxsbbQdVLr4HaXdcMBQBqiSYAaDWWqnfDsby2wj0tTVZx2qKEnwJZRkEHK9KzjiRHZTKLTc8iT8TKucpbq4SFzw80gqM04ISX0+Q2UNE9ebOku+tY4v+4k6yrzoNwhWG/isuda+5hljLPv/TaZADEpIcq9f4w0OiaLxP11cdvSKyA5XL/MwVv7i6Kqh9fiycoNWmu9nyirG+FfLwGJ3M8fWPL78IRsizwg1ip5uE+JSEc7S5wJ82selbeGdP/0NnjGkmz22PN1cjxIvfVWY/Z8EozeV/G6DBM2JF9jF1NCc2Yg=","authorEmailMD5":"92efde5d548b57c5f5ce697f25f88913","authorUri":"","authorUserId":"disqus:agshinnabiyev","authorFallbackAvatar":"https://disqus.com/api/users/avatars/agshinnabiyev.jpg","message":"Great article! I'v tried for month to find exact explanation.Here it is.Thank you!","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2018-04-30T13:21:47Z","timestamp":1525094507},{"_id":"178e2d80-9ad7-11e8-82d8-69ed00e8bcf5","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Amir","authorUri":"","message":"Hi Stephen, Great Blog!!\r\n\r\nAfter reading your tour of tasks section and this post, then I get to the following conclusions:\r\n\r\n1. Delegate tasks must run on some kind of Thread-pool thread since you must use a thread to run CPU bound code.\r\n2. Promise tasks are actually the real async operations. They use a Task an a \"interface\" wrapper but no thread is allocated since there is no use for one.\r\n\r\nAm I correct here? \r\n\r\nTasks are complex and I couldn't find an in-depth blog (yours is the closest). Most of the blogs focus on the async state machine. Can you also recommend a source for a behind the scenes on Tasks? I'm currently reading the source code using ILSpy and reading your blog, but I would like to go deeper.","date":"2018-08-08T06:48:44.263Z"},{"_id":"16f24680-a339-11e8-be2c-8d65cf80d10f","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"178e2d80-9ad7-11e8-82d8-69ed00e8bcf5","authorEmailEncrypted":"gUYDP2iNePxFBrUJ2Cp7kZ2Ck8D+/PhVyoADoHDe7/Ggdo/uyos3GSxT+N79xA4AfP12Sn7vPIRRsVv4RvAjEQRjCyFz5nLjx7loBYheXdE2FXIu42mNDLKrQYRLlGIwjjbHGq+nUs3KOuD+x6tfCmsO40lpyu1VmfzmVqOVA0nnPuAHHGTNdHxqlIeLuVd3tzlUhp3j9NSL2sKPKxLhz6fpDs5kH20D//tKojh7QMzDdlqa3alQYtzIPqN3t5WuFsAp/2rqxmTvktgpUTM81MpHXILrRgHEnEuaJ7KuhJe4VzFCRYl+PkIsMezSA62NRbd04kpYAWN624ART6+XBto68juzC5UMl4qWBl6ImH1TeRLPzCNlCNeOnPtTo66VAqfL7ncJfUt5VmQTUZ4lfDUEFFpPK54n5ULKZXrwvLli9WgMX/+wC4i9KZwaT72cZkZo6vZQd0wC5aiQGdeIu1Ni77OkAgRollgNUSbcfz+qqkrFrT1ca1LsySYXeDMFt5smr42XKrWEV0FWPSt+y735lhE/EImy5+SsXFYxzC1WSOSPpGmfKvrr5VK75veABEYcyBlU0AU5qpo5Tc+WoFjdp2K19fltRMq8M8Bx9jSBbHdc3sbYK3pv1+qKOS2r46kztvqo7SJ6DUAoWpZbXEuP29nnzXlc8elXWWip6mQ=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Yes, that is correct. As far as \"in-depth\" sources, there aren't many. I'd recommend anything written by Stephen Toub. He has some great talks from //Build, MSDN articles, and some blog posts on the Parallel Team blog.","date":"2018-08-18T22:50:23.310Z"},{"_id":"8fdddd30-d1c3-11e8-94ce-b56b73f5fd7f","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"gcmtIkmlbLU0gjPo3kUU8tEG6hHYdKpdlxZ4tuvclHfzpMIk2P37GNOXgf5x3QboJoOuvrjLRwXnxK+64RB4DaogtuL4+gzOBqDkeB8BiFsglcdZG8YMK6x7JZCxcQXabtXOwjDGIZ32TZJq5WjcVXzEgKQ3MrLzPnDiLiiFM2Tpvtd8iZBLP/tyT9xiISM4gfLNdxsJYRXJTPmtI6tMCT2Bfe/AF1dELEQOmylIZ4R1hZunUK8gIzeZxqbCOm2uDP5/+wjz6oAmMR5nQZHGwVeEpPPDdo7iFkncNGPwPOjDHeUHt9agKBEt/x2zgAVgo/eV5b8Ep4Wa4UlpRfX33Zp1PmgtMmv35np3U8BfNoBT2K5o4cA0N/wXVujuInfFpDSvDrQzv+zql3KTL8rNgkOKlAGB6rxWxSbp5uTBgp84ACM51keqhOS1YEVRixznr52VLXGe+3bMPrPcrx426cGY5R4WUcyIurk2WuEF5p0U4WW7Q3sM/BSgKnxc7rxUldXbh86N5EqB0N2Grf2dyFvzoQLEF06JTXylNbSmsdpKNXlFlMPmRR188SUTeQ9xtxn3kAjkPJRkJA1rcC31SnTt2ChfusnmiMC3fgfob/un+DUFNjfLfllihMqDkin9SjHf7YWrqAS2fGUAblMumPSLk10OfEpC4ljXifC+hKA=","authorEmailMD5":"fbd0de6ca98b9ab6d316ee57c4239058","authorName":"Mark","authorUri":"","message":"Could you help me understand the limitations of the \"There is No Thread\" scenario with regards to this this Microsoft support article (https://support.microsoft.com/en-us/help/156932/asynchronous-disk-i-o-appears-as-synchronous-on-windows), which says:\r\n\r\n\"On Windows NT, any write operation to a file that extends its length will be synchronous.\"\r\n\r\nas well as:\r\n\r\n\"The memory manager in Windows NT does not provide an asynchronous page fault mechanism to manage the file mappings used by the cache manager...so if you issue an asynchronous cached read, and the pages are not in memory, the file system driver assumes that you do not want your thread blocked and the request will be handled by a limited pool of worker threads...Because the pool of worker threads is limited...If you issue a lot of I/O operations for data that is not in the cache, the cache manager and memory manager become saturated and your requests are made synchronous.\"\r\n\r\nIn the first quote, it sounds like that the user thread will block until the write operation completes, and in the second quote it sounds like either some kernel thread or the user thread will be blocked waiting for the page fault to complete, depending on load.\r\n\r\nSince, in my own work, it would seem to be harmful to performance to use FILE_FLAG_NO_BUFFERING for reads, and pretty much all of my writes are appending to the end of a file (and even though I may know what the final length of the file may be, I can't use SetFileValidData() because my application does not run with admin privileges), does this mean that I would derive no benefit from using async IO? At least, no benefit that I couldn't achieve with just Task.Run() on a sync IO API call?","date":"2018-10-17T04:17:30.237Z"},{"_id":"a499b8e0-d7cf-11e8-a9f1-05b1ca7b5c0d","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"8fdddd30-d1c3-11e8-94ce-b56b73f5fd7f","authorEmailEncrypted":"pBGBxwXK0GyQQ+5F+9LgSpUqvDe3Zpbi7Qvt1tiZqTOPrJNpquzBZ+NzXzZQnFvhrSVYYElot8QqM6wYRIDMWW0kM1J2I1+FiopUTY56Fw33DZTwLutCeOYFRoutBqZF9tjMsaHeQqMTeFHjS+8b6ulf4iHtw8z+4eaiUjWrgfUWsamRZNjkP4qui+JMqwn48w/D6iw+p2fokbQGSk+89DUTLHcmFkKvEPVR2rxsyZQYGpQi/Gu4HhAzIvH8Rgl3mEzufv8XgiOY0eV7x7s3B5LoG5bRrzLc6dUma6bpFAnSMv1utPgRJd+CPSlgcVmpAU2qPfGR++yol4HoSS6xjC4XCssx9xAYxM7B6OrOnkvZDeFSfJjliKpuCPpegbFKDVO/Mw4JtkLuGG/TtgJMtUiN+FjbEYJlyvH0eetiZEooBtKsy87WbQSPDNImb7qVvo2lQK1B1czg4BJspSkQDxuVvCjveZq4dmX3xhlCOzRBkHwQzsffJ8fvpvggb5Sk7dCAXy06PpbOWS47aRF/90NOvaaSit+yU8L75YiNaH1ULcgNprCxwpY/giBrR3b+JjGX2/NRBA2zrA7XqqTrMC5BzWVNFHUYK2AFMnEIrDISOPqHXg4Rst3RlB1vCLLCixXAmj6bhHw89+5GazjlZ0nmbLfEEmLcMVp94ywn6fw=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"There are some limitations on Windows async file I/O. However, these limitations may be removed in future kernel versions. For this reason, I tend to write all my I/O as asynchronous; if I'm appending to a file and the OS makes it synchronous, it's possible for a future OS update to make it asynchronous. If I write my I/O as synchronous, then I can't benefit from future OS improvements around asynchrony without changing my code.\r\n\r\nHowever, I would recommend running performance tests with both async and sync file I/O running in your particular scenario. Last time I checked, there were some performance concerns with using BCL async file I/O heavily.","date":"2018-10-24T20:59:05.966Z"},{"_id":"703cdab0-dc79-11e8-ae79-43654a0a22ec","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"N0RzPjrEiJkMLle6Qx4VVLyGqGH7EkDlD4zX+mEKVWI7kXCGUZcQ/XAi6QxnnE3VP9RabC/tL1G+x03bHvrhKaCOTRdqvMp04YGI316BtBAao0JPQsI1SxiWt5oCy0SprtjwfVTqp8rco9qsYVVfmKAZ5XN/In6UZB1E8L8i8jq1vqOoARL4TN7DqhTAhXcU9XkAWmMkw81IlUeWOMqXwmsNwdiKiS6SvIiIsCVZbiNKlLMv4fH2ayLWlGK3J/fSnAs8F8RDSXA2D6CE1foRd2dPJFHD67OcN3MTr+RENry4LF7K1ODLrbOX5OnbE1qxotAmEnDba15XD+PNtyviV7vaNEHi92l91PBU3iAhCU2mDJPUY3Zy/wpW3zsXFPWkk88X2ENE9EY1eRFErKM0ByrnmgY5XWEbnaWkJ4gzklqFroe9hLDgL5YhbNnhHmdOewx7StfbWMg0F0UjuqgLcFWzCGQg8tqJuGyERijftk8aBORsl/DMz1S+3vd33xEUprtDQXo8aKY43NqHm3suchnCyROGORY7Si9+S2ZlcAqpeu2JlrJpis9b6CauJnmiizoGVmkaya6vNE7/LtsDYgk1hOPorM54q9vCgUo54TU+D2VUaE37nU7GceXfwiCRhDjFwCX47oaGDPVdZttnLzJ9wsszFC0DMKo4/ycW66Y=","authorEmailMD5":"63f3fb68fcc00284ed01066773b6c8ca","authorName":"Sean Vikoren","authorUri":"http://vikoren.com","message":"Thank you for that really great explanation!","date":"2018-10-30T19:24:37.152Z"},{"_id":"67aae750-0ab6-11e9-9bb1-17a44b157a7e","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"6e9c0a50-0a8c-11e9-9bb1-17a44b157a7e","authorEmailEncrypted":"OgI7XAiStLVUTt1mULR+weLFm1EHj8xfSbvrhP1FZTDjtfmi9IQD28MURPo8myg1YCF+GYkRgPT7afYWDAIF8BWnLLdSnG+yQ+EKrgGfbASWm7YyXZxQErir6mUjrvJ8SEbfcJ5lZVm/wKWcOjvcwK5OL5j67hHVNYqzPwhGBScs/Jun9dpXEY2+P2/eMw02JZb25PyzMUMzIpTS+hg3+/WS7aEnoLTWg4Jh9bUF2ZgHoSpWkz9Z6LXUZCWCYGliAQN95e9olQTMF9UeZcF5IQ1x+Imj0TSaBqocfT9nsQOlSTez/npZQg8KaZMfPHV1rqBlfD8xGnA6OldcUa2nCiD1zy963cg3TSRA9jpCjOrX2JVecj6l4MYfYGoHF2oSt2ROfRAYA0LdWJvgpZNsl0gQdSzxiXqOUDCl77Xtj1vTY0stxIRNBrNVY6U6e2zsJa1EsYYT9qjMPEB4YQn/iLA9AxXibcQIV2WKr/kf69Hfb2H1SRguhhZ8gM6AvIFXhLTFqfvHEzrNxnH2s7XBY4VmNkGZKAQrUC7sGw70tvZMJ6Rr/YcwdKKDJmPOPiF9XlJjezJspAqKEUC9jogbJ6iDbKmDC62FTrx2VdpPrG+PeyvYULGqcnQ67aCc6Z+uHgKSPk1HqQDJfbrJMJM+18ysQfmKst1AKXwz8aFlfLk=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"It's possible (in theory) in any language, but it really varies in complexity. JavaScript makes it easy, and C# / Python / F# / VB slightly harder. I've used this kind of programming with both C and C++, where it is much more complex. I believe Java would fall into the more complex category as well, but I have no direct experience there.","date":"2018-12-28T15:36:55.731Z"},{"_id":"6e9c0a50-0a8c-11e9-9bb1-17a44b157a7e","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Pravin","authorUri":"","message":"Thanks for the article. I googled to know exactly this!\r\n\r\nDo you know if the same behavior is possible in Java (or other non .net languages) as well?","date":"2018-12-28T10:36:28.378Z"},{"_id":"0bd991e0-1b5c-11e9-ba78-3d3ffff9172b","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"a7563b80-1b54-11e9-ba78-3d3ffff9172b","authorEmailEncrypted":"k58XSbKR2ESt6V5hm+pVNO3iyuCrk0sWmNCgQUIexGC5IEsVe3RdEK7HZgDBNkm65Zn6AmsG4wOeSCqnA4lk2rQHy3B3fWY7C4mk9ALPWRlnJFkuIPCVl/Qh6+E00KgtkrkfMp7pVDpluZ2BcE+NK4mr84wL582xJcnwz3b/pf4JXEtd/8XTJFTf0zQN0eLxTHN1tSDvn/KcNFtURdYfdIyCNIkL44eEoMjoTNTkU+7zEdbh6YSnMEXsvL/oYB3YjrSfX1LF94av40kq65TGeuO6yn5SxvtmKQEz1z0UYXW2Pvfwv/ZbSQhdvtF4cZ9ZzS8peyP75a2rFfVq0oKcOISIW3RS8xp3UwZxFWY/kMGo1G+5GAgLoEaxPaIgVKZteymy58aDrIWy/VjfIpARnI/41ftMR1viYVATmXGDZBQXAnslmpW9sb6bSp8BQfUA52EkyFzzJ7bY3yRfHrvbyY2V4RaNUQHF9e6hxrC3+TrbOm6IhZdmfpMiLcHI0pxQWWuOurpP1p/GuvnDkm2mrpiQTOHSjd7QkQCz2pW9PWoqc4TmRVGoO+f9BKShI0XlVz2xQIAGcmaxSTqOQG7gonINAM0LjVesDzo2l6SzVbZ83s1SQsFMYAdJgXPhcQqOl2REo47i3B+Jwi8FGPtIGTqTQ7zuK696MjtHJj1rmuo=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Hi Mike,\r\n\r\nThanks for your comments. They illustrate why it is difficult for me to explain what I mean when I say \"asynchronous\". In particular, I wrote this blog post specifically to go into detail (on one specific platform) explaining how it's possible to be asynchronous without threads (or processes, or whatever). This is one of the biggest questions people have after reading async intro posts [like this one of mine](https://blog.stephencleary.com/2012/02/async-and-await.html).\r\n\r\n\"Asynchronous\" (as used in the modern sense) does *not* mean \"runs on a different thread\" (or process, or whatever). The modern meaning of \"asynchronous\" is what us old-timers would refer to as \"callbacks\" - just a lot easier to use these days. It's true that asynchronous *used* to be more synonymous with \"parallelism\" or \"multithreading\", but its meaning has shifted over the last decade or so.","date":"2019-01-18T20:02:56.726Z"},{"_id":"a7563b80-1b54-11e9-ba78-3d3ffff9172b","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"http://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Mike","authorUri":"","message":"I think the author has over-complicated something that is quite simple.  I have been managing IT domains for 20+ years, and we know very well that IT loves cryptic sounding buzz words (so that people think it is all way too sophisticated).  Since ancient time faiths have also used this technique to create an environment of mystery (or even magic!) to create various beliefs.\r\n\r\nAsynchronous is a generic word used in various fields, it does not have a special meaning in Windows, nor should it.  Asynchronous simply means that two entities/things/signals/processes/threads are not in sync or are not finishing on the same clock cycle.\r\n\r\nThreads are really processes (piece of code running) with minor differences.  If you want to execute some function, but not wait for that function to finish, that function will have to execute on a different thread/process.  You can call it mama thread or papa thread or basement thread or whatever - it is a separately scheduled piece of code task-switched by CPU.\r\n\r\nUsing all mumbo-jumbo words and OS specific convoluted abbreviations does not change any of that.  Again, if you want to continue executing some code while letting some other piece of code execute also at the same time, you are using more than one process or thread (does not matter what terminology you use), and it will be task-switched at CPU level.  If you have more than one cpu (core is also just a cpu) in a symmetrical system (as is the case now-a-days) your 2 processes may execute simultaneously.","date":"2019-01-18T19:10:01.568Z"},{"_id":"62502ef0-202d-11e9-991f-271b0cc77544","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"e19c8330-1fa0-11e9-8fc2-efd230bc5aee","authorEmailEncrypted":"Kp3Uojr+9MD/Z7x2+ITmPZhbSMg+6NS5nOBIZvzUpWjIcQ1o8+CutB95X4rcUm/WftY0G/bExkyZoTh5+p2sV9yBMPiDZKNGLZzQKtj2oxKObomBVG9obbew+rM4ROFcLPS5v9Ra3Jf7mQbcfHYypGVkLbLrIUmxWH5BjIo3Ub6FfRxxzj+dJCd0kAdevoQyFDXI64CPlp7qVzpYqoLusUXXmz8FPOZBK4Wx9b8rPkYQN5y7hCq786wL5/UxT5Br+0538fA3gE8T8np2GE9q1xCqqfYeluHMZ2oco44ZcSVehzPcmZ6hkqIO/dcnLIP1RH+QecZWb3uiLAaYZTb1N75ZtmYoHwkThgyw3OVBrD6YTEBtnyT/6elxsaR9wq3hOPHi77KE3qLE3aOV/odnZrNIRuMjfm1CVpohzpCiV5amS/IxZNrt4I1h+Fnylan8L2MfCpQNu+O+7VHqInqSPLstxi+yazamXSWISyZ78D2Yh3ykbuKNFXBU7zgBeOYp43LcPyYClPy4FuLRKKpw8N48XAJmgP78AN7umYYpVqX2P7xtdH2bQq2Iy6hERsGUxhbUpOpt6ARbV1X6O1Fi72xS+rOCLBClejbijsg5MAwi4E+6lyu525tbZCasNuiknIfVth3FoV3LhID2cfb7kVwNipOLw1UIT4nnVZRtun0=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I/O threads *usually* are not blocked, but there are some BCL methods that will invoke your callback code on an I/O thread. So it can happen. I'm not sure if Core has fixed this or not. Of course, you can also explicitly [schedule your code on an I/O thread](https://docs.microsoft.com/en-us/dotnet/api/system.threading.threadpool.unsafequeuenativeoverlapped), though I've never been sure why you would *want* to do that.","date":"2019-01-24T23:11:31.151Z"},{"_id":"e19c8330-1fa0-11e9-8fc2-efd230bc5aee","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"JihUI8Ge5q7dKktgHvIwfJI15gTIJW+eJWyCRcvz14ct+EOoXsMq8LkjJ6/hzaaLuOyIPQsapsWChUlDUbW3oDAy7ZmwOKORDIWiM6BoEqCmR3bT4+DSkWzEcirqus03d9IVsUmBemsg7c2B1eCybEik1F39tkXCZMmeG6HxvV/GXdETMjfbHP9lgNivAg+/+4RoXVWBwJ/eYqmvjYxeDvC7yMyfNKasr/qgUhmFjaXlpGl6PKjFPJ7cYIU46edTmj2yBNb1CZlBJKo2WM9BhLIDxP4h5ZDG9r8GcSprc6JoDADUEp9XSTawRUb15ENDJ/fH+Wz3bNlM5lzn9fguaeInpjiWQBk9CsFp/3A8JaP0+H0ODscfI2yROgKgM11V7OG2SDTGPlOhSQHIkfhYhNXnufYZhR/l5JRm8wGlZmMfRc0BDh6O3firmjtBAbpWFYj87Bex08Efx9xddD+2y5tEsYR6XWcoDiZ2JW7nDubpOSTbvFFC0F+7QujbCjMz40wijqAUS9LRDQo4XzcrTLt185MG6t8QNe5Kej6HMbNwIDnBkpIH7RGNDPmUxpQs8AQ2JnwIbsVo5oD7riyj80hpesfDyot6r3abSovJN2RzlVeQFtIyneXWt9cKABXFyQKuwgD+ZWlrimq7Nxh2j/rZ3jgXclouHbMvYJI2oxY=","authorEmailMD5":"72b7a6fb3a3b4dcd8c8ada0586e0d8f8","authorName":"SangHeon Lee","authorUri":"","message":"Awesome article, now I understand how async io works in dotnet.\r\n\r\nI have one question, Do you have any idea about situation that we need iothread much more than number of processor? (like 10 iothreads per core). Because many article recommend user to increase 'MinIoThread' for better IO performance and people said it actually affect to performance. Moreover, default value of 'MaxIoThread' is 1000.\r\n\r\nIt depends on situation but as I know, if there's no blocking method in thread loop except GQCS, we don't need thread more than number of processor. And also coreclr limits number of release IOCP thread to number of processor. (https://github.com/dotnet/coreclr/blob/master/src/vm/win32threadpool.cpp#L456)\r\n\r\nSo I can't quite understand why we need more than two thread per core, Is there any blocking logic in iothread or am I missing something?","date":"2019-01-24T06:25:45.672Z"},{"_id":"402c93a0-309e-11e9-9886-cb4396af2ad7","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"Rlqdq+Y7frV0Zsd1igf4/Ta25tPx/zbRbv80Mrk2SfEgJEH9ElB8wXbweOY96j8LPNnwcQOTdEogM7wHWLv/B89KNqzAec6Fn0YHFSFN2PFsLDig4SmI1Bpz3SggIFDXJJhTe3FNAZNgRhnpx2YapN3kIAw3GRqBMvYdGGoe36/LaVBQc1N+w7uIDtGK6KARWrojzmIaL1yJBd7sTgSGbMWsw+0vQUsnk6o83KjwvPohWjcBSPheFe2QO1fVvxmenhdbgkCrIcUKa02akEiYqS3nW61Va8hSD0OwTPjjqLySzF4BWhMS1rsgTBkUby04IoUT176yYKpy+IdLivEo5u7XIu9JAeMOOoEP4UtmSGNq6qP2aorUuP/F/hbDgFDUE0Cpi+PAgCRkdRztIdsVHNj4jf58lf6zOYmEpayR4uP9qfb3yqIb6IvHmczWsrt0dk4t2L9j6HFNXVvhJZhLlsYhdUaLvXwqrhqP5CbrGM9+adJurIq5UiqpFRPMD0G61u2DkgC5iOb2KDwLrJubqADww7ZzojSd90tX0Wv2vc5O1jzSDfL8po4SW5OnxUmR03GW9FUv9omDU4jOOw2axTzmpIVmFGSoOX9IYPU/XFRrqIm35Da5yTeqkdqVmR8Okc5b19xNJGTrlmvmVvsp+kMmKTByk3XOcidrbW8g1yI=","authorEmailMD5":"acb477e35d3daa0bf579a3bfaefdfdc0","authorName":"Avi","authorUri":"","message":"Stephen, this question does not directly relate to the material that you dealt with and as such you are under no obligation to understand the question nor to answer it.  If you however do know the answer I will appreciate you sharing your opinion.\r\n\r\nDo you know if async/await are *NO MORE\" than a syntactic sugar to the *Task-Monad* or if async/await are *MORE* than just syntactic sugar to the *Task-Monad*?","date":"2019-02-14T21:19:45.674Z"},{"_id":"9a48d390-30a2-11e9-9886-cb4396af2ad7","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"402c93a0-309e-11e9-9886-cb4396af2ad7","authorEmailEncrypted":"fvzFj1CONlSZtQAMHvyAW9thXdITvbOBzsaFQ1bXAXO3qNKviVmMsKkReRFOPDaDh0m/HCBziy2MvpAV4KvrqbvUKNmrlrWl8VnuAF1MDkNuCrnJ2MCL/mCglIsYngDojkDt5YI4m21pGJa7Ap/oa0tKMGhA/ojsso8+8ntzK0dv0P9IBdFwsZI8iJf6ix/OWoIvaGLryZtRwNQzUVswI2kpgQfK9PgZjxIPrkONcA/4bBwlsWBjr/Ot98mIdMljVZGaRHcMJedM3h4EPbkU7CF27DZKxlu1P3NuW+u/VdDgFL8fyjQhKeZ3Xdvh86uMsCYJ2N06TyF3ra+bSt1g/3ToXAa8+i8oUTrXJa9iu6Jd5ssfURmGT80zpHR2vaOXJwaogja30ZLi1Q5aGuv0PQ+G8y+mBiLdKeIocxOthuDVMZGhJ20RiWEeezd7W/UOHPT4pRKqMsPU5iRtvLbmPPhkgaR/4gi4PgITTaPR5yK4oJtxN/sJ8wAkDAOONluaILoIKw7gILzW2tke8vLaSdPmTlEqcW+40o/xW3uTmKcMGYMbXALZ+rfsVM5EWfmXY+Nf+NWlbVWNoBCOXPicyxEfFiV7xf9jJeHu96k1kpiAHHoMclM5i4ed2Qo4O3NZAVB3qk8m7Lh3zeCZhQbq4EWm8bgzWWOeWMkBKjULgk4=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Copying my [SO comment](https://stackoverflow.com/questions/54681739/c-sharp-async-await-are-syntactic-sugar-for-the-task-monad) below:\r\n\r\n> I believe `async`/`await` are syntactic sugar for a Future monad, of which `Task` is one example. Compare the `async`/`await` support in F# and Scala; while not exactly the same as `async` in C#, those languages illustrate how `async` can be built on Future monads using functional macros.","date":"2019-02-14T21:50:54.835Z"},{"_id":"145d7ec0-30bb-11e9-9886-cb4396af2ad7","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"9a48d390-30a2-11e9-9886-cb4396af2ad7","authorEmailEncrypted":"YPVFAFSb0xm84id2tRSHpF/yScDONqHI8RZpHe0Y0q4wlI/U8adufTVNR7oBDfx8Jb+NhnAb1bGgOdvgkuumXR8PyDFL/Dh383IuNw2oCZY4ymzXdge9d/tKThDYf74jxeb4/59Mf808yuKvqTqgpzKb60EmCeewubwkAsnrodumPySiX/j9ZqRNIfek3yqhQZNwtrkNdZSAVF3fOhJN3atPB8Uvhz24wrvjDz6Z/pIc5Re6wyn2/0nGcHjs5yzTYjlgMlsgDQ+3XD5DrXHGXLrglN2SnIceZ7srDGzEd8J4yup80MmFXPU6rXAmAnVkPqSCvTCW2PHj5PXHukMH4G1PNr0EAJ4NBz2JvFjYZ7MuVP66ARoU5QYQE0CQUGah+J48NUX26IB+5bzj199h3GtQNtkB6ZLWVqBbL83eme1rQJMcVpUB8La1gTJvwZPVY4W3MBV8MgU0d4GkBH3iyuIjBu+KSnJs6aTM0PEiCIErfqTq4DPAM3gEoM9HdX2hH1mqXqtj33n6xmll2EAzqXUboy4aInXhTSburw3ebvp8bARGkRUs2t2UdSvc+pb98cq1pRrnJXDDZB96vP+8xx8RJrzcfzmSXJrjlYnt0NEVtqXVd3qfzbZ/HMR4rMIX4/GXjq7mAO5GNL/Lk3eRL9ent/rFf5a7ZdxuWqfcsvg=","authorEmailMD5":"acb477e35d3daa0bf579a3bfaefdfdc0","authorName":"Avi","authorUri":"","message":"Thank you Stephen.  Your opinion is always welcomed and valued.","date":"2019-02-15T00:46:07.613Z"},{"_id":"c603a090-5489-11e9-b3c5-295a240c9847","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"ff65bfd0-5461-11e9-b3c5-295a240c9847","authorEmailEncrypted":"cnxXAOLZdfk9uqKo1JWViI55wYrMzxO3M9R3coQBQF+lfp+YQyyyFsS5XYJ7ybIRckutV+aLgZR0tSpm/cy/oy+dglZ9mLVLXtTbl29itDIPH+VqPdnfH6Qojrs6suTY/B7QPoC8jpPPGCeHedEPJtZYsR4Uy+sdfedIwpUJ5FMyP/1BQVVEFWJ+zpROPujm2ndHvcmqcX2pQQIm6PDosIk+4lw2l2RuBHMaWzUjAmzUZGzE6DT8cy4+c4QTLFwAsM9MX137NqrIoI4SZyfzLilWyH37mTLIuA76VX7KR4yAd5/adC2VY3zDaQskZBfOfZlpH0NRG0LHeLsKvWNKK9Qk9387aoWh6SlmG1dt+ir4WKdQGKcJHH6i2u2q42k5eXjPB+MPg8OUqRl8zot1ObAl/4wINPVKxHNsfMeWpsbdVMRaLrEUgEU/T09Ug9ZN6tUkqpx0IH0AlonolsmOOikIYmu82ah99JS0Cu3leIyAfJo5IwiQ4uqnb3V8QpiIph2q8lg4nGPR5dsXKILFK8qWn17JTgLPp34W1PBADoYF/qo7rr8o4Pec3+upOjisJgonZmK3puZiNecLGOtOll6xZ0ikC4ywdjLJidpO1vFYjbDP7nTqLp+0GoUZoncC4MjCo79Diy7IQPLrqEtF+cpQPINeoStDugGANpuBFds=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"This post is about the internal implementations of the lowest-level I/O-bound methods that return a `Task`. There is no way to use `async`/`await` at this level because this *is* the lowest-level implementation.\r\n\r\nFor a more general overview of `async`/`await`, see [this post](https://blog.stephencleary.com/2012/02/async-and-await.html).\r\n\r\nIf this doesn't clear up your concerns, please follow up with something specific in this post that is wrong or misleading, and I'd be happy to address it.","date":"2019-04-01T14:23:52.684Z"},{"_id":"ff65bfd0-5461-11e9-b3c5-295a240c9847","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"http://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Akira","authorUri":"","message":"This post is wrong and misleading!\r\n\r\nRead the reference: https://docs.microsoft.com/en-us/dotnet/csharp/async\r\n\r\nQuoted:\r\n\r\n- For I/O-bound code, you await an operation which returns a Task or Task<T> inside of an async method.\r\n- For CPU-bound code, you await an operation which is started on a background thread with the Task.Run method.\r\n\r\nSo many views on this post, please edit, author!","date":"2019-04-01T09:39:09.125Z"}]