[{"_id":"876030af-232e-30c8-bee7-e106e0fbc11f","authorName":"Alvin","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/03892201689252059476","authorUserId":"","authorFallbackAvatar":"","message":"I am currently developing on VS 2010/.Net 4, which is not async capable.   \r\n\r\nYour explanation of \"confusing default scheduler\" explained some things for me that I ran into a while back. Thanks for sharing that.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2013-08-29T23:15:24Z","timestamp":1377818124},{"_id":"8e5e07f2-1f7c-3ca7-8e74-f2bfcd966cac","authorName":"Sriram Sakthivel","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/14791805082342292214","authorUserId":"","authorFallbackAvatar":"","message":"Really StartNew is dangerous. Thank you stephen :)","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2013-10-03T01:47:32Z","timestamp":1380764852},{"_id":"65e7549f-c00f-3bc3-ab0f-226c92e84bea","authorName":"Clutchplate","authorEmailEncrypted":"MmHlMlHUsrYzkC+QXn45zqN3l5Jq1EieWS0ftf+3X/VcwIBI+1+VkKKcprVt/7p+2n4c0Eumv/NDUC3B44yOXulgbiq6t9NeW5WhiGBF/4zvH7qsLNTso4ZwuHB0401qbYBSHGrBONga7MhTvyyLIYWIKom5DI1kB5Q43HwDc2NkNH5Qwkh7vniJQAbXqm8w/IqFraLSF/ZKYLWn7XIsarbzk2Kto4hzIGHrbfi7OrBD5GR76Xam2syphkW5+77E2UPOi2EAUgsMsaI54GQBF356SpMdeUp3t/fNtdnhLeEizMq+cKRweWGl1XWdBcLPI77dR9kZEfY1+wvFlk4WmdvGHK9hamjo0c6F7vjCy+dCtAEt0vSCL8U1C5hjny4z5obHP+3s9nXdRKFMmiIVmY43k8oUCzcETYYvOW8RfJYxghPznQGNVGDH8BoU/8L0lZ+dwJU3eGAMM5motTkA7YDlidLXKw62jw2ho3k6SojfDEKBlShjJUMuURJCfVR0OXOHlyfVjgBtPSKroLskth3t9+h42yePKkDV/uZUtmPuJWTQfKJ7CTcQbO0ry4THZSvPUCxdQk2C3s/OVEfG2xkMZSA/4t6FYfhfarNjmMPVLedav+mS4FeO2Z0halkSLvedIy9UYIuGhdG4OcjlfWfeaZMwptq0cVtr6Vh3A+o=","authorEmailMD5":"0eb1f28f208475fed6a5a7b632847285","authorUri":"","authorUserId":"disqus:clutchplate","authorFallbackAvatar":"https://disqus.com/api/users/avatars/clutchplate.jpg","message":"I am running into an issue that I wonder whether you might be able to shed some light on. I am creating a task with StartNew() and passing in LongRunning. However, the task never runs on a background thread, always on the foreground. Do you have any idea why? What is the best way to make absolutely sure that the task runs on a backrground thread? Do I need to write my own scheduler?","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2014-06-17T17:17:44Z","timestamp":1403025464},{"_id":"a65b0b35-8205-3bfe-825c-1c1b089525a5","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"If there is a current task scheduler, then StartNew will execute its task on that scheduler by default; that's one possible cause for the behavior you're seeing. The easiest way to ensure a task runs on a threadpool thread is to use Task.Run instead of StartNew.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"65e7549f-c00f-3bc3-ab0f-226c92e84bea","date":"2014-06-26T19:25:08Z","timestamp":1403810708},{"_id":"0eee5468-5f80-3677-9c58-7c1a5c44ed9d","authorName":"Santics CS","authorEmailEncrypted":"bIPgZhxPhPqpYtxe9by21CLMBS9c0iIVTFcLuAvN9LtwbHZAAO4yskUMz6w41NZlfXg01M+3ZXTQyxS+OZOD6ZwoPBNGQgL2oyQ7k4+Ps6/B3NYR3zxJy3OlS2QU5y8rziZEWKDlTvbgd5Wq2pZ9E4HTHMq2VVMb3SNRvOBDp8+7cAYfDtIhvhpsmL2AmR4q6z8dr+mexWQ9+KqM7riFBeDVOdOISFBLSFB+6B1uc7Z3gD09XhxtPSm7tz1VYNDbWrBTguoya2yg5T60hdJkH68urkfuG/UiOjHo3/VcmnIcR9Dbvl+tKB7MlqN5KvWKIezpz/cof/7fX2swaawYA4FS0dBMQVCiJiGICpH+pVDwaiEU4h1IpOwNYBlwaXKQm9LGnXtEEWP/J/zKMXqFS0Bm66LHYFeTulx3vA5WLiwfN4q3lhd/WwDCvYunPDzLb7a2MAJLe7hx4JItfue0A2wFEGSt6YKuOIZYJpIrNYExFqzjR63Si/VHSC11CdktbMfJoJY3F87FKH317DBgynhdWN3z4Gep8nv0KlkbLpDKnYs0ZMXBRb/QXNkLllctzv6ZfvG55P5UQztR4Emx6HOVFLnvNp3i+n6JMkLx4VobX7oz4zFHWI2wCtaTVX3KqDk5Y7xNT6WIlEi66wLRJlptWifX5+VIkFEIq7wvsnU=","authorEmailMD5":"4428ec33bbea616384a1eb27d83adbf7","authorUri":"","authorUserId":"disqus:santicscs","authorFallbackAvatar":"https://disqus.com/api/users/avatars/santicscs.jpg","message":"Is it possible to split a task that is already running in two? What is the best way? I'm using StartNew going 'AttachedToParent' as TaskCreationOptions parameter but can not get it to work as it should...\r\n\r\nYou see, each task executes the same procedure (with different parameters) to add objects to a list of 'BodyPaq'. Within each object 'BodyPaq' there is a price list. Each task should create a BodyPaq with certain prices.\r\n\r\nThe fact is that using StartNew as I do, are mixed in the same 'BodyPaq' prices that are generated by one and another task. I don't know if I'm explaining myself well.\r\n\r\nIs there any way to split a task asynchronously?","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2014-11-07T11:41:07Z","timestamp":1415360467},{"_id":"47ef68e4-c324-36a1-baf7-1659c3c5c288","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"You can't split a running task into two; I'm not entirely sure what you mean by this question.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"0eee5468-5f80-3677-9c58-7c1a5c44ed9d","date":"2014-11-11T19:20:11Z","timestamp":1415733611},{"_id":"e2017b51-c82d-3440-ad3d-c22808973a14","authorName":"Santics CS","authorEmailEncrypted":"AOfnX1AxJdI9UgU1i2wKxmMcy8mLgnkyz9pEO0j+o0awGtsLE8C/UA2tUNHr/IF3U/tjSRp66jWVsh++/Cso/epWwz1NKUvSArFeaOZnEE5dBP9qG9TmGs1xKFNqE7HrL+XW6VcNOACt2HUqNVZugWvCHqRvmORcTFhXZCnGa426zimWVHT8c/JuUQU62XgiWnS7q5xbQvzjz1PTJuuMtzrjAOKicvLiakmy9APVxZC2cP6MXWjvVCxpBPmXzY4bn2i5/galBK7ab9kLLPmvTM/tlR5I1/qr04XoBGS5qo8Y1tKb/jG1Zaqshl0GY9yuwTftXcNg+jaGWkoTXibTX12+7wfDP8q+no94vtPspDFnYGQyzSoSs9esH432EOq3/42wqfOJFgi4RmXWP38sCDiD0YrzyfuQLCvOpK1BtOWinnUC3FuqFsshZGEzIzvJOrjvYnLtNnKbeqFOmypAx5pD6aqbmIN6KTHLU/b2Vd7UGoW67/R0s6Qju0xeQv3Gtf2oHlxRKjCowTdJzN1coKcImra56J6cE72DGkRfMqhVSYG3dWnNopsz3TgDKGyBD8jeTdTav7Sqw4eOnL6VfgzJRykQ962iEfieczgco9CuhW2g6yK4LSSY9kDPGaTkbxYprpuJvzJf85RYtAZsbc40vG8TF/w5mpNhd/Mteeg=","authorEmailMD5":"4428ec33bbea616384a1eb27d83adbf7","authorUri":"","authorUserId":"disqus:santicscs","authorFallbackAvatar":"https://disqus.com/api/users/avatars/santicscs.jpg","message":"I want to launch two tasks from a current task. I know it's convoluted. Surely I will have to throw two tasks from the beginning to make it easier.\r\n\r\nThanks anyway!","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"47ef68e4-c324-36a1-baf7-1659c3c5c288","date":"2014-11-12T08:20:47Z","timestamp":1415780447},{"_id":"14c99371-7bc6-3aa9-96f5-a4edb608d287","authorName":"Santics CS","authorEmailEncrypted":"oXFBOYEC13KTO+Muw/NBZvKdCiQuP94WqibQvc0j/QdArdyknS/mzfq5I4wB8mIaNGd2NFuIjMbESVb9h9PLY4D0ipXYTR2/SNwSPlOsSV71L2CkkhwHKScCzcaVrHGCAywLqFYYZ/zmo/PThbIEBjV8fAH1onjsZA3jsos57utxMET1tD+DjQxXIf4o5DAcytHpdkds4s9JlI6thpGqfJFmQJNkrcghcL/XP5d20CAQZRVvRCyc08DUewwTMEm+Ob2TDXnezd0ELEC3OspBkK1vC4PdEgc8fb88Vs/3hbPUtlchjGHu7SWXPiSwUJofjeHit+2TxOJqsIEtpR8KyvOmuDneZ9c8De7KZyK4Cum6q6KgyCFTx4eX6HMeawZqu2VFiBXaZhfYQRXsrV8PdnqQ+G40WdfBW9pEQvtsMfWBqrWTpFE9Ym8u4R7FPlx6jGuirH17uctDj+MksxwMWyxnEKaZX2ErXinyrbTbbrqEKsrjKmPBpFNBf3m3YradxnLRRx7L5N5FIOVyY5vY4VrKK4RJ56KqBeSk6hFLeizdyNcC61Gs43j07dfBfEfDl6TvG3mFNeT7TXNittr+EdirskHmLA/uBvYikhzqDb9WM6aff0AruuBO1+7Pj3PVFMZhJKjfHvLhFGWzfY8/FzFvLOOHQLNe1kmhlAP4Tkw=","authorEmailMD5":"4428ec33bbea616384a1eb27d83adbf7","authorUri":"","authorUserId":"disqus:santicscs","authorFallbackAvatar":"https://disqus.com/api/users/avatars/santicscs.jpg","message":"Thank you so much, Tomorrow I'll try with 'Parallel.Invoke' in the office :D\r\n\r\nGreetings from Spain","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"8c2a2ddb-211a-3628-aeb7-be0eaf064ef9","date":"2014-11-13T18:54:16Z","timestamp":1415904856},{"_id":"8c2a2ddb-211a-3628-aeb7-be0eaf064ef9","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Sure, you can start two \"child\" tasks from a \"parent\" task. If the operations are asynchronous, this would be best represented as:  \r\n async Task ParentAsync()  \r\n {  \r\n Task child1 = Child1Async();  \r\n Task child2 = Child2Async();  \r\n await Task.WhenAll(child1, child2);  \r\n }\r\n\r\nIf your operations are synchronous, then you should use Parallel.Invoke or the like:  \r\n void Parent()  \r\n {  \r\n Parallel.Invoke(() => Child1(), () => Child2());  \r\n }\r\n\r\nI strongly recommend the use of Parallel for synchronous work. It is possible to use Task.Run or StartNew with AttachedToParent, but that's a whole other level of complexity.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"e2017b51-c82d-3440-ad3d-c22808973a14","date":"2014-11-13T18:38:36Z","timestamp":1415903916},{"_id":"35b829a3-fa7e-314f-988d-aeda3b3d8b1a","authorName":"tiagomargalho","authorEmailEncrypted":"IU+nzv4UU7u/n9J70eCFZ95/i+3OnOgrxmDCZSTsseXpmorGjduIxi3n5ubl5LJwtMOewAQSNDxExVEwh8kSELrnijDcmz+8RhuJa+tuqIYTCDx9V7R+PfF5Up4r/rW8jOjPlz/Rnb87stQo+zZB67Oa5wsnE5XcjS9Le1Cn0l1XmeD76BRzFciFbWjeYMT/bAUv3C4WcIUT6G7UapyR08t9VqHJC3cWJ1Yteot/0wto5VG3xgqVUh+wi7JTxMAJuhwYPcBYz+x34lprhCCM3dP8imVpPm25gB7/DFA7/+7oWY1UsRvbxaY1gX59fq887GT+BE2DfUMGA82LC+7TWjVrap4wMkJYDmc5scpK0f9poKGLxu+sqKxlqI5MXGr65jlwd7ufEBUbI131IkYPZW2ezkz8axQS7o/FmQrG4bKhe7BsgujAe4q5i7xfKDRVUC+8V4OiEM+61YQbAJcOYOaGWOw09YtGlsE8VKH7N38MZ9cBSxhLMqvyHKsMl7npDBFdHeSJDL1035N6vjm/sTpXNpUHwl12K7mvemst/KaYTg0VyD9EhVIkVhr/QiLmesJZKJJ+42H6T4GoQif1ZCjhmczZGzGJhTZZW157DrTRapqTQTu+WTj9FA7pH7J32ARb0w5Eqbno5s1V8iuFh61Uv2s/MMzoq7txmBnYfac=","authorEmailMD5":"59e75e71c30cfc730d146ec630fb89c8","authorUri":"","authorUserId":"disqus:tiagomargalho","authorFallbackAvatar":"https://disqus.com/api/users/avatars/tiagomargalho.jpg","message":"Hi Stephen\r\n\r\nCan you please explain this paragraph a bit better? \"I often see LongRunning misused in particular. In the vast majority of situations, the threadpool will adjust to any long-running task in 0.5 seconds - without the LongRunning flag. Most likely, you don’t really need it.\"\r\n\r\nAre you saying the thread pool thread will be \"promoted\" to long running, meaning it does not count towards the thread pool limit any longer (and it's not used as part of the pool)?\r\n\r\nI don't find any text mentioning this behaviour. The only related information I found was the thread injecting behaviour of the thread pool: \"The .NET thread pool has an opportunity to inject threads every time a work item completes or at 500 millisecond intervals, whichever is shorter. The thread pool uses this opportunity to try adding threads (or taking them away), guided by feedback from previous changes in the thread count. If adding threads seems to be helping throughput, the thread pool adds more; otherwise, it reduces the number of worker threads. This technique is called the hill-climbing heuristic.\" from [http://msdn.microsoft.com/en-gb/library/ff963549.aspx](http://msdn.microsoft.com/en-gb/library/ff963549.aspx)\r\n\r\nSeems like threads are not promoted to long running, but instead, the threadpool will increase the number of threads in the pool only if you get more throughput (probably applies best for I/O bound tasks).\r\n\r\nApologies if I misunderstood what you meant.\r\n\r\nThanks in advance!","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2014-12-02T09:10:12Z","timestamp":1417511412},{"_id":"76d24b9d-2085-3ac6-9bae-2923539d5808","authorName":"tiagomargalho","authorEmailEncrypted":"b2zZAhJBRqPZUEj8iitp42Jupda5HUiq+T8ZfQgXdOD44+bKkvPHCmzbKYXo1pu6uOwsoOvPh1jjtCjAFxPwahZ6Ojc59BgIGTQGJV9f/11EOfzwzajVh6q2xCo4l1yJtkrKN8KBC1Ysd+5PD1nAjr8wfU2kfPR3UvgWvK7KMvsyVGcwwE9R80biW66zJYx3rjYD7gcBmF39thQFOgF9FDXe7aHGbHKJuOqfdEt3Np23Ma66JT0KwMCGXbgPabbPhru7ZPOFv0MZa3MGut/GkabMHD4GzrsoVipjX2Tkwe5XWVXO1XR3D2XKpe5a+Cie/2BgpO2PxUQH+sOUKmFAgyMRACs8MWKTf8nhSzpT/SRTTc0RbqhFpFhAkItqnEsCcSkXxZhMuLF4CfyS3zwuAv73zdf5fd0/530GflpxhCotDmw/SGhhy7WiNnZbwFEdNv1P8Mu0mS2/HL9v3ye30oSREqgwV+9WgcF6/UGnnjlIuPiBFOeSbkHf+iCRksQGLe+FC9PB30PfGzHPes9cVrRjYOyhBibElnBAhma599LZyy4ps3QtFQA/bDjjN+ius5IkxqTxWs5ov5UyVKonv5fok4CnFfLVZUVUmgSGHBUc/qcPSaUOaUjX8LK7SrKvCxN75X1Eiu2rcI/DXJMyVSrR/4YiGdU8BLP8sptbN3g=","authorEmailMD5":"59e75e71c30cfc730d146ec630fb89c8","authorUri":"","authorUserId":"disqus:tiagomargalho","authorFallbackAvatar":"https://disqus.com/api/users/avatars/tiagomargalho.jpg","message":"Thanks for clarifying that Stephen.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"8d315410-98fe-313e-b67a-b61f732df801","date":"2014-12-02T23:01:50Z","timestamp":1417561310},{"_id":"8d315410-98fe-313e-b67a-b61f732df801","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, it was the thread injection time that I was referring to. The thread still does count towards the thread pool limit and is used as part of the pool. They are not promoted to LongRunning.\r\n\r\nBut still, every single time I've seen the LongRunning flag used, it has been used incorrectly. First, LongRunning is only a hint - it does not mean that the delegate will execute on a dedicated thread, or that it will not count towards the thread pool limit - it just happens to be that way in the current implementation. To quote Stephen Toub, \"You'd typically only use LongRunning if you found through performance testing that not using it was causing long delays in the processing of other work.\"","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"35b829a3-fa7e-314f-988d-aeda3b3d8b1a","date":"2014-12-02T14:58:59Z","timestamp":1417532339},{"_id":"63b8108d-1ff1-3d1c-94ff-f7002764b530","authorName":"Micky Duncan","authorEmailEncrypted":"IEFnNOHPHJe1OuaLNhT1Y8o2/bFfBHABQ0FAQPSwvxgSVEoVREH6ZipRYo6Rtk1IIbTa/gz4da5pHhAsHsyfEqN1QfLpVSVGq8b9cofvWF7H1+xENHkiLB4UHWe+cqkCwIznoHbdY19MpNSwP8XrG0lAfjoiutKUV6AMs6pMVeeyJEAXNSS8vnKRqXN3CnmXddpW8M9QpI6uL4H/DMR3vIZ/uApK99RZg1ygLaQpTdlZs6MK8u10ltSajHyRCvddX7G4S62MjjYCZ24d8tl9io1xGnXcf4+aT85H0rP5K+YXV+48H+DWqXTarktYPtgAjOWMgwy1bzLRCC+mlxGYS8+/N/OMAhw1ryufL/NKzHkNTsxaMzEcUa8WnE16+ctzayFwa9HTxIwugs/uBE+1/4G/IiQDOUgZ0MROZxb/FBm6ZG7wDG0oQDrn+3W9mFUi6EnVjgJw2xS3yYb2lHbBy3NYqV2Lgz3RpVQKGQUHcKrsUPlDpuzfCBFh1Mefps7JtkA8Xr2MKK5MGucPMiho5O4CR+Q2TzqkFRbtM96c3wJgvT4P4gBmVXFROS5V+qXwqkT43g36hBbP/8wn2lXoMUwjN1a9cRveBAYKZJqfAAZGOnRNJdWaCzoLmz7+1pmECVUSN3/+3GwDkQXM4ivBxcuncXMsj/XtJg97fkYgFGk=","authorEmailMD5":"06a9c1741517b919426d11540c27734b","authorUri":"","authorUserId":"disqus:mickyduncan","authorFallbackAvatar":"https://disqus.com/api/users/avatars/mickyduncan.jpg","message":"Good article Stephen. Apart from async delegates, is Task.Factory.StartNew only a problem with UI applications?","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2015-02-04T07:52:14Z","timestamp":1423036334},{"_id":"a3635275-c84b-36a6-afd4-e8763ccc02aa","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I first ran into the \"default TaskScheduler\" problem on a Console app using a custom TaskScheduler, but most of the time people see it with UI apps.\r\n\r\nI'm just not sure why anyone would want to use StartNew (unless they're doing dynamic task parallelism). Why type out \"Task.Factory.StartNew(A, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\" (or even \"Task.Factory.StartNew(A);\") when you can do the same thing with \"Task.Run(() => A());\". Task.Run doesn't just have safer defaults; it's also shorter and more readable.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"63b8108d-1ff1-3d1c-94ff-f7002764b530","date":"2015-02-04T13:31:52Z","timestamp":1423056712},{"_id":"e855e547-bda6-3d8c-a163-73e6b4591aed","authorName":"Micky Duncan","authorEmailEncrypted":"H/EUIEb3iFvWEmSMVrAJ8JGre1rXxz/W1vjDywNlWeJ3YPgP+WNymaSv4xt8zU/yvozNAd9kSvcSb22rLoB+L1f+Y5w3aCD9Llt9lmTnuiZqKcoazlW/KDB+zZ+tddcmHNYaRL0RirUWZ3CXPqebyzFVoAwGnaGV0rscIOUbmaP5mPRQbsatBMUK5R0Pl26mBCiW1Na1fIPobw+ToHbEdKYfkusmaoNmTmrjJjrebg9vJVSKRmKIGqE+mSKOeJJypYE6ML2rLBWTurZaWo3roUflp8Im6DVF2ajFabq8j2hL3eck1w7TuTMzHqQJDaSTgrd5s4FJC0kmfTFxR80KrFbHiRtJLHjxFUoDnye6RMvjBa6CpIhWzZ8vN944rK4sq2j7910bzbNl8dr0Rx4mVZJlCuj3TECQC05lHNTMp8JOs0Yvr/A6Cyv1S1ZL44hNF/Qw8xiwJCPKrzzzYmHqZXhhmiS8Z9UgS7JunO8OpbzgzEBoJStDY1VxkCYVDyaaUbmpEw1y/YHtcxnjbeL145MCz/gHpp61HQEpHFZpYRy0bxv8yDn3gSNdZ2iI5+vKL+RSCdkHDPoDmGuvc+336IY9xvb3vhn1VHpLj0XvtBGv25hO3ef/CoSKvT1pfyTc2HGq8IrEz9IflTkKoBL1ScS2x4rfclEELFC4MwQ2DF8=","authorEmailMD5":"06a9c1741517b919426d11540c27734b","authorUri":"","authorUserId":"disqus:mickyduncan","authorFallbackAvatar":"https://disqus.com/api/users/avatars/mickyduncan.jpg","message":"Thanks Stephen. I shall move my code over to the safer form.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"a3635275-c84b-36a6-afd4-e8763ccc02aa","date":"2015-02-04T23:21:18Z","timestamp":1423092078},{"_id":"46499f7e-9471-35e3-b0a9-1f909c304660","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"No, the point of that code example is that the code is *not* explicitly scheduling the computation. Note that the computation in that code is done by A(), which is not explicitly scheduled to the UI thread. The first time the code is called, StartNew schedules A() to a thread pool thread (as the developer expected); the second time, StartNew implicitly schedules A() to the UI thread. This is not a contrived example; I've seen developers from multiple companies make this mistake many times.\r\n\r\nUnder the hood, Task.Run does not actually use Task.Factory.StartNew (you can verify this yourself with the reference source: [http://referencesource.microsoft.com/#mscorlib/system/threading/Tasks/Task.cs,89fc01f3bb88eed9](http://referencesource.microsoft.com/#mscorlib/system/threading/Tasks/Task.cs,89fc01f3bb88eed9) ). The point that Stephen Toub is making is that Task.Run is *similar* to using Task.Factory.StartNew (but with safer default behavior).\r\n\r\nAnd the central point of both his post and this one is the same: Task.Run is better than Task.Factory.StartNew.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"67b267ac-b4fe-395f-8f24-aa0c152954b9","date":"2015-02-10T21:40:43Z","timestamp":1423604443},{"_id":"67b267ac-b4fe-395f-8f24-aa0c152954b9","authorName":"H9uest","authorEmailEncrypted":"npIzoVA4ky8q0tdVg3FQEf4ewaI/4EYvTBfKa0KO6xipW2roA+TBqElPK78xpxjyJH4NUb6qx4SPUD+UyIJY7GSsfeQ+GGmFn8wOkVQZbibubouEUc9kOwknax/twDIM7XAooCwdetFlA5HE8sd+bBKxDECOzMuBtGcd4VS8GuRyPYQUcbVEnqbGja8YyCNEkMLpMGZS0sMvXGsDaREEeS72Ytu6LLRQ0G9tSToODpmM+aMrrmWWXgmD8pdq5A+5XPU15H/9md5dGW0D0UWHvK6F6Vjd0a2G0sHB7BrBHDVZiK4hk27PTEH3eF6iWtkRkkOcuVJ5NgsGArhat8114G9AZP3FOzg0A8CpGKi1wPCRkJXuYSJWrH9EOF2UtH9cQIooHqYN6xXuOBy1opj3HEcHBhB7kZGWFQ0srreDeNl8VGUygHfncs0NHVW1kHy3wuUz3UTtsoOncSNB3vxtmaHjgR5EOqJ6shBh202YbPdrygfTDaFcKuAkdhFG8dH2Z3trPje7iTfSwuLZVLyqWquIvkw4gPBzfWUwDEkO612u3yxKa75ThPdCQPv9kGaixN1wZ7T/XRDpLuPLkqLdZjMr2BircHqedK1CZCzV5sC+kqmQUnaIPT9fvM0zGihJkYRCx26KehsD+iTpZPDjXAWNB/fyAWCcsDhNHNAc07c=","authorEmailMD5":"0e3bcd72dadd8e7244b046a40e7e32e2","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"You second point for not using task isn't fair at all. In your code sample you're explicitly asking the ui thread to do the computation. You can't blame startnew for this. Also, under the hood, task run uses start new in implementation: [http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx)","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2015-02-10T19:33:05Z","timestamp":1423596785},{"_id":"48de3933-771a-34b2-95a6-4d6bde496024","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"1. Sorry for being literal; I do try on my blog to be literally correct without going into too many details, but I guess it went too far this time. Regarding dangerousness, I still disagree; StartNew is more dangerous because it has dangerous default values. I believe they both eventually simplify down to ThreadPool.QueueUserWorkItem (or UnsafeQueueUserWorkItem), but I'd never recommend that method either.\r\n\r\n2. Compute() is not the method that does CPU work; it's just the \"managing\" method responsible for scheduling the work and handling UI updates. A() is the method that actually does the CPU work. A() is not explicitly scheduled on the UI thread.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"c7a8aa0b-ac89-35ef-adaf-21f8bdf83573","date":"2015-02-11T18:16:31Z","timestamp":1423678591},{"_id":"c7a8aa0b-ac89-35ef-adaf-21f8bdf83573","authorName":"H9uest","authorEmailEncrypted":"bQCGkDpU2uQCH3G6nuoi33wthBcEyiSIfmpAnjlIAjvOTjvEhush2l+jR2iTyr3sPtFBHm+OMyz9cwGkP/QEJJarF+Y6y3O7nIbsMa0kra3GBL7Lj9ozsdxuHhk3hrLZzmmQfyLlEmHKh5woeSrTDmGFBDUmpP//wQUiAwcJFETldxsdhAecDytFF/JQESHhgfRA6xk1ZRtXCEvjJVDJSlULFKqui5XtRbT2dD/rOkzVdOplXT3TyZ6zMZBggcxo+TNDwAQPH9L9WGYs0zuCim5yaUjxcDx1gi0pnZUgtBjjsVIKoBa+2uQAaCJasnaUbbskygx1WqEvZej1YSmTIgHc0UHKwq8210knukFY5K5cf3DYWCzplVMO4av0t23TOJOIm7WH3r9S1Mqoxr3kkTDPFX0h1F3D+zGR4b+3ZLC0urko6xjRv2ta9G1nB5pl6LVlMmM4hcyOGgoS63UeqkODZ/WtdwEFh5WbXOLzHvMTwPeO+2tO8MO8C50kJgweQaupTCy3oVQOhebUEeFwEBboD1aJIup0J+99FFq1sP1IB34TISETLDWFbaSa5oBk6mPG9F5VBAwqlEEDrwPC0eaPGj9t8Dzn3PP3NmLUlKdyeeSrmXExNnCjGPi4yZQttWDf1iBk7PYd6eNBrcDUd0466E+MW00tNx1TUm5ku+U=","authorEmailMD5":"0e3bcd72dadd8e7244b046a40e7e32e2","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hey Stephen:\r\n\r\nThanks for the reply.  \r\n1,\"Under the hood, Task.Run does not actually use Task.Factory.StartNew\" --- Literally you're correct. But seriously please don't take sentenses 100% literal as a natural language processor would do. It takes fun out of idea exchange on a forum and makes it more difficult for both of us. Under the hood both of them call the InternalStartNew, which assigns work to a thread. The fundamental mechanisms for both are the same, not similar. Therefore, fundamentally, neither is more dangerous than the other. They're the same.\r\n\r\n2, \"the point of that code example is that the code is *not* explicitly scheduling the computation\". In fact I think the code sample *explicitly* tells the .net virtual machine to execute Compute(2) on the UI thread: ui is the second argument passed to ContinueWith. That being said, everything in the Action(Compute, as well as the trivial tostring) is explicitly requested to be executed on the ui thread. If there's any unintended side effects, I'd say the programmer shot himself in the feet. Not fair to blame startnew.\r\n\r\n3, \"And the central point of both his post and this one is the same: Task.Run is better than Task.Factory.StartNew\". Yes, I agree with you that in most cases where we don't actually need fine grained thread scheduling control, Task.Run is better. I can tell this is indeed the main point. Maybe it just rendered my arguments on the previous two points pointless :p","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"46499f7e-9471-35e3-b0a9-1f909c304660","date":"2015-02-11T16:46:17Z","timestamp":1423673177},{"_id":"09a1b606-718c-3b21-92d9-de04b312b2fe","authorName":"Chris Gomez","authorEmailEncrypted":"FhqZ3xgdTOhmz6kTRDZc96pwXYaAm1+AD77IKvCkFbxPW+m2PloevMqXpD6hUwh3b+IbrcBZ5flZ96c2Zz987sczyaU+ihD3PkNBOd1vea7AXqYCEet6anE+0VZvJFQ2B/fBMdi9mTay9Bz9qAZoUjZcmZGou0sNbvZpMXZav0PBWym5lbQ5IzQICGrUJfBH9qoJctZJaulU/eAdU24vMmMTHA0QV+RdU4XHY1jeASV0gydD0+fFdJsmrQ6cXl3P4ilpr1o5XTtyvjMpHulfrT2QDGmlpi6s8PpqH0kjR38w5Z4DTZsL7biAx8c04UmWOlZl8jfCkid3CWH9TpyjMHIbiH1383q9zgpFulo0A/7LDtqFQbPbVpgNaRZLqFh5ejLvUDpTJW9Y9omwJqk5DzdfeqAa1zkMKh4X+WiA3lyxtvA2r4p1yKYRxBZzjx2zADTtH6Rui/DtV9cZToe6g7V0n0Ji+Sgad+aUOcbGe2N/wDSxuYT2EkKwSdZ9iAAEnAHZnHyzKLf46KErP/1TZutiaG6lwS5HoyvHWEwuDoOu1TPUAMJiLaavuvHzNWe4hpS38SNW5ItrC/H0GdXQrlGAdwT2Tf9R2usZvVpRPcGIlkM5Tjicufit5BQt5bEMfd1GB8bu+1SaS8YKZeF1tepNEjOPDVF9HNMlkfI815E=","authorEmailMD5":"a3e218285eb020632564c99943fa3940","authorUri":"http://www.chrisgomez.com/","authorUserId":"disqus:cg_spaceshot","authorFallbackAvatar":"https://disqus.com/api/users/avatars/cg_spaceshot.jpg","message":"Another thing I am running into is folks looking for guidance on how to use Task.Run or Task.Factory.StartNew to run what is really CPU bound code, but what is really going on is they want or need to comply with a method signature that returns a Task.\r\n\r\nI know this technically doesn't apply to this article, but I think that people often land here when looking for such guidance on how to create a Task (I did).\r\n\r\nBut really I am suspecting the answer is (based on your other series, Stephen), if you are really CPU bound and must return a Task, use Task.FromResult OR look for a version of the method not expecting a task.\r\n\r\nSpecifically I am seeing a lot of code out there dealing with creating a custom MediaTypeFormatter in ASP.NET and using Task.Factory.StartNew (with default arguments) for no discernible reason other than to get a Task to return. But you can derive from BufferedMediaTypeFormatter, which has no such requirement.\r\n\r\nAm I analyzing this right? Thanks for this great technical post.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2015-04-29T12:01:43Z","timestamp":1430308903},{"_id":"df04e5d3-0c7c-3d55-8d59-e7ed11fda0ba","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, your analysis sounds right. Task.Factory.StartNew is certainly not a good approach if you have synchronous code to run.\r\n\r\nIf you have a synchronous implementation of a method that returns a task, then you should use Task.FromResult.\r\n\r\nThis is particularly true for ASP.NET; there should almost never be a need to call Task.Run (or even worse, StartNew), certainly not in a MediaTypeFormatter class.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"09a1b606-718c-3b21-92d9-de04b312b2fe","date":"2015-04-29T12:40:40Z","timestamp":1430311240},{"_id":"488a2247-8676-3fc5-9a55-03d0906c0e28","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Actually, you can use the built-in ConcurrentExclusiveSchedulerPair and specify a limit on the concurrency there, rather than using the one from the blog post. It's just my own preference is to use something that's officially part of the BCL and has thus gone through extra reviews, testing, performance analysis, etc.\r\n\r\nIn this case (using a custom TaskScheduler), I'd recommend constructing your own TaskFactory and using its StartNew. There's nothing wrong with using TaskFactory.StartNew; this blog post is only about the dangers inherent in Task.Factory.StartNew. And yes, that's a tricky distinction! :)","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"d1599327-48cf-346f-912c-bcce8716342d","date":"2015-09-28T16:39:43Z","timestamp":1443458383},{"_id":"d1599327-48cf-346f-912c-bcce8716342d","authorName":"Pelife","authorEmailEncrypted":"IlCE/AMAFjFEK7GwIlmN/0Qh5fOaweVeecoubXXJMGg5grt5kqtsneUiFFvkI/ppZBzQQpULYpvSVdRpIQiPLmBJU92Yr3lkxUclVPd61M4aTPi3zAVqCbcG1WDHXrFjSP4urYa3xyhLE2v2CRG3C6y8t9hJggCi3it2PQbmDK+flMn+EP/EgFIqEiO4jk2zQBbPQaxKjc7BT+Zhjt6TxnAvsa3/qX0yeAAOIX+9woTFOTez6+jlYRdzcjqdNUEqXbMKO6vk+U5UpReWrrKSfqEyjSOD26OJoO9I9aArwTGQIw03b6QAhnUaIn8aniYGvoMHuZQtzXz4Jr4CEDL2QdoUpxmpuM/ii2JJ6VYIBne2drwd2m6lqtOfP7O3kSIaWaD3xYfg0O5cXH8McUhEBLu3Y0/HCcc5tNPnLShXxZG3KvuATY3NwWHL/mubwDx4sLd5AlAokqxeEQjffPXZEma9IMwVuAqU40Vz3RwR8kDm5YSaMjPqZkPh9Ffl+Gndk0DcAjofVMnDzHN++PAhuQTx7PUozii/f8fXMway+cLB1auBm422/pCckg+t1fPb+bmdcR3N5KUrT9hh3A8vA9m25Zh/IhJbBB3WpxpauT47kG8tshLj2KgL2EAGHGaJFEax0clMCChn7Sk2nSQL/GZ+jrUnpjMeDLGxp1jw3uw=","authorEmailMD5":"195874aec0753f1d16a72748a887656b","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I have an application that allows the users to create custom groupings on a grid (by dragging columns into a grouping area) and one of the columns is calculated dynamically according to items in each of the created groups.\r\n\r\nIt is a complex calculation and depending on the dataset and grouping configurations, the datagrid may need to perfom this calculation more than a thousand times.\r\n\r\nThe user may abandon the session before all of those threads finish working, and in this case I need to cancel all of then.\r\n\r\nAt first I tried to use BeginInvoke passing a callback but this created as many threads as groups created and the context switching gave me bad performance.\r\n\r\nThen I moved into StartNew with the Default Task Scheduler, but it does not allow you to control the maximum desired degree of Concurrency.\r\n\r\nThen I found one library by Microsoft that implemented a class named LimitedConcurrencyLevelTaskScheduler which allows you to specify in the constructor the maximum level of parallelism.\r\n\r\n[http://blogs.msdn.com/b/pfxteam/archive/2010/04/04/9990342.aspx](http://blogs.msdn.com/b/pfxteam/archive/2010/04/04/9990342.aspx)\r\n\r\nMaybe this is a good case to use StartNew but in case you have a better suggestion I will be glad to know.\r\n\r\nI have your book on concurrency and I really enjoy it.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2015-09-28T14:57:55Z","timestamp":1443452275},{"_id":"0efbe75a-b2fd-3aaa-a63f-698c40c45e35","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"In that case, I recommend using a TaskFactory instance, rather than Task.Factory.StartNew explicitly. That way, all the tricky options (like DenyChildAttach) are in just one place and you don't have to worry about them in the rest of your application.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"19384973-8045-3004-846b-69ca6a53261e","date":"2016-02-16T13:33:35Z","timestamp":1455629615},{"_id":"19384973-8045-3004-846b-69ca6a53261e","authorName":"David","authorEmailEncrypted":"ge+jAqgaHp3BrUpSq+kxjrZYMZAlYLFT/Fd4MoUCh3iXKakmIB4MIxOsuif5ZbdkkiqoTfRVsQKiojD/yEOjE67im2vJG6l+mMNfsCn5Awvr6arfb46Z84lgHf705cNHFsK/xJ9kzZkSsTZODnr84qSnQvN7vOdbKb8K0Rm16oKD9BbPKkpriXQ20uxbXhnVTGBqyf9Tb2DdQXkYredFF9tFE6mq8hVoqzbnRN3KMNLlq6y85cm6dheLif4b4BvYG+3jsgep1xvBvKyLDr8qRRN0+AQHjhwOuhnxuVD2Qre7TsmNVRQlCkSCv3kxHFTgApkhqBCVJhvrnvnMSpS7H6Vn9Ucl7LeziHT5NPXC1ADIy3Im+P7WwHV/h2w2mbh4YFe84zmkSOINZjJtEJg4zNhKNxDLIDvkGZoxcaq2JaeFB7pC2v1wX15+MT4Q9RCgSSYsoVGXhB44Z9dzGgubVQkPmD8gsIouj2bx0JdV0Ej++T377iirnolIqhXbB+IRT4X9y13JqrjFyOqjxOd1Zrb94nsHHt1BOgGb1zHGX6V8tOBJ5FjZXjXM6ul0GDRdpBjMeGHaXJZejrALDLSsPgQ9/itV04Ta7Dy52OtxXzzk7EFWHCb7yynEuzfz7vucdcVDjVy5ug7JH22eEcAQjtW/n7QdKMzRUf8ZeZWrEQo=","authorEmailMD5":"c89737d078faaf58ba7e90a29ca0c12c","authorUri":"","authorUserId":"disqus:disqus_adZ54t8EJt","authorFallbackAvatar":"","message":"I have written a report writer based on the Xps document library. The library requires that the process be run on an STA thread. The STA scheduler open sourced on Github provides this functionality leaving the UI thread responsive so I need to specify the specific task scheduler.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2016-02-16T03:09:05Z","timestamp":1455592145},{"_id":"ca6d4b22-d3b8-3edf-8169-33ad67e0bc10","authorName":"David","authorEmailEncrypted":"UwPjg8e6jVzN/boOt2b9LOef/lELWUIpMqRk+X+kWpd6cCvsuynYem9MiUi/j5mc1TVbSsXeZ9AfshXJzDGg0iaDfMhPwJZIhFnY57o2Pe5AulNmKVSDUalVv8iO24wgNX8oLB5uVFg0dzanJ71pOPRGs2lociWZ2rE+Le+h0vroXj7z/zqOC8wUpPNgpXErBpfNKJoDYGTWbjVksTc58ntmeHeBBXtew13DQnS/m7dhS+GiFAsTucDw2Nxt8lEV8MR3eShf8Hkd/AeLndyVeR1+poXav/ERbwtcsqJ8XmTEwRFjVWbcK83JliA+zL3TCI4tZZzAqv37e+U2p0jEApOX7Aq8nDnXgqoXyG2j3sawvrJySqopMlV60PkxAunckXI4AHszcKwJpfMQpfGBd+k72fxV5kI1/TxSHxb0VsWW1wMU7uWGELAFMvc8tYSspSS/sCgj98dEO+z5LSxFOUhl322aFx73UER6bRPaebfUOsffvvdun4EpUpmWCCLnlDSGMTMVB16GBJXMpEOTVXnu23ZO0X2cfQuQQbmR03Ac58wAfaDJEBVHHIpnRsPo5e88wbFZQKUdipi6SZBpVQkUfRDE3oAf9LOELEtUV2H0oEMSHrlnEFoqMWu6fO+Oc3M2kStC6XinmTyIQuJJVASBvAG91mhu5mgbrWYwbcc=","authorEmailMD5":"c89737d078faaf58ba7e90a29ca0c12c","authorUri":"","authorUserId":"disqus:disqus_adZ54t8EJt","authorFallbackAvatar":"","message":"Thanks. Have changes to TaskFactory so the additional options have now been eliminated.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"0efbe75a-b2fd-3aaa-a63f-698c40c45e35","date":"2016-02-17T02:06:48Z","timestamp":1455674808},{"_id":"4e2f02d9-3ea6-3ebb-962a-51afc8d75b71","authorName":"leftler","authorEmailEncrypted":"p+v/KC3qdaYCvioShBWHNsIsHff7rInsc3TcuUPcCN7OL/GV0R9hQ4TRTaj3i3yQcRY8ZypX76d3h8PfTTbCfbKWA2mwZrUPcMo81vJlZfXY+u0IO1pli/+RoWdMKkBIRahQF9EUqWoT7SHbYMQMz93fO9XiXyPREIRuUTsEtRu89YhiGdADss/oVv7KOhqXVfW7+YfZNmYGLqqq8Evb4oI3E/lkDsRF0P99KutaqBI+PUz+5I67XGVLlsg/9hwIv32k+HLMJAkLuEreYj4NLag0KEAvCLQAc002d4W2x2tT4j3K4tJouO+LuqeM9JVG78IHqJApNWai08NkkbQG3C9Jriag4qVZWQsaAVmfusb9KdU1WUcx74zVwtKHQLZ8JSp78KfW8eZRgJjJdwn40Bzjv9C/8VlvBAWKnQHCPX9voB9ZoYW/64upuHmy/54V+/EEFKAmdRlv1rxvnNnYVcdFW7754buPMXX5hXHRF9ISKB8kTFAEADhFbeX0iRpWSUf0EA9kX6C0VHTdRhLcBSPs0UqtNLTEUcqtB53E5PvUAjnSiJ/Hluk9zps9gxlpK8Nw3ltBDJeCF4O1HIqcxznhrBuB2AEebDUKr/aQ2LE+/FuYf66vwaMYT+pp/CJMXEsKXb6Iti7wPMFd8Qnty20JN+JvkBUOezD9LP8nc1o=","authorEmailMD5":"cdf128a0ee0cf38f0a673dbc82a74449","authorUri":"","authorUserId":"disqus:leftler","authorFallbackAvatar":"https://disqus.com/api/users/avatars/leftler.jpg","message":"Do you think you could update point 3. under the \"Why Use Task.Factory.StartNew?\" to mention TaskCreationOptions.RunContinuationsAsynchronously, I frequently point people to this article and that creation option was brought up by a person I was showing this to.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2016-03-14T21:07:06Z","timestamp":1457989626},{"_id":"622a1f39-5a14-3d2c-aa48-285f5b812bd4","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"That's an interesting one. I'll update the article properly when I get a chance, but in the meantime, \"await Task.Yield();\" would have the same effect.\r\n\r\nNote that it's *very* rare to have to do this. The only time I've needed asynchronous continuations is when I was writing asynchronous coordination primitives (AsyncLock, etc), and even then I used the flag on TaskCompletionSource, never StartNew.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"4e2f02d9-3ea6-3ebb-962a-51afc8d75b71","date":"2016-03-15T13:01:09Z","timestamp":1458046869},{"_id":"313807a1-2a39-3f09-8f06-9ca0d53311ba","authorName":"usman","authorEmailEncrypted":"peA6NsQInaETzCYMeVRbbWLwMFo0t6qkezPF+mSjBc8Djin2fbDm1ixScT8/nh4po4fiJU4QamKiF3YNfu4sZLV/k7y9/dAhYrFGmYZkECRanV3DeWB/Uj6tmq7QCvQ9AXltBVUXSjszqHiAP0PWJRA4dJAOEI4iMB5Ofy0iTrhAEpHMgZmXhmAf/ZcsGhso2oYNDNUy+5AQ5Un3ObHb6YvCbZYtSosrUWMHLrk3GoqwwIYaKuTP2LQ4dkmDmDSlgwsIoQ6hZHoRdd0LKfnL0IPMKAjy/NyQKvfbtsHAQoqRYWaWuH3uVK2/uMvJ9aK6LHEM88TFZv9AIk+GUpwfDgq7ot8q6jSZNYYyy+VLeBAw1DxhkDaTBOWFhgQkne8fxOQo9pVP/2rm0P58t1qx5XaR7Z/ZRr1OPjMiCjzG+aEV+wS2sdQpsqdOUSImJ5ZPuAcRLyyU0Evze8gBOhj3YkBa72t6IdnmN8U1WpACJmvB+r7zflhiLSVTQLcfj1F6eJfAAxdGZj1qd1B30zCg4QvhmfEcZ2ENJBOwBmgonpF09FvJ77knyI2ytq7mQthurKDpjaCKygK2JLJ4L8OjBtoac1gWtXoua6mN3I7NtMyNKgqvHeUsUDz3e82Si8qDnliskeNoW4Z6LdkpHD7u39ZWLm/mRmwGPurxflZ5EAY=","authorEmailMD5":"a30f2bbefa16b5a7bfe27b74b0235bc9","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Dear Sir,  \r\ni have a function in which a for loop is implemented with too much complex computation and for loop work for million times .i want to not run a function single time but make chunks and divide million count into lacks. and solve it with multi tasking to decrease processing time ..how can i do use sync task or async and what septs can i take to do this","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2016-05-24T06:43:08Z","timestamp":1464072188},{"_id":"9d996676-e1b2-3963-be28-449bd0052e35","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"That is not an asynchronous problem; it's a parallel problem. I recommend you look into the Parallel class or Parallel LINQ. Since you have a for loop, Parallel.For would be a good place to start.\r\n\r\nI don't cover parallelism on my blog, but it is covered in my book.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"313807a1-2a39-3f09-8f06-9ca0d53311ba","date":"2016-05-24T12:15:50Z","timestamp":1464092150},{"_id":"09fe86f7-7830-3c41-b10f-3dcee7f262d0","authorName":"Marc L","authorEmailEncrypted":"CwQzScG25N9EN4goJiE6B5GhVE2HcKyDzNeDMtyP+6kW/Qdgd7RTa0zWvKm/omHja25yy/FZ5f/oFQscwETO+M9VjdPiwM7r/8hGjGev0hFOyK/ZTRqnk7HxqSpxgP1r2Vmrsrrk8J29ejUfG2oWIAiepkG50uQsYoNtoQq+Qh3+jwzaj+PvvR7yYsNFoKAWub6fHNRXQvK2iJtB7MibZ7EMaTunq/QuzfJ61zXp5L0EJpFCwm5S2uy5BwyKNvcLwJxSTzgArinTF7nS3PaDkeKp8gyL0yLWMWhYQcy0haokME19zFLh6/Wmpf1x3xxM3KWJcFIxXvYbL3/sRB8ZHBFNef/QPdUEczdK3wMLjmnOpv/10yhyS3+fMA1ELzqsDh86E+zk680hcpWehBRwMhmSCqGdln5UfkXom2QrdFpG8O9+rOyoT9HVovzxy8HwvX+ncuK20IV1jf/mXoIKVtCfW7Yd2c7Ulf0AxXYNcKzYYNz9sx1pOJZCG2GdGBzLNE58gsQWsL4BL/WU5HwtXobdmL6UA90TYcbCYPJvwTXmgQuWonJY6/4+3Q5fgIl4rVzP5K+haYGIvB+dAPsohXepGU45siSFCfKwEEbVjEYfBac15euH0KJNrSbYT8ABiPuJy97V+7SDlHcpx+CpBJg6Kyp3eR8T1i1lzprQA18=","authorEmailMD5":"52c1ee2fa281a382362618009ecbc6d7","authorUri":"","authorUserId":"disqus:Mlewando","authorFallbackAvatar":"https://disqus.com/api/users/avatars/Mlewando.jpg","message":"Would it have been better to title this article \"StartNew Considered Harmful,\" or is that bad form at this point? Really glad to have found your work (coming through StackOverflow). This is treasure trove for software craftsmen.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2016-05-25T15:10:00Z","timestamp":1464189000},{"_id":"355e590c-01ae-3992-bad0-ea251eab2c84","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I do seem to recall reading a blog post \"x Considered Harmful Considered Harmful\", which was rather amusing. :)\r\n\r\nPerhaps in this particular case, Harmful would be a bit strong, because StartNew *does* have a use case. Unfortunately, easily 99% of uses do not fall into that use case...","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"09fe86f7-7830-3c41-b10f-3dcee7f262d0","date":"2016-05-25T18:04:57Z","timestamp":1464199497},{"_id":"9c99d7ce-0469-3e3e-ace3-72356d9036a1","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The use case for StartNew is tiny, and I do address it in this article. In a callout, in fact: \"the context of this discussion is async code. If you’re writing parallel code (e.g., dynamic task-based parallelism), then StartNew is the tool you want to use.\"\r\n\r\nHowever, this use case is incredibly diluted:  \r\n- The vast majority of concurrency is async, not parallel (and thus should use async).  \r\n- The vast, vast majority of parallel work is data parallelism (and thus should use Parallel / Parallel LINQ).  \r\n- Some of the remaining parallel work is static task-based parallelism (and thus should use Parallel.Invoke).  \r\n- The remaining use cases are dynamic task-based parallelism (and thus should use StartNew).\r\n\r\nSo, if you have a situation where it's amenable to parallelism (i.e., CPU-bound work that is capable of being broken into multiple CPU-bound pieces), and the number of those pieces is not known at the time the work starts, and each piece of work can start any number of other pieces of work, *then* you have dynamic task-based parallelism, and StartNew is an acceptable API. For *all* other situations better approaches exist.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"efd5d3ad-a9f8-3ea1-ac0d-d5bf54af2eaf","date":"2016-06-09T12:08:02Z","timestamp":1465474082},{"_id":"efd5d3ad-a9f8-3ea1-ac0d-d5bf54af2eaf","authorName":"Lawrence Thurman","authorEmailEncrypted":"LliStuYbNFUSDLudhohJPEjA4wDpQCP0WB1OI7MY61cPx9q7bvTIuFD3quX2KE9h5tzJ8Xcp/GYoK9yAhfDZftzw3s2daQdSnvF47BhDOD3aQhWfVwHvchlIIF/5QegT39cC950a+NtrkheI+JNRKQ8iTNUkOYOsDOWywcHZa5NbekowWR2N8Y5exQlJ1irHKHc+3J3z11P7TA55EHOFga+JK9FYjYDwEEjgBq5X7MxKjfbmm4kcG77K5ancelxFt6fXLr6b1HUp+aGnfbuzw43341LAn4c1h7fajUJND+qZLDJoh/6xMuXP2Au7UVdqRzsmW6xF6mO287dSsE2vSvCkIbLFllWT3p8vq/qq5cTg8gvgZ9vMpasaY6q07yUWUVe2UwBZgwYNe/3IodA3WtpIrICpw8+7E/tGbV1hopJKWcj8ASkzGD6YEWnIWIzExhYbzF0FtrXdw92khW2+4l6WPjjGU2Z7PJwIYLyK0vNb8RKb1dbQU/0hEVFTt4MR3f8vAGGvTRlhHqfeEFTJDY23AYrunM095mdCs+Iy65IhPKaIYY5xiolMCKwCx6ha6saTXviZD7x/EMtPufjk+AJ39zHUAKpjGpcpvYhYkWe2ow2AsP5XYjAXVfj7zCFQfI1Vxo7Jgx/gUQOHQNNmfRtyvcnymMbJyLCyW/IydAY=","authorEmailMD5":"20673212ddd02bfbc7be2f0ac6ca776d","authorUri":"","authorUserId":"disqus:lawrencethurman","authorFallbackAvatar":"https://disqus.com/api/users/avatars/lawrencethurman.jpg","message":"I have just found your blog and do like it. I just wish you would go deeper into a real life situation. For instance, not putting everything into a single method. I understand that you do this for simplicity, but at times it make things more confusing. Anyway the reason for this comment. StartNew I agree is not good for async/await, however for parallelism I have found it to be wonderful, especially for data calls. For StartNew is dangerous???? maybe StartNew is dangerous for async/await would be better","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2016-06-09T11:05:58Z","timestamp":1465470358},{"_id":"2acd6063-f7fb-3482-89c5-63b0a87628bd","authorName":"Craig Brunetti","authorEmailEncrypted":"Gee3mdvoBlK/Ez2W94nytGRlPWZkd5VFZpNini55YVPTnvtH7qSxC7BquDVWaa135W+Y4q5HyRplde1y/bQE/ublgp6p/GspDVw+QnKxYSWiYiLrg0XgjnjQLHNcI8mjDmKfxOMmYlJgJiRi3XvhgsUP1/XeNQOAx2FG/WOKXReSF9Td+49q13hPJU36R1YVmgB+0S6mws/KgSMFGTlIA3CFIojHiQo+edk+VIOxCkKqqeYckKuRw3gX7qCHxmyp3xgQ/NQqmo87ch6rNTosvhZ6epi33ICRxnHcee4AuxEcU1sahpPBvneuUI6yVBFMZTFF6Vo2my0w0nYHbFGGV7xT1ZpXTILsG48sYTBvNyM9AEtWDEttWTj9PVWm55lCYXAsjFttqPOavNJGuLZSu42G1EabB1ByV87qCqk7BS/oBDzalBAWgz5cq0CuZ89kr7/OLHlGjulVAqzxTosXiI0dtbPbGIGcHMDX7hqPWfYZSlcoCLyJOAMkJCYI0WwBZp7FJ+rOJzASomkY+x9nAYhU+FKGtdPcEVdSi3PZ1WmRxQHqZ6X00S2plYT3Wo+nNcHxypUZ6aFGXrgwd40YpK7dOnSKRyqtDMwHLunOJvZkqDHW3bLHc+axiSV4cVlwJhIlFf7zDueESNzicRgdPiL9CuWfJ9loG0AnIsO3few=","authorEmailMD5":"a0c658c500db456bbd691d6ed64b6d4f","authorUri":"","authorUserId":"disqus:craigbrunetti","authorFallbackAvatar":"","message":"I've just run across this blog, and I couldn't believe it with my own eyes, so I tried it out... and, well, wow. But, it still smelled funny... H9uest's objections may not have gotten specific enough to defend his position, but perhaps I can add to the mix...\r\n\r\nStartNew respects TaskSchedulers, one of the reasons it's more complex than a simple Run(). So, fine Run is more simple, but it's not \"better\", because StartNew isn't dangerous. What's dangerous is a code example that pretends that a Forms UI thread should be considered participant in TaskScheduler (which is the assumption leading people to use .FromCurrentSynchronizationContext as a Continuation's scheduler).\r\n\r\nWhen that method is called, it makes a brand new TaskScheduler, from scratch, that represents little but a synchronization back to the current Thread:\r\n\r\n[http://referencesource.microsoft.com/#mscorlib/system/threading/synchronizationcontext.cs,826929a6f7e9421f,references](http://referencesource.microsoft.com/#mscorlib/system/threading/synchronizationcontext.cs,826929a6f7e9421f,references)\r\n\r\nSo, in essence, in order to appease a desire to hand something TaskScheduler-like to a continuation in order to get back to the UI thread, we find one and pass it. But you're tricking out the Task system, by simply asking/passing that new TaskScheduler (called a SynchronizationContextTaskScheduler), you're now setting up StartNew to fail, telling it to use favor your scheduler over its own simply because you want code to go back to *a particular thread*.\r\n\r\nThis is what smells funny to me. StartNew is being considered dangerous on the grounds of code that tries to return to the UI thread is an off way. That seems entirely unfair... because the call to update .Text should have been specifically dispatched back to the UI thread directly, not done through the Task system (and then the next call to Compute should not have... though that's another problem entirely, a .Run should have been invoked from the Click event handler for something supposedly so expensive).\r\n\r\nI believe this will happen with any thread that's not being managed by the default TaskScheduler (of which the UI thread is one). So sure, be careful, but it's better to understand that the UI thread is a different beast entirely.\r\n\r\nSo, all in all, though I agree that Task.Run is easier, its simplicity removes possibilities and depends on instantiating these SynchronizationContextTaskScheduler objects for no good reason... it's waste in comparison to a Dispatch. When every tool has its purpose, one should realize that bad information can cause bad results.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"c7a8aa0b-ac89-35ef-adaf-21f8bdf83573","date":"2016-07-08T19:35:08Z","timestamp":1468006508},{"_id":"d588b275-2448-3402-b9a7-ba0234100d6f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"It's not just UI schedulers that cause this; it's any usage of StartNew/ContinueWith when there could be an unexpected ambient scheduler. I did run into this with a UI scheduler many years ago, and I've answered a few SO questions where others did the exact same thing with a UI scheduler (so it's not just me :)\r\n\r\nBut even without UI schedulers, I've seen smart programmers run into problems with the ambient scheduler. I've seen it happen in code using the ConcurrentExclusiveSchedulerPair, as well as the old StaScheduler from TPL Extras. The ambient-scheduler semantics are so tricky that I'm aware of multiple code shops that wrote their own code analysis rules so developers *have* to pass an explicit scheduler. Which I think is a great idea.\r\n\r\nSorry, but I've seen enough people bit by this that my opinion is still that the StartNew/ContinueWith overloads without a TaskScheduler cause developers to fall into the pit of failure, rather than the pit of success.\r\n\r\nNow, if you're using StartNew/ContinueWith for dynamic task-based parallelism, then sure, go right ahead. I haven't written anything against that usage (I still always recommend an explicit TaskScheduler, though). I guess you could say that StartNew is dangerous like a chainsaw is dangerous. But if you need a chainsaw, then you just have to learn how to use one safely.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"2acd6063-f7fb-3482-89c5-63b0a87628bd","date":"2016-07-09T01:58:35Z","timestamp":1468029515},{"_id":"61894417-ded4-3cc6-ba87-f188536c6d43","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"That would be possible if DoSomething returns a Task that is eventually cancelled. In that case, it's not a \"problem\" with Task.Run; it's working properly. StartNew would just be ignoring the cancellation.\r\n\r\nOn a side note, you should use await instead of ContinueWith. If you use Task.Run with await, then the code would be clearer.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"d38954ec-2c27-3f54-9071-7f316db7b74f","date":"2016-11-15T14:06:51Z","timestamp":1479218811},{"_id":"d38954ec-2c27-3f54-9071-7f316db7b74f","authorName":"Milad Amirzadeh","authorEmailEncrypted":"eDdnBdN5KjW9VQAabEB4R5hfIINbzGr+9CyfeHt5LsYo+kJHUr/W3ckuL8U7UiBJ0a/MXeOJjj7kzEf3I6Jza3BNICl62hIgxQFRXf+Ao340MPKYNn7DYdMmdedTzQSu2GrlbGTQuIeSG71YcOg+cEEvy6vNp6Crvgk2g0bu59GzkMTfO4YXjCNnRRwirA7VOLuYVrvUGlxAtiNdhgRAXtqdwzKDLMssDilu/Vk57S2WdYPzqbqj6BvH62nh8aJrAn11T7HEjfgTLgdpV4NcE/C23FHFnYUTH1x2XiVXgMTemFBjeLfsMVzMC8IduSPInB10f2uBsow5xqhrWYobZlFTlYkV5G1yfrbSFZzrGOUS5fpAWBBtwrMttHoAP8P3xiaxnP+kmIBxcDbwV8t14mDbuZxt9epvQL8xc0Iek8PB/5MF8ez0TuCUtWyaRqo7W53vI9qs1QEfei442ARyFLu+Tr9UcF+Myn5tSYzybduQCKsqlBpcdqY66oOI+83ZAKrNo+cvrUyB0rwswLfM8K6NVO294mVD4vov6Rn/lU3tjgvKuUOFwg+D8j/Wefk+96WFSnuwDViqoLa+JkESCej7uq3PmNVeVeF02sQRWU8XVbFvYY6syfDC3sHPM073E6ItsFOj819KUfZJMneJfaHG0UN8Vzsu2r+qtX3Rcg4=","authorEmailMD5":"587fdbd7e35e921ce6304fe60640623a","authorUri":"","authorUserId":"disqus:milad_amirzadeh","authorFallbackAvatar":"","message":"Thanks for the article. I might be late but I appreciate if you look at a problem I have with Task.Run. I have these lines of codes:\r\n\r\nTask.Run(()=>DoSomething()).ContinueWith(t=>Log.Error(t,\"Error\"),TaskContinuationOptions.OnlyOnFaulted);  \r\nTask.Factory.StartNew(()=>DoSomething()).ContinueWith(t=>Log.Error(t,\"Error\"),TaskContinuationOptions.OnlyOnFaulted);\r\n\r\nAfter a successful run of DoSomething() the first line(Task.Run) throws a TaskCanceledException while Task.Factory.StartNew works fine.\r\n\r\nThanks for your time.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2016-11-15T11:18:05Z","timestamp":1479208685},{"_id":"8e318159-0917-38c0-a8fa-62de2c770d7a","authorName":"Milad Amirzadeh","authorEmailEncrypted":"k7gSkwt/dxCMTK4RlVJxLKAShyxQ47omca8LdgHCtj4fnLFUCqla6UalPcPl6H0ZLzwHty6t9M5Fy1CePXX0QZu76LEtVt678XJQ+HJuClGhzQUyknblra19hSFewipkp+sd6Cjh42PbUqVJBbLoSWZW8R3H077voFD9iz2aN1l9QMj49e9NKeYnHQrrw+L92LKKLLAxskvqJMvtXUTqvjxxDZOAMGun2ycyc9rJavdsQ/tFvC2FysSRMs1HeAMZfdpk5mSvfuWjDiMZGlhe57uNyKwvplvo+derFZsdN0+NOlJCml0SXkYBCJ6qqX54WTgMhkh8RH5wrznOcPTQ49u8b7JEks8etIAiQzA/xRB+FJ6+uNBe0am4xc6bjDF7k1nsSgJkQ4KG/S5lL4ZwRyFKsEbnMjjgbR+13YJdddWs6WPSVjvcTrIwET8989qkbyJtvESEZtuR2uTF+tJLPwKtKRdLSYiYguRsBwZh03JvUYYDcuwhp0C76oE5AzVliA8/i7AXSAT0X9cnQQaq6BfFVqHVgQWtnKXZOK+GorycgtvodEkwWtZXtwyQRmd9WZFRbbYMSCer5CuKP8g2cy5Q7eWL6ryX2bK3+bn3jBw7+eN7YRBb9A58ugrecmt2bgHH5rYV6dmQvwxREaMldl06w5uX67Srt9S4gWtRlkw=","authorEmailMD5":"587fdbd7e35e921ce6304fe60640623a","authorUri":"","authorUserId":"disqus:milad_amirzadeh","authorFallbackAvatar":"","message":"Thank you so much.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"61894417-ded4-3cc6-ba87-f188536c6d43","date":"2017-01-02T12:51:20Z","timestamp":1483361480},{"_id":"05c6b04d-c681-3b38-82b7-7c2a70eb4dc4","authorName":"Andrew Francis","authorEmailEncrypted":"ivIXGsZzdmUw4JiuUO+EJr3XmZ18z/rmUAik5O6w/tGUQuDQtTxRl+jrlETSUI6SeBXD67B9+JR/OFynjA/rFybv7aWtHAXiVNlwpZo19xjHgT3L9BFVBQGZX8BlADSOA82jppKNdHqfQI7xa+LbkOtd9eavlngdClArSan7nNUuTkbzpUUyFtjzXuknlW3vVvR9Ajlmf+QzTJ1y3uNnbD/Tb8CKa7EuGrEfZl6E+5U47SuIWIu/DjyXJea/DTSe9DZgphTqkOKSh/+IMqimGZhVD8DEfxh7yoKaZzAn1Hf5+h3xwP0RX4qQA5UwBW4G1QrTuCxGL7trVGYVt+rRN8eZfbIXqjOFuK3xORzgF+7tB31coUcq+DPSTLsZ9IhKOoG3znNKt4q12soSSdNyKJShD8me/RKZfomXdvFvl6CNXzbdWKvX1X7jWT1u6hMQlG8X/Xg9ZndYVAYEw96P5ALnwHmvyWicrBuH+cT+XXNS+2J3aF6OIQHNhi3JDOzrrMyDNmK6fI+bD+324/0JOmzmPXEh5x5/MZ83LugXThryzAKDyudO65zvcWSE8QG9tbnUSJdbHmKZYV2r/T+riqSU9z/7uYb91HFEcVkZV2ZpAC9/lMUp0gcQbUqChaH5JN9D8Gd46uQS0l9ju0P+gu1D1PcNMP3kApVmXcU2FB0=","authorEmailMD5":"cd5672ed264d2747b735327eb78567e4","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Aww yeah, it makes sense now. Thanks for always being there!","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"c01365a5-e3b0-3a35-a88e-f220572c02d0","date":"2017-01-10T15:45:07Z","timestamp":1484063107},{"_id":"5b8e4a90-26e5-34d0-a936-28e7f8cf481d","authorName":"Andrew Francis","authorEmailEncrypted":"aNG/DbA8vft7VVMXVQoLppebZQY0ZHBDqXGKA3621eW8Di5QdNMR+UGtuSISCRuMIzb0+1TQVAzBcRUiwJ0afDiY8FYl7I9dHnA6EdfmCCbGnD6hgaDGZvj9Z/1/aWR1d1Yz+7f+dM+9snBOsjC6TE4Wjkzo9RBN+3R0if3tjvfLwvrHxaDOrEgQiN1SKgGYM3u+tSaAZi6A1CN55ou4i+xEcRQ60Z//EMCRS+8kGs+jH3ve0uSswnPm7R8a0LC4n+HIRenRkEdxRcIUt28EckghELYmlw5RDHsgxT6TQiMfl5oo7cZla5GNfHWJs8RoF0kosdX2J94Nv8Z606IjRFShnUJn2DrM/tV9HvE9ZZbmWBMyozoJIhubXVrBevWT76p3nGBWwGhaUAjo7gprie+pZXovXJrw1pmxZAx2YifH+CSmBdiuEMw03+0WEHjnHrXwvYhi9qUvodXMDZqMwjIwqmx5Y0rrv7CixjNqYksuR/jbC2+7xUGRbNmqLTbfo5pYS8P9dSDaf0SdxE+gcobvZ9GL4PetOBOU5QjDw1G4cTgni1CkwQIv1SvhBiT6NUXT9zSVgH3obmQht1f3802kviTvWaqeJ2BWhlEIuZLsXAGRzql7/NBQ7qTMT3xe9Vacq822JiJREFfWm84E/UbqG2S4bCcFnDf2lUU+bAg=","authorEmailMD5":"cd5672ed264d2747b735327eb78567e4","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen, how come when I try this on WebApi I get a new thread from the thread pool every time? Am I missing something?\r\n\r\n[https://gist.github.com/anonymous/128df0ebbf01e1ffa8bccf2c0843b9d5](https://gist.github.com/anonymous/128df0ebbf01e1ffa8bccf2c0843b9d5)","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2017-01-10T00:06:52Z","timestamp":1484006812},{"_id":"c01365a5-e3b0-3a35-a88e-f220572c02d0","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"You're getting thread pool threads there because there's no current `TaskScheduler`. There's no benefit to using StartNew even in that case, though - Task.Run is shorter and has better defaults for the other arguments.\r\n\r\nIn production code, you would not want to use parallelism on a public-facing server; it could easily kill your scalability. This is true whether it's StartNew or Task.Run.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"5b8e4a90-26e5-34d0-a936-28e7f8cf481d","date":"2017-01-10T14:13:12Z","timestamp":1484057592},{"_id":"7584cd69-a03e-3a9b-91e7-898cbbcc2323","authorName":"gökhan","authorEmailEncrypted":"frW8rYIiWPCT2dFt1Y6PiXD4oET1q7M59juwrfmp/iNWCHQzXy7yGPVY2rnJIERVQw6DetVhxsxwox/BQlfXidZapOwBWnUam7CPfMzD8ikLHBhWuJj0MWvXC91o7qQ9fITnh7L4fHIZFDHIGx/mz67DsiVOBYTPFSj+njgHmt9rbbZqaLvkj6WtXhBaykHcmkRIc+OExzTLqFi98UNM+rlYgTji4bdBDI0h/dbX++W/DNH0ucbfO3GiJmTu3CL9YwKqqtaC9+q2aIJVU/aaXBLS0drqN9CE/TFiFi3qggYydAoE/cgq7xYK4ptlBj+nQrc5YPFptVNsI6c9fcnr3C4NWoxbyuSO2JTXKwPntiB+RYR5P9zbg3GO/1qUbpv75PpHUJqNUYXyzoKTX7L1c5uh/g+KtrkENu7dXsLagjg8yFqb4D6ohpkounHn/OyqjlP4kVGYpOWHI+sX820kx4nKpyoawM/eaefjtplTwffWVMoMpQql/aQ6+x9u9P1Ktzu2rW0407I1zCstfQk4WxkX+qecf8V7tM9Y6EES22BCel60UQL//Z3VjbLwc2pXuEQlGvdzNQzmwW20/H78rXGnmmEv+hPHb1V1+O2rmPo171nWL6ozCtYtIslE6NGgtMzULjtokIdmjmQfXxQueRXEpzX8TUxhZGM3mNzRc8o=","authorEmailMD5":"35cc850e3c96577ab31cdbef44c322da","authorUri":"","authorUserId":"disqus:disqus_1jnwzdtCHq","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_1jnwzdtCHq.jpg","message":"Thank you for important information. Let's say we have a loop that we   \r\nuse try catch. When it catches an error in the catch part, we register   \r\nit to the database using a method named LogWrite(). We do not want to   \r\nreturn. Do this, but continue looping. Fire LogWrite() and forget. Which  \r\n one should we use for this? Task.Factory.StartNew or Task.Run ?","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2017-02-09T08:39:48Z","timestamp":1486629588},{"_id":"cc7fc363-ced8-3bf1-8713-de57ff42712a","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I recommend not using fire-and-forget.\r\n\r\nBut if you must, then Task.Run would be preferable to Task.Factory.StartNew.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"7584cd69-a03e-3a9b-91e7-898cbbcc2323","date":"2017-02-09T11:43:32Z","timestamp":1486640612},{"_id":"9b4c9fd5-4479-39e5-bda0-1ce26e7a03f0","authorName":"gökhan","authorEmailEncrypted":"Z4ct1FgsAO27ScLbcssWf3zuejEBl7XR+fKiE7sOAVZxC/xuUg9NAi7tIG5XRvuYsK8rwTf681kSV8ZhY8ri7KdVd62do7iWMLdyeGU6BV1kKOc9mY7JlJkF0eFLKN7PMmcEYoX6RRvBuGLDHq+q5FOCA8pVFeyJx+C1Pqt8+r64l8w0VFRJOe7W+v5KAcIPvxnjr5SSlZ7QnGPeZ0T4INuh4KN+noN9xQiK8uLP3B70YuXc+kVlcD0AiIX3codTt2ZrGo2OEg46hPeHYrfrYPFocEJqkXOASBJ1Z/TS9qJrs99B2nZcYD/zpM1EHjENBeqnRB8u/4W/ev0EEQTC4Sgik1yQyF80U1PW46UdBONAtJYzKjpSu8PVU25x3uM9lPzqAs7B/B7JpGQwKHpF0kIdCcSwiIPN/lxz5qWQMb0Ya3J86dKTLw2qKDKV/pa/kAwVNur/XVQKssUuUfBPg8ky+h/e2jEXUIbj7vHqFmw3mrKEZBwmltXR5LpBrbEL5RWhDg0OX9kUTHcstxgz8X5eKBaWGvyHNwdkYjmq4sc0XN6ra9YuGs4MqSv77/0V86wWKTe2jHi933SyvxZkYVmcUu850TF7MCqtcYl8nNvcZuvtiZxMa+hJENajPd0a4cct9srRsoshlPxcjv8yjcW9G1vNaEhZw8XkxU6WLbI=","authorEmailMD5":"35cc850e3c96577ab31cdbef44c322da","authorUri":"","authorUserId":"disqus:disqus_1jnwzdtCHq","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_1jnwzdtCHq.jpg","message":"Thank you, i using live api. I need to save time on every occasion. I using Task.Run.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"cc7fc363-ced8-3bf1-8713-de57ff42712a","date":"2017-02-10T08:05:13Z","timestamp":1486713913},{"_id":"57978e81-d2b6-310c-826d-1af71d17f69e","authorName":"David Wright","authorEmailEncrypted":"DyEksCNyG6gAu0PUGRCCf7QDBNDm2k7ATAdTW/URaTnQMAH5cSuHoULuQqiogoFqrMbpqt0RjR4JZg13+R1Mse+DaqpzvzIF1AFxGS9I73w8J7KKFGvQ0lF8nWSMKz1elNdWdrvDRJAjnH4YHL9YoeeE4wgG564UYpyIZcckjK4cIFAPbJf6Ohzsf58TJJAoyyUSpVudtmuLe8+D9Lp2xT+vD3a7sKSHoTI6ZKjTBf7b6VbT6tGbU6hc1RVlHVg4qgLvrZJbsIem4MHWo2bdyI5AClssfBMkNkDDaFGxkcB7ztDwkuT07euxusmtkdnTKpBiMXU8GexB0JKNfN8RID5CrqZlVOFdT6B56BcXz4YTpVI+QzMrymi030okvfQXPmAzdM3OtoncQ4gg9pHSt9FO+TVW1gLF3roLatJNQf0ibsDq3jca8aNDImFXzk0N6wyETsqn7umfzM4q0GIU+JG/5gzM5LynFzg5xJngzPyQd1Knt+vYRRE+E0WALZLyI7rMGqpbiKKkHzdLgx81mTKN6+r4/VZHtfMDUQO+HupQ3RSVQJMZaP9Ix8E2n9mvqD4DDhPXAtgRZFFF4z5qsIfoRxI/JLSYXkmRM3JF8/94zhueFc0+G4RzLXTzXPWSKw4XQNEh/VaHTGr5h3tkWriSA/bxKHn1FMOPpCP1gtA=","authorEmailMD5":"493e9873244c4ee952e775e7f5dd072b","authorUri":"","authorUserId":"disqus:disqus_gFHel0qnPC","authorFallbackAvatar":"","message":"Does the use of TaskScheduler.Default below constitute adequately specifying a TaskScheduler? Also, in this scenario, I really really want to guarantee that the thing being started is on a separate thread, hence the LongRunning. I'm under the impression that this is the only way to satisfy that guarantee, i.e. I can't rely on the ThreadPool for my use case? Is that correct?\r\n\r\n this.cts = new CancellationTokenSource();  \r\n Task<bool> commandRunnerTask = Task.Factory.StartNew<bool>(  \r\n () => commandRunner.InitiateRunOnNewThread(),  \r\n cts.Token, TaskCreationOptions.LongRunning, TaskScheduler.Default  \r\n );","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2017-05-20T19:33:54Z","timestamp":1495308834},{"_id":"948970b5-9e6a-3d7f-add6-29d33352bba8","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, if you explicitly specify TaskScheduler.Default, then it will run on the threadpool.\r\n\r\nHowever, LongRunning does *not* guarantee that it is started on a separate thread - that's a common misconception. LongRunning is merely a suggestion that the task is long-running. The *current implementation* will start it on a separate thread, but there is no guarantee of this behavior - i.e., a future version of .NET may decide to have a separate \"long-running thread pool\" and just pull a thread from that pool instead. Or a future implementation of NetStandard (e.g., one designed for embedded systems) may decide to just ignore the LongRunning flag completely.\r\n\r\nIf you absolutely need a separate thread, then use Thread. However, based on my experience, the probability that you actually *need* a separate thread is extremely low. There's a ~95% chance that you should just use Task.Run.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"57978e81-d2b6-310c-826d-1af71d17f69e","date":"2017-05-21T12:19:52Z","timestamp":1495369192},{"_id":"c11fc2f2-725e-396f-bbf9-0c597cd22e3b","authorName":"Brian Keating","authorEmailEncrypted":"eQIRslBQwk2tLJil+AEehryks/xuugcyJlWp2BtsARxb+lYI51oyFS/dnc9bJWIm9ZmFkkDNKCeFiOtHSi7tRGA2FX0J9YOGTw59ADQ7ZbqOOj7fLt+EB5smyv+DBdox3mmWFV5aKxUF0ST+eo+YWuQI40mnZP3J7euQuVsUAX97swv8SP1yFW8Ga03w/1+qCU+h5pyeDGMaL7BBO+HVFyTWgzDWqRVfiOeyNrj/DPfQwrxWirYFAFMTjMGkrkWKBC3M8HiIQclgKILFR2gv24+xA56jnnxLf+0AsqzomXeEGbHZUFOiN9JVpenSTcXJ2req1LyHr7f1KXBFvFFafCnrK1rH/btcKho8cDshNB6Ex8eFjDAa1zwlrILiAOZGICoA7gDkADl0OECMmZxjVpnxwsmJZ8FII/LMKszjOjei4d0Px43kXQ+ZbCTjDe87G6wcauy4+0yj1F67YFrI8f3pgoZj+WtZ2qF3Pi4DDdenrh+fnbjlgY7kwiCsfXvWBCsKj3DD8oZYiCE1LWflBexzz9+ZsKjcrqmE4A8/93tu+lHW7i4kndcSzBEmIulXAyZwipMiLfAnGg+CBJO7V0F5Ulz0NEtJci8pJzM2n9KBc8Q53sC2Hmc0pNORMNNf4IgsPNWG09ytr7LPc9Brp/FAkQU0wH/mXgvqme5Zjyo=","authorEmailMD5":"a99911453d5e23ffaaf762168e14f40c","authorUri":"","authorUserId":"disqus:disqus_5juJQnAlIv","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_5juJQnAlIv.jpg","message":"Task.Factory.New can understand async delegates I believe. However you end up with [Task<task>>] so you need to Unwrap the outer one","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2017-07-27T14:39:49Z","timestamp":1501166389},{"_id":"70b2ab7b-0014-3853-aef8-67991e17a293","authorName":"Santosh Jha","authorEmailEncrypted":"m8CuP3RIt7/wtG4S9+9n98+c55Rwx3TToA2j5xhZe7bIhp3IPwrRMXLeXAPDPXbpxzE+6X2LSBBRZcmvKJeIlSpjjWCi1t9WIH0nhfqOabS88UEHLDr4luqYohFHeipK6X9ONaui+irKCmb55UWb2q3lWlL++eVhX84uvl3qRLAe/QKkhnsKSOPu3d0lKdyrs2UMLkne/+QiGYeboIfSa9O+8SB6h8p5wAvMCoVrT277kuA4PiBujeNQMxKylyngeuukTrTaqfDFhJ+9v97mwFoutLfoyWOXW88EcSw9IQTRsztvCZJY8uOurXbTK5xONpHYDqYrjcjNuaPj0CyTH/F2/0ih2vEMcv1riawvr/TFGAX5HvYzIHzySggK2E0YIelXQ+ljv702P5I3srPFL4Dttl7bld1mcaYlQZp32wWjIGg85U6PB0wYfK4i5gHOFVLepMma/+Ij/KjLAmBv/aJcXDUogkzVuGoHhK+O6m4wshB0bAgAes762BuA0+10Wxza7nvB6bvTSVpraJyLtFGbA6KN+kSAxmj/eDIabVpyWyM0W9darTAkNeEh3ZVu+zPt3AQNaDgZaMC/RehGUhjYavyY94EqMcnAYyCnNB2/SMhT3i5E0aZK2WAqKvjIkLmlsIZ7uzFdKkmqN2Z7SjB1i4QloWIVATqej9wwDsU=","authorEmailMD5":"9f34f2494befcf3bad0aad393063e923","authorUri":"","authorUserId":"disqus:disqus_sISt9TbOob","authorFallbackAvatar":"","message":"HI, after reading the blog, I got confused. as currently have used Task.Factory.StartNew () to call a function which is responsible for calling Web API, and like that I have 7 to 8 methods (sync method) which called in one ACTION. So have implemented the Task for calling all the API in parallel. and To harvest the result - as the Task got started at the time of calling I have used TaskGroupPreferenceList.GetAwaiter().GetResult(); . Now i got confused that whether i did right or wrong.\r\n\r\nAs per you blog I should use Task.Run () with all the Sync methods and club all the task with WHENALL() and then get the result by using T1.Result,   \r\nCan you please have a look. and I do not want to use async because the i have to modify lots of code as its already in production. I am using this to make faster call to the webAPI.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"9c99d7ce-0469-3e3e-ace3-72356d9036a1","date":"2017-08-23T09:51:36Z","timestamp":1503481896},{"_id":"d8598b65-72d9-3245-ae4a-ae1adbbd7044","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Asynchronous code is the ideal way to solve your problem. StartNew (or Run) will consume one extra thread per request.\r\n\r\nAt the very least, I'd use asynchronous code for the WebAPI calls, and wrap them in a Task.WhenAll and then block on that. That way you're only consuming one extra thread for all of the requests combined.\r\n\r\nThat said, if you're fine consuming extra threads, then there isn't a need to change the current code.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"70b2ab7b-0014-3853-aef8-67991e17a293","date":"2017-08-25T21:16:18Z","timestamp":1503695778},{"_id":"69f0d490-db90-3525-85c7-9c0715efe877","authorName":"Brian Keating","authorEmailEncrypted":"GUPT6KULuTra71zH0YwjixlMvks04tnaojIwYeN8Zqq6b7zd8HiCjshoAHGQGbAsWUDbm+5CQ2lz4ExrAzQYfOc3oMluTmvHtGIj9i5Ey7rmlKZAIgTeibKEa11N/lTY84jnaZbKGlXBqpa+q6EJH2DRvZAabU8f5z8RgWXxYhvfic3NJze0r4POV0oQXj4IJ2aMZM+fdXskkLmEklQUbi5/Dm7GSo3+9lqnjHt0++asMkbjG1HeyY5HmwgIOJvZLIOOVpsEzkhCT7yODwplman78ikUyymlF4LW5edtuEwlHvwgM5TGEbrsKQyQUnpJwwri1t1txw6cOTPaG+UgsC+Rq3asMYt7luxtz3C0jakVqWc0+8g0dCH63Oit70l9lW4g3u+30B2sJW/UZM70UEgmOc0t+PgAq/YanAdet7UGCPHu8ynSh8Pj68IVDnK9N/PmWRVtBlXFNwTO4l67v4XOfdK2JeJdldjZ8VOYZjOFSDp6UhuZoFolXiYwCGZZum+rBjcnNeic71fTUQkxeqWaJD7WwWSbhs+UBbCabu5kMqX250oR1riiTeiG81GKB7zJ7O5ZMB8KctKB0vNYRK7kW6TsKrtUKysqyvV/CGz8Ri8ZubzpbfpJqUJFxJLKatVYxu6UWSV+WNO444CROih2IueIYkCAUMa3kqNp8F4=","authorEmailMD5":"a99911453d5e23ffaaf762168e14f40c","authorUri":"","authorUserId":"disqus:disqus_5juJQnAlIv","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_5juJQnAlIv.jpg","message":"Ok agree entirely   \r\nI must have though you were saying Task.Factory.StartNew didn't allow async delegates full stop, but reading it now it's clear! I retract my comment.  \r\nNice article.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"cc6c14b3-694c-3a67-ad4d-c6262d4ab497","date":"2017-10-04T20:32:52Z","timestamp":1507149172},{"_id":"cc6c14b3-694c-3a67-ad4d-c6262d4ab497","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I disagree that StartNew \"understands\" async delegates. The wrapping is the default behavior - it's how the types flow without consideration for asynchronous code; if StartNew understood async, it would unwrap the tasks automatically (like Task.Run does).\r\n\r\n(Sorry about the delayed reply; Disqus has been sending a lot of comments to spam and I just noticed today)","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"c11fc2f2-725e-396f-bbf9-0c597cd22e3b","date":"2017-10-04T16:24:47Z","timestamp":1507134287},{"_id":"5403a2d0-9545-3c81-83cc-ce2bfb2688ed","authorName":"Stanley Toles","authorEmailEncrypted":"btH2nSP+hwtBozRWtmxI4qrPXmdUTLKMfW2nt+bFbQCXzCtpHQC9GovK2jD6J6WxSBINV9Dx7kQGIiF+iXqUqtEu2bO6RDKEyYhMszvYhtHyEIPldC3nvgv6FzMlOF/RIK4o+cJ6LR11kAsXj81Tyt3cXJatOqKr722yZXqbNjesDf0kA2Jdi4haZrnG6FawsR8NnR42er+rC/xCcsyF7/lCj7sZW51tIlHw1SR4wqkJDJ69CoPfjuTzLbrG6nnjadRsG4vWQMWaEWBFFpYbycnno7+9jObIN63YS+OmIlGpD/wSf1eDbl/wUFCQTvFcpB5V9xwsz6epu2WLR8jHhx4cOnx6DSjUpYPs7GHP0Oarwl0grC/wL2G25Ci80ZjWZKu9F2FjvTVYKMm4KbAzeanOjGfeBs5bm2wZSTl2HDV6pMUSX2Yvi2PEK9ukRnSruunhm7G7UwvHnE91UbTNGtCtmRBMg3oPktDpuJFpxVQ7WODv8jI9mJF3jkQLXVWys48zi57NIR1X9P42oqOBzohQSeD7Nzu5XjhYnf0oq6GGPGU4Au0lfh/ULmxs8khANOz4lMW2gysJu2VEzkobe4NvSfsBbvzj1fE9Yf1FrJk+QmiZ5OyYKipcge0NH8K+06C1w5Op1JW7qkhWl5WTzhjaNVVMN5MvrREIFSgyVc4=","authorEmailMD5":"4ab8d3a959128bb3050007f2d8d949b7","authorUri":"","authorUserId":"disqus:stanleytoles","authorFallbackAvatar":"https://disqus.com/api/users/avatars/stanleytoles.jpg","message":"In the second example you said \"In this case, “A” will run on a thread pool thread! But it’s important to understand why: Task.Factory.StartNew will first examine the current TaskScheduler. There is none, so it uses the thread pool TaskScheduler.\" ... Why is there no Thread in the second example but there is one in the first?","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2018-02-01T16:33:36Z","timestamp":1517502816},{"_id":"9353ce33-8941-376e-b4fc-f7382eb1a627","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"There is a thread in the second example; the first time A runs, it will run on a thread pool thread, just like the first example. But the next time A runs in the second example, it will run on the UI thread, and that's the behavior that's surprising.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"5403a2d0-9545-3c81-83cc-ce2bfb2688ed","date":"2018-02-01T22:34:13Z","timestamp":1517524453},{"_id":"965edeaa-2432-31a3-9a3d-715ecd8d6791","authorName":"Patrick Kursawe","authorEmailEncrypted":"GPmKShmBezQPHUe2Krw/W4Vu72H6OLUl9eACTOc5kARmgS9e35nJpB1xMm8tIHc5/KQf3cYYG2TLQNRJRFT8GvYQHBuAj/rcwMjMOabuaQAbZwbrDL3AVMhu/WeQxCwg3+Kzu7ZzZsxS4sJJj1P0U162CX+gMCoDldk2xNdEg8gFqH4uthpDBE9EpbIh6Kcvn2FnIlBASqvC3pgkMMzqACoNZOCtgabIkD7JAw00Qi0CsI7CgR1sx0MyUiErVEZeyXPv7l+Rhw8SIv0DIx+/+ESQSFLpUxYm2xIz6VlvH4s5fAuuJQm9sje0BSif4qgaAgQlSNF1fHl8O7oA8nq4I2CxHn537+THPVLaglbt2gHU+FEkl6fGxKebUyM8Ra9RUsE3I1isuq9bWnF3P9Z5h8wAK7xJSCezVpulGG6zKUSeGhctesDzmLEEfaAxQ3LYHbulfRHFTuNQhgP08WHaZfboF5ZaSVXGUoNX2vf3R7oh1HmqDh4ZykRkHXkd+pX0cwEgX1OAOPMXOfxyqKp7oMaS21sbXwiTFWkpuNXZQGA0rUa1ylqMQ3tskU5Vl4hl8625UmnrSzxHq3LS14dIlyNfMCXXRjISXmtefv2npznBAKly+pNz7/2fhfU4ubnorISRxww+VOYefVUWXGYBQXrbODdBehFUlhISfrUzu6U=","authorEmailMD5":"b20148f6b8a869f4b4264f299bed2c05","authorUri":"","authorUserId":"disqus:patrickkursawe","authorFallbackAvatar":"","message":"Just ran into this problem again. I am using a SingleThreadScheduler to run things for a third party component on a dedicated STA thread, and I had a deadlock when trying to Dispose an object. Checked with ILSpy and saw a series of Task.Factory.StartNew without an explicit scheduler specification. So the single thread scheduler was used, and voila! we had the very classic deadlock. Thank you very much for this article!","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2018-03-12T13:50:45Z","timestamp":1520862645},{"_id":"e9f31d47-0474-3b74-95aa-404571c9021e","authorName":"Guest DD","authorEmailEncrypted":"hYDUUEBCzS1qlAZABPNTGptMFTH7BdEE0SIn/+v57GzvkwWCuBwiqA47ToVkK5MDEbGJotyG2gaRVA6bZfwlRIUGZkQ6tN1YvsQel7QfuRo+MMmOM6f4ovqVo0OEslmKjWwTcjMgjGZtFm9M2tUkxuNIarF333AUhijGDnBOSk6aj0Iaotccbp370NUAYZX4IBvJdVOQnyP8JrTWLLMEtDRW6FtUasppDHJ7sA6JlcjalBYdP8fV0114MQSPEjDBhRaXJYupF4QAC8+YMuSGeTgHGsZ7j8/wTjQLieUNcmkgf+0SznqEEsFtSKut00R1PkhjzSMaRS//2ZGcEbbbtlePthwY3A6G30dN3bQcwhiYX4/7e6gZ00hkHIbAlzK7SP1ogHDrjdq6C/OuCp4jGcqH9V8IdSK62Bz2O7xeuSmXEr54IIKLueXx4WcPRf4XaiLA7Gu1LF4PJTYbp5afvy1y4DpCgSMWfsTyH4yWtpv7npG3sqrh2+jD3sI4/9GXe5wHloCXqtIWZ1phANrt2+A+7fb4BZmCOc39zfPOlxperu9HqPryFprMpCMx4tOfJxKBnO+RL5bAgNbsj7rdZPpv8CFKNkpJd3bWQEQSgNKBXtHX8Ayo/tkUN+b49NVAm0wH6eFNLHXXMn3fql4VHqdNkYAouiec5TUHi6MV5aw=","authorEmailMD5":"ca791bad362f96f061ecaa8b64d2d1b7","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen,   \r\nI use the below code to start a never ending worker process in a \"windows service\".   \r\nIs it advisable to use Default scheduler for running these kind of long running tasks?\r\n\r\nTask.Factory.StartNew(longRunningWorkerAction, aCancellationToken, TaskCreationOptions.LongRunning, TaskScheduler.Default)","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2018-05-02T14:56:10Z","timestamp":1525272970},{"_id":"c8357fec-fa6b-3a58-a41f-5db083f96d7e","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I would use Task.Run, myself. But if you do use StartNew, then yes, TaskScheduler.Default is a proper choice.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"e9f31d47-0474-3b74-95aa-404571c9021e","date":"2018-05-03T12:09:33Z","timestamp":1525349373},{"_id":"1ab6ff5e-db79-31e4-a2e8-39fd81324165","authorName":"Saravana Sankar Ganapathy","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hi, i'm using code like below. will it cause any issue? Does it run in synchronous or asynchronous ?  \r\nPrivate void DbCall() {  \r\nTask.Factory.StartNew( () =>  \r\n {  \r\n lock ( _synRootObj )  \r\n {  \r\n// performing db calls  \r\n }  \r\n } );  \r\n}","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2018-05-24T21:59:47Z","timestamp":1527199187},{"_id":"1d4cc85a-54f8-3591-a70c-61dd06b1d434","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Hello,\r\n\r\nThis code can cause several problems. It has all the problems I've outlined in this post. The code runs synchronously, possibly on a background thread.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"1ab6ff5e-db79-31e4-a2e8-39fd81324165","date":"2018-05-29T23:34:24Z","timestamp":1527636864},{"_id":"10cb80e2-a572-3268-87cc-c445c50f3b3e","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"If you're sure that there's no current TaskScheduler, and if you use the appropriate options, then you could get away with that.\r\n\r\nPersonally, I prefer Task.Run even in those scenarios because the code is cleaner and shorter. I would only use StartNew to avoid closures if performance testing indicated that was a problem.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"3a18d52b-aa5c-3ac1-9859-e35fd101681c","date":"2018-06-06T21:12:13Z","timestamp":1528319533},{"_id":"3a18d52b-aa5c-3ac1-9859-e35fd101681c","authorName":"Piyush Parashar","authorEmailEncrypted":"","authorEmailMD5":"1f4a1dfa8e2f8ee38c5608d964d6abe1","authorUri":"","authorUserId":"disqus:piyush_parashar","authorFallbackAvatar":"","message":"Hi Stephen!   \r\nWhat if I want to do Task.Factory.StartNew inside a threadpool thread already and not a UI application. E.g. a WCF operation. I want to process my incoming requests in separate threads so I start a new task using Task.Factory.Startnew. The advantage I see here is that I pass the state object to my worker methods using StartNew to avoid closures and allocations.\r\n\r\nWhat is your opinion here?","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2018-06-06T04:06:15Z","timestamp":1528257975},{"_id":"7df3f370-99b5-11e8-8d30-1bf63827e222","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","postUri":"https://blog.stephencleary.com/2013/08/startnew-is-dangerous.html","replyTo":"","authorEmailEncrypted":"Xqyzql2vc9OohOl0NCGKBf6Vw9rEgaPEzTbKPMaiA+cn/Y3ebbGm0BzDsOhg3GgPJVsDobmvRu0WdJf2EcyuGzPx2dQ9dU3JeXxeBn4fJ9KGCPwjValmByp3oV2+w/nTc8eselFF/m9zXGVILsHizgwC07vgG4/PYv8BQSD/haB4VoBHT4UlQ40Sl3DhO8z0CdiT5K4I4JQGqAAlMK6nBEcJlWnp6t4Ew1qbO4op20/f0VsVN3RsyJUH4e67G6TpgzVIpsFN/zkMDCykW4hHd6srVNMNzjWkqZEVuDGiqxrKuO7FZxqpZ6yiNuSZRvjYn0GXEY8YurF8vVfxVTgg1sCFIpJ8Jjrw7vo9j1INh/HQftvvVa+X3otFaItUWQ0Qhq2bEZk/Y2TV7bmqpso4zxbl+BJib/ykrpuw4dLQP5Rvn6xpBXQkVBy9Ey7Na1TXxl5IXgiSE7UehZrYW1hNtk9vhdRBPilI0GfVIDpZggtnqWyGe+50Z69g923FdIdeEXrMiq8bvlXASSQM6OFmFJUAQ50HbBUvVboRYQVEP+SWGzLsbQ2wNfgbJVKC7uqNqPGmYYfb2BCMG+/BNNL9Gs7rkmsemndwPc1xsJfKqtDq1fB/rDcjaXFrOWGIS6ojelVi4z8jCOD6UWvLzcMyQbkxtQt9t+A6DQM4ijTQhRg=","authorEmailMD5":"1bc84dd9decead284ea89b7df6e404dd","authorName":"Shivam","authorUri":"","message":"I have a console application which is supposed to be realtime. We measure the time where micro of seconds count. Now on an event trigger, i have to spawn around 8 to 10 parallel tasks, where task runs not more than 1 millisecond each. Upon using Task.Run, I notice a delay of upto 6 milliseconds. What are the alternatives available to me?\r\n\r\nThanks in advance.","date":"2018-08-06T20:15:42.002Z"},{"_id":"91a86860-99ba-11e8-8d30-1bf63827e222","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","postUri":"https://blog.stephencleary.com/2013/08/startnew-is-dangerous.html","replyTo":"7df3f370-99b5-11e8-8d30-1bf63827e222","authorEmailEncrypted":"Bq3MYSIcshZZpyHVwg9IxWJLWFdU+mp+Xc+XHwIhcLvbrbp6w3ZNOmhhI1dpsUxMz3r5teRHxUKW1f7RquDmiUo0SbJawU9mm52f5LZWTvwThV38ImrLk0aLnQyj0/fTTUoK7SPUPLqVM+8GFyk9nGupeBGM3ifa0xOmGgy4MCspPwfO8Wz8usFg8Ml1drmqtTNrLrwZz0BpP6uBVx77mX4QPSqCJchyDnfB40e2aOIQRb2EauRI2+qXADf/UKxZi4rWJq2vlPjd1b95XRzaS2C3KZUZdYPTo7Hgn8o1m2dc5uQQ8vPawybtbtSg/6w0AlAGAyMnDIVHeg0SVCCxup6acLzXYj8rps+kfkCpWnb6Gt5Bm3tzsIM+K8WapNS+8XA9XEmWrkIQ0cyneeqevbrEx4nUdWX6MPHOH7bWEd3tk6IHX++Y3e5GxbMwWy6oPvMKVtV2cg2YXVvH7ykoJBkj++5CegpEU0Qdr3UBVeUg9KgN8xZKK9hnpyWshaIOJYdLBrtkBnV9Ta6gXwV4uSeBR2JqfgFjCWIs9D7rI/HyBteZOkE2n5rBpKjKmXZ+HtpjLY27U0pW2aMjHkx5R9wfKjEO5qWjnXW9DvptLaoPvOSYHmUZ5zZxiV7kATmAB4yWcSMaW2DEdjiR/INvt8iAgjMxXX54r9xCK9E2Hf8=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"You can't use Windows for that kind of an application. The OS thread scheduler has a quanta of ~12ms, which can be reduced to ~6-7ms on some machines. That's about as good as you're going to get with a preemptive scheduler.\r\n\r\nIf you really need to run tasks in parallel in less than a millisecond, you'll need to use a realtime OS.","date":"2018-08-06T20:52:02.543Z"}]