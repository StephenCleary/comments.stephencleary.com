[{"_id":"f3ea5f9a-8aeb-3de7-a2e7-f30d5758d355","authorName":"svick","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/17579249405158039163","authorUserId":"","authorFallbackAvatar":"","message":"Having multiple consumers in your “non-dataflowish” way would still be quite simple. You don't need TryReceiveAsync(), TryReceive() is enough, because it does not block.  \r\n\r\nAnd I think your example with multiple consumers is not very realistic. If you want to have parallel consumer, you would use one block with MaxDegreeOfParallelism instead. (Unless each of the consumers represented some external resource. Which is an idea I'd like to explore more some day: using TDF for managing computations distributed over several computers, though I'm not sure how well would that work.)","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"","date":"2012-12-01T21:21:48Z","timestamp":1354396908},{"_id":"0ba63598-155f-3ab5-aa2d-7f8b97681c69","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"In my examples, I was using consumers that wait to receive. Synchronous consumers can of course use Receive, but asynchronous consumers can't use TryReceive because it doesn't asynchronously wait. That said, asynchronous consumers are probably a rarity.  \r\n\r\nAnd I agree that the multiple consumers example is not realistic; in most situations with multiple consumers, they would all be doing the same thing so you could just parallelize them as you suggested.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"","date":"2012-12-03T00:09:05Z","timestamp":1354493345},{"_id":"9ae6e8fa-aef5-3943-aa2c-e58a53192864","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"It sounds like you'd just want one consumer that could process in parallel (my example is more about three separate consumers; they put the results in different places).  \r\n\r\nIn your case, you can set up a dataflow with just one consumer and specify the degree of parallelism in ExecutionDataflowBlockOptions.MaxDegreeOfParallelism (by default it is 1).","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"","date":"2013-04-30T16:44:12Z","timestamp":1367340252},{"_id":"fb6f9467-3054-3aaf-a9e2-14d0a92431a6","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Excuse me,  \r\n//I've read your post but I got a question can you provide me a sample where I call different consumer in parallel?  \r\n\r\nI've seen this  \r\n\r\n var consumer1 = new ActionBlock(x => results1.Add(x), consumerOptions);  \r\n var consumer2 = new ActionBlock(x => results2.Add(x), consumerOptions);  \r\n var consumer3 = new ActionBlock(x => results3.Add(x), consumerOptions);  \r\n var linkOptions = new DataflowLinkOptions { PropagateCompletion = true, };  \r\n queue.LinkTo(consumer1, linkOptions);  \r\n queue.LinkTo(consumer2, linkOptions);  \r\n queue.LinkTo(consumer3, linkOptions);  \r\n\r\nbut I prefer to call them with Task.Parallel so I can parametrize how many consumer to create...thanks","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"","date":"2013-04-30T16:04:54Z","timestamp":1367337894},{"_id":"9aa2d887-1e40-3d42-8d06-93c8779f7bf5","authorName":"Robert","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I would appreciate a suggestion on how to implement efficiently the following scenario.  \r\n\r\n- One producer prepares request messages which are submitted to a \"component\" which consumes them and replies back with another message (a future)  \r\n- each message can be processed by a consumer in maximum 30 seconds   \r\n- the \"component\" which consumes messages cannot process more than x request messages at a time  \r\n- if the \"component\" is completely busy, a producer should wait for an amount of time to be accepted for issuing another request message. If the timeout expires, the request message is dropped (as cancelled) and another request message can be processed.  \r\n- the producer should be able to await the result for each individual message if he wishes. Practically, for each request message a \"future\" response should be generated which can be awaited if the producer wants.  \r\n\r\nIt seems like a good fit for the subject of your post but I am not sure about which async/await constructs I need.  ","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"","date":"2013-08-28T02:10:16Z","timestamp":1377655816},{"_id":"e3991af7-4e6d-3148-9820-91cd85879108","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"You may not need TPL Dataflow for this.  \r\n\r\nFirst, you'll need to add a TaskCompletionSource to your \"message\" type. This will act as an indicator that the message processing is complete.  \r\n\r\nNext, you'll need to handle the throttling. If you're using TPL Dataflow, you can just set BoundedCapacity; otherwise, you can use SemaphoreSlim.  \r\n\r\nTo implement the timeouts, use CancellationTokens when you send the message. For TPL Dataflow, you would pass the token to SendAsync; otherwise, pass the token to SemaphoreSlim.WaitAsync.  \r\n\r\nBlog comments are not great for sample code. If any of this is not clear, post a question on Stack Overflow and I (and others) will take a look.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"","date":"2013-08-29T20:08:00Z","timestamp":1377806880},{"_id":"f923cc9c-42b3-354b-a3f3-8d9da809a89a","authorName":"luizstangarlin","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://luizstangarlin.wordpress.com/","authorUserId":"","authorFallbackAvatar":"","message":"When implementing a WCF custom channel that process messages N:N, you end needing a totally asynchronous Producer/Consumer . For example, messages received can generate zero, one or more messages, same way on send channel.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"","date":"2014-01-15T01:59:53Z","timestamp":1389751193},{"_id":"0c68d212-a193-390e-a2d4-016074e0b03b","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I've never been in this exact situation, but let's see...\r\n\r\nWhy can't you just call TriggerBatch as the last thing you do in your action blocks? You'll need to \"prime the pump\" with a few small batches (as many as you have action blocks) to get them to the action blocks in the first place, but then it should be self-regulating.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"7dca2dbf-6224-3846-b867-136c87aca7a7","date":"2015-09-10T16:01:57Z","timestamp":1441900917},{"_id":"7dca2dbf-6224-3846-b867-136c87aca7a7","authorName":"xenonforlife","authorEmailEncrypted":"f77QboRjV+6nZxGGBJWAx1ffdxv+ZsA9/sW31gzm7NLbKmjewZeYgd/loh/tcF55acI30vU0r6mOfJ2lT95ycNIIrJooBkyHcVRNb3ahnNAkRYpaiWXwd8XLHyH2k/PsHhTzvgaLmpJIwa9B2wXbkJEB4KB5dv3evfOwF4RMTJsLILQRoJt6GE/gnMxWJDakf2JO1pZ/tcWiN3UAzjgfAWI74NxUVjiyQJEgaHsot5ewUGMbsKibApHV3BhOksFE1v/R7fTlSdwAahjXpsIJ30nlcTGMMLhkNUumrJ3F4jYZEQi4yUzmQkznSoFvyspbJmiJ+ys80DUkmu7gtI+ebPaTvYoP2B9pdFzcHf2B0KY+tikKskcrOeq5ROHIOcr3a32r6eBUvxmUEFJhBgHehUOPASRYdlpJC2+5Z9O8DYIN138HKEPoB51WZ5mzDiAwLcUZG2uvh4p4d36rk1579YPiLcZYPRMqyqNX+N1nFUtqIxAXMAlA7luPaaETqs9AGtKyHAlw2PEXlsAo+g83Q/bQotB9ngw1/6g5W4PkvPjyOmeWP93aA0NvHBlmFpZee2Bv3l3iBpqeEn04oDNiH3fJDxiYo/fnaaJumoKA7SwguPLG5c19TJmHlXJ4YTkZl/CytPWmrpSDCUlqfwEBz8O3PLzvpdYDBQKrNaEcYYQ=","authorEmailMD5":"678244a0ad782aa2a25518ca6168b046","authorUri":"","authorUserId":"disqus:xenonforlife","authorFallbackAvatar":"","message":"I just hope this blog post is still alive, I am just learning how to use TPL Dataflow and well am getting confused over and over again. I hope I get some insight from the expert himself. So in my Producer-Consumer scenario, the bottleneck is really on the Consumer end. I have multiple consumers as you, and each of the consumers send an action to external hardware, which may take some time. My Pipeline looks somewhat like this:\r\n\r\nBatchBlock --> TransformBlock --> BufferBlock --> (Several) ActionBlocks\r\n\r\nJust as in your example, my ActionBlocks are the consumers. I have assigned BoundedCapacity of my ActionBlocks to 1.   \r\nWhat I want in theory is, I want to trigger the Batchblock to send a group of items to the Transformblock only when one of my Actionblocks are available for operation. Till then the Batchblock should just keep buffering elements and not pass them on to the Transformblock. My batch-sizes are variable. As mandatory, I do have a really high upper-limit for BatchBlock batch size, however I really don't wish to reach upto that limit, I would like to trigger my batches depending upon the availability of the Actionblocks permforming the said task. I know I should use the TriggerBatch() functionality of the BatchBlock somehow but am really running out of ideas of how to approach the problem.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"","date":"2015-09-10T15:11:54Z","timestamp":1441897914},{"_id":"fe0183cc-1a55-33f5-ae78-d0555b1d62e0","authorName":"xenonforlife","authorEmailEncrypted":"iUVtYMwW5uykd5M3teCvzu+VLKLuIBp36sCVcRNtNs2EsB2O9Fz7HOQlSGNiwBrYWttRz3v2Hc9W8l491YkzlvBA3OrXb9xg3eRSzFVOiCc9a6z7wRbnnex/ODWJL3zn0ftb5LcucbqPTmcqgzc2Hh/9PeVZdWEruDGSjjOTHgLsjR9qPXxm1qNSbzRZTm3aLHaFT8FrW2W39cmWyEWaiCVOXuDfGA74hsBUdn9nlJR1Bcs02No/zNKlM+65QWyRZFb0Z6cyXVTzsmarNCjTRrXY2XmnhOQClk94jlgtV3FqCqbRZ5Ei/07dq4lLjro0l3hgo2n2jFAyKwO3HMvv2IAM3D4egli55k3ztWVlPdRRcmuiP18BnkyYovdaw354cFCgmx33w8VN4dM3fq2xlf1YmXIxHlgxzmAUR7eBIHCgIzsXCZvQl83K7UCDIJ/wBUopU2fFiTSwhkYFxp2F26hSpteQBO0zBXmD8Ln3a6YqL+yM60/9CmfgxuuCbHBeXRmFDULKswSm99ZIewZEAUeSdRkf/gQ+Kr58cLFpLglxzRB3woOSAuBKiprgTZ6wad6K91k480HUEXqLxpdgALPWXYQ8V6HgY4meEVpSGE37kVve+XBQ73IyhxeQPbOjuILf6/HSHmkZybBikXuoDOhYmLJ7+AxIeAfQ3YKzRhg=","authorEmailMD5":"678244a0ad782aa2a25518ca6168b046","authorUri":"","authorUserId":"disqus:xenonforlife","authorFallbackAvatar":"","message":"Thank you so much for the speedy reply Stephen, I did think of this solution infact but then this approach poses another problem (which maybe disadvantageous in my case of contacting the external hardware) that as soon as any ActionBlock is about to be over it would trigger a batch, therefore I would somehow run into fragmentation of an otherwise (preferably) larger batch. The next thing I was considering is triggering it from the TransformBlock (as the first thing in the transform block, here too in order to start the pipeline I would have to start it once externally but after that it would be self-regulating). This way each successful propagation of a batch through the transform block to the buffer block (after transformation) would trigger a new batch (wouldn't it?). But in this case then for a smooth operation should I then set the BindingCapacity of my BufferBlock to 1 (or equal to the number of actionblocks)? so that when there are no actionblocks to accept an element from the bufferblock, the bufferblock inturn stops accepting inputs from the TransformBlock (and this is the point where I am getting stuck, since at this point the pipeline is self-regulating wouldn't the transform block keep buffering its output if the Bufferblock is not ready to accept it, since from the documentation I could understand that this un-accepted output would be postponed/declined, but I am not sure how that works, but this is the point where unfortunately I am getting completely stumped)","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"0c68d212-a193-390e-a2d4-016074e0b03b","date":"2015-09-10T21:58:44Z","timestamp":1441922324},{"_id":"2d8275b1-2593-3951-b084-fa24563a95fb","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I'm not really familiar with your requirements, but it sure sounds like you're overthinking this. Most of the time modern computers have no problem keeping up with embedded devices.\r\n\r\nAt the end of the day, the best way to know where to do throttling (etc) is to just run it as-is and observe the behavior.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"fe0183cc-1a55-33f5-ae78-d0555b1d62e0","date":"2015-09-11T00:39:35Z","timestamp":1441931975},{"_id":"a5934daa-8613-3be2-9f8c-eaaabb2d24c5","authorName":"xenonforlife","authorEmailEncrypted":"oBCcbiE8FdPgZKIRJ8Tu+/wdZHQtPme98wHuEfJD5mLMxyZ/CP7qgGE5bBTUWshkL3hv4g1wYIYSh3yCNR14QlF7+DvAHPtSxwqDwLt5zFlHrtprDMaERqxFkk7i0lN1bOkuAYyrwNvQwz1d91hgT8FkMK/N6z7RqYL38eLbmCUY9uTekCwZFpkZNEpEACQnJqGRSaOlQY6JxtUdypgqHBvCdTAxbEDoaD5cFTdbwkRvc+NBgiXfpqM0xluZvW/xySlaI0TmMV7YkFnM09XHeWICLSldQrSGQA8P0oLVSMXga2i361Ntuo+77tnCXtG/kixTD2BXvUnLZyAq+yrKOrY0a8LZ990w4ORCmAzsyf2pAY/DEJK6iurUiHaKJmEEDbDuDUFgCcxSLsYwX9B0uEeXhaySVxh1BGk60jy/x59tFtjcjtECUWpH7FPBMoIcMKOYg8yrT7xfdg8DlCzz0lT5L/Z7wIbKc5UeiHubxe/SrrzQmQ2+PkTZe1BpUnl9wgnJ38eF2MpqEcYi3JCDBDGLJaoGT6Q7XlMadpyyA6HW/WI6A9rX7J6SgB4Hmm/7c1xU85Z3jx+0NOZLmovVwORwMBn32BKU/GStKUtEe71X/vq25/Zw3c9PevqVFu9docjTJ1BxjC5EVNr+Ss2M7X6Qf4fUGFEzTw9sIrVlpuw=","authorEmailMD5":"678244a0ad782aa2a25518ca6168b046","authorUri":"","authorUserId":"disqus:xenonforlife","authorFallbackAvatar":"","message":"Thanks for the suggestions Stephen, after reading this, even I am now feeling that I am overthinking this maybe because this is really new to me, but I have to make mistakes to really learn it. I will just give it a go in small examples of my case and observe what is really going on. Thanks for the advice. I really do appreciate it!","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"2d8275b1-2593-3951-b084-fa24563a95fb","date":"2015-09-11T06:14:32Z","timestamp":1441952072},{"_id":"349b05d7-a73b-30a0-a8bf-956cad81315d","authorName":"xenonforlife","authorEmailEncrypted":"Fay3u+SF6OBzEb8WwN9qsC9wygo0n80fZicJ8hHH2E8LJlE7x9AijoGr0s90n29Hmrg4vC3IF7P077nGg5P6dBt9Etek9l8c+9U0JSrU/tUYvG0BRRk2fQxfepgjsoSmDhsrJ1PuoYHBwAvqyG/6xtJFWQ0h8sTA3s1bilLRQ23zF0NoXN/CEbWFlZofJiEbHPAHrzLdowl27V5qXOIKy1uMygdRdqlLlc+iQi3NXS3JrLJuKHGYHL11MhKcU4WKg+A/5LUMM2ApObok7E38GJRqHYJgwKKIklehgBJ8ajIHUlFPPLEVxuSZUvF49heXxHYg9PvNbbGPPacc1CJCRjDRn9+rj5TPc3eQNG/sQ6M+3UwVwEvoBmMbBs0QfCb4fOHYbvkX1Guv2BLmgZxDQdMpaEcB6+i8yKKNRpm+KTMCkNb9AQu1ySMtBiRewIjUwsAZF9kKHkQMQzGDmN0GwZEJfwupbZdowLrc81zOfj+CjZBV9VfuB8BySnQzzaVfo0GYWT2/qJd3CDU2cz0iF/iYUBYzRZl9z/enMBqhgmriMZ81oP3+n8x0eYv49qESmH8khIaiWhDUZHANk1UfGNJGh7zYrOdznth5cD4mcAPTGlwf9HGtydQQgUh9jbBOaXevD5P+kBW5LSWbcGmQQA9KcJTnpuPOe+FUIy8NYD8=","authorEmailMD5":"678244a0ad782aa2a25518ca6168b046","authorUri":"","authorUserId":"disqus:xenonforlife","authorFallbackAvatar":"","message":"Hi again Stephen, Your advice to put the Triggerbatch as the last thing to do in my ActionBlock indeed gives me positive results and I did move forward with the implementation as well. However interestingly after several days of working properly the pipeline has come to a hault. Upon checking I found out that sometimes the inputs to the batchblock come in after the ActionBlocks are done with their work. In this case the ActionBlocks do actually call Triggerbatch at the end of their work, however since at this point there is no input to the Batchblock at all, the call to TriggerBatch is fruitless. And after a while when inputs do flow in to the Batchblock, there is no one left to call TriggerBatch and restart the Pipeline. I was looking for something where I could just check if something is infact present in the inputbuffer of the Batchblock, however there is no such feature available, I could also not find a way to check if the TriggerBatch was fruitful.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"a5934daa-8613-3be2-9f8c-eaaabb2d24c5","date":"2015-09-22T10:07:14Z","timestamp":1442916434},{"_id":"f6f03198-13f2-3a14-adc4-41f8bb8514b9","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Good point; I'm not sure how to solve this. I recommend you ask on Stack Overflow.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"349b05d7-a73b-30a0-a8bf-956cad81315d","date":"2015-09-22T12:05:43Z","timestamp":1442923543},{"_id":"7dbf9e85-1934-375c-8a19-40d0dffefdfc","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"That would be difficult to map to a standard request/response pattern. It's *doable*, but not very easy.\r\n\r\nIf possible, I would recommend looking into SignalR. SignalR allows the server side to send messages to the client. Though in your situation, it sounds like you'd want to use a client-initiated request with progress reports coming back from the server.\r\n\r\nSignalR's progress reporting support isn't very well documented yet, but here's a small example that should give you the gist: [http://stackoverflow.com/a/26591235/263693](http://stackoverflow.com/a/26591235/263693)","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"fc943720-3119-3c30-8506-c379ca49e776","date":"2016-03-09T23:30:44Z","timestamp":1457566244},{"_id":"fc943720-3119-3c30-8506-c379ca49e776","authorName":"BPD","authorEmailEncrypted":"iWxYHVLomn/bJkIktNBvGdjfK4kMjNg63+hxn3rTk8rp7hT8ZI0RZBW2K9VjKPmY+4wm7Cz+9GWh8w6XeiaKX1ICy0DpRsOoPLsVrpRIiXSBLk7/J2zic5TWp1uRPO4/zXxVoxnZQ3Lo6sX+uo7/uXYwHMOxVw75jVggfqWm6XkrS36bm0Uamj0Y1i3rewl1ScobzdER4d0nRegb0o4iZHLCUwmfOxWP83O7sLxZmh5tbiW1ShWFqZvAuVdmLr29EtF9DRxNK/v3UEaO49OgWc/sWf25vynEnzDmWBg0G5WgD0iwRn5j4RNRMrErnjsGcW87Cl99JDV5BEfTqNv6oK4hrPxjWVTRFyq/3VQK8s/aEAqDvkTaMJtQEMaXSEylQrn70NZQ4+xw8kMR2EBInLBgHxiobpjb0gsTLPd58fWa7aT/mPKAhxikFoFYUmpRqg+CF++M9Vyl9U1APJynzOY127L975cOJyaFDvqJAv4md+R9Or1V5VcOFvTkSasNjOx13IXIhRv0LADx0gqQJd1Axhcbcg+5DHAV8dhZDRTiHTjZ5fU86qwIf+HIOYW/94G2PCWiCSRnvVR1WViSw31bDmDdUx2unm7a5AVJ5lFWUys3bhwz4JiixxhjRglLuIYpQOlvLVKkiX/1l91bVxOkIlhpT5Z788x1kxXYASE=","authorEmailMD5":"972d9371ad028ab56436fa052d2736bc","authorUri":"","authorUserId":"disqus:disqus_lglbHNZnIf","authorFallbackAvatar":"","message":"I am hoping you are still responding on this blog. I have a scenario where the database response are received in segments(pieces) with a timed delay (certain milliseconds) for a particular request. The consumer has to wait certain milliseconds for next segment to arrive every time it receives a segment, but return that segment immediately to UI. In the mean time we keep receiving requests and every request has same cycle to go through. Traditional produce - consumer model seems to not handle the delayed response cycle well. Do you recommend a better solution?","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"","date":"2016-03-09T22:34:56Z","timestamp":1457562896},{"_id":"fe2000cb-f497-3b7c-9490-1a8206ca8f29","authorName":"BPD","authorEmailEncrypted":"fyL++HEzp2aqYKHAriIq9IaJX90shSu1HiQXr/pF400wacbsaROJ7iDz7vMT1peoqOcACPvalljAQy9T5u7HX827z5UC4JS+GA6YanhpXe03vlJIRg4zlfoASYV63q+fYu+7+baWFrxbHRZBnpyawFp1buKKia8BmGD3bVJx60KtH/S56Pc5zGiiipYQhi2X10DkrbcVgTpRI+Pqaljo1qr2l+rtpS+LSktAf2PCjt+NWcWGFUo2+VwEQDoqcQkNXy8YSr5UOLuYjgrBK14Q/jQyFKDtJYnyXl4wLc8FPBobMmuU68Bp5n8LhdN1H/+3nWwU1itpddvVFrQtyuxabP4Nn/52kgXetVZNiTygDTf0MAeClYAvTiZ5cVHkgCMdgt98YwiBEeZYtNaAnVYD5VdCMVwJEZxadt5srxPIFRtmO02fLskJsFPHBKz+SlV8GUvO62g4wbkcSElaLP8zi83vF3tsawCjdvCCR+9v0z4CO8T+VfY8M+fqTFI61zzFhdX/v3KTz6ANYRvSIaUPXv1fbZFjAruU/MHPQ0KRUT7KKPi7s1hTZuWuIYsocGwBc0twZZp1dDHTK5WP9T3g/LdHTMpX35cfv/JVXC3ELK/h+O4Tbp9Vntk9fCT4ccHNVYkZMD0IL6TbytujOTbxuT7lGtnLxJVJEKvAdMfvr5I=","authorEmailMD5":"972d9371ad028ab56436fa052d2736bc","authorUri":"","authorUserId":"disqus:disqus_lglbHNZnIf","authorFallbackAvatar":"","message":"Thanks Stephen for pointing me in right direction. I implemented the progress bar pattern and it fits my needs","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"7dbf9e85-1934-375c-8a19-40d0dffefdfc","date":"2016-03-14T21:04:50Z","timestamp":1457989490},{"_id":"15288893-eb55-39a9-b9a1-6a45056864ad","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"BufferBlock is similar to Queue, but it is not just a queue. There's a lot more to it, with sufficiently different semantics that deriving it from Queue doesn't make sense.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"e6085fd4-2d55-38e0-98c7-06daa91835e6","date":"2016-08-16T18:53:44Z","timestamp":1471373624},{"_id":"72580076-b47c-368e-bf85-0a8c9c39e725","authorName":"Buggy Squashy","authorEmailEncrypted":"dnFtNrP2+RGDq0WDjDpfM79CO1b0emZF3sbb9kQaj82QjqFAzkjvGimpsosfTKE9Y4NuNuMunc2OLeFCPIybzs9AloeC7CpK6OnHYBtcDmXzzDJqaw2ou9vE/iqNP0g5n7JTVYG4p2p7G2yy5nAk6wpTa2bwQwQC7dGonJtqk/pxptYSxrxJ01EMwh1MXvZ7ZenPf4EhB5Y2D/cRSSGfxqCyhjBB3A11dp37godVNBlw/RERGVHcMKSWD7C/C8NwdHzruCftTiaYWzuK7OzX2uxco7Oc/UcODDu3FKsvPL1IwtEE710gZbfLVVppoLF2Csoijsl6IIyFFEqed/Nja744Jncuw7lA9ACJNKWLM9d+y1jCwaQw18jLoP+KNeUNzWhaI8jA8nlLgQlf0obAjnA0UXuA2noENG2AE9h0ETwuQuFJsudOr1QX2SL7doSbZqNQSiOdUGwJGbsFrMTomi1K1Jp+8Mz0dZhLAKasHeJqZWxcBxYhISNGUEAZmLnrHarS2gAYiOvouLHJa5cOz4s8pMqzh6xM920oTS2cgfXZQLB5W8eK0MXxDPTfZxO+kS3ZsyDCldSbBHOOOsBz6Ft3EbeqvgQME/cuFMHQmInNGQ2R1so3WoI4jTYwCA73Tz6l2h/WTlhlOprhnsGnIoz7DnWgEjVRZA45S7hcXk8=","authorEmailMD5":"b13725d59b683df333736b9a404801df","authorUri":"","authorUserId":"disqus:buggysquashy","authorFallbackAvatar":"","message":"Hi Stephen, I have a few questions - (1) is the buffer block derived from a Queue class and/or conceptually similar data structure as a queue? (2) How can I delete some items from the queue (in my application specifically, remove or kill some cases in my queue that are just \"waiting\" to run). (3) Also in your throttling example, can I make the queue a private member of the class, and if I retained your consume and produce functions, then can I have a separate functions which is called by the user interface - one which mimics the one in your unit test to actually run the cases, and another one to remove or kill waiting cases, am I right in understanding this? (4) Also, how can I manage the waiting cases, since I would need to know the cases which are in the queue but not running at any given moment, so that I can kill them if instructed by the user interface (or if user specifies so, then to kill them regardless if they are running or waiting).","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"","date":"2016-08-16T14:39:22Z","timestamp":1471358362},{"_id":"a10a677c-82fe-3019-bb90-c0abd2c0ef42","authorName":"Buggy Squashy","authorEmailEncrypted":"UG0o5h++pW0pSMgNY+Iq8VRM4TinEUkf63JCjs/srOgpZaHswKAV2lLzBVTxfUfoNVr5VLw5qm1QlfFqG43eUaDxNkvZYS8IwhTmNwo25InGSF3Vzk9wYR2mF1wPn+inz3RVJceze+0nGnP5KcMcjcFl7sG6zMPR7DI5hJqv1zCw7uHWDsQsBiKBh+KsI6DSzNWxU1NkbKRNwWxqkXunnV7ezcRPqwTmBsjYQQo2Ts7T8uQl60wLkdnS6j7nEbKAJHnemRlhmOEz1jpkpUli2weJDZUtT7iTjqGARbKYpatPd1cu7WGLBlM25dtDw/9xsV+WLn/Wv4JfiZmGReNJ4VcWZL90RsTiLJKIHSl3Rnr7zdEIszoCllZwn1XsfzgoytwNb8seu+mmDBD6r7MS8LihQuoqgED2UPRCfCAb1kiYoiuG7W01sk6TMi7JcxfnNwfIN/S/TexzXJp9tSfw6gtKGK86rIFQpYa2adLpi1QieciCXqo7AI8C/zisX6Sc1MCGZNQeqKX3QW51kAATyfnf8hYDL5Ac75p1KT2G/trkGEqh6fkJvlT96BRP0LzA1kIzhbwLmevuVmykZNoo2clbv8ffPiDtpgrzHk5VFRG0+Ajn7SXIRxYYaoc46PHBR62ioPggyNI/gNd94N+NhUIRnjdeZthx7AkLFbCYqXE=","authorEmailMD5":"b13725d59b683df333736b9a404801df","authorUri":"","authorUserId":"disqus:buggysquashy","authorFallbackAvatar":"","message":"Appreciate your response. I guess few more questions - (5) do your Produce/Consume methods have to be 'static'? In what context would this be useful? Reason I ask is that I don't want to use static data member BufferBlocks as well for this, and also I read somewhere that using static is not thread friendly. (6) In my situation user selects a number of cases and submits them to run, upon which, my framework \"produces and consumes\" the resulting queue as you showed; based on this it seems like my case fits the single producer, single consumer description, am I correct? (7) I am trying in my initializer do just like you did, but instead of a constant, I am trying to set the BoundedCapacity to a private int data member MaxDegreeOfParallelism, but I keep getting an error \"A field initializer cannot reference a non-static field, method, etc\", any idea why I can't do this? Does this mean my private data member MaxDegreeOfParallelism has to be static to initialize like this? I confirmed that works, but could this have other implications as a result, as in (5) above? (8) You mentioned that each item is immediately removed before its processing begins. Does this mean that the item is removed from the queue in the Consume method as soon as queue.ReceiveAsync() receives the item, in your example above? Also, if I understand correctly, the processing on an item (or in my case running the case), if any, has to be done right there as soon as the item is received, right? Thanks.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"a91c41db-eb22-37bd-8dfb-9de70b96158d","date":"2016-08-16T19:45:14Z","timestamp":1471376714},{"_id":"a91c41db-eb22-37bd-8dfb-9de70b96158d","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"(1) No.  \r\n(2) There is no built-in way to do this. If you need to cancel an individual item, I recommend sending a CancellationToken along with each item, cancel them as necessary, and then have your processing check the CancellationToken and skip processing if canceled.  \r\n(3) Yes. Blocks are class members in most real-world code.  \r\n(4) As noted above, it's not possible to remove items from the queue before processing. Technically, each one is removed immediately before its processing begins.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"72580076-b47c-368e-bf85-0a8c9c39e725","date":"2016-08-16T18:07:26Z","timestamp":1471370846},{"_id":"e6085fd4-2d55-38e0-98c7-06daa91835e6","authorName":"Buggy Squashy","authorEmailEncrypted":"hXRxMo1uHAOL7sfhpb9mrq/niXkYW0TpAzrd99Jdjk8dUbBXuz5AePFnRfohTTD+K+ARu5IvcK6RBNd+tclak0xkMPTglzEtD9LEeEDTNFJulMJNLDQYzRMjVM5yc+gp5K34gaASNFupz0FsZ3b5QfUbgJGH8aZJDsS6vIkM1KvZxtL580coWHu662BYOaQO96WMuACeufvBTe0KRTvow38wC3MMvE2yFtZO1fAShUMcMgydH+n9CgslFlCaex2w3IbOHOPvyQo3UiPQzxroAmoAhkD64Kj42oSRRXJ7lHq9VaIl4HUJ7/9F2q6tVQDA0hipyPqw5o0b1VGjGAgP19FpwHkOf0/+/QVFAMGnwg7sgPFR8+bZRPWV/i3v39yfazEz8xA8GxRkKNbMfzz1CGs0hPqE8HyoGm/2i6mbBgkSt2R0YsN+D6FTi04up/hJ9hCnR5QDQvFpMboYdTMqqSXrs+YEaG4Lume/Zosawcl1C7kEVb4qoW4wCcmIuqY3DVVhf96uG8IJcIELLgeTNjG3SV4EqBTf2H1w0Chx56xdudda/SGHT5/M2jwlwtLR1A/LJUa1d1gkykCuJC81qIqmtxqJRxO81RX3MBwZ9QZQe4TUP9RQ8GwqhVyeRa6Ke0OxeQJzzBfB4Vb+IJQLZiHufRydT/ak4XAMcVXYO/U=","authorEmailMD5":"b13725d59b683df333736b9a404801df","authorUri":"","authorUserId":"disqus:buggysquashy","authorFallbackAvatar":"","message":"Thanks for the response, it helps. For (1) I recall reading I think somewhere in your blogs, I think this one: [http://blog.stephencleary.com/2012/09/introduction-to-dataflow-part-2.html](http://blog.stephencleary.com/2012/09/introduction-to-dataflow-part-2.html) that the BufferBlock is a simple first in, first out data container, hence I was wondering if it is similar to queue in that regard. I'll work on the remaining as you recommended","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"a91c41db-eb22-37bd-8dfb-9de70b96158d","date":"2016-08-16T18:27:44Z","timestamp":1471372064},{"_id":"1f0215a6-23f5-3334-85d4-257c87ff45eb","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"No. Multiple consumers means actually multiple readers. It's a rare scenario, but useful when you need it.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"42a4afb1-9deb-3a9e-aab8-a6b7cabbc5ac","date":"2016-08-17T14:39:56Z","timestamp":1471444796},{"_id":"42a4afb1-9deb-3a9e-aab8-a6b7cabbc5ac","authorName":"Buggy Squashy","authorEmailEncrypted":"OKLUyYVCKhKujg6wB6fdCqTxQx/zJouYSR2d9x3dYRZQsknmowqxUQd8iqnfkFKAWaGB46yoCn4JpqrMnbwsoxGgDDCldDmr6TvlCaI8PgggADb728UXEtD2CS/A+g3R53kL/Z6gufQSVDNbo25wQKLzcmhO03eDp+J3eI17iCTbcG381qOeZ/r98a5Yt1z3t09hrhi68OY9yyqG804l+GCHPNvQ7qmgpT86hEdQ8Fxs0fjmLKia1cBl6mwGOpKVg0W6DUThAhg9lnvgbmFnD+9R+iz7G6/Gq15Rx1qJ+fL4aX90lzxAtZ95f9fgWQQYPy4Bq53FJ7vZ8lOzW6PpR4RT9KF8vC9BFWlqDvBWVO2OmeVpCFLXADCYbF7fWi/PpMJW/TWf454wCvGxlXYUWfROj8V4wONTsyjZp5exF7rXcFqHQf6bCjDDyXClONbQu5nWz1FIxC0q65xJ8wI02drhB4KD+BwdHjZN8VI00UYYlMhyiJV3Or/sHUX+O4retIRxK9AVXScOsfS2atm+y6O42TTeUeNWR3tQZU+5n7Bh2UawhvRJBK9KUU5FYZKhvDKjaLOxMqGyywseNV2QcyM1sKUdBtXyLNjK13sXe/mZ5pzu2fgQj+X4PfRoXiWPk55cgp5cUaheLyb7Ndcv1Rr34hrHIP41qW+o99JHkSs=","authorEmailMD5":"b13725d59b683df333736b9a404801df","authorUri":"","authorUserId":"disqus:buggysquashy","authorFallbackAvatar":"","message":"Thanks again for your patience. I guess a follow-up for (6), in what situation would I need the multi-consumer pattern? My user after selecting a list of cases and submitting to run, might then repeat and select some more (possibly different, possibly repeating some) cases and submitting those as well..so would this make it a multi-consumer?","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"4a1c6ada-6397-302e-ba80-f60356433c07","date":"2016-08-17T13:55:31Z","timestamp":1471442131},{"_id":"4a1c6ada-6397-302e-ba80-f60356433c07","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"(5) No, only if they're global.  \r\n(6) Sounds like it, assuming you've only got one consumer.  \r\n(7) It's not clear from this description. There should be a straightfoward way to make it work, just like any other initialization code.  \r\n(8) Yes, and yes.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"a10a677c-82fe-3019-bb90-c0abd2c0ef42","date":"2016-08-17T02:20:36Z","timestamp":1471400436},{"_id":"4b64b7ce-ea80-36d3-b127-f11fd0b99134","authorName":"Buggy Squashy","authorEmailEncrypted":"i/N3Iuaf3ZBsvooN8+X8d6g1w7olI5xRhN6L60mvf5ocTeNUrZkEyh8SanllfKCPug0QikTGDXe7ESTu8ztEAXeepUMmbJUjMyRS0RFvKC92qF9eZwvTdh6l5rTGeHA/pJ5+r66i9BOVGELlHxXRdV6m4s15sIpRGQPshnV13o9x2y3ktKenI8gx/v7ij8xYv47adGbwcqk3xf8BQR2/rZOqGIHJs9/vy69+EqS0yxNcu0snBXwDNjdCl3UHlBoyNOy1ACqk2u0gpWWeKT/oH/RmoQl91CQ8hOW+1EqH4YC7+aFcLioegGorpi4BlcScC8z0CnsPIbp1Js5wafUfAXwlnzzp+kQZ9wKDDOUK833Gf7Y1vmt9IHPxnK/X8Xw/Kn3LkY4/CV+kBV3GC3KoRK5tB5syMcOPLDI82CHk9IzczSEbGAfo8Ja8NQJqUfpjxk4F45l8UErhs6P5xGGaCA03yYNbWclU0UB12/lk9RC4eKsE38irIZwsK2vjvkShIsXwCajsN9Z8MO3xdjJZa7lIVaQmtQwz0DUXG2HiYjjeoARneUTIpykqt0ulQdpMcxKW3xtco/iRlinX81UAX8PIm4nv1nM5jGuA/Ruey8FRZAfawJo1r8/+5EPk7dXkkYXe51uOFF1z/NvLMpEjR3+OannyqQO3NODcSaAliMs=","authorEmailMD5":"b13725d59b683df333736b9a404801df","authorUri":"","authorUserId":"disqus:buggysquashy","authorFallbackAvatar":"","message":"OK, got it. Thanks again. I decided to go with the CancellationTokenSource approach. In my \"Run\" method (which is based on your unit test), I loop over all the cases selected by user to be run, and initialize a CancellationTokenSource for each of them to a new CancellationTokenSource(), before proceeding with the Produce/Consume sequence. Next, in my \"Kill\" method I loop over all cases selected by user to be killed, and if I found a CancellationTokenSource corresponding to that case, then I call the Cancel() method on it, otherwise I simply skip over it...with the idea being that if the user selects a few cases to \"Kill\" and then selects the same to \"Run\" immediately after (or vice-versa), the latest effect would take precedence. Hope this is clear and a reasonable approach.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"88d0f722-98e2-35ad-b659-40ac779f2273","date":"2016-08-17T18:39:13Z","timestamp":1471459153},{"_id":"88d0f722-98e2-35ad-b659-40ac779f2273","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"As I said in (2), there's no way to dequeue items (except for processing them, of course). I recommend having a CancellationToken (or some other \"do not process\" flag) along with the item, which your processing can then skip over.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"df045556-b7d1-3bd6-9be9-0606b7ced0fe","date":"2016-08-17T17:25:30Z","timestamp":1471454730},{"_id":"df045556-b7d1-3bd6-9be9-0606b7ced0fe","authorName":"Buggy Squashy","authorEmailEncrypted":"nYiTI0x93d/rKds9PSsnz38Nn3iyGJYdrE9kQ4SR0Cx/OgFI6uX9X2UnMsDTC5xDdjHiiibPLzPNUwAz4vcac4UR8z5haT95dr+A4hP0PNhuGErgAYLqSXzjxJLWkWLJXbmW5E1nydph8esTTXR2jtTkue9+XIEp4CX46itqAsWZxFZOrkbRvE77pA45Un/X3jvuZ6FeShFlIVZhZM70ZZTrSd8baFRw8ibKqoxhhkhJ6uxPzQX9VwkrmbbOd1ZqWBLsdjJcW2PiuQ3fTpYA3iByuWzc2yfuFJnzffV88VM0zNOoLf0vavddNQl1Zwb209TGGiDZ7utcvbCbHqPqxZblcCJril9ZL7STgWm5+Ubc/J9HjTI6Tt4pA1z2vhVXmOZRCCiB56iRThGqCdbYgGUi7VMc9trAN/iVHtOzb4d38qplohm30k37DqhSzwFTS+mqGRP9oMvEOu2g4oWfi0XBvoclhK3jZmovlgrbUkptMFtWDkXF5G5gN63LGw10L5sqM8khpZG4xNraAxAUj8vXdqdiLj4nmSOZX9XZWqwwaaUIKrJYIqoclI7ANMiCdYhWucYK9jRAY5QkOPAevv2Z3QtbL5aDbb8402tXncsKgPe0jiZFhXly08zLnmgTiVEWgXlaoiFclmcFN8bcdeP48Qk2EGsqLj35UEuFWto=","authorEmailMD5":"b13725d59b683df333736b9a404801df","authorUri":"","authorUserId":"disqus:buggysquashy","authorFallbackAvatar":"","message":"Thanks again, I completed all the implementation, but in my application I would also like to remove some items from the buffer queue (for e.g., if user submitted many cases to run, so that some cases are still waiting in the buffer queue due to the throttle specification, then I'd like to allow users to select some cases to 'dequeue', whereupon those cases should be removed from the buffer if they are waiting - but I don't see any API in BufferBlock to identify a case in the buffer, much less to remove it from the buffer). Appreciate any suggestions you have for that?","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"1f0215a6-23f5-3334-85d4-257c87ff45eb","date":"2016-08-17T17:07:55Z","timestamp":1471453675},{"_id":"e1a40902-dfa8-3d2b-a7f0-2081bbc6a956","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, I believe that sounds good.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"4b64b7ce-ea80-36d3-b127-f11fd0b99134","date":"2016-08-17T18:51:02Z","timestamp":1471459862},{"_id":"02a16955-1167-30ef-a48b-7dc0c47e42b0","authorName":"Buggy Squashy","authorEmailEncrypted":"NR9aYuNkezCUsvprLzp7OQm/DP1kVD3GTXbBR4mV101L+Y92a+psb+rVzDfGJ7fUVYyIYkJ6yJGJ48DbPG/VGLO+uc619B+Goev+xTywYEwAxBxsNT8q6GUiehP3FXawEHaApQ1rHXotGvld5GtEEQj19DopZwuspRU/SW7idaQ542Xl1SdjZ017pwdTBeEr9ehcbP1PfY18gOSOO0xll+YS9qq6+iFeGSxjFyOciHwD0YpP7NxVIUdzrD2CPCMBklhEBLBhZ0041eW65t24c2svPQypJzo7St9+U7ACu2axIKoT+sqISMUxg+YqkmjDtZX/6H3EiM9HWAet+sGRgSDe5oDwIsneyPulnmZ5Z18++NUNXKWCF2jCrzvp/99ul+N0YPUbKKFIiPOhNydJV8AqoAFwOd6NSUfL+50D2bcm04impKJixGmPICYA38FveuX/1Bc1K9TWgOB7M1Fy+Yw3/zobaTIZ7z5uuq7p4BZg2XiBCtJvR7oYbYpqmayirAXKPgrNJI/Zs1NriMm10fjdT9t0swYGMBX3KJcVwQTbBBOVp+Ugj0WQ1YWBC4zBLPW+xXsnk7mb25HcafBsHJDheTmuhzVKVojd2izgNLTSK3SDjcpCIJLZmPxKgjY5Ck023ZfW31P7Mrmqaxnt5f+AptemGmQGyeJZ9mICDd8=","authorEmailMD5":"b13725d59b683df333736b9a404801df","authorUri":"","authorUserId":"disqus:buggysquashy","authorFallbackAvatar":"","message":"Hi Stephen, regarding the above, I guess a couple of more questions. Thanks so much for your patience, and apologies, I accidentally deleted my top level original post/comment, not sure how to re-insert it. Anyway here are my questions, (9) In the Consume method, right after I get the current item from ReceiveAsync() and am ready to process it, supposing there's segments of this processing code which are blocking, is it better to do move these out to some point so they are executed before I even enter the Produce/Consume cycle (e.g., in your test method before I get in the Produce method call? Is there a way to do this between the Produce and Consume calls? (10) For the CancellationTokenSource corresponding to each item, and other such flags or data structures associated with each item, if I initialize them before the call to Produce, then in the Consume method inside the while loop, if my process on each item received is invoked as an awaitable as: bool ok = await my_process(item), and if I check the boolean \"ok\", before populating the CancellationTokenSource or any other other flag or data structure corresponding to the item, then there shouldn't arise any race conditions, am I correct? I'll plan to test these also myself. Thank you.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"e1a40902-dfa8-3d2b-a7f0-2081bbc6a956","date":"2016-08-18T14:49:37Z","timestamp":1471531777},{"_id":"24cf38aa-a9c6-383b-96f7-94de4197da9b","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"(9) If it's a separate step in the processing, consider using a TransformBlock. (10) There will be race conditions between issuing a cancel signal and the processing seeing it - this is unavoidable. But it is a benign race condition; it will just cause a small amount of extra work.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"02a16955-1167-30ef-a48b-7dc0c47e42b0","date":"2016-08-20T00:47:32Z","timestamp":1471654052},{"_id":"6f51f1e4-4ed7-3083-af13-f118de7f6187","authorName":"Buggy Squashy","authorEmailEncrypted":"IPpawreaLYcJlo0GgzqwqdqR0K7/XXk/Gq8WC2adO64jjFHKICKBQgnJCgWIfFTuihoL/gU2IMOsMOB1J6DeOAylLrDsuGorjNB2LEpPfqerMUM0eD+QORxXATmLvKsisGfKWea0mLj/PVQC0XC7mh53MfYwr36YUWsYBHYSrVjOu6YrN54MwN4GoYi3EQgkTte0EeFRT/p3E23uYBNG2KTvMXh29mCLkLklOc4bYh+M59swtocNrkxLOQ9Wq1uynS3YwvvidfqWeSkqsJbb/Ua2NHuizWTsdziE/kBih+ewRRUZIRqC+61dKxiLRfl39Oo9ynE3nbnznVfPMDeuvdYzpH8MqAW3LqKEXqweUIRg5J2eWv99J9pNuJ6QPvUEg8ndZ1QgXLx8Gxl8Mdzd5z70rqNObey2KIT2kkafW+ROvTeNItLD11oadgjgKX5nFKdeANAeZr8lT+n3oW3/xNl4CO//Or1G9I3OkxWkzoC2TyrN5XKrykaHKwkPYglu7hTDfGkfTqouKLRtVAFrHW875EHbV3mbS7uD402FC81ZMYGuM+C0Bn3fm9H4InKGspOlSuIW4rG3JrarRQEfRxFGQgvb7jnc0nZ+bemcd1dHpVrRHLnCorJGJ8T+toXctTecOW7GnwgFcbfXFsovjx4XvIPNsQtfPQY2OSgnOpM=","authorEmailMD5":"b13725d59b683df333736b9a404801df","authorUri":"","authorUserId":"disqus:buggysquashy","authorFallbackAvatar":"","message":"Hi Stephen, me again. Thanks for your patience. I have a couple of more questions. (11) First the producer/consumer queue implementation appears to work OK for me, but I noticed after doing one pass on the items, then selecting the same cases and attempting to run them again does nothing at all, any idea why that might happen? From my limited understanding it appears to be happening because the buffer block is transitioned to Complete state. Can I reset the buffer block somehow in my method which is analog to your test? Or is this is a use case for multiple producers? Even that doesn't quite meet my requirement it seems. Can I just use your first example for single producer/consumer with throttling, and just drop the call to queue.Complete() in the Producer and likewise the queue.Completion argument in the Task.WaitAll(...) call in the method analogous to your test? (12) I noticed that using the producer consumer queue enables the cases selected to be run asynchronously from the main thread in non-blocking fashion, but sequentially one after another w.r.t each other, i.e., the first case runs first, then the next after the first completes, and so on... this appears counter-intuitive, I thought all the cases could run non-blocking and concurrently since once an item is received, it should be ready for processing right away? Perhaps it has something to do with the fact that I'm using one boolean variable (initialized outside the while loop to true) to await all the tasks resulting from processing each item. But declaring and initializing the Boolean variable inside the while scope still results in the same observation!","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"24cf38aa-a9c6-383b-96f7-94de4197da9b","date":"2016-08-23T14:33:14Z","timestamp":1471962794},{"_id":"038e1ac9-6cce-39ff-a744-7bf625edb351","authorName":"Buggy Squashy","authorEmailEncrypted":"TnlK3ZSoonn/+0y4/d5w7S2VE4DyVWth27AcGfMjjZ3ADZkflyLUWhTjAlLJBw88NK25HWnTZpkTE0qvUprBMuFG5IMrLQxGtt+SlF+yNYJCduuDsBHOxrDUmDoB0E2f0rK9DpRoGx0lfLb4UtICUoB2g6iRCSwGhi5uYAEJF3TPz9UwnCYMmcUkcje1hOoOAp3R+nwHeTtctL7dc7DlBO8KEdzwyYtK7TRo3uQ4UQW9UZUFbH0CXO+POzf8iLZaW2OGAB884N0xmxLJLN5gxrOFiXXhm+c7fdMd4lQFEPo6BSdJJUmhapiHQnUt4u+LHPnNsybL5aajWgpjJyjRffOCdznlMjAetdm5aRGMXAEMcpZicRZR2MVih8OPQHj5Gg6RFpi9ZVB8Y/0HVoNFIKK3WOLEZWwCaUHQ3H8rNZw2KjDeOiydIdYi9I/9BspMpHAMNEd9PqbvsyHdyMMuni9mS1kzNLE5hYUlTo6Yci8NpwuruQLOuUzrf0FkPKe3CaL9GUm4/QZNlAIwOKjZhPeYXNCXdPc9RoiZzRB1SS7AmhNBwqzvBpypQp703Ng3cwbinzySzlAUgiRQX2OXbXG8MRyXq3MLzsKZFEfWPzDPft8Snz4dgWSupwbzVc7oEeuQtbTX8tZns/hHUbjG+OPpCz+jLajb1n22nYnSXGk=","authorEmailMD5":"b13725d59b683df333736b9a404801df","authorUri":"","authorUserId":"disqus:buggysquashy","authorFallbackAvatar":"","message":"For (12) I'm not sure I followed, I checked the DataflowBlockOptions definition at [https://msdn.microsoft.com/en-us/library/system.threading.tasks.dataflow.dataflowblockoptions(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.threading.tasks.dataflow.dataflowblockoptions(v=vs.110).aspx) and it looks like isn't any property called 'MaxDegreeOfParallelism'. Or did you mean 'BoundedCapacity' like in your initializer example for throttling? I already am using BoundedCapacity but I noticed the jobs are running asynchronously (not blocking main thread) but sequentially w.r.t to each other (not always though, sometimes if I re-run them I notice that some of them randomly run concurrently).... I am confused here.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"c4dd915d-24ba-34e2-bef3-b4747bbdd262","date":"2016-08-24T21:06:59Z","timestamp":1472072819},{"_id":"c4dd915d-24ba-34e2-bef3-b4747bbdd262","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Right, once a queue is completed, it's completely done and you'd have to create a new one before using it.\r\n\r\nThe dataflow block should honor MaxDegreeOfParallelism to run concurrently.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"f344cd77-d003-3f25-aa06-ff5831438d89","date":"2016-08-24T20:21:13Z","timestamp":1472070073},{"_id":"f344cd77-d003-3f25-aa06-ff5831438d89","authorName":"Buggy Squashy","authorEmailEncrypted":"Lamj811UZNL/O+yghwo+Bh6GSorchY8iXqOKh7j75NBaObK3A1TTLbNutyU99xXvCbMzU9Ajfu+WOdMrll+HO4ApvvD18Mcd7PPe0bXB0Qslvs/+7OuD45CYrWaij1/4LrGiqvgGiY8dUqCxFj69gtAyKyFQ83PS4Os7WvqTXNi9vZpGkH8QEGPi1x2j5j8FqloYky29olypE32g3tkqUu0PV3CVXD/vEwEgZFuMv1OG9D9079817h8SLeLmy4ioYQTKvso9gTGt0/hXKThgUr+or4X4l+zKxrD1kmjrQlU7Xp9yYtpM3JzbHBDjPcyra9Z0IAJGWkVKQOf7zs50bmkvn1WHJiISth0wNHmwshQ+JKHgfLdgktyiJHiqoD8xisnUxQ3j8NvBweQed4svmyh5tEHQWvTG+zYN5kGvTkkiyMu+hKj+5fpMEUw+/rCCwKO5VzretfRoDlNBADPX/fvg9ffuT9YXBpCRaI+n6Dby+B3SMq20nNGEZhvG8aEIgWL1ch8T+aStGfPg9E+r+vcOlarHlM85R4ssa6x+oDplN/yOD06RJ84MAU+OoQABYlv/HQ8qXBEwworF14IYh0jtdHrhUprcmO7De1ZUeu+iHpBkA/C41rh74bgzREV3ljdSJ4HRfbxzH/k49HZGvJ9H9KuJaEi7S/gdse0VBJM=","authorEmailMD5":"b13725d59b683df333736b9a404801df","authorUri":"","authorUserId":"disqus:buggysquashy","authorFallbackAvatar":"","message":"Thanks for your patience Stephen. I posted another couple of questions but it disappeared. I think I resolved one of them (11) when I re-select the same items and submit again - nothing happens. This appears to be because the queue was completed and so I tested that removing the call to Complete and the queue.Completion parameter in the WaitAll fixes this without any apparent side effects so far, although I'm not sure if it is a good idea. (12) The items are processed asynchronously (non-blocking w.r.t the Main thread), which is as we expect, but they don't always appear to process concurrently; more often than not they appear to be processed sequentially w.r.t one another... is there a way to force them to process concurrently as well?","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"24cf38aa-a9c6-383b-96f7-94de4197da9b","date":"2016-08-24T15:56:39Z","timestamp":1472054199},{"_id":"8c49be6b-7e51-36cc-9095-e5ed0fc6529a","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"MaxDegreeOfParallelism only applies to blocks that spin up processing tasks. Check out ExecutionDataflowBlockOptions.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"038e1ac9-6cce-39ff-a744-7bf625edb351","date":"2016-08-25T02:23:02Z","timestamp":1472091782},{"_id":"da442b6c-3580-3513-ac90-5be383fdb609","authorName":"Buggy Squashy","authorEmailEncrypted":"XizfbLzs5mX0zkasV1AAr7TO8iJmexzng7J+/XqGBkq4qNq9Isw/gDfl7wHiQD9SarShnRFoH/cNSXYNUEdCMprtwa0fnvi2iEY4ZDke3mOwEjiOC+p7oxUJbN0BQuVMvDJJT0H1uu9VbbF+qk8Tj2wK6igtciJPruqkPTtyltMKaBV7CvRkVIZebaM8Zyf9zUHEBmWVvRiNDf3srfmF/sezxw9UbwL0p+1EbG7wOXjGkcCoh9xzvBU2pCBrHkdczgB1uKZ98T05dDg2Z3JQVYTp6BIYmXEPaWPPY8iLuRGAd+iDPkZqShtM2BhohaNWXmd65Sa4VbelQX494/FqaL+f1Q6NRB5NFiWsD7ovA0wvqD/6RAivk2icpS1ic51fdbd1WdBgO8kzS6ii4Z6+TZjNdLq6co0WW0X1Quzwj6WcTGjUFxEfHMkOQDo8YuY5wZz+in6QfVonIVqB3o1GqvnMNd90yVwszp/i54M5IsgqHh3XNqlfcwyhsRR+uhqLlC76yXg03oBzRrj2jkOcBEsvIZcgf91yFxu3TTWIXoDM6hHYfgXutBmbMkCKuTk5pmyqDMx7SsgJDLbcU+luyv88Nzk7hfQxpX7MspvDkPYfrJMXsO2VrCnzQOKi+X3RPvq4+hHuYQgGuPgLYFHOQaqtQItpLv8Ip+HvY3fUOP8=","authorEmailMD5":"b13725d59b683df333736b9a404801df","authorUri":"","authorUserId":"disqus:buggysquashy","authorFallbackAvatar":"","message":"Thanks Stephen. I tried with BufferBlock initializing it as:   \r\nnew BufferBlock<item>(new ExecutionDataflowBlockOptions { BoundedCapacity = maxCapacity, maxDegreeOfParallelism = maxDegreeOfParallelism,}) with both parameters set to 8 with the rest of the code as I had it before; but I still see the same behavior, i.e. sequential processing of the items in the block. From doing further research on this it looks like BufferBlock is just not designed for this. I tried to re-write my code using ActionBlock which apparently supports concurrent processing and throttling but no luck there as well. I posted it on SO here: [http://stackoverflow.com/questions/39150903/concurrent-parallel-job-processing-with-throttling-using-actionblock-in-tpl-data](http://stackoverflow.com/questions/39150903/concurrent-parallel-job-processing-with-throttling-using-actionblock-in-tpl-data) ","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"8c49be6b-7e51-36cc-9095-e5ed0fc6529a","date":"2016-08-25T15:00:51Z","timestamp":1472137251},{"_id":"8e83b8b9-1893-3b43-ba8e-1a8c05947a86","authorName":"Nicholas","authorEmailEncrypted":"pIy7bDos954DRaYzRkcey2dSCqvChjIKxmtw4Xfuek4d4yPiU10eBD6XnP2uUoPv7SB3IhetLdpzTzF1uOztT502TkkfFaxSZ5J3YV2a5TUmnJzDg0iA18Hc+enbstaDTpSldj3ZHQxn5oYOQh9ngbsjYHuyiKEBvooQ2NRUXHfATTImuYjO6ZUMd62u4nkz4lgqSCEcTiIM6MD8+A6m9s85x25Mvi3cFYBMOAif7unK2I9rWB2idBYm6m3uz3JA5GgyvMifLPaHIb9/jcH0yPLjJkyY9gIVtPd0M1eUB61yU5IBUlrOZcjSxN/xMeY2uSIHCt2Ljq9yCOH3ytz18NkXA39NNdyH3lAQluv4uOohsx9aoGsVCNJIfllRLzPGgz4G+b1Y6ywwMFTSslzPT6ZxOORV6BSO9qS/MZcqQdCl+1U+4DEsJN3JuCJl9s+n2QAGjBg7pfZov1YRjJZdhsng3//CncmKGKQPdxmL12F9/TMH4H30TtSGDvLCDspdOHDwcT6Ulq1EeBO7hr0fXWzc7/+NKQ4FJ93pr/ewSnH5yFPTV6dR3b6k0GtigV7ED1uc4FPbkiRy6Ss+Cj49RQpsz4XuFL7cYsh0oY8SUWt0b5RjGd+dEEbV1igVUiTIlk6ay8iOvee0r2w3hc5TaI8cTpMCLYHAZJ/0cIyB/K0=","authorEmailMD5":"a495a370830f1691666642f1e0fd5ee0","authorUri":"","authorUserId":"disqus:disqus_7SSc9LmSyX","authorFallbackAvatar":"","message":"Hi Stephen, thanks for taking the time to explain TPL, I think it will be suitable for creating a pipeline for processing throttled tasks, e.g. only consume xx per duration. I guess either in a specialised producer or a DataTranslation block to release tasks as soon as the duration has elapsed. Putting it in a consumer action block would loose the parallel execution. Do you have any suggestions?\r\n\r\nOh, the last example is more helpful if you used the following consumer definitions\r\n\r\n var consumer1 = new ActionBlock<int>(val => {  \r\n results1.Add(val);  \r\n Console.WriteLine($\"1 consumed: {val}\");  \r\n }, consumerOptions);  \r\n var consumer2 = new ActionBlock<int>(val => {  \r\n results2.Add(val);  \r\n Console.WriteLine($\"2 consumed: {val}\");  \r\n }, consumerOptions);  \r\n var consumer3 = new ActionBlock<int>(val => {  \r\n results3.Add(val);  \r\n Console.WriteLine($\"3 consumed: {val}\");  \r\n }, consumerOptions);","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"","date":"2016-10-04T13:25:24Z","timestamp":1475587524},{"_id":"e38a5c27-7a09-3773-adfb-3d3b765cf902","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Hello, Nicholas,\r\n\r\nI do not recommend using TPL Dataflow for throttling by time. TPL Dataflow is designed to always flow data through as quickly as possible. (The \"throttling\" in TPL Dataflow is more of a \"don't process more than these *at the same time*\", not \"over a period of time\").\r\n\r\nFor time-related operations, I recommend using System.Reactive. Rx has a number of built-in throttling systems that work with time durations.\r\n\r\nAnd as a bonus, TPL Datafow and System.Reactive plug in well to each other!","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"8e83b8b9-1893-3b43-ba8e-1a8c05947a86","date":"2016-10-04T17:11:08Z","timestamp":1475601068},{"_id":"1bcea007-e335-3ebd-b122-4d7b40783a0a","authorName":"Nicholas","authorEmailEncrypted":"hngcCWeOlFHKFzXOKPUxgS+ds2AcsIXVqHSp/y0tEYohG/FB5/8XcUaqKEFGX5myqkdjPGyUg6qNN+PeSAJUMqu5pbBkH2uMbjvZnF9Ugmlb1+eLXL2wCiWk3UgwUasrCsAgxfhmgANtEbkZSZ5PghfBrZwuv9KoTZlJQ1el21c2wTKzpFPVAcyks/UjSMotv+5MnqKGfaoygMG56NEzb2VI65RxtKhSBE8abckCr+FWd+sMfP/rKkeSOxbL5PpXlcGAU6XQi/cces/svjqI48FZWeVWdCEbquty3/17erbz5TpiBGrSHNUDcLeHQfoPVXIiMv7d12b+Gc5oYdL1hXrDNnLrDckT3+pWPnGDG8BjHcgQ6NwrC5zd5eiIx5FeZbAoXEPIFflbZU12E04I6JNuqIYW+z/CYZRH4fjLSz51OT4j1GgDYiPvybJcYD8c+qOIkqHvcPfYOt7DnfIwoMKtUDR2l+vCU9kYY55WhQjQ38P0R16Xxi5fukqeKGsGSG0lEvtLMF4+zTE6+CNIReCpiP9HylIVOECHTjf83fpldk+nbq7nh5qOHwD6B5s+f9abhLY2ILycTjO6bFmwwA67fbAzyBkDG5oXRWklBkluG1UUK5Tf1srcbZUh1kEuvctmBDSeNdO2Yw29fnhfoTYoduO2qYseN4Tqkf41/40=","authorEmailMD5":"a495a370830f1691666642f1e0fd5ee0","authorUri":"","authorUserId":"disqus:disqus_7SSc9LmSyX","authorFallbackAvatar":"","message":"Thanks for the reply Stephen. I just extended your example with a Transformation Block that uses a semaphoreslim to waitasync after xx items are processed, it then awaits a Task Delay for a duration with a continuation that releases the semaphore. I think it works for now, but I do not like using the wrong tool. I am hesitant to post on SO as there are hundreds of similar questions, just need a simple async queue that I can continue posting tasks for completion and it will manage batching the execution and responses to the producers. Maybe I should take a look at your Async Library. :-)","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"e38a5c27-7a09-3773-adfb-3d3b765cf902","date":"2016-10-05T02:59:38Z","timestamp":1475636378},{"_id":"389f005a-be32-305c-ab95-cd4edc9be21c","authorName":"Peter","authorEmailEncrypted":"JpikGLMrIxB6X23/VqwwfHuICh2iQ2aFqNpqVOV4AJPPSap2yTZfJR8CFIRWzSKkoim+a0Uu5L/h7xbCXamEJlAIw+i5Pps8zEhnLcnURPmM1Zh77MwuuGkb+XybeuKJO+pP2XqVVZDfI2rLWLe9OuPKnOYDXuFDPUqSCBFYOGaEsXY4C6/qVo5MdyOoHIsy9a8IGBlozBj2dTvUpcq/T6bDkmvXokTntITKorXVjudaCHF08IOmhDQQSS/0UvBzVCzvjnNZSFGBwaYQPVIcsgAsTWVpTxygQ2gbE77zi1eusACywuubCFXNn40EGwLKlnU4C4Qo6ISrDiOOHhJ5x9o5kmO+YsBdv1fzf27wZwR7EwUMvPwzlYdDAiiJp72TiRew9I7sFCBg61KoMw1tJvdxr00PUl0gY83W/vyok2OyQHj1Pzm/MsLOTH0N/dZ3Uox2aSIEAjjEuSlE2Z5tGrOaucPeEDILY98Kprduy0lWzMwdQR7BtA3YBGIBIMEUKMK2GiPG/AIprcoQpf+ZDd40LhttKfFD3pCB1WOQoxn8ySdOubJjQW/4RxMtKeHyTkjiBHw3RKJAzB/U4ZlHb8mRh9TczAzPmWiByE6LRQJBQ4EymF6IhDT0v4wqUdd1trkFSLT1P1VTzboi7NFQ+uDw4Qn+aU5IvC0dyWL+br0=","authorEmailMD5":"c4cfe03de383452ad0c9c586cf12a4d9","authorUri":"","authorUserId":"disqus:disqus_hLG8Vpfw7A","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_hLG8Vpfw7A.jpg","message":"Hey Stephen, not sure if you still respond here but i will give it a try :-)\r\n\r\nI started working on a program and thus exploring new things .NET has to offer, so i came across TPL Dataflow. Thanks for explaining it first of all, but im kinda at a point, where i probably don't see the possibilites i have quite yet and so i can't come up with an own solution.\r\n\r\nThis is what the program should do:\r\n\r\nI want to import XML files to the database. The incoming XML needs to be parsed and validated according to the XML schema. After that business objects need to be created and it needs to be checked if the item referenced in the XML is currently locked by a different user/process. If this is not the case, the business objects need to undergo a few plausibility checks and if those are passed, the data only needs to be saved to the database. If somebody is currently locking the item, it needs to wait until the item is released, so it can be processed.\r\n\r\n- It is required that each incoming file gets processed at some point; it should never be canceled or require that the same XML needs to be sent again to my import.  \r\n- The order of each XML is vital and should always be kept.\r\n\r\nAfter some research and many tutorials like yours i came up with the idea to use the .NET FileSystemWatcher in order to get notified when new XML files are available. This process (the producer) should create a joblike object for this xml file and and place it in a BufferBlock<job>.\r\n\r\nAn async consumer would be already waiting (blocking thread; async/await; while(await Source.OutputAvailableAsync()) for new jobs and start processing once the first job comes in. This part would parse the XML file, check if the syntax is fine and validate it against it's schema, create business objects out of the contents and add those business objects to the job and place this job in a different BufferBlock, where all jobs gonna be that need to be imported.\r\n\r\nA second consumer would work just like the first and await the first Job already and start by checking if this item is currently locked. If this is not the case some plausibility checks need to happen and the import into the database can start. Job done. However, if there is a lock on this item right now, i would have added the Job to a third BufferBlock/Consumer, that only has the task to poll and check if the item is available again and place it back in the second BufferBlock, so the import can be started (the lock will be checked again to make sure the item is available right before the import starts, in case we had to work on more jobs before this job came back from the polling-consumer and somebody locked it again).\r\n\r\nThis in theory should work quite nice already. However, i have one more problem, which is the order of the incoming XML files. In a case where two files come in referencing the same item, whereas the first will be placed into the third BufferBlock (lockcheck) the second XML could be imported just because of bad timing where the item gets released after the first XML was placed in the lockcheck-BufferBlock. The idea was to check if there is already a job for the same item and also place the second XML in the third BufferBlock so i can keep the order. As far as i am aware, i have no possibility to check the content of the third BufferBlock when processing the Job in the second Consumer.\r\n\r\nHope thats kinda understandable. Im a bit overwhelmed with the TPL Dataflow and kinda can't the see whole thing to understand what i need to do :-)\r\n\r\nThanks in advance!","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"","date":"2016-12-14T14:00:30Z","timestamp":1481724030},{"_id":"4786a8b0-e1a6-31ea-8a81-7105e16f9659","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"This post is about using BufferBlock as a Producer/Consumer Queue. It sounds like your scenario may work better as a Dataflow-based solution instead of just using it as a queue. With TPL Dataflow, a \"consumer\" often isn't necessary; you can just end the pipeline with an ActionBlock instead. You can also use TransformBlock to modify the data as it \"flows\"  \r\nthrough. This seems to be to be more in line with your needs than having multiple producer/consumer queues.\r\n\r\nI'd also recommend not to place \"locked\" jobs into a separate buffer. Since you need to retain order, your processing action should just wait for the lock to be free directly.\r\n\r\nHope this helps!","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"389f005a-be32-305c-ab95-cd4edc9be21c","date":"2016-12-17T13:38:15Z","timestamp":1481981895},{"_id":"6f6c48d6-ee0a-3759-a404-5729414e8bfb","authorName":"Peter","authorEmailEncrypted":"Df31fuQOBdOrG68RFliSaXCBopiBEm0dZPgv5Mkex0eyTxd+RtsICcLS9toZ8+i8D0SHpJFeUsptYhlm9f851cVLlSaQac53j/DllI79b/XPZUN5zB+275nHTKzppcGZELW0PkZ2VhSd90NxONGuNbrKTkauhWnfFKnaNUivLDkUE5cp45GzNcXYaeKx7R1yN4nMhPEhcD7nrOh8iY9Q5N5UBM1K87RfTsxb6VxLAM81Hfw+selxLcv4/8szTqunkN0YfdjGZujlM7C6uvoyWx+uoJVtcLbWZYUaczzrQp34O69gybZ+tbTEZe/4gNhd5E3cn7HSee3o0Ck4vaELtJw6wnfxODMUd9HPbC0xHSHKeU0HodMF7F+w6Dtt7+w1egAJJcSkUS6+RGi8jHpSGS9gOURcLrs/9B1JdSs6Oii1jupukzNswxjBRucC7PbOaichY2PiU7i16s40ygEFCAjF0y7bdCyTULNM2BRXP9OHJbJYRG/apZzppKrRwl6qmk0fu9/QMeW7M68GyhdhhjcLZGqMgzk4jtOya8EWVM7PfzUWDJOyHpkxKQOwEVA8O4P8gngCTOqORQ/ajn5H4tl9JMTX8cteNyl2CBPXd2U/GaqA30DCoPV9R79G02xF7MGSUhvJAxl/u6qV6JLB+CgxpmiW2UQFzzaqBwJEQag=","authorEmailMD5":"c4cfe03de383452ad0c9c586cf12a4d9","authorUri":"","authorUserId":"disqus:disqus_hLG8Vpfw7A","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_hLG8Vpfw7A.jpg","message":"Thanks for the answer Stephen! I'm not quite sure if i know what you mean by a dataflow-based solution? So tpl dataflow is not really meant for advanced transformation/processing of the data? More like targeting simple data?\r\n\r\nThe idea behind that producer/consumer in a pipeline, was to split up logically different parts so they can run parallel, since reading of XML's f.e. can take a while, but also importing the data into the database.\r\n\r\nOrdered your book, should be here tomorrow - so i can get a better inside look into TPL dataflow.\r\n\r\nWaiting for the lock is probably a no go, since this can take hours even. I only need to retain order within those jobs that reference the same item, not all of them, which makes it slightly easier.\r\n\r\nThanks for your help!","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"4786a8b0-e1a6-31ea-8a81-7105e16f9659","date":"2016-12-19T13:21:14Z","timestamp":1482153674},{"_id":"d603e332-98a0-34a6-bb52-14358642271e","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"What I meant re TPL Dataflow is that it *can* be used just as a queue, like I do in this blog post. But it's far more capable than that - look into ActionBlock and TransformBlock to build more dataflow-oriented solutions.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"6f6c48d6-ee0a-3759-a404-5729414e8bfb","date":"2016-12-19T17:10:59Z","timestamp":1482167459},{"_id":"4d68b825-80a7-3ff6-bc83-8af23fa7078f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The code you posted is a valid application of the producer/consumer pattern. If you want to use more TPL Dataflow, then I'd recommend looking into ActionBlock instead of BufferBlock (which essentially moves your consumer(s) into the dataflow mesh). And no, with multiple consumers, you can't guarantee FIFO because multiple items are processed at once.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"9f99ae37-3b8e-360a-b7f2-b2d78b9774fe","date":"2017-07-10T13:53:10Z","timestamp":1499694790},{"_id":"9f99ae37-3b8e-360a-b7f2-b2d78b9774fe","authorName":"burak","authorEmailEncrypted":"HtOG6Yd2YJxRMwWWU1NXbq0NukUhyTsDyn+mzWsckynwD2haYlut/gxOzC/Mc4P5OWX4+GrEIwzW3NiJb2R+AJT0AuZAFzMXeRG+wjuid0C8HhFr+yh93hCaZV3n8SLQ23AIOAMe6fmcI29w0XpTpY6h846euYpXP2EvB++jGz3+ihpmou5VzCFkIzSVKcVQRQJdAzgKVooueKhzGl3QRA2/aCHvj9m1MI4tpysn3Oqewq5axjM/mnmemsb9qYCfK95mjiT0XqC9u84NmG0kxisXMkU+tA6+f4/mHgs18MGMy68YNb06UGKVfNrM/vSisA9X6quC6qEgz8hKnnzlcf4DfAh2ACPJ6p1/bg3EuwqL760Bh9OOrmfiyRjvYnf8xj/Ybg8Yt3hGw5buoGSxN/WscYTzoBnN7xhgNndYA1t66l4cvenicqzlaSlx2qq4dBD21wRHqNJDX25fmYMReBEAqf7FQySwOsudaUk+T/K9t3kZp8ZI7zI5Wxc8qDtkLLkOE6y8gh7WiGT/LiFLzahBQgi+vPnYcSbkaZ6roZBxppWU0PVvQrJm1K/8ca/1xsd3wG/5XHL1o+HwUH8d2WHIGWYEeRVbI2jBQR1KWz/BHY/vvh5QPpvYFuJjdw19NIL0D0BRvQWRy603YbGgu1R8/GvB0h4AlPqAax93v8s=","authorEmailMD5":"181f504d1045d08f580ebc4ce4f9a843","authorUri":"","authorUserId":"disqus:disqus_30IsJOLcrN","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_30IsJOLcrN.jpg","message":"Hi Stephen,\r\n\r\nThanks for your brief explanation. I have a program running as a windows service, an infinite loop performs producer-consumer pattern. I was using BlockingCollection<t> implementation for my purposes, then I decided to migrate to TPL as long as I investigate on TPL . So I build some code in my own way this and that. Would you mind to make time for reviewing my code ? I wonder if this code suitable for long running? Do you see any bottlenecks? I haven't used any parallell approach, if I want to use parallel, should I use it as you provided above \"Multiple consumers\" ? Can I ensure the processing order(FIFO) if I use multiple producers and consumers?  \r\n [https://gist.github.com/fabercs/a4c92abccbfeeaca92293386406d8ef3](https://gist.github.com/fabercs/a4c92abccbfeeaca92293386406d8ef3)","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"","date":"2017-07-10T06:11:45Z","timestamp":1499667105},{"_id":"8e7ddf9f-8a4d-3827-9745-65dbf80ab7fc","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"You cannot reset a block once it has completed. You'd need to create a new block if you want to start over. Or, you could just not complete the block as you mentioned - that would work fine. Many apps set up a dataflow mesh and just leave it operational.\r\n\r\nIf you only have one consumer, then (of course) it can only process one message at a time. You can attach multiple consumers to a producer/consumer queue, or you can change the queue to a mesh and use ActionBlock instead of BufferBlock. You can then set the MaxDegreeOfParallelism option on the ActionBlock to enable parallel consumption.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"6f51f1e4-4ed7-3083-af13-f118de7f6187","date":"2017-10-04T15:59:51Z","timestamp":1507132791},{"_id":"df6f76ca-9d7e-3bae-89db-75f6e636d0f9","authorName":"Valera Valera","authorEmailEncrypted":"WkW8mVByOMFXgD8RHYtvudL2Q11PWFW83D1uZD/vTKTC1ruPd8LLePz55z5hqlGR94XkECyq8WeT1VF4S+uPnJ/6pUSBM9MULhg3aTGsPBy3BO6w6J8nQK0bZrGq2fuL/TH5I5pd7SPdxqcTxWbq/Tnf6AvYknnG35FWrjrN3eYWPybjKDnBzjny4N3oUNfZy2f1KaSRLGVCYhSRdk3fPLe3fWGuRiykKyAPx7Yu40Yk9WhYEQStQS55GMKNvXfow1sm+CBGzndnWRIhl1lVHubvwCgCkB8hnCIZGVUvBWRcK2EEvgz8Qe/je1rqak7gK1PPtQgVtzTW0Bb7RN6d3M3t72TUsoIzQc7dQEIvg72Y9ruGiGslSxhvzBXoE86+AxYrvRTvO2m2gZFYajYmqaLJVqXZXxCsObdqgxUZ5sgKMaTMzc3e9vCqrn4p/d2JcvOI4Jyy/aetmaFjO+RX1sBgifbu3Wch1yCJag1H19evdBzwL/l/7s9/JTSdpej/jHmNTOHnZCAAWDE08qUH1bsLygPmMP4Fs5looiXp+9bq9E+Iovxq9VhBX3BPqPkfukQStQ2gCo9rEFULJBBVtg02tbsMHrSwQrTuQ53G1U+TdJDR2mJcczlXdpQ4YpxR0WNBPNAM+0+ilHoX5T5CFnBTa6f6wY/hY9Bicfr7LGY=","authorEmailMD5":"614c725eb605a8a6268d23b7d05aab13","authorUri":"","authorUserId":"disqus:disqus_SAck8xFJHW","authorFallbackAvatar":"","message":"[https://stackoverflow.com/questions/48337739/blocking-collection-when-collect-results-inside-actionblock](https://stackoverflow.com/questions/48337739/blocking-collection-when-collect-results-inside-actionblock)","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"","date":"2018-01-19T09:27:50Z","timestamp":1516354070},{"_id":"5a5e4c2b-1e3d-32ef-a819-2b778e8dd21f","authorName":"Ondra Medek","authorEmailEncrypted":"cwcYBRVUP19w9IwypYDLph2+8OXt6/c8nPp5JvKdk3l/5CpwKMrrulFHOLrlLSJhSLAf/Yuc9rjaLf3I3Lbc+GNJbYTcEah5TkffCO8XC4W1+/sv4j9gvfr5fcYdVQxVrfoEQbHJ74luMgCTge3E2lnjQKA/U+9NXUNvDrLpFEq38Y52K+sEUwJmbRJXLxbY3Ttu68eZvDsScnTabUzokKx06gVfaefBF8ffz29PUg5Qd+zPd/d6+ZrY4KmjmwU6Gmx/j9JcVQzeYD/kmoI3tYmBQj7pnyBnNlUx+xiGjEr2BKr8ZlHBhT53B/f4j5KksDUYrFcFUjhZwiAaUs7josByhI+McomynPOoLM08wPBMXF3+W+3qSvHIh/Uw5PodZsqnOXltDgRKcnvh8v4PWtQ87fsAAcUnPUsTnqA5InGgk46iWxJKUi2Tgy5+HG/BwNkZy6cgftsV3+JngeOe6WJ6zuJNHfv24Yc8ieK2uM8Q7jhbWFmn0L3csi783B5kb4qdqMr+WZ6JBHs/ur0aW5sNytACRHWoMU2nrVSZ5CD2XvBQKHubYn9iZUXCn8dV0b1NwDTvEAhYnEFu/SXfg0yT+obpMAvWPaihpRfWU+s5iRNRhs+AWQjlFKVLIrDtvxZq6740H8X+AwRpa78bVwEzHb4+8YHZ36iV4tfKrQg=","authorEmailMD5":"788da16a4617bd79f2bf91d8dc258455","authorUri":"","authorUserId":"disqus:xmedeko","authorFallbackAvatar":"https://disqus.com/api/users/avatars/xmedeko.jpg","message":"But the Microsoft doc uses TryReceive for the async multi consumers, see [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/how-to-implement-a-producer-consumer-dataflow-pattern](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/how-to-implement-a-producer-consumer-dataflow-pattern)","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"0ba63598-155f-3ab5-aa2d-7f8b97681c69","date":"2018-02-04T21:00:31Z","timestamp":1517778031},{"_id":"e26a04d9-4aa1-3dcc-ba7e-6a14f3c380e8","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, as long as they await OutputAvailableAsync, then using TryReceive works.","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"5a5e4c2b-1e3d-32ef-a819-2b778e8dd21f","date":"2018-02-05T18:58:12Z","timestamp":1517857092},{"_id":"1c08c5d0-aaaa-11e9-afbe-45c42c8a0a63","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","postUri":"https://blog.stephencleary.com/2012/11/async-producerconsumer-queue-using.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"","authorUri":"","message":"Hi sir! I have a question and any help would be highly appreciated.  If I have multiple consumers can I write them like this?\r\n\r\n        async Task Consume(BufferBlock<int> buffer)\r\n        {\r\n            await Task.Run(() =>\r\n            {\r\n                int item;\r\n                while (buffer.TryReceive(out item))\r\n                {\r\n                    // Do some processing here\r\n                }\r\n            });\r\n        }\r\n\r\nOnce again, thanks alot for your time.","date":"2019-07-20T04:52:00.629Z"},{"_id":"96007ab0-aae4-11e9-afbe-45c42c8a0a63","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","postUri":"https://blog.stephencleary.com/2012/11/async-producerconsumer-queue-using.html","replyTo":"1c08c5d0-aaaa-11e9-afbe-45c42c8a0a63","authorEmailEncrypted":"aU9EMgg34cZ6bC0bUXKRe3Ox/Ohtt5QrncziPFNTefcb0PRDaPnnNV1VxxN9P1u1oPHlU5jXjQHxiC9QcLG/SImFPS9cwhudDG3rZ4+hXOXkuYoRZfZvC595y1EeJOqZIqCHefmfphFGoVOBrDqLBPZ8Rcq6tN8K4jzGC1yTWKhloaLEqGdMct95dHiLm1BOgRatnb3K42EROS/RPjvEUb7Sjevje5Sg9iZ+dApANpmZmQBsYHdfR4l+dNjESTX7IOjRibeS5NrHXyns9qtcp/jRknTQTs/DJBgPf5O+LDY3DApuQPvyyGwIfG6mLCqBfRWYYXFlTrO0kS5DYJHp9YJ3qFZsyjXmeQ6Yqp8g0JFAJZFno6/YCGESqhhRWQc5F4R4NrG4SV6F+HBDG87e4iXQxl0dcCt1vnRLI0V3Hcvzlsk/FrGPa+aPFw0YRADfXWSKANmNpTJV0TfzD6ttHmEouY5v3JFgOAxrKO5Y6l67yGcgQmYne34pWcbdPN7hG22ydnK813lMTSeq8TtqaH7u+ErNDACslzRIFlr9B6WQfbyvNcVeLJ5LlDRzKMuEpBuYwE0J4S/KKWYOhGowAyGHxTPZv9wl4sbf3ZhwmGxFr17YSyHJxtgP6GScGTS0J82YdXdnoHWxOTrK6cUp0Sq+y+xK+5Zz2+bCTTA1RFs=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"That wouldn't work as expected. `TryReceive` will return `false` if there isn't an item available *right now*. So any time the buffer was (briefly) empty, any number of the consumers will exit their `while` loop.\r\n\r\nIt's also a fake-asynchronous method, which [I don't recommend](https://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-dont-use.html).","date":"2019-07-20T11:50:36.014Z"},{"_id":"3deb98e0-bcba-11e9-9f52-af444f91f655","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","postUri":"https://blog.stephencleary.com/2012/11/async-producerconsumer-queue-using.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Theodor Zoulias","authorUri":"","message":"❝Post will (synchronously) block once the throttling threshold is reached❞\r\n\r\nIt is actually worse than that. In this case Post discards immediately the offered item and returns false. This is the kind of unexpected behavior that creates the potential for introducing bugs, and makes the BufferBlock class tricky to use.","date":"2019-08-12T04:32:50.432Z"}]