[{"_id":"70a0a7a9-9d40-3d2f-b63d-131068dd8498","authorName":"Mahesh","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://maheshkumar.wordpress.com/","authorUserId":"","authorFallbackAvatar":"","message":"Good insight..thkx ","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"","date":"2013-11-09T22:06:57Z","timestamp":1384034817},{"_id":"a677a408-6d34-33bd-ad59-ee70448d907a","authorName":"Alvin","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/03892201689252059476","authorUserId":"","authorFallbackAvatar":"","message":"Stephen, this is a great article. Very helpful. For whatever it's worth, I find the terms \"CPU bound\" and \"I/O bound\" to be easier to understand versus \"synchronous\" and \"asynchronous\". Keep the articles coming!","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"","date":"2013-11-09T06:35:45Z","timestamp":1383978945},{"_id":"4a744f47-64e2-3aa1-ac2b-e3dc8937a882","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I believe you are missing the async keyword for public Task PredictStockMarketAsync() in the second to last code box.","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"","date":"2013-11-12T08:01:12Z","timestamp":1384243272},{"_id":"79cc43ba-31f5-340b-8e93-905a9e2ca23d","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Fixed. Thanks for pointing that out!","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"","date":"2013-11-12T18:28:32Z","timestamp":1384280912},{"_id":"75d51504-d8e5-33c7-8cdb-52f5518bdabc","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thank you for writing these insightful articles.","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"","date":"2013-11-13T06:48:10Z","timestamp":1384325290},{"_id":"0e3a2b55-8086-3e89-98cc-4427a1ec339a","authorName":"Guest","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"If this is a significant issue, perhaps make it part of the naming convention ? Instead of MethodNameAsync you would use MethodNameAsyncCPUBound or MethodNameAsyncCPU or MethodNameAsyncBound ? For better or worse, method comments often go unnoticed, so given the significance of the implementation detail, perhaps this might be a better solution if not quite as elegant. Sorry of I have caused any degree of cognitive dissidence.","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"","date":"2014-10-01T15:34:30Z","timestamp":1412177670},{"_id":"155fd827-1f85-308b-aefe-477aea826523","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I agree. I would recommend keeping the Async at the end, in keeping with the Task-based Asynchronous Pattern naming guidelines. So MethodNameCpuBoundAsync or something like that.\r\n\r\nThere's no univeral convention for this currently, but it's certainly something I would recommend at least on a project-by-project basis.","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"0e3a2b55-8086-3e89-98cc-4427a1ec339a","date":"2014-10-01T23:42:00Z","timestamp":1412206920},{"_id":"35f5343d-7fae-3555-9472-805644bb9456","authorName":"cessna048","authorEmailEncrypted":"HFLXd4n6/TECQ6StH7VbpKMnOoiBc1r85NlRUzsjLsZftCezBl+UBoCNNSLDqalbLbJG6Nrt5+C1/wurOPQORvQJMn5SoFv1FpDU2Z4v77GTL7crjWrhw/wjVZpZ4iNEC22v2yQlXB9kygd+f/n99lBRBofsyUaD2LkgoG0/3gKSH2Yv7i02OZXSMiTCD90gkBRCKDDufdYPaVjVkA5sNVjviBa/J1Fo8/6vVKj2TQ89SPZ/lOUvuR/CU772IFG/hrbOFgocauDXmJJSnfsBONgjKbVw0wPo/+yafVvEMKdoyLTq11mvidnTUWPm2XqGJ1EAeI25dm03Dz6fDQPEpz9XVC9O683s0WJq14K06pB806vBs97F7qTvErpj6vnFbal6+6Txlxj6bC6xwqF2X+lsigT3IrpWgiSfI54erbONiJtD5ia+t09upfMGwnWyNa0FQ3cq4ssJYaJqgqWkguj/ZpUe7COIJ1MWnPlmqOjYWq/k19WyKjaQ3wW4M8Lrq7ptDZiAsoqvWpt/+OL5Ur+2aOuvfRp8dTPUDs1Za2T5x30g2skbJ82+JmChEWlMAgbG9nuVaTyt4ibtKhZW7jhZdFxrwJpHfy8LNmEip4EiSTJFaMvzUjplQt5BJxyqqHdfgj9DuIRn/eS0nVcW6QYphe8n1nvRnQuoQJH6ZuM=","authorEmailMD5":"99a3bcc695ffdcd91a1d946e0a409f85","authorUri":"","authorUserId":"disqus:cessna048","authorFallbackAvatar":"","message":"Thank you for this great article series. Sorry I am such a late-comer.\r\n\r\nI am adding DVD burning to a WPF app using IMAPI2. At IMAPI2's heart is a blocking Write call so I am wondering what approach I should take. Here is what I currently have but I wonder if you would consider it correct implementaion of async. My feeling is that it is, because it is I/O bound, but I am not so sure because IMAPI2 is not \"naturally asynchronous\" and I have an asynchronous wrapper (fake async?).\r\n\r\nThanks,  \r\nBill\r\n\r\npublic class MainViewModel  \r\n{  \r\n//Command execute handler  \r\nprivate void async BurnDataDiscExecute  \r\n{  \r\nCancellationTokenSource burnCanceller = new CancellationTokenSource();  \r\nProgress<datadisccreatorprogressargs> progress = new Progress<datadisccreatorprogressargs>();\r\n\r\nDataDiscCreator discCreator = new DataDiscCreator(...);\r\n\r\n// Add files to image  \r\nfor (...)  \r\ndiscCreator.AddFile(...);\r\n\r\n// Create the disc  \r\nawait discCreator.CreateDiscAsync(progress, burnCanceller.Token);  \r\ndiscCreator.EjectDisc();\r\n\r\n}\r\n\r\n}\r\n\r\n// Wrapper around IMAPI2  \r\npublic class DataDiscCreator  \r\n{  \r\n...  \r\npublic CreateDiscAsync(Progress<datadisccreatorprogressargs> progress, CancellationToken cancel)  \r\n{  \r\nTask<bool> t = Task.Factory.StartNew<bool>(() =>   \r\n{  \r\nCreateDisc(burnProgress, cancel);  \r\nreturn true;   \r\n}, TaskCreationOptions.LongRunning);  \r\nreturn t;  \r\n}\r\n\r\n public void CreateDisc(IProgress<datadisccreatorprogressargs> burnProgress, CancellationToken cancel)  \r\n{  \r\nMsftDiscRecorder2 discRecorder = new MsftDiscRecorder2(); // Interop class for IMAPI2  \r\ndiscRecorder.InitializeDiscRecorder(...);\r\n\r\n MsftDiscFormat2Data discFormatter = new MsftDiscFormat2Data(); // Interop class for IMAPI2  \r\n...\r\n\r\n // Blocking write   \r\ndiscFormatter.Write(result.ImageStream);  \r\n}\r\n\r\n}","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"","date":"2015-07-16T14:41:24Z","timestamp":1437057684},{"_id":"f0028b8a-7b69-3c88-97c0-24ad3851960a","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I generally avoid fake async especially in libraries because it invites misuse. So to me it would be cleaner to have DataDiscCreator.CreateDisk just be synchronous, and then have BurnDataDiscExecute (in the UI layer) call \"await Task.Run(() => discCreator.CreateDisk(..));\". The primary point is to move the \"fake async\" part out of the potentially-reusable code (DataDiscCreator) and into the UI layer where it belongs.\r\n\r\nAs a secondary point, use Task.Run instead of Task.Factory.StartNew.","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"35f5343d-7fae-3555-9472-805644bb9456","date":"2015-07-16T18:15:11Z","timestamp":1437070511},{"_id":"5402f356-1fd9-3942-94ef-9169c1d29cf4","authorName":"Andrew Stephens","authorEmailEncrypted":"ekkfgRYFfPZyQkxknvZklfzF4P62555b4JYTHrkJgYa2Ly3+/VcT4VFThhilvM9CF16pa+2qWOaI6bjErknujNlO6AaO+d3EQ3S6tHi+tntMA6Edc03ydJUwNVzmgOG9M4DFYATzKwWftHWLaDXyeXcdka7JV8NqdH7WU5MAVM7ThHuvqFv9uSN3+JkbP60Do2FHE0jc2u2xDZoRU5epculqdvtKoQCUaMFX/PiLQplxZYTrR0LsDcbRQDgBVyKhTu7HBgg7lEEXjqhVTnVnpKv6LZBs08a5VD4w1JPF34wG0rcRjWlP5JvOu56/d03ftGW3LYiNbP9v2YqYNMjeeDt26VvFAEA1y3glpyleDpDtPHOh0wxyOEejpuGJuJq1zFyqpZKlDkLib8N7b+RHNeoypT8aS+M87+SImOZ/sS1J30c74BQrbrr70RFis7GbFLOxFOTaEovgkkcdpylm2Vkm8kC83U+0shpEaGjNsN3Ae1ch51ra9r5qXKdNEtKFTXKaxWSVt346JtgRBSv8+bFj02D9VFWCbSJIcUd6mEEIeSLhIpFNt1HUGLMtM25Ol8zQEshTAeXdy5x7b7Bt2+VjWSvmXtVsRh5Ta5y5IwONFyBVNEol2XQ6hjCc39lZCEBIfsV7URZqSEdNvetZzmF3OYgiFhYA+L9FOs6f+34=","authorEmailMD5":"89bfbacc849835ca831d84ae6bd014aa","authorUri":"","authorUserId":"disqus:andrew_stephens","authorFallbackAvatar":"https://disqus.com/api/users/avatars/andrew_stephens.jpg","message":"Excuse my ignorance but why (in the last code snippet) does MyButton_Click use 'await Task.Run(myService...);' rather than just 'await myService...'? Surely the method is \"awaitable\".\r\n\r\nAlso, I'm a little confused by \"CPU bound\" and \"I/O bound\" in this series. Why does it matter what a method is doing? Surely a long running method is a long running method?","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"","date":"2015-12-02T09:15:59Z","timestamp":1449047759},{"_id":"8f74b0a9-65bd-312e-9c82-f7d719f7d379","authorName":"Andrew Stephens","authorEmailEncrypted":"nJxbADHUfnw7+BI0jhSUKaoFtWN+9uGxOsDl5UKr56Plhx8U8kZ5f9mw6EZQffS+UBqGRB7DoqqEr8LYZMk76nqk4PEwriLpzhjsQc8w9P8fbx9CDSz6NWYLjgPTyq+h8SjXR6J9fk4fI6C4Zh9X3vN5c4MoO68JiP/o6Biii+kp4IU3k6tQxGntxnZtqud7QLLo1wkRxv0V5r2CG0VwH0TH094rp1YxFXTanXUg4kP/UwgJnVnjTVfCGMoIyh+cWha4f5CKhkuw7tVvNqnXvOfgqJe98d8FP8hpLpRKSyOzhe8MakbHX6aBnPU3nCRHr5JP1vsqTHdsVKNWgsPIyMTRRNDa0CsuFQqNxPHO9qMOu9anFksYFNygFp8RiaAdW3t8zb8xokFWeXI3kZJwdu5Fx+Lcro2IeHrfqhAZs5EOgYMdnalszRB3uv1ZbyrgXGsW1y7Hj6wGQJDZEpHGwDttumpRJHPjWFpvcjG4bGYJVCIJz2OdO9FSu+syE+MA/qOpIZqqbVnCAPyTqYY5AlzmjI5/lhKVuBk595UKkqazGUqpx1chbIxwA8DaqYUIL48Zu8e7AOmKSYqy7Ru1leMeBSIH+/j/TX0EkMGZ5gbdj3r50zl9zGfeELL2a/X0MTAHqRzadzOIUj0swLUz87LklMhvApSyBhWbzZyPstc=","authorEmailMD5":"89bfbacc849835ca831d84ae6bd014aa","authorUri":"","authorUserId":"disqus:andrew_stephens","authorFallbackAvatar":"https://disqus.com/api/users/avatars/andrew_stephens.jpg","message":"Thanks for clarifying. So for the purpose of these articles is an \"I/O bound method\" assumed to be using the async BCL methods (e.g. socket.SendAsync rather than socket.Send)? Book just ordered by the way!","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"c9694c5e-4f12-3e50-b741-7528cf34723a","date":"2015-12-02T17:24:59Z","timestamp":1449077099},{"_id":"c9694c5e-4f12-3e50-b741-7528cf34723a","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Your two questions are very related.\r\n\r\nFirst, the difference between \"CPU bound\" and \"I/O bound\". The difference is that I/O-bound methods are naturally asynchronous; that is, there is a way to implement them that does not block *any threads at all*. For more information about this, see my \"There Is No Thread\" post: [http://blog.stephencleary.com/2013/11/there-is-no-thread.html](http://blog.stephencleary.com/2013/11/there-is-no-thread.html) . In contrast, CPU-bound methods *must* use up a thread by their very nature (i.e., they execute CPU code).\r\n\r\nFor I/O-bound methods, it's best to have an asynchronous signature (with a truly asynchronous implementation), and for CPU-bound methods, it's best to have a synchronous signature. This post (\"The Complex Case\") deals with a situation where the method is *both* I/O-bound and CPU-bound. In this case, it's best to have an asynchronous signature but with a note that the method is also CPU-bound.\r\n\r\nThe reason that MyButton_Click uses Task.Run is because the method is CPU-bound as well as I/O-bound. If it just awaited the method directly, the CPU-bound portions would block the UI thread.\r\n\r\nAlso note that the ASP.NET controller does *not* use Task.Run; for efficiency reasons, it *does* want to block the request thread on the CPU-bound portions rather than switching to another thread pool thread.","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"5402f356-1fd9-3942-94ef-9169c1d29cf4","date":"2015-12-02T13:20:48Z","timestamp":1449062448},{"_id":"fbb86401-4097-3f6c-878e-df7acdbb76fb","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes. That's what I mean by \"truly asynchronous\".\r\n\r\nWhile it is possible to do a blocking call on a background thread (e.g., `Task.Run(() => socket.Send(..))`), this is an approach I call \"fake asynchronous\", and do not recommend (though it is - occasionally - necessary).","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"8f74b0a9-65bd-312e-9c82-f7d719f7d379","date":"2015-12-02T19:18:02Z","timestamp":1449083882},{"_id":"3070325c-a41c-3896-ad6e-4eb1858c6da5","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Technically, it's the same SynchronizationContext unless there isn't one, in which case it's the same TaskScheduler. The vast majority of the time, the TaskScheduler rule doesn't come into play, but it can catch you.\r\n\r\nIt's not necessarily the same thread - that's only true for UI threads.\r\n\r\nIn particular, ASP.NET (currently) has a SynchronizationContext that has all the \"current request\" data like HttpContext.Current, the currently-logged-in user, the requested page culture, etc. When an async method resumes, it will resume with all of that same \"current request\" data, but it can resume on a different thread.\r\n\r\nFor another more common example, the thread pool context comes into play when there isn't a SynchronizationContext *or* TaskScheduler. This is the normal case if you use async/await within a Task.Run (or any other code running on a thread pool thread). In this case, there is no context, so it works just as if you had specified ConfigureAwait(false) - that is, it will resume on any thread pool thread, which may or may not be the same one it was running on.","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"c283aa43-841f-3c84-89a9-6814d2eee83b","date":"2016-02-05T13:59:12Z","timestamp":1454680752},{"_id":"c283aa43-841f-3c84-89a9-6814d2eee83b","authorName":"Andre Soares","authorEmailEncrypted":"jswFfOTEsNYPur3b+MxniJSUqar59A6xwBh+VO0gF2WgZhht3ta5PnvycBH2azJ4Q9GHIiK4J77lpmegHmJfglQILJb6r0mdijaJPDwZ+iPi8w+la2pqPxw696JNl6C6+FGqU/JAfR0ZN/YtFlYumdOh/ceWSEwa5hCmgJI4mVIcAf855Sk3gNx5wIpmPF8g1Q1Gx/gmXcYWGsJeci1M2TCi5uNp3z9FiBWWvEV39QXfUd0ig1yDcYNMN9eq6jdh9VInqph3kdn6oqKRW75RR5+dND1oBhzjT+hTGFq4OGzQXCW1OzJcp7GO6yA37WRTQO46qP/DN+Ctlc6pn6X6BCHD7LDybaVACwxQYx13NTvij2ayUTUH0tCoadnq7XiOr6beU+KbRrn1M+3b4mM9vy7RaxOCi/GDCykSHVm9QRvSX9rYwqeP4gtMZ6C6eTYvJBLH4N9BwY4wQuX0Ap+S2+qJsKdaYzYx9xHdQWRh3+/sPqVrdptN++FM6MakHEFPHugrMwvFNC19siJL8t0oMMeQxFb2JwTErBxcqtcXoekXy/hieyVYRjrVzX0CR8VsPOAoesx4BvDsogYFP5G9j/yA6mV7noXdIhNl9iCgDCpFbEZBdMUWwKbYdWYcfop5QvDibtzEoYYaiM19t5ycJT9Cq8Sgz1hu0pNLw81xbcA=","authorEmailMD5":"804aee742efaa7a85465e07f45fbac25","authorUri":"","authorUserId":"disqus:andregsilv","authorFallbackAvatar":"https://disqus.com/api/users/avatars/andregsilv.jpg","message":"I am really thankful for your article series.  \r\nCould I say that the continuation of the the method called using await runs in the same thread it was called, or it is only in the same Synchronization Context, unless I use ConfigureAwait(false)?","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"","date":"2016-02-05T01:49:44Z","timestamp":1454636984},{"_id":"3e57502b-fed2-3baa-b862-718a831630c7","authorName":"Abhijeet Nagre","authorEmailEncrypted":"dEqLT/nb3p9Lhn9ssAmh5Nfe88RFRpkR7Np6Ed45Hx5GpzgqoLg4Av8jLuHJGcFzFkZk12Wvtw521XBu2RylM5MgJzkT39BZmbnYXihGqBFb0rrab0Acw6PgpZy+bAoKK0eIbUzAcIIvESpY9mIOx8xCmBfhipVqY10FBfYjRkjcG2rfpmfi0YIRga9TNlV4jWv+zCJ9uPLP8Mt5hF6VemspzNlh7Ou3Ajoytv/x0TBZQIRXtxfwdsPh7xJmCQYPFOAxS1WfIXyXBQjuf8ZLYzv59HLl/LYedGx1VBlBC7XjOHQfCqU180Cfkf0r8PlxlNKLOcHgmNI5T2s1htTYdbZaMqXrskrHyYY3eZK9nGMD+ntVtHGBDfmAr9ko++x6B7hzmgzoVjXzLdXtx27sIkSRLnOivIslHuiaJv0+U637bZi05O+BxgHX/swdotkCHzXt4z5rGcJ4OorRZX4LtnreQYj0cxkNIyVGH+ZE+P8kzl0jwuUlcxQ3iOJisKIsJrDcogYS9LoK8xvotXciEx9jNEkiO3/YjaiLHbaMUflB0ZORn0jUbPJBBY1rsQp7XOOMD4Dn8uyIB7h5mkULmDoNBxk/U5Fs43cmUmMtC8gzqnuBBvbtPGubdlOqTonN315Q6PPXNawm1OTR2UklGQY13hM4m0EyWOsOoDlULGs=","authorEmailMD5":"14256ab99ccb16cbddc92bb32e1561d5","authorUri":"","authorUserId":"disqus:abhijeetnagre","authorFallbackAvatar":"","message":"Thanks for the Really awesome posts Stephan.\r\n\r\nI have an Application where I need to process nodes of the XML, processing is mix CPU and IO. I used Task.Run to run them in Parallel as I had not ready your blog by then. My approach was to start processing by using Task.Run and once all tasks are created Wait using Task.WaitAll. Now, I understand that using Parallel class would have been better. What are the disadvantages of current approach?","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"","date":"2016-05-29T09:51:46Z","timestamp":1464515506},{"_id":"c26c8341-83bc-31f6-bd67-1a51393042f2","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"It's just not as efficient, especially if you have a large number of nodes. The Task.Run + Task.WaitAll approach is OK, but the Parallel class has smarter partitioning, so it will process them in \"chunks\" and won't use as many tasks.","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"3e57502b-fed2-3baa-b862-718a831630c7","date":"2016-05-29T19:17:01Z","timestamp":1464549421},{"_id":"91963b5c-5ad5-388c-bba1-2d7dab3073aa","authorName":"Ankit Vijay","authorEmailEncrypted":"mA8Ee/bevaTFup1kogW71w3q14mT9dQcHwNMeVd4WlLuYtiBWWL8ujvBJY8/EgazQXDRV6YGNTSq7g2SgITWmDrPIyR6nCqbht21+mbSG2k+UQwyCMwsuvaXwxlqnxbjwUWkzbpXaVp2crlhiBKr4z/mbz4xVfCANOUzqNtn6obN2Z4VUj8mYa0QmCZtcavG0PEcererRfUVp228UvtKCT8VYwQViJChM4slw6K2NQugNdEwwUEXfwudxsBlTI1xmRCJeu22aMQF7NK+nkrGMBNYAJLYOMsWU1q8mB+nDTSTnejKwKKvVNVjjWplXf0TPWKZ6Nfwm2wh4MLOegXljMSIhB4gfQryUWxp3pnzvN2+XJb87NnVar0J/FcimMjOqJNQEK7VWy/zK6bH+jbpPFbFIvo0XiTjnqtEIY4V1VYmh2wccpDjjVF/hYT10aQZqZHXn4wjFbIuNvEMw+059j9MghU9PgDf5tz1j+S4edG8qPOcehx1yPge7Ilj2zVJ2YPs+dIZtHzEb1j6Fz3Sc7FMs2LITTXc+jJ4Oup5wq9ktGHbSxugfMmCXYpGet4HvARrqd90WDWWvfg2rPnjHSDF9OlL5zLTRQiO56kdTUgQsvlHsonocGZOydAODZNaKaS7ygv5eyY+cPqJKKPq6oaJs09TLc4AOjGnbF1XdPU=","authorEmailMD5":"e1c24b92c9b66bd981f63d9461f34a75","authorUri":"","authorUserId":"disqus:ankitvijay","authorFallbackAvatar":"https://disqus.com/api/users/avatars/ankitvijay.jpg","message":"Hi Stefan, since myService.PredictStockMarketAsync() returns task, should not it be called like this \"await Task.Run(async () => await myService.PredictStockMarketAsync());\"?","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"","date":"2016-09-07T10:11:24Z","timestamp":1473243084},{"_id":"b235d174-3ec2-31c2-94c5-33b0764b49a5","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"It is called that way from the UI, since the consumer wants to avoid blocking the UI thread.\r\n\r\nIt is not called that way from ASP.NET, since there would be no benefit in doing so.","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"91963b5c-5ad5-388c-bba1-2d7dab3073aa","date":"2016-09-07T12:12:21Z","timestamp":1473250341},{"_id":"0144281d-3ba4-3373-8a46-57e6dfbe5db0","authorName":"UncleBeer","authorEmailEncrypted":"jh8Kz1L3ZfwMzlQl2Sa/CxhHCun9f9/KsBhvq+aqpusApfdtSixRUSImiwHMh2nCTzWTTjkhgA1wccXKMkpIbu7k5p8+W+/g2g1vK0sexDw5+ArTMfP7fsMcpLbvSxNg4LgaAeATekq5o4HyjU+liwPlKeWMWQsB7xUJmLk9aT+zJgBUzB6ug+z6bXL2bOPsP+i+0e7yfXY2TIJuxxM5k8lEAGzfxcYzLCeGukbackqWUhsw/1L205/UeNgzkbKdPIpaiYxp5MBisC/6CmHxp7NC9R/AIyFJ/wG4mo9wbHuLn1KylO5oEqCtVfBsV0VhxfenUFMQAFznKIuAyo5RT0gsBkxyT83s1UZk8miYMIzQdzTurKfDS1CnjwTsDEQJ8Uo85gsK/gkdnC5/r3OiGsbXe6OqHRcG2x/yWCZbbmdVwk/1VKVxkxSTcQ0jSCQJ2XeTkLNnCrvi9nAx7hnUf4JujChlIAzYTfp1QTLWJ9fHyOdUY7Vg2kt1J/cPh2bvtfhApPhNN2jiVpNEwR2TDLziS6qB1oIUlt0oOthcFHQT/We6cwAXOOl2/azPlB6GvZ/8AM62k8KO5ebnmzGejJUhrNZ4F8VjOj5Tcysb950TARFy5YFeAycvkn959AY+GeyRldbGeUctWSMfyXX9EEuiE71NseK0ODTVUubo6Ok=","authorEmailMD5":"0b5fe433afdeb475554873eb12d3c983","authorUri":"","authorUserId":"disqus:disqus_oxBAuCWbiJ","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_oxBAuCWbiJ.jpg","message":"Hi Stephen,   \r\nthanks a lot for your useful article. However, I have some doubts about my implementation, which I copied below. I'm starting from an existing class MyController, which is handling HTTP requests. I tried to make the class asynchronous by wrapping the synchronous code with Task.Run.   \r\nWhat do you think, is the usage of Task.Run in this case correct and am I using it in a proper way at all?   \r\nThanks a lot in advance. :)  \r\nP.S.: Don't know why, the site is adding stuff: 'myresponsedto=\"\" ' should be simply myresponsedto\r\n\r\npublic class MyController  \r\n{  \r\n public virtual async Task<ihttpactionresult> PostAsync([FromBody] MyRequestDto objDto)  \r\n {  \r\n var response = await Task.Run(() =>_myHandler.Execute(objDto));  \r\n return Ok(response);  \r\n }  \r\n}\r\n\r\npublic class MyHandler : IHandler<myrequestdto, myresponsedto=\"\">  \r\n{  \r\n public MyResponseDto Execute(MyRequestDto requestDto)  \r\n {  \r\n MyResponseDto responseDto = Router.Call(requestDto);  \r\n return responseDto;  \r\n }  \r\n}\r\n\r\npublic class Router<myrequestdto, myresponsedto=\"\">  \r\n{  \r\n private System.Net.Http.HttpClient _httpClient;\r\n\r\n public void Initialize()  \r\n {  \r\n _httpClient = new System.Net.Http.HttpClient();  \r\n }\r\n\r\n public MyResponseDto Call(MyRequestDto requestDTO)  \r\n {  \r\n var myResponse = _httpClient.SendAsync(myRequest).Result;  \r\n return Map<myresponsedto>(myResponse);  \r\n }  \r\n}","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"","date":"2016-11-08T11:28:22Z","timestamp":1478604502},{"_id":"168a76aa-a6c0-3e90-9c26-65fa8ceceb04","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"No, you shouldn't be using Task.Run nor Result on ASP.NET.\r\n\r\nInstead, just let the asynchronous nature of the code flow up:\r\n\r\nclass Router {  \r\nasync Task<myresponsedto> CallAsync(MyRequestDto requestDto) => Map<myresponsedto>(await _httpClient.SendAsync(requestDto));  \r\n}\r\n\r\nclass MyHandler {  \r\nTask<myresponsedto> ExecuteAsync(MyRequestDto requestDto) => Router.CallAsync(requestDto);  \r\n}\r\n\r\nclass MyController {  \r\nasync Task<ihttpactionresult> PostAsync([FromBody] MyRequestDto objDto)  \r\n{  \r\nvar response = await _myHandler.ExecuteAsync(objDto);  \r\nreturn Ok(response);  \r\n}  \r\n}","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"0144281d-3ba4-3373-8a46-57e6dfbe5db0","date":"2016-11-08T12:23:40Z","timestamp":1478607820},{"_id":"4951fcc6-c428-3233-80f6-0ed7f40ed74c","authorName":"UncleBeer","authorEmailEncrypted":"ehKcKgTogRZty2JQ8yP511Uvi9/WJPkoI719GG0JwzfZT1kDtH4xy//roSRjD8emiC/Ql5m4UDSNukhs8K8DaH+pW8loN/Uv4ikBM3UfJVkXACv6NikVGgFEZ3N9gC2hyBAjhzQcis2PTD58uaUZnWvcU5LxEIiEQyW9lmrKGICwE7ppgeolnF5ZfEWWrx4W+5iLjeFAocHA9hCJ6hl+QSJaD9FB+ueOP2brLwEy5niFhWnumoFeqei4vcrWfv0VY0FeSzGjeoSpUGcgs1viPEh38Tz9OusylQlXNH+FRFbl2D+uAOcoHvlhPSW+JR2b2funtgkxtBqVYb97VZSnuq19JwNTuSYX18rOvr9tOrSQYlcHNUgCWLc6PUnuLeGFDKcKf8HCG5cfZ+cqJl2i61Y7c+nQHqZu8OIZJg6MREW7/i0FdRjhSO3/uQmSPlPmoU86FjtZIVcgB5rhY6EtRqLuuhOtpkpbzTMRZD3Mixf8HG+zR86rvk7KbLKWIQKsr5HG9NFW0lMB/WHNHG+125JRcdAsRy4gCcM2wsj4NB3k/qPynDRlMxnsLWOEU2WG0/BBG2jl1L9VF74c5f7vawV9zut5JT/XjTReur1NR8OsDZiO7yyYsPll24+U0dZa+e9sDJtDrvBanEpr1lbbiobu8Cl+EcdIrvi75DIfQYk=","authorEmailMD5":"0b5fe433afdeb475554873eb12d3c983","authorUri":"","authorUserId":"disqus:disqus_oxBAuCWbiJ","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_oxBAuCWbiJ.jpg","message":"Hey Stephen,   \r\none doubt: Are you sure that the Task in the class MyHandler is not async? I would expect   \r\nclass MyHandler {  \r\nasync Task<myresponsedto> ExecuteAsync(MyRequestDto requestDto) => await Router.CallAsync(requestDto);  \r\n}","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"168a76aa-a6c0-3e90-9c26-65fa8ceceb04","date":"2016-11-08T14:54:05Z","timestamp":1478616845},{"_id":"51b347c0-5458-3eee-b265-8824e4b81049","authorName":"Yoelvis Mulen","authorEmailEncrypted":"vZ6E3948/WzhkWpa6QaTrg337lCdXuSFR+hhmCrSL0JQa4E4hqyXuq02ccIUc/z2kwKDxjCkfZLhbWDStAvkDz0XeqVWogFTX6UlsbG/TCSvl7q/ZBuE8YHMu6saiOzNkFZz6P6x+Gpgyf0ImOeayGg9fOpIO3sfTy41RO0nO8NJTxezKDYOOmvh7upILMFpONMmUvS4Us2Z+ou0zPPBkcahxkpMmdLmwnbcsMHRJiXo+C4bzVVgzvvOVLkpKCLL1AHhBhhdH4gEv7DX0bgi2Q9GauBclBjYFc+AgvveDMfqhuT8SPgzrZfuVkFgi0+EEwcYPDXgwTOi0sXtyPO+V4A80pgE+17f7GZMCHc6dEbbX//zjz6Ys4HDMfXxqPwfrzX2853lRnUblLowJfj7ix0yu4KLjExsphS0UE86hdP7HLJ8Zse5ABm4+xBYb9vlzm/QWDZNAOIGRkg91u5SUMB+6W9yYAFtsQ6LWVwEQ+jCptqo2B3sQ3bnjbINKBkYWO+3e5/De0p030cuCjAVLC9s77WHOehTu1Ttnn4FnZYAJy1oWBHwreuuSVCaPHWuuWBhIEbyTs4OQmXPSOOsdwCcNz6ElUw9rCR3jz9cCs7/NvQwEWnU7auq4x4x5LweBcwziLHi95XMqgdH9O1aOIVzqDJWi6eotCe0DnJwHys=","authorEmailMD5":"311c6d390de72104c17135bb61226eb9","authorUri":"","authorUserId":"disqus:yoelvismulen","authorFallbackAvatar":"","message":"Hi Stephen,\r\n\r\nVery good articles, but I am still worry about the multi-threading work, what if I want to run a huge CPU-Bound algorithm in 2 or more threads instead of only 1 (I mean in parallel), if I write the CPU-Bound algorithm in only 1 thread, I am losing the power of multi-thread, and I think that we should take advantage of the multiple CPU that we have in our computers and servers.\r\n\r\nThanks, GBY","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"","date":"2016-11-08T13:15:26Z","timestamp":1478610926},{"_id":"ab2229ba-dbf1-3c3c-93cb-c4b1ffb470b9","authorName":"UncleBeer","authorEmailEncrypted":"PUdOfyd2R5HV/K8+TojRN99u9FZ3EZJoSp+9rTzjX2h0KBGJvdCixfzsclujbsxTCrnxLxCwVKqzoufS0XdDNJTrIKxhJlDAJ6JblpGMYJ9biEwVlzD5dVrMDPnMRFSRNqoM/daQARdrMe6fQmYwK4ux9Y76UxVorlTRq/VTHHUlStMLeizsdormjAQOhnOAKsgYJsg9zJZujZOFhHlMW/Yni9FR4WF4j979kAKQW7Mk6jSWvjn685rA7ZKC95SD1TTJ12svxefJol82zQslcKGIQKbihoCzCeaDFgmJvLwMw5HRCgXDcBE69AudtJtTIjtcNGxkhSylf0mvet96gEGRJ6s2K/zpJzCpn8Hk66YdZW6ggEQabm1LbTtmFdotYG1wVcv2dt1TTjkmQY+wCvSirmUNeuYAs26Cm4cJu2T93BcG7Uzew26omRAsBNHT9xcmxO7euKj8rsgw2lC54ye9KSk25Lh8+y+cPKdYRfGoWvS+mJ9UyxmRVIlh/otC+mAmSxgZQIr9+CzlPvojtPkzSyJVVy16E0v5LN8xQYA9p3UrprUD8cSynaP0Yq+GH7e9YPWiNL7/49udOEKRk7gsqaoEcVqczY+XdYojeMNnVlVJ/27NWNQ2vLipQnyIou2Ip9bODd28GwT/+T8sguiuvGUjKGYGXIjrVwSgm7g=","authorEmailMD5":"0b5fe433afdeb475554873eb12d3c983","authorUri":"","authorUserId":"disqus:disqus_oxBAuCWbiJ","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_oxBAuCWbiJ.jpg","message":"Thanks a lot, this was almost my first approach, before I switched to the one I wrote in order to modify the existing code as less as possible.   \r\nThe only problem now will be to make the class MyHandler implement a new interface (and not the current one with the method Execute): The new interface should remain also co- and contravariant, which is a big mess, if I don't remember bad.","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"168a76aa-a6c0-3e90-9c26-65fa8ceceb04","date":"2016-11-08T12:43:12Z","timestamp":1478608992},{"_id":"05994ba9-48fd-3cbd-b043-630cf25bcef9","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, return types from async methods cannot currently be variant, because Task is a class. As long as you await the method call, this is not a problem.","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"ab2229ba-dbf1-3c3c-93cb-c4b1ffb470b9","date":"2016-11-11T13:06:40Z","timestamp":1478869600},{"_id":"2771bb2f-1af2-3373-b290-f2c318a3fb2e","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"It's the same thing. I'm planning a blog post on the subject.","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"4951fcc6-c428-3233-80f6-0ed7f40ed74c","date":"2016-11-11T13:04:18Z","timestamp":1478869458},{"_id":"f7a7289f-eedc-34b0-a97e-868ef0583b3e","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I never recommend parallelism on ASP.NET. Every time I've used it, I've ended up removing it because it impacts scalability in such a negative way. Parallelism would only be acceptable if your service is private (not on the web) and you *know* the number of simultaneous users would always be low.","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"51b347c0-5458-3eee-b265-8824e4b81049","date":"2016-11-11T13:08:58Z","timestamp":1478869738},{"_id":"412f8851-a251-33b9-9f6a-e5b73b9fee3c","authorName":"UncleBeer","authorEmailEncrypted":"AcrwPxZV82wua1v5eU9Ai0hGIBL3D3vAOp3EW4B129B/ntZ1BI40tL4LpjyvqGwa4yIJpIf6aU8r3PFWlGTuCyw/tDw7DEUSgh/bVf4jbZeNMjQFFc2wsABL7UIAfrZGF1NIzM345LnHx9H0b9OwQIyECSw1pi+jsu0IE2GGH4H2CVRlKQ+1tg9irL6ZxAg9LgqfbF8sZQVGM1DYS22Qy9luWbitjyOBY2CwHdfR6jIiSaPYdtLlTBaH/HHUz2iGpQ0fsmAQ9aXBCSX7zTPY9KvkKe/MLDWaD/2cGjxGUwAyXi64PeQbtD5rzOcwpwFOUAvViIDe6iuczx/zKYWPi9NxMq0xc810Q6sQkZR0lHXkSp+hjtF9bYseIvyuSoiGbe14Api+90g+atgw63PZABT3wKL4UEzttc5JkknBsGoxBs5Y4rlnLTeSdZvGU+jx9dhm4I5ZEZcq20g20TxIYelNyb5BrVNE1+SOmBgVwaRuTIXWpoCWVBj8fz5quoRYejKtbw6sr3hi/tF9BwV6Y77AaL1IsxWaJz5+ecXYS04SbfwYwC5NOo136vLEDISSohOKURlsYeXpUd7Wf3OrVdiXmDWRs83fX3nPI/NjbLy8xaAHLf7iNzDuy+pqUzM8vtu+wBLV1ak+PdUYa6ehbpHRsM+9LKfI/KZ4qIjiE1M=","authorEmailMD5":"0b5fe433afdeb475554873eb12d3c983","authorUri":"","authorUserId":"disqus:disqus_oxBAuCWbiJ","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_oxBAuCWbiJ.jpg","message":"Great, this will be much appreciated as well! :)","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"2771bb2f-1af2-3373-b290-f2c318a3fb2e","date":"2016-11-14T08:24:54Z","timestamp":1479111894},{"_id":"61c35e56-6e3b-3bfe-8ae3-42a6feb40bb5","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, that's correct. If your app is not public and you *know* it will only have a few users, then parallelism would be acceptable.","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"c0fadc94-1085-32b6-a3e7-7dfb4fdcbe71","date":"2016-11-16T20:11:49Z","timestamp":1479327109},{"_id":"c0fadc94-1085-32b6-a3e7-7dfb4fdcbe71","authorName":"Yoelvis Mulen","authorEmailEncrypted":"aPgDmoNA8rCBIGlkm7LRdi0hEzgJFu4t9ZIikiybC1L5/ZfcRpFVbBkk+5QaxrXooDVBBAmmOOicDo8b+l0QHGpmDei5iP8hZ+v/eEV0Otf2lQtACp+GBqRvjUiYTRKNgvf3mz4adjchMoss1Svdjrn8uiJOYEmo+oPOtX/rdZSkAwalOJdjmxp3pdEJ2PlXEFYLd6Z8oA9KRLWfgf5i6Piu4EZNpG+shmm54s7swJdo6fwrX75aSUr04rDPqgZz0EWsX3F/3BYJCMyFVDA5QFMGk7rxdWel7oCjHinKTdgHdO84tYfPVAjVGc4yzA7dM1tPPB/iIVSelX6WjytFGl9RgYsPh5h2YLQsmPcGENt4eyfpWRMHNXtoUUWDtfYe6T+DzrCpx6+LDiL8uutyXiw6y99gK+ZIms4XZ7/w+IBTae47mmNRpjup9YCeBECJlXwL8KpxJjqRAqF4OOXCO4glUlyrImXdrNEcTQ1JtxD2hb7a9nYCgh/OVXqh6LOIZdZ7OWCgm/rhoSNS1Wevd4YHaVqphPOyGN7464QOtrFAqm795NF3KbMbY7fkah03KniUblg7jGAHsTdvPjNVgHlNg8xHFxbmzM/yy3gGLBz+zQc9nkTXu9IzjpQc6UGReJA0vBSYqlkHsD8xhdP8k6ufS/N5xLzeBmKqBh4gdNQ=","authorEmailMD5":"311c6d390de72104c17135bb61226eb9","authorUri":"","authorUserId":"disqus:yoelvismulen","authorFallbackAvatar":"","message":"Hi Stephen,\r\n\r\nThanks for your answer,\r\n\r\nI suppose that the impacts in scalability that you are talking is because you don't want to spend many threads in only one request, so for a public service with a lot of users at once that can break scalability because is using more resources.\r\n\r\nBut, for a few users their request's answer could be faster using parallelism.\r\n\r\nThanks!","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"f7a7289f-eedc-34b0-a97e-868ef0583b3e","date":"2016-11-16T19:15:50Z","timestamp":1479323750},{"_id":"4f59c044-6fec-3deb-b2b9-503341e68071","authorName":"cactuaroid","authorEmailEncrypted":"SxHnbrGvFJvKgNft7hAKcbNd1GRIbrTAXmYNoqugsp9xhZzV1fuT3EAQrKI/gsf1tJqrkZ+nFewd2EaWbi3RXKGL0/l5vImy8t9PETyFQ/ScAhbBkNUcFwighKGiNgZyv1df4t37l5hD7UYKYhb2EKZs2UXXinKKdvlVoiMRoegjY0vUDwkpScdVF9wQ7vPEfHSrUssQMMX5A3KGKpI0dkV6OgdxEJSI1xf5XJHqIjlVIdiquMc+JG9eJETKV9koNOzPgJxsHpuRYiQfDpeeC6vSgfwzITbfL0dy1YpGWMGQAvbGnQQOxhiY47/XmC9NZ6T2KyvQcLrL+vTvOMuSivDC2m5pQV+QFHZd4EjSveGBrzsi+/2VJT9dE+8g/VEsAsOV7l0I60m4nkYb2uXYwCqJaKAtjzVePNDwXtIfK5hf97tWlYeqWlrdoN442ZYwh4AxokX6rkLgFHStNMA48njyVnVeNlY+h1+oQeDb60F0C4p5STbBckhoffhcV1ZTS6VGdTRxZQA/hWBQSgBlbyHGs2Py1iJNV8SgkhCqRDbjTWhfs+PtfhpCVKM+fNLcyfe2rl6nL8UJlqjuXxs/LovhCz8pLPGNs7aDOd4+KlmkK6NDbsv3aEcXLJW8ko5+/+9+2LkptakB0jBUNrlMO34Jn/cZkLT7XME3hEL+vk8=","authorEmailMD5":"ed034f2138cb4134d4cd3c658f9fb8dc","authorUri":"","authorUserId":"disqus:cactuaroid","authorFallbackAvatar":"https://disqus.com/api/users/avatars/cactuaroid.jpg","message":"Hi Stephen, thank you for your these great posts!  \r\nAs you reply, for UI-based client, it should be \"await Task.Run(async () => await myService.PredictStockMarketAsync());\"; otherwise the next line runs before PredictStockMarketAsync() completes. But on your last code section of the post for UI-based client, you wrote \"await Task.Run(() => myService.PredictStockMarketAsync());\". Would you correct it?","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"b235d174-3ec2-31c2-94c5-33b0764b49a5","date":"2017-01-12T16:44:24Z","timestamp":1484239464},{"_id":"6d62e939-b395-3138-a8a3-66291230a7b7","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"> otherwise the next line runs before PredictStockMarketAsync() completes\r\n\r\nThat's not the reason.\r\n\r\nThe reason behind using Task.Run here is to prevent blocking the UI thread. This is the \"complex case\", where PredictStockMarketAsync does both I/O *and* intense CPU processing. It's because of the CPU processing that the UI thread wants to use Task.Run.\r\n\r\n> Would you correct it?\r\n\r\nI elide async/await in trivial cases. More info here: [http://blog.stephencleary.com/2016/12/eliding-async-await.html](http://blog.stephencleary.com/2016/12/eliding-async-await.html)","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"4f59c044-6fec-3deb-b2b9-503341e68071","date":"2017-01-12T19:34:53Z","timestamp":1484249693},{"_id":"f55ebead-f5aa-37fd-be35-31825a909e29","authorName":"cactuaroid","authorEmailEncrypted":"GqDVJmijcIgOG58tdz0P2N0HlUwn2f6339mUMg3gvw1BZYXZajXmpeZuww4fwuncJfIjUgALzuFNwzDEsAByhpW8IoX+LevRWLTTZiAp1PrTzxIlDiQA/x2/ssIvpUC6u+xQeNcmioP0OYYIs/K/RkENfK4ADDqK8G0rc6LcHizg9u/Xa+j6CZmkHFFFD08RcLKJHKpzp3JFvB/0ntYk36zCMm5xBguv2pcVDzhKitJqi5AHtU3EryN2/X2ByH0vzHYukY5stlMlzYUW9GRmx3dMqSPosL1pkL6bPFpwXj64cX+JXpi9FWoFPUYLsXRkT2FvIpx7SOBsFiU2gFG9EMeMOZwu0lsy1oIetLqrTAZp9FvSrLNdjNQSUaws8hYVxtkUX2I92DwsZtEDgzkUCWFLzuF9UizpsOAQ9wiJopWJYCgCDm69wr2yh+Ugn37NJnlSQmXtpMpOXhp0doec6FCkPG9HMRSIuq5DtCIQWpWYpx1kaLb7zxkA6DuYMEBIRmZGEMOAnLGJslo4lmi5lyjajzAD+ID7TZ2Ah3GjfiF6KGw19TLP1hFnp+Zjk67DUsO/qp57WgTDPKwifDpvt7/2yUlpoCl0Gm2qFN2OyMsZp5/x4YlauCuFiwG8KhJUyX2bAJuroFcAhvFIyJnhZ6buX8mux+Z7NgpvxuuhEp8=","authorEmailMD5":"ed034f2138cb4134d4cd3c658f9fb8dc","authorUri":"","authorUserId":"disqus:cactuaroid","authorFallbackAvatar":"https://disqus.com/api/users/avatars/cactuaroid.jpg","message":"Now I understand your point. Thank you very much!","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"6d62e939-b395-3138-a8a3-66291230a7b7","date":"2017-01-14T22:51:39Z","timestamp":1484434299},{"_id":"6cc8d2a5-334d-3580-9d80-4d410151ae47","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"You'd use `await Task.Run` to offload the CPU-bound code, as such:\r\n\r\npublic async Task SetTextureDataAsync(IEnumerable<int> serialNumberList)  \r\n{  \r\nvar client = Clients.Instance.GetClientById(ApplicationViewData.Instance.ActiveApplicationId);  \r\nint frameId = ApplicationViewData.Instance.traceExplorerWindow.Frame.Id;\r\n\r\nawait Task.Run(() => var textureElementsUptoThisRow = client.OpenGlesParameterObject.Textures.GetTextures(frameId, serialNumberList).ToList());\r\n\r\n//some UI code to set the retrived texture  \r\n}","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"b6a545c7-9c6d-377c-ae85-aec4fb4c96bd","date":"2018-01-09T12:31:59Z","timestamp":1515501119},{"_id":"b6a545c7-9c6d-377c-ae85-aec4fb4c96bd","authorName":"Visakh Vspm","authorEmailEncrypted":"i9jXtMRy+UtEJ2bsOg62932VWeI6bVT0NzhcZrtleHOHhWeZ0upwmfIe5LiUrolAjipSyxFVAlGQ6dLcg5F5mV6Wu5GJpYH+l+rcd9AA9FnMVmuobdbUO5MNuMeCMRd+qjGwu4KF4NB/Gj/Daq8Uf9fDYqZKu7L3m5ZU95h5B+S9VKs790Imok7xOs1TvGx84/nuHEMtbhC50DUQuAZXp5lMoHCDWrZF8mHbvbot4Cea4V++TmciLhsiHiNVn8YGRVYtP/SRr9XGDMZwKBTRKD6m9kPbu9hqEPIo5UhIcJ7dHTfTq63Fji7cJ1VsDi5oUdRgPMk7bLwNKo4VrR7gCrHiALBDoQUTlN6nSiqKcpd6sfRct9jnTvznn390EAOjgl/sdJ9W2AJpMCH4nPHbEcsQCQKROePdCyEklH38/xYAljq/gwyceNrfs6hKzmONSj9n7i97RFVvMkehzzAqzuEFAzFQF6HyECuEkZ9P/ggvBG42fXMLtx4UYWaANx18KFNha3tjtAjG4PFqvR/+BZJehQlA+NuLX9ZHsKvPTGbNsfORZoknG0pZ2YYRleCNaWx6wD/HAeNsXBThIfiDY+ywSl/f+zIG30wPk0sYm3MG6EDFIDQGXmh8fX3BenIUKST37Uc3SMVc3smR/FWf5OVn0sRTlsCPJpIDZwcnssM=","authorEmailMD5":"073ea6444ef0db89d4926d8ed8dc0f9f","authorUri":"","authorUserId":"disqus:visakhvspm","authorFallbackAvatar":"https://disqus.com/api/users/avatars/visakhvspm.jpg","message":"when user clicks in one part of UI(first), another part of UI(second) needs to updated automatically. But second part update requires large time because it involves cpu-bound operation. am confused how to use async and await in order to achieve responsive UI.\r\n\r\nshort version of code  \r\n--------------------\r\n\r\nUI first part  \r\n-------------\r\n\r\n private void datagridviewMain_SelectionChanged(object sender, EventArgs e)  \r\n {  \r\n DataGridView dgv = sender as DataGridView;\r\n\r\n if (dgv.SelectedCells.Count == 0) return;\r\n\r\n currentRowIndex = dgv.SelectedRows[0].Index;  \r\n if (currentRowIndex != -1)  \r\n {  \r\n UpdateTexture(currentRowIndex);  \r\n }  \r\n }\r\n\r\n private void UpdateTexture(int selectedRow)  \r\n {  \r\n if (DockHelper.IsDockWindowState(ApplicationViewData.Instance.textureWindow.DockState))  \r\n {  \r\n var serialNumberList = frame.ReadableApis.Select(p => p.SerialNumber).Take(selectedRow + 1).ToList();  \r\n ApplicationViewData.Instance.textureWindow.SetTextureData(serialNumberList);  \r\n }  \r\n datagridviewMain.Focus();  \r\n }\r\n\r\nUI second part  \r\n--------------\r\n\r\n public void SetTextureData(IEnumerable<int> serialNumberList)  \r\n {  \r\n var client = Clients.Instance.GetClientById(ApplicationViewData.Instance.ActiveApplicationId);  \r\n int frameId = ApplicationViewData.Instance.traceExplorerWindow.Frame.Id;\r\n\r\n var textureElementsUptoThisRow = client.OpenGlesParameterObject.Textures.GetTextures(frameId, serialNumberList).ToList();\r\n\r\n //some UI code to set the retrived texture  \r\n }\r\n\r\nService code  \r\n------------\r\n\r\n public IEnumerable<texture> GetTextures(int frameId, IEnumerable<int> serialNumberList)  \r\n {  \r\n //cpu intensive code  \r\n return currentFrameTexture;  \r\n }  \r\n-----------------------","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"","date":"2018-01-09T06:23:28Z","timestamp":1515479008},{"_id":"96205f0d-0309-334a-bd77-9607bf1c38b3","authorName":"Guest","authorEmailEncrypted":"GGQgeQwUcEMIqO8g9CMVxeYKcKChCp45w8cjXaOaVRAwl+D4wjCmyuMrdQLXc78kuAW0I+kHR2T/wlEfXWxTAiKCxCsuZSBOhXNmeFVcJlnv6SbM0ZtQ981gGMbUMHLKM71tMfGcoTQDJ4Q9pgH3Uq+z75G2ocn7P2mtYwesUsIlgU8WJq9HBON4Emsk9tLnCwTtmmlm07pSkFJKPAxZqPEFzhLyJqb1KK9XmyyG/C+yoSR20l+bsZoSC5m9bH8dAo8JbzmWk2oFM7IXSntwtmha6780a+i4DUhWkuO0nvjAadDbkoLanFTpiq9qcGNhdAHG4HV6xE8yHulQS7RRSAVhmfePh/pJydPi57YFCqjwWjrhSu4jchbo6Makn4nNypU4OT/6idFs3JwQMYGius2ENmWPxWJmHZMe3A966a+f+RczFNzhdGK7mMdf5RZmXcOw6OEM330deMc5ZTx+eY5eGQHbV+D7LS+D1ahV9Em4v7ILkDKYRkEHsvuVXwMutnHWsj82Bj3e4idZSlxwCK+7HuSs701lfKZeRw/tkfYjFDfjrOVpaFsIR1o2uUSaHiRnZUhNoqMf0OypV1l3JBOWwHMTfMOsSwhjvja/XuhN5VLAnL3t0iV9NEGORWbMO7CZpV/fznEP0LHX5amle60ScgI0js4kkWzt2ju4PNw=","authorEmailMD5":"ee3538940b56d40eee35ca99cb98847a","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen, I have an issue with converting some code to work asynchronously. I am running into an async chain that is resulting in my API needing to return a Task<t> to another .NET 4.0 application which cannot implement await so it is forcing a task.Result which negates the performance improvement I am looking for.\r\n\r\nWithin my API,I have some calls to another API, that I do not wish to wait on before returning control back to the caller of the API. Using Task.Run to run these calls in parallelism shows a 15 second difference in UI responsiveness, but it seems this is not suggested at all.\r\n\r\nDo you have any suggestions?","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"","date":"2018-01-22T21:36:16Z","timestamp":1516656976},{"_id":"26d626e9-139d-3384-88c7-e7540b63205c","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"If you have an API (as in, separate processes), then you can return a Task<t> from your API endpoint. The consuming application can call it asynchronously (e.g., HttpClient) or synchronously (e.g., WebClient). Clients cannot know whether servers are implemented synchronously or asynchronously.","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"96205f0d-0309-334a-bd77-9607bf1c38b3","date":"2018-01-23T14:13:49Z","timestamp":1516716829},{"_id":"e3fbdfc3-225a-3d3c-896d-6d979c15d152","authorName":"Guest","authorEmailEncrypted":"lOXfHHV+x2kKjr6FUw9mC6xZVTmR29nFQPRrGf6E0zMvE4C20WIfSoC5es5iXZnkmnos4JswE7psIVQ38kWS7ygFRwd06EEGR9R3FoGdMSWC8pDc+RLKzRZU7HyzzD2Wdkvmwh5zvLMokDiYI8OyNQqiefGzIGrqegTm3/tsszNlvXSmMpL/7Y4R8Eg+xJ4iPi1bSEyChJzeiXG/6baHQmNDi4xO50H8bTG84XCgyVLtBKRM9PScTFogZ+zdpAwIEe+BPZyK0ZQ25pmcM3BkEhreEwrnGdFHwKJxEoZx8Q4tgpY+yKge/7e3TwANi36zLg8kCP/6c3D6/S1T33/QHDtlpc+l860DUgz9/GoeGEVQtv9ODTkC04m2wWM/WbeC4R+8d2cyp9jSv91VJS4YYFm5BNvUEgHMkGrpJSIJQZKh10zGmKFAMZnNkLLDp2N96UmfhzQylfkpxHRmKzG3stSQcy5t5EknPV0M0AajOOBcLyj3Zi6lSPdNz1HqMIpry66l0g99+KuafXbRTt7DwI0Tls/S6JjWjbX1oAUPsYzDGr6qGfqVtghx/UC8e6NlCMM8Nn2RLgndSsY0IpuGmIPJpzqrRxLOamFBrObfj2fGQ6DmOvglJj6MOgvxSmQjYS/IOuKIiz+uj76l1eKPrjaQz06XTpJlqsSoMT+Oo/w=","authorEmailMD5":"ee3538940b56d40eee35ca99cb98847a","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"The client code is very depended on a response, thus returning a Task<t> still causes a slow UI response when the 3rd party API is slow. My attempt was to decouple the 3rd party API calls from my functions.By decoupling, I can return to the caller with a response(it is not based on the 3rd party api). I did this by using the Task.Run() to add those calls to a threadpool . You advise against this behavior. What other options exist?","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"26d626e9-139d-3384-88c7-e7540b63205c","date":"2018-01-23T18:48:19Z","timestamp":1516733299},{"_id":"a16dba99-b7e6-3681-aa52-64720cfa9ac1","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Ah, so you're talking about returning early (aka fire-and-forget). I have a blog post that covers several options here: [http://blog.stephencleary.com/2014/06/fire-and-forget-on-asp-net.html](http://blog.stephencleary.com/2014/06/fire-and-forget-on-asp-net.html)","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"e3fbdfc3-225a-3d3c-896d-6d979c15d152","date":"2018-01-24T15:36:08Z","timestamp":1516808168},{"_id":"d9a6c72c-bcd4-39b1-b63b-de49d1507f52","authorName":"Guest","authorEmailEncrypted":"rQyymeOPALsehjULY9SOyz5xxd3e+1hMiuWuLGXIfSV1tTy1zK1IqkM2nmIdrhImPv4fZp3bBs/wwbad8c1Ynz28WcK5r11ZMmY7be/AqTe9kvnL+rO5zg11a+9i464bN/lWB/ksYUT6AiD4Tuxc7mBDoK/VIB5MOa4xohhwu05RcOJBafUO/F2bX/zb+nBlVsbWgv277GjMyoamnr4ZbG18mo8MGwv5mcUoybYH+tWNq7nfgxDQQ4BWgrrODJZLUXYTAIXkIRouNzo9/Af92iu6OVUQScNRrcaSDUyrsnnz18er9HDVVdO/f7phXh2vs5K2iUZMaUCCY/j4OxFyNfXmK1z4Pc0g9E4zTpKHwFSPaBFYPBR8o4ji0Q5R1qa10/1OCBi5utNICaqAjRyZQyN8cPbCprdL0yWEv8MN1Z4INVtTzKfi+l/lrmSfx31A7F7vs7DtJ/nha5tLfKgwh038ZdgYYnO7NwCYDy3Vl+1/gwCjHaDWc4mVYYvr4zWlDVEt4pUX3FdxMmeOlgg8gq2NnFeFH3kWigQ/VzhlHkaWHsM+pFutTqK0D65WO64FCjufqTPdZLqpwSaDQSoe67zWtZ9odcO3LmC0wM6xio75XZMedBpKOGm67GudjfYFB96Wyydi8Z8G9g1W8DdAhEWBtXNlnNKEPNyUkAP2BoI=","authorEmailMD5":"ee3538940b56d40eee35ca99cb98847a","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Yes, I would call it fire and forget. I am coding using the .NET 4.5 framework, so the QBWI option wont work. Additionally, I am not in the position to add packages or outside code and implementing a distributed architecture is not feasible. I have come to the conclusion, I may need to spawn my own thread to handle these notification calls.I understand it wont close as a foreground thread but IIS may still end the process. Do you have any objections, concerns or suggestions to aid this solution?","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"a16dba99-b7e6-3681-aa52-64720cfa9ac1","date":"2018-01-24T20:07:15Z","timestamp":1516824435},{"_id":"4e64f38b-cecc-335a-8678-bde33604718a","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I recommend that you carefully read the code in my library until you understand it: [https://github.com/StephenCleary/AspNetBackgroundTasks](https://github.com/StephenCleary/AspNetBackgroundTasks)","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"d9a6c72c-bcd4-39b1-b63b-de49d1507f52","date":"2018-01-25T15:58:40Z","timestamp":1516895920},{"_id":"822832e8-cddd-3390-8efb-d61896189ff1","authorName":"Guest","authorEmailEncrypted":"vVLe5sIcsY80eQednGfKbL5uxRsvGaeGjH1n3DN1wmi1YlzTVPZ/Vcv1NwG8utt3g2AuZO44GoRRNEz9CXeVdzk13Hr39Roq8CnJiIsc+gnLf4GBHu83Q6XPtURwYMDW6kfewbB+PMLked0xDT8q3USP/jcBM5KDfIP1TieoxO7H8qaophAozkMCFuS97vjm4qxNDpSvAlQ0r7d+lwHNvx4XgkNMa7yJG9H8+1DE/15fsBE9LVQvVgPP4Et/HaPd4DugNnV3rR+GQ9sPkAlZWWxCFDtSOafy1JLCRfy2mjSGq3fdpjudpYuRErAWHTHd/sFptEgUfa+5R1rKO1Jv4M2STlvaxsFME4X8r0jL+GGzkWJ9f76UPQMrFDHUrHhGETcy5yT32OgTtm0ZQG133Q2WZRciaVeXU1NNjhEZJg7fTNDQhejAGRhjIt8jaDRD2T1hou25srmzK4KXxXobFwW6/BVEzLv+YqprZPrlHs5YFuODCepa2RsrzEVGJ+M6zscNJIdJ6ko/DVo1st5yBHXs794D8untamjdukej9gNiAzcIjj3R9i3jeY5C3ZFpmo6YN9QRVdGyM3OXtF9jCJbH2nQF0DRNF2UzSe3+0Nkj9+X4lTBD1K4xomgXXQtagSeHUTb0fQcA38ieAuC8OTyH9jqV7gyZQRTGTam7Ihg=","authorEmailMD5":"ee3538940b56d40eee35ca99cb98847a","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thank you for the resource. It seems the background task manager will live for the duration of the application. Is that expected behavior ?","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"4e64f38b-cecc-335a-8678-bde33604718a","date":"2018-01-30T16:16:52Z","timestamp":1517329012},{"_id":"f7de0f55-5c15-3940-89b7-eaba3937ccd4","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes.","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"822832e8-cddd-3390-8efb-d61896189ff1","date":"2018-01-30T21:29:55Z","timestamp":1517347795},{"_id":"b36da04c-5cac-3555-bac4-226f3e6a4b26","authorName":"Coder","authorEmailEncrypted":"G+bhZYnbOeGiFVqD7eKr3aJUUAfulJfmUMMy3iqiI3giF99N3du95Lhig9KCiU8PwonI4c1w/NOY3EkYf356p5HShoYjxN1s0HI7khymuj4XwdR5ex6omR9vx3ypFIPSrKEgGG1fFizng6i9tpDBXFM0DVe8KTiaFM8igd0EBBpR+0phC10COWjM1gozDGKauhw6zOEFCGsfpuURxg01ffW5tnc3JhjXRo+DY9EOTW2Nni/gPmRL+ywPjPiNdBrR7To1lxTVuU3qfhGPSKK1K8aMpzA4AqIEWzK2BVHE8GCOay+TGX3GtbzQ/CgUx0jkw2xNecw8MN4Y/LZMarxgqlJ+LQzbGWEJFUqI2nI+lPL0aE3g8TTJ3EIUBA/Ls1Ok2smYh/5pSV1KiXL83hO9Z2xFcDfvaxNlsnYrC8k7XwttWjD8eKi9er9q4ZZrcP7ni2mE+bA8vWep1jv0XmiyrHAD755k7c37qNaG6vHXwB0P1jFnlnoK77C34HIDFFX52W5SpPBkjScRECfvyMlk7p00t+36V9rFEeUSTaYmfXzknuvVCdzMlF2OSXwced6DJYBPcayH10OkHUmbTvOFZ8YDYBYPad/fZRgw8tAVAlpB4+JwXecAXAIybLs5wTsMdufm9ECahj9BvQJvulAXbvS7mzswE0uHYQuJ7fOBjHQ=","authorEmailMD5":"ca791bad362f96f061ecaa8b64d2d1b7","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen, I need your thoughts on the below scenario.\r\n\r\nOurs is a web service, which listens to different notifications and processes them accordingly. In addition to this, it also has a custom-coded worker thread pool (we have used Task.Factory.StartNew to create these long running workers), which listens to a queue to pick the job and executes them. In each worker, the status of job being processed will be logged into database (simple insert queries).\r\n\r\nIn this application, we use Task.Run,  \r\n#1 - In all the notification subscribers. The handlers will be invoked using Task.Run.  \r\n#2 - In logger, to log the worker status into database.\r\n\r\nIs this a good practice?  \r\nAlso, I would like to understand the difference between using Task.Factory.StartNew and Task.Run in a web service. (basically in a typical web service like the one mentioned above)\r\n\r\nWe are experiencing some performance issues in this service. Initially all the tasks were invoke using Task.Factory.StartNew. After reading your blog posts, I have converted it to use Task.Run (expect the place where we created the worker).  \r\nBut I would like to understand how it functions behind the scenes in the context of a web service, to proceed further.\r\n\r\nPlease advise.\r\n\r\nThank you!","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"","date":"2018-04-23T13:34:04Z","timestamp":1524490444},{"_id":"8285c817-4ae5-300b-b9c5-ba86523ee457","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The best practice is always to have the workers in a separate process from your ASP.NET service. In that case, you can (optionally) use Task.Run in your worker, and you don't need it at all for the ASP.NET service.\r\n\r\nTask.Run and Task.Factory.StartNew are similar in that they both queue work to the thread pool. Which - if done in an ASP.NET service - is borrowing threads from the same thread pool that ASP.NET draws from. I cover some of this behavior in my article on async ASP.NET: [https://msdn.microsoft.com/en-us/magazine/dn802603.aspx](https://msdn.microsoft.com/en-us/magazine/dn802603.aspx)","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"b36da04c-5cac-3555-bac4-226f3e6a4b26","date":"2018-04-26T02:18:31Z","timestamp":1524709111},{"_id":"65f5128b-e8a2-3ea7-81ea-0a6547baf5f3","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Ah. Well, it's a bit different then. For Win32 services, you can take a few different options. You mention you have your own thread pool; if you wish to continue using that, you should probably use TaskFactory. Task.Run will always use the default thread pool.","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"f4cdda79-59c3-3a09-8720-f5ec584ee3e9","date":"2018-04-30T13:53:08Z","timestamp":1525096388},{"_id":"f4cdda79-59c3-3a09-8720-f5ec584ee3e9","authorName":"Coder","authorEmailEncrypted":"GuUzYQir3YxDqCG1Q3soJzHRSnQ9ZfhkX3mtBRiFYmKJe6pbxg5r0uEZu/Dhmd5bYg4xp0TLXlvwxIsx5XqinnVcwTCL05qP9ZnpFT+I3lFblvpdontcM92ac3E91/JNVULX6wbrZjP7WMuROlyP5+iFoIbc6bsRcJ+vxBXYylxQbOiNLO+uTulLhKa/ZCE1UNMT67gMU0EOLp/wwQ4gHGTPR7N1UFZh5pZjOLBMoVoUkpZPPURMjy4gFTohSnkakO58vZkHhQjbt08mQ3VMLeUCKFrolfAwoTVndtXW2HElFLPhHECdSPu+2iMjVseOCdLbEuX36Zg5gGWHm1YGkbgzrDXU4NcU0a+seI5aPQDGHNrqCtsv0GJh3bQnzdwTNhD/7I93PfGc+cgBbB97HQ7chMMRviM5LdEFcc34pv8Kbz/0/QxGpjCSV1Npc8/MIFIeCs8cHdQ+6OkE/71mG4spV0RkCEIyY7owEuxIJpjPEZRbBTvmbLTqmlOZD5LWEhwctUguvvjF+HWS2aMMMtJTZ3YmiqqUDnb+N43cZupOXOpQj+apeKQDcyF+OGx3yJfltf/Xed1Wg0U9Q+0YPcg6GxtROQWxBR6hXuk1sUZNHJWakqIi9VWlt+EC31DCgbD2TjgGZq4uyzzd/M/sIFBSCgCSDKT6jniKNHLxKrM=","authorEmailMD5":"ca791bad362f96f061ecaa8b64d2d1b7","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Stephen, Thank you very much for the response. The article is great. Provides much insights to those who are new to async programming.\r\n\r\nBy-the-way, ours is a windows* service - My sincere apologies for the typo. Got used to typing web frequently.","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"8285c817-4ae5-300b-b9c5-ba86523ee457","date":"2018-04-30T10:36:23Z","timestamp":1525084583},{"_id":"4266ec62-3b79-301c-9a34-71ff607830dd","authorName":"Dave Dansey","authorEmailEncrypted":"BxFv2j8QZH9fiW/nRTCK6IH9pUIP9c5dUbo/GZjNX7GBkmUpGH8NHAmayKXNw2dRrUkdxyYHA4yrvGmBE90N4y2i1FWam/SL/cYNTnIq0rehdMGqAvQxtxL7A7/UOPKPL7pt3X7NBc6tuzwYcYipBi0948B1lb9Kx4GU9oWJYCLXM8v/U4/dNGlT1nBoo/x0GNMxgdSNWY7ddF9z42VDBIV69NJMQcCPg2F0Qp/AHGLyuq+Yv7Uuri3KyHP3gHe2QuKje5nvYtEqxLXQxgl+Y63Mpy8GE4ybF92LzisLq/2L5YI1F9YNtr8EH1xD0y/0ifNQUuMggHGBb2AvOGuZtdXGrxvWLq2CfJRfVqAqG+4Q2qsbVh+KsDXUJ56KbSMC88WR1sYM4gXbw3bPf+TCkFubB1w2sOVIE5X/927SQ341OQ4bYt8k6X7TGJ2lEh78DGS9CJaqodIWjH2kx2hCa+LWeUckndft2OU1sP8sruaFEhs/zdRMVdaJeQWt7iQgSDkVw8Mhxis4bUMuB9JMR92M8qOzukwr4HIZb+kGWoNJzS8kal/KxGqxNb0BQ2ctHR4/Wx0aqk4ykoZNbIdXs8fc1kgCukQQq30/SgfftnTceD8BUqeXQeTcNixaL/t9oKSHnS74pzumuvidw8TUswQRRbk6sRml1J5ITwu4vKo=","authorEmailMD5":"8a98b0e3035b36a6128a7025cd8a0b65","authorUri":"","authorUserId":"disqus:davedansey","authorFallbackAvatar":"","message":"Hi Stephen,\r\n\r\nThanks for your great posts - I'm rather late to the async-party but the info you provide is helping lots.\r\n\r\nIn the above solution, if you know you'll only ever be calling PredictStockMarketAsync from UI-based clients (therefore awaiting on Task.Run), is there any point in making it an async method; would it be better off just calling a synchronous PredictStockMarket instead?\r\n\r\nI assume that as it's awaiting on Task.Run, the method is being run on a worker thread, so the awaits within PredictStockMarketAsync are just not blocking that worker thread, which has nothing else to do anyway, so may as well run sync and just let the I\\O operations block.  \r\nMany thanks,  \r\nDave","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"","date":"2018-05-16T19:13:54Z","timestamp":1526498034},{"_id":"07e07ff8-6f51-3969-bac2-03b60727010a","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Hi Dave,\r\n\r\nThat is a valid approach, if you're positive it'll never be run in a server scenario. That said, async does make some things simpler (e.g., \"do these 100 downloads concurrently and then retrieve all the results\"), so in some cases you may want to avoid blocking even if you know you're on a thread pool thread in a client-side app. (Blocking one thread is no big deal; blocking 100 is not so great).","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"4266ec62-3b79-301c-9a34-71ff607830dd","date":"2018-05-17T02:08:33Z","timestamp":1526522913},{"_id":"e3533c72-428c-33c8-bf3a-7c92e045ad46","authorName":"Dave Dansey","authorEmailEncrypted":"XsssaGZlj8RBW9lnzLLZSwytzGH58qK1FIdCAcNVku61iKsMixgkF/FDe98CtivnZbiPq/42HQERKM/fTdEDTv0tmkSp+TZjspTJz6FzFOZLpJ9Nmz522eFPjllK8kOI09pQ5/pxIli0Ug3NMChDkEoZUs5YOk5qeC65nU6qYl40hgSYgZMtr7XrfgHgYBHtxauh4dVUhIresJ6Hg5D7DlmeLHeEWeI9Y9Imuv+yRtM9WVnxEjIXKHgfemJV4EOC/nRloIjavg6vDQZwBMpUIXnQrJx74Y2jeRMAaSPDomro/2J1ap9irRX5cshS4UvSwX7ZqqOn9oi5nSQaKOk7C/tNCDhZDMXhDzrnd6/xqKugL3wzT3jffLdvQXptCd5CCpsQtpB1lXU7lGQ7TiMKox1NPgZoF1xTKCnsa1L45uJWYxQ6UxtLrBGpe9nhOEzRwSIaYlb4+cAqtu7ir10DY62oDdU8ckoFRU9a6h4vdcXG1MPmAsW5xU02ueNN+xmNhn1xU24YEoTZMaovlyN9k/4k0fXdWwqd4ErxdqPU+LTg5wgN9haEdhwbtJj0neJ+sUcirO5glWFAVq03x961ABuNS+ulcjXbLxVLdBLhir0nPHDrHAbCyXFu+sDGOqAiyqc1l4Fn9O47Jd8r4ljpK3AXDUn3Mfsb/Qb8CVryiEo=","authorEmailMD5":"8a98b0e3035b36a6128a7025cd8a0b65","authorUri":"","authorUserId":"disqus:davedansey","authorFallbackAvatar":"","message":"Sure, that makes complete sense.\r\n\r\nIn our case I'm looking at our client-side service layer for our WPF desktop app (we do have a web app but that has its own service). We have a large n-tier framework, started over 9 years ago, which has a very flexible\\generic architecture (before EntityFramework took off, so uses our own equivalent). We have our own Query object and EntityModel, which get serialised and sent to the server - allowing us to define any data to return.\r\n\r\nOur ServiceBroker on the client has just a few public methods \"ExecuteGets\", \"ExecuteProcedures\", \"ExecuteQueries\" and \"SaveEntities\". I was attempting to see if I can make an \"ExecuteQueriesAsync\", as under the hood, the \"ExecuteQueries\" calls HttpClient.PostAsync - but wraps this in an AsyncContext.Run (from a Nito.AsyncEx library which I've just looked up - and found out you wrote! - p.s. I didn't write any of our service layer).\r\n\r\nI did make a proof-of-concept for the above Async method (putting Async calls through all classes from our MvcProxy to the QueryExecutor, which the UI calls). I found myself calling it from the UI using Task.Run anyway, as our ExecuteQueries method does a good mix of CPU and I/O. It takes a payload of a list of Queries, then for each one, validates it, works out whether to route it to the local database (cache) or the server. It then sends all server queries remotely and all others locally. When the results come back it checks the response for errors, unpacks and de-serialises the response. Just de-serialising a large response can take some time, which I found locked the UI thread, before I called it using Task.Run. This feels like a complex case - I guess it's quite rare too!\r\n\r\nI think I've concluded for now at least, I'm just as well calling the synchronous methods from the UI using Task.Run. Our whole ServiceBroker is designed to be synchronous, it uses a lock, it's static - it's just not geared up to serving up responses in a properly Async way (where you could send multiple requests concurrently and have them return when they each complete, without blocking each other).\r\n\r\nI'll switch my focus to replacing BackgroundWorker for Task.Run in the UI (something your related series has convinced me is a no-brainer). It would be fantastic to have an \"async\" service layer but as a beginner, it's not easy to work out how to \"do async properly\" in a large pre-existing application!\r\n\r\nMany thanks for getting back to me :-)","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"07e07ff8-6f51-3969-bac2-03b60727010a","date":"2018-05-17T10:11:16Z","timestamp":1526551876}]