[{"_id":"68748ae1-cb91-38e2-af4b-318a0d146258","authorName":"Jeff","authorEmailEncrypted":"","authorEmailMD5":"","message":"What's the assignment in the Start() method for?  \r\n(\"var unused = instance.Value;\")  \r\n\r\nDoes calling instance.Value trigger the lazy initialization?","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"","date":"2012-08-16T22:11:28Z","timestamp":1345155088,"authorUserId":""},{"_id":"adb967cf-302e-3c8a-8a5c-68495c1be110","authorName":"Stephen Cleary","authorEmailEncrypted":"BAHjlx5a5c1GtcrHU08ANk9OW1ha+wCD0EY87dZi8+OBnMG3ciZQ+Vol20nJ5UkVMhRvPo7VduZWYaD2TcWmPf+ZUwQsHBHLpNqoc8CiXeZcAlLF5C76KhaIgJdhtlSEzPDwq0O3TMQQon7eLpVDy0DZyBb0y/y9PT0U1vjGNqGeORwHUviX9oEruYKaO5Uie6Z69mp7sLX5czayiUHo4QQcVFMWLsDMzv/SAKbtYrIyUQ/pjMi33ihrS8N5NHLvPOo8Ekdy080+r9tbHbeWysKYAvXRa2MnTptUMIJ2s+wB+3bQRLBy0gWDsyQr5CZ3bgceasg7140SjiL/WnmdZjxdIABYDf+XT92icdnDiWqrRJtrv6fBz3+mlyjw6JMdT2Y4gBSR7f1zuY/dNPv/ipEQOUTzYUX/zyktM2aVMogwZIKRknx3dnr71muwlUal+j2nXcn4cbvW174bDsGFf68cSXYSA1bKu0H9cE1jkEtYgE+6kJBI6yDcMtQUgMW/6NTZpUVTj0p+km5MRUNKxmmeYInwBNY8IZjXGWIgAaYnC/+FPR8nlYfYeFnXpwhHZlgOuSfn0w72VhMAhKwgVa3THa8KeWc1Z3NJzJIeHrnCXBGgHkhXwF+Hhn8xNJYvS3eXwBwaLqW9e7RDBy3oROoHetyklouyOrJLhEy2bbw=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"Yes. There are some use cases where you want to start the initialization but won't actually need the result until later.  \r\n\r\nOf course, you can just do \"var unused = myResource.Value;\" yourself, but I think calling a method is cleaner.  \r\n\r\nWhen you read \"Value\", you get back a Task which represents the factory delegate running on a thread pool thread. Accessing the \"Value\" property kicks off the factory delegate (if it's not already running).","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"","date":"2012-08-16T22:46:47Z","timestamp":1345157207,"authorUserId":""},{"_id":"539e6a19-e628-3c46-8354-1804100fdd34","authorName":"Robert","authorEmailEncrypted":"","authorEmailMD5":"","message":"Thanks! A couple of stray \"span\" tags in the code.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"","date":"2013-07-04T13:28:23Z","timestamp":1372944503,"authorUserId":""},{"_id":"3231f8bd-fb2e-37f4-be45-81aad54cd069","authorName":"Eric Ouellet","authorEmailEncrypted":"","authorEmailMD5":"","message":"Very nice! What about a new one with INotifyPropertyChanged to notify when loaded(initialized) :-) !","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"","date":"2014-02-08T02:57:34Z","timestamp":1391828254,"authorUserId":""},{"_id":"756b8c59-40d2-33b0-9876-040f3de51767","authorName":"Stephen Cleary","authorEmailEncrypted":"h1Tg/lc+ZqSNuHlnveZMNbQdNhZ2Db4YoUGEQAXanzysCW+Zbtn8lY+aiVrS6wPxWnRpbubouDKMH8dNbmJ2JdbuGblTgC3aKCk+bV4bWza1x9TQqNp+ESK83pSt0cUedfhDaMfn9KwEymT5V+H5Qqode59ls6ypzhGAx/6JbFS5YmXDeoK7kNksQoNFTWuuUhQ70i5JdZuGgu5Y9mO7nvHvvcSsPGbbvR7460Bd1jEmqemTgc1CJQOzWaLv6lacgw2t1xwG6w6EaHUZAbo75f6dexUEYQKtv673H5uj4B9btuT3V2VDrIwQrSsiZEDM0LlXGxykgwbMxYSltHTzk1Cx1CX0XLuIm/fKxil3r9tkqK6hmSFL83A+zP1P6fJrIGMAF+aEaGvKewdNNRQvDXy3KYqiIxXwQ0KMfJSfUfRVmOmq81rNwwFLa7StcbvF/VuMC99lo/SvRLirih3iYsU0JI+cTsiVMuZ/0rqCY045o/YYjD9Lk7i7hpIFBaPzLp7gr5up4WKcdc+ywp73Bt/HSv0xQowwXFU3/nqTaU6N5cK7BiBj/GA+wyS96vlZZ57tz0GR/crcKsu7URy+V1lcDTdAWfsLNJT5DFde9b+G2W7pQ8jUdtCxs4uM8p1MUVvAUCZYoSLt6m1jjwzTDFrGCYzo08MYn8S8tgC9E6A=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"AsyncLazy is intended for use when your code awaits the asynchronous initialization. If you're doing data binding, use NotifyTaskCompletion instead:  \r\n [https://nitoasyncex.codeple...](https://nitoasyncex.codeplex.com/wikipage?title=NotifyTaskCompletion \"https://nitoasyncex.codeplex.com/wikipage?title=NotifyTaskCompletion\")  \r\n [http://blog.stephencleary.c...](http://blog.stephencleary.com/2013/01/async-oop-3-properties.html \"http://blog.stephencleary.com/2013/01/async-oop-3-properties.html\")","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"","date":"2014-02-08T06:10:46Z","timestamp":1391839846,"authorUserId":""},{"_id":"49f49d89-0fb5-38b1-bd81-84152de24e73","authorName":"dotnetchris","authorEmailEncrypted":"QwnUi+6n1WHqRgw4uUGOG9tlNMOzLaHEUPSk/ihzXE2ohj1gUPfEhwmaOj2kphCYGdMjCVL4BzpfdCJygw/s4gBLaGwz2iR1PSCMUFa9GZyymqJU3f2NN6DuVHhpyk2TV1B3UANwUOPNVsugLu0w2Cyn8hDDePcWTqrsmwv6lNDWx+I7W9ri6dIEHEHWQHMY6XNo8BZPtGKWaK8w7JWfuIZFPHJJkogfj3y7SNhT/LM6E8ziIrLYM7G8OdXMF3cxr9JbU/WBYMHgdgqHcMSTHV82ocFhNzVrI1rVppE5/Mn+735AVFP2lTNL4EZ5PCR/Qv/jTQDs1Butupw5dygb31qorWM+J0rylBl6BNzs7PyAigv1qZKhN/H/kAKjT4lVNBdOMEat1PLh1fJHdzwXyL/CSod+f6sOW7HunGccxHmpJuxXsntnfnNawDZ1RTZLW9fvZRVcRcNHDy6STw05viGfHgJel4Hx6C/b2L0OZ0nqzvn9jWMMcrYXPr9PVBy6k0INChlGLQqoqIG6pzb+LHk/kXTnFb1wJuG76Cq3QKlDKDrHQwTtZSXWTbNpH5Fo6g3RD9X0AuROt8rhLnVu6EeHHdw69q4UtsF6rVYyw+emSYl4qXH6hUru1wNDGFYnIkuqrzK5JpvnCyU21dscV3K+GSQP3GZt9bkdSson2LQ=","authorEmailMD5":"f0e7c2d0d5d83c928cfcfce66928160e","message":"Yes, the .Value property invocates the lazy, the assignment isn't specifically necessary.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"68748ae1-cb91-38e2-af4b-318a0d146258","date":"2015-06-02T18:25:39Z","timestamp":1433269539,"authorUserId":"disqus:dotnetchris"},{"_id":"71b4b46b-fec3-36c9-9dad-5bef347b3ebc","authorName":"dotnetchris","authorEmailEncrypted":"LKXjtIZsfd/1VhtMqtmyS3N5dTRTXeARuaxNELxkbsvQWHSpuEaN4o9ezR+uoyXF+KAwW+aT0GEzG9ZUdQDv+cQZnsZ4iDWKIjAHAL82w2qazjThSdowqXA26NIyMKaIszgeIVKuZjkadehsyviFpdv/VzQWT38kKgV2vwKqZ5JAAfIRLQGUn/Q6iM8okz0kzZ+VcqY9O4ZghOPii1zvh8MNvoDXQiGPc4zb3zyqSq1H+Wz2aW4ztw8AiAAIwylJHgyj+LqhCwD3nkrTKdgHVU9i0j1YWomeDTrYKXeO75Uw+1CdIF2VnMGX67dLxOkz3i2fDtOg7NtVhNMM1DbNzGW+bQlqcia9fcz/79iqDE3NQM/8Llx+rZQqFs/9kKRJY5zxHIzfPJSwaQ6x415GA9t62SjYZA5nxP6kIbxlD5egabnz2k7nAjEsrM2WbG6YEopry99AxKFGBD0qHgwfPR7Z+xamuqIhQSDG9LYATiyL9hAcW9pDEiRNPKv8Hldd58jEYmP/2CDP/qF8jzkZ02c2YFP3aj7ZTej4kTe1G5ksJASSijWUSBdLSqZONngoHQGqNglL9JOkBYV2jJ3pHyF/UUTaG7aEp5vBFyQ7zQ6Ce/r7zsZ9VuZLmHOh681dmcvDw6mko4q+sK9rAPdNJATxMQZ84BPg32uMiN8NVn8=","authorEmailMD5":"f0e7c2d0d5d83c928cfcfce66928160e","message":"Fair point about the AggregateException. This usage would be under a console application or windows service. If this was ever executed under ASP.NET or WPF it would need to be outside of the request context or UI worker thread as the application would be in an undefined state prior to the completion of the Lazy. If a UI thread or request thread tried to access the Result prior to completion i would expect to either block or return some kind of not ready error perhaps time out based.\r\n\r\nCreateFoo() will take approximately 10 minutes to run during which there's nothing else for the application to do, but the internals of CreateFoo are massively concurrent. CreateFoo spawns somewhere on the order of 50 threads all returning back to the single thread.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"e654d7aa-fca5-388a-ad25-d87cb5db5b34","date":"2015-06-02T19:07:10Z","timestamp":1433272030,"authorUserId":"disqus:dotnetchris"},{"_id":"7a589abc-e0ca-3fd2-ae55-8f89434bfef4","authorName":"dotnetchris","authorEmailEncrypted":"KHhbItH8MnoiUZnbjObSgXDUHQTNXNmE+TaPt0URHvZvU7B14LnC9kFf5uubyaa7/r43BLdo8l9nPmsnh1wl3J/GZrTdMnZ9OZxX16oVQ/UncZ9gRMJ7MwuqTpcWgw43HKJleHskvGhiJH4zW0KuzWesRyjNVuo/5Uy499F+7YjkIZahyX8sSQYwER6LlUbcmrCWEJMPLgfOjo3aiEdBfEDWa6cMHoriN8JedlYehH1xJ02dMLw//lCqPFGhDd4ZifM3HvJpev/rJLlEScq6mj77LDxYY3DDN5HVvkRpoO4q4VeUoFDnHP5LrStvB986/TnO0DlC20HtSvhf/MzNAfN40AzY1hmaDG5acnC/GDexmiYhicvDkOnrVfVjPypIOXUHZnr5B34GDP16T9eHT0PJ0tMHLkc4PFjrPVuLa8Shp3mGSNd/4MMFTCYBj/lvYyGGiMJ+n/U8bX/QfqDc0ComaceZaJHLYHsYNIC0gZlpvWudzzhGGLQakiAVX1BkbnwHy4W5I3bfnRF9rLFQCuMxrqs678Uh2OUC7Isz73zqKw6ikO45iGy72mTiE8Wx+xI6Xtg6Wj1SiJvU4eXwTPzZ4r9nN/BMbNc92DtV4fkk3JDSV5w/Ug6lSwizbV6rDxiifgBsVcGiAueoVQYXz8zVs+4+A5kqWxApRwCWNbI=","authorEmailMD5":"f0e7c2d0d5d83c928cfcfce66928160e","message":"Are there any pitfalls to doing:\r\n\r\n``","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"","date":"2015-06-02T18:15:16Z","timestamp":1433268916,"authorUserId":"disqus:dotnetchris"},{"_id":"e654d7aa-fca5-388a-ad25-d87cb5db5b34","authorName":"Stephen Cleary","authorEmailEncrypted":"UH58KyVzwB17Tk+7Ngr99UbygMpocLwI5NoBv+QOWbdzW0Qi8irZusKNN6ApJ0AjnFew9Z7Oa3bOOWGpndFEWAOQJ52P8dcg+FNPZWwl16COf0EPwrgqtxMIrPfWu8TnKYBFxDVz3ZxothJ6Isbmaz4yWsS7LCpse0c6Sf5aSmP/epkRunHiW9B4lPZFbv7WbsANkiUbVhlLjO9NUrg4sB9UEGp4MAxKaVZgC5VMkuhrwcNXFaOx43d5/GqhbadarR51q+d5I8MnqjPBs1ZYFP1AkaTUMoeVJnWTjncn1Kce123JpQy135eUQkX2FHRStxeANnWzV31fgdKPm2ZT0ScXWiJAhycIDVyPPdoJsHcPzSB0O/NaXZn0sclS3QZNZ/O6AR2qEkV2XCldq1lE7YAuTzi3A+n92LNey3wjMVcGRJ+XMbsJ7dU3cl+MkMG/KUiPIjKh4aLX68GiDCEQkW8qXcBJScWUhQ506FLxDYFWLAcmsU1IUKZ6IGMZU1+NCZ1OEcJMqGjkx3HFV91n6030qZCpmY8ZnZriujb0ChZk11rcsHMNaLjhLo2tDHTMNTpeR8NGz0ep1L1vGfLRX7xKr2+z0DZgDRb5AgnoFjW4Bf1hdhlnLboLy/D9Uf8DtLMRivLe31z4f3aufWU5g9UGZgX7bc3+a0oZ/P9iwvI=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"There's a few pitfalls.\r\n\r\nFirst, Result will wrap exceptions in an AggregateException. This is easily avoided by using GetAwaiter().GetResult() instead of Result.\r\n\r\nNext, the AsyncLazy<t> will complete the Lazy factory in a very short amount of time; it is only locked while creating the Task<t>. Then all awaiters that consume the AsyncLazy<t> share the same underlying Task<t>. A plain Lazy<t> will (synchronously) block all callers until FooCreate completes.\r\n\r\nFinally, you inherit all the downfalls of performing sync-over-async. For example, this can easily cause deadlocks if called from UI or ASP.NET request contexts.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"7a589abc-e0ca-3fd2-ae55-8f89434bfef4","date":"2015-06-02T18:33:02Z","timestamp":1433269982,"authorUserId":"disqus:stephen_cleary"},{"_id":"41c3203e-fddc-3d39-b306-212c781fec93","authorName":"Stephen Cleary","authorEmailEncrypted":"RoLWqNpuY1aJdW0ni+OVe+rVwwOel18bheiNEB5Q383B5+xNKj9dNK0l4KD6pb3/9xLM/uPHUFEIgO0TNgf0ywf+YJgLSso/L7cHlMHo69dVVg/qNvS2XrRNUWfyvSqeY2RI2mBq5gxzIenkLofsu/YYtXbb9I0yt4OV9La0c73GsoNsDlMFOORP1gOSXZehHf3i7IQdBa2VDn1mdPXDrRM6JHdC7IbgwEmvcv7Tg9h/DAD7Dc/zJBlCJ/TxNrC+36YDx1T5CjCu/PXUTu8QrBGZ3kiN9VbOfz27NDRCX2yJZuMtQJGKm+ZppCTgEBYsnZL2EWCkHO6J3mJRsz9CWX6y5pzZx6QRMs8+afAWIKo0PihWDfvxnTvgk5xCoSGQG0GGtmmdyVuU+MLqlfS8+VmDdUq3GuBklhUKWQ7GmFDHo8H9SLUS3X4059QG4z0pldH40nx5ZlAA/KKpMG7TafX6MIjw59lif49Z+lV6WOdZfExJWHvUrfZfcVC9PTevdjgNG2aY54HAgoZpraU0pqx4RdNrq2WQxBIlHTux857oBAloogmopRnKkWV90sAgj9Fp7VxuEWzH1VBiL7+Cq1DRrt/aqvWezBrxb7Eaq28R9qztYGWHvcMEqBS9HcMMDbMYUFRLO+u6lDQGpjwMLP7JBrtaYBHO1rnBIg/WNeU=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"In that case, you certainly could use blocking. AsyncLazy is intended for situations where (possibly multiple) consumers want to wait for the single resource asynchronously. If they need to wait synchronously, Lazy is a better choice.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"71b4b46b-fec3-36c9-9dad-5bef347b3ebc","date":"2015-06-03T01:37:03Z","timestamp":1433295423,"authorUserId":"disqus:stephen_cleary"},{"_id":"871af978-4bc3-33cb-a365-646b48bc306f","authorName":"dotnetchris","authorEmailEncrypted":"c+n6HVS5S4w19yBcEN8sDycmRqTd4whJ9NIGyQUXFmpWb7I/UHiPZfacKLKGmDLnZJ6M6A7S6TDOU+uR4QShYU3wIlG9U6+8wycHCN3VkuUEARPb0hWog0gUgJNInw8ftLjoho5ic9uvUuHbH1vfeB0H/abFBiv5cwr5LnYP4PXfkOMhWVG91U9NyGdGrCHqJtfRRMVuDPL/jGmio09vGhSC1OHzEZWu3jJ092wixbYIpwnpol4NMseht6eWS1zghHDEKRKfiFrc1dWxjK553+xbyKEQDlsRoEoGEfUNkDOe320YXR+WAP+OBtJoc/etiOEGXdqOrIahnBBy2z/T4KEAaSutL0OphsukYoIxzuE5cYb9tF74KPRQQC2RPHRoAwBwcPA+/yUZJIlKo261KvT2JVy6LxDRZbw8CpfP9uaukCYVLp9MoAT0KXVR4jyZiKYxyBjLS5a7uBcXvHlSwin+INRaw1JDiPHcIEejnsDC53QHs5hcVnfuuSmYlwb3nldlgOqTSPVhjUCdn1W6DNs3cbO2qpsLM67nBgC1Dy70c/tJzwR1PwkdNYeSNiZQPTQLibLGgulCVyMNLg+HsqhO90eN9Vq5XUySp2taZZBWoLQXj8C3OmUvo2Qi3KF59w7GOOk9CPHo0MksVNNU+pJs0YtCa0ufDlRKpY+aOC0=","authorEmailMD5":"f0e7c2d0d5d83c928cfcfce66928160e","message":"Thanks alot for your input, also great work on your book. Of course one of the times I really wanted to double check it i have it at home 1000 miles away from the office.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"41c3203e-fddc-3d39-b306-212c781fec93","date":"2015-06-03T15:01:01Z","timestamp":1433343661,"authorUserId":"disqus:dotnetchris"},{"_id":"7ca88b7e-62da-3b91-bf66-28346cf67748","authorName":"Morten Hartlev Lindhart","authorEmailEncrypted":"M/UvucY7g9raC2MuDlsK7mO5cY9LFW6MDw6yYo/iK074OxWKAYAJTXiwuiBmpBWAOtGhveTlbfWQD7gfeNiAloETme1wLcWX0ugEpQkck4/9/fkD0miWBsmHkKRVc2YfOco+GkA/RszS8cp9wiOJTBkEcQd4IBvAcJM6BWxvZ6B9prWDZQXdyUDljfrlkTm5Bu0ALBglwSBmiyaHoOdGl8+PI6+uexU8J5fDSUeXmn1GiF3MEYyhYV46QajT/2vxnKfKIIw+WTsTnCPzWIo7yurY+P43NnZEXvB2eMFNC30nQ1kL3r/bd1ISsvPdf+K4q8dOT4ZHZVyFXiq5F0fLo0EnI4nF8tzVh1KJTB7BKs926kpHFl0Ea5OeKSNDANgW8lphc9zrhChzIUU3eMRyl6mhEYiDgSopfO6GzSpwEipmelkqcWt7jfSXHPGpiRQxFkzv45R91kBmitZe8VB2kO4+oOoyurFDcxI9vS6MPhdHEAdlMOSNPPLtdxl04r1/QVqOufxgJgsRZmpfT1lcstoWXz8GQJIcdvcVg5/MuSa8T2FN30EUfHnRhW5sEPJYBE0XqzHiZDQjlCWYox55t4leg1KTM48Gh92e1I7dLcBKW8wh8YvM92oqJFeQzRIYPihbAJERXKZ29P+LMtb2MkM3EhovpKUWoTQ32TR29PM=","authorEmailMD5":"cc0ee0e44f61f25ee49857e1cd93e00a","message":"I'm a bit uncertain to why Task.Run is used, since this uses a new thread. Wouldn't the \"right\" async-await pattern try to avoid that?\r\n\r\nThere probably is a very good reason which I would like to know as to why the following constructor isn't there:  \r\n/// <summary>  \r\n/// Initializes a new instance of the <see cref=\"AsyncLazy&lt;T&gt;\"/> class.  \r\n/// </summary>  \r\n/// <param name=\"factory\">The asynchronous delegate that is invoked to produce the value when it is needed.</param>  \r\npublic AsyncLazy(Func<task<t>> factory)  \r\n{  \r\ninstance = new Lazy<task<t>>(factory);  \r\n}","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"","date":"2016-10-31T12:44:42Z","timestamp":1477917882,"authorUserId":"disqus:mortenhartlevlindhart"},{"_id":"97856346-5792-3560-834b-4e777b86c1f4","authorName":"Stephen Cleary","authorEmailEncrypted":"sVICNnCNaXrwK307Uxsti2JUJk36ywT86WdXvggt7Boo/GnFv3UKW0TjpWZlkOYK5v/98x2llJDlFCTWYklvKy33EnJibpTfupc1S3HHvL4VPaslF8s7nuttHuI74fHuVm1MULB2k0l3THC7xFw4s1IfvBSx3KXdWxikw5YqOXLrHiZNvC8bbxvX/263n8QYi+/aXiLKpfb3dfDYSTQDWJCcGjPWXx3/ZsTs5lT0Kc+YI+guxyzlWp6oNICWjbmSA1QxibitIIXTk5QPorGRsNYMFHzjY94rRSB1HoZ8/T83GZZxFiuBudYx8IwnfkuD18h5gcf4CiSG9ih0J++d7IKZ9VKyP2LvxzD0InrCpybr4EywVd++QvdrP1DyJg0MVcTVUKHqIoQarXMGNa501fvK4rOk5EPlAV4jSrvCOgJCcyuRAE7s2z1T7hWKjiJ2EjWzXDrxRzi+o0AXvTmuh6kIamo1abuGD96xey+P38GoE+cQFgdzLDdjKxWlCKFIg6HSfwjQeQhwArM7gnZ8ghL+y5JwcgaerbaNveCxqK0xcF7cqQoSIFE1C4v5Z52mGIaTTjevRK7RdyE52DmRQCL0297YCcXWgY8FfsoSFGCCjZHTLIUH2V+CWeXsR85YoDc+hNMt8aMg2PCxxq/5mWglkCzQAzAFJQIs99S9IJ8=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"The Task.Run is just for consistency. In many cases of lazy initialization, the factory function could be invoked from different contexts. This *could* create a race condition in some scenarios where the factory function may run on the UI thread *sometimes*, or on one of several ASP.NET contexts. To keep the context predictable, it is always run on a thread pool thread.\r\n\r\nHowever, this is not always desirable either. So the current version of AsyncLazy<t> ( [https://github.com/StephenC...](https://github.com/StephenCleary/AsyncEx.Coordination/blob/master/src/Nito.AsyncEx.Coordination/AsyncLazy.cs \"https://github.com/StephenCleary/AsyncEx.Coordination/blob/master/src/Nito.AsyncEx.Coordination/AsyncLazy.cs\") ) takes a flag argument that allows you to skip the Task.Run call.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"7ca88b7e-62da-3b91-bf66-28346cf67748","date":"2016-10-31T13:13:50Z","timestamp":1477919630,"authorUserId":"disqus:stephen_cleary"},{"_id":"902dcb3a-8935-3d8a-90b3-76917704e4f6","authorName":"Anthony","authorEmailEncrypted":"t2GKzejxCu85bwWVaezIJIE98b9PjIZm3awa0we1iK8Af8jckqaTdtsIv2GE4g/8C8iQlmL94SJKncK2ktSZpx/6A7/ow+qJZeXrxh7ggr0ifyI1SaDPnqaRxI/SqgCfp25QHrU1ztjmlkF3xsuVL9izZTsgOYrzxcQo1h5IsuGcRbPZHH3G0hx62eBCDG/ciA5gCPiHHLoxNduIPpqy1AD2z9pcoJs1SuegiJNqImKRrpx4oYF/yVGw0dvDpO+w7m5y0fJ9k0tP5IG2MYNSQX5kIyQwFxuXCB84BnlKw/YA1yGpqSw7w1qSFZ2scBfOdkH45la+XnEKgL4xF+hSW6dhdWO6ET5BHQgM+G7s6YGMD4tocCifcmAxvBx3kajTtotM0ycm5xH0A/ibily+Oa+Y6Ql3zsSQJHVIlQt5pkybYNSn2CGz7cGoPHCTatHX4QdTSxx7rDj54GBoKxeuOwR6M2XHkwiRnaPs4Ebvg6SUUSdPAHNTMQA16TwcpDGq73yVgRzw297zcWVRLngq7ra77Bn/w1a4PqmGgLssXWe97USCo88ll+7jn51j0V6M8tMoYyoRm5xCotu1WN+3pTaHXIX23PSSiFlBIFwDU2X4K7+CVyX/DF4hq9ZM0wWmjhvpycu3/lVIUWTgmlx3wE5CrL58Pmlt/9rKbR4/I0Q=","authorEmailMD5":"93a2fb94cec652062074c28dacadf2fc","message":"In the most recent version of your code, there is a mutex to manage concurrent access to the lazy instance. Why so? Isn't Lazy type supposed to be thread safe?","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"","date":"2017-03-12T20:27:54Z","timestamp":1489350474,"authorUserId":"disqus:ahocquet"},{"_id":"8480e4a3-c37b-3ce7-97d0-789d2e76359d","authorName":"Stephen Cleary","authorEmailEncrypted":"rBGm6fL24nthcXWPS2dHUlW0B6fm8F21ND7giKCGlNh017Ln/bUl5AjAeK2k5WZfyg909DM6WldRLwdMBjoky2Z3klNFTes7UeSF12uKbl4tIKwp81npSFpGDdPpNHSS+Pw/ywE6LlIvGr3mBHePf4F/uAno2YCgjNqZMB94JuP8rYWcNim9tpgDuB6AvcyaYc3YmIqqedXU/mCF+xhCm0w0cUtHm6hGNsM7dbDLw8n4w0Uq6/iojmWD586298+an0RJQ2Tua973VT7bOmqsTtKh3yeiC5A4SXRvkaLAZRzJSnFFRnq4pogl+5f+/RbrkGvugLsNHnsB62pwicR0SmoK4frXIRf7RBffvlmlvy2mh8pER+zsuDUeUIecykhu+i+1SHTH3iv2r66C4dH6I7OwUwLL5PIyCQwcFaPWEFzi1wpCgWa7UKDBeGIVsUsPh9OSVCadWq6so/4wpuWJZY4dyWl6R7I2yQHWbE8O1bBaQ+pKViJ9FnNvm75nYunb8k0hIbPL/ZH+jjYVMPAduWteH6qMftAS0CWIlZAO2Gxi1YQolWiafsRdXrsXr8SKq1lgfrgAqy78zjCHdhYZL6mxAKpLax7fwcp7UnLWSL0EAaIVp8M4w2dlww/Bg3uxRygtOZsBWNbPb/ICPuQWZdOtuA6aoPbQHT0no2GM5Tk=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"The most recent version added a flag to only \"save\" successful initialization attempts. So the Lazy instance itself must be replaced if it fails.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"902dcb3a-8935-3d8a-90b3-76917704e4f6","date":"2017-03-13T13:38:05Z","timestamp":1489412285,"authorUserId":"disqus:stephen_cleary"},{"_id":"3a872801-35a7-3a73-8dd9-f0bc420fa8c2","authorName":"Stephen Cleary","authorEmailEncrypted":"gwCJtzaRHeIwYylb8uHlDwP9eW2zVBrCls9R6BEef2aNzYYZFmfXNfKqUvYeA3APERYUL8tjIN4T1ivE3eCnwcOvheQaI/66YLfInTgrzIE8c7ZTfVCByEC0izqzSohgXrb66cuCXvPQfVvE15SHKIKS+I/9PeefTj3VOWCQlwCy1N3hJzQhFDjnfmnQ5iFCBu3QeOtYCnc8TDDyfLGQCfhM1LTSBQRgcoQLGLuytc/0yR3+vQfxL7gK0xqOSHGSmTodsajHASuuYJgWqgL9wYJ3tUn5TJg07U27OdD9VtZ0PXs0tBk5jm4xqznJ9pBfltN9HQDlrbvNoes78Vvtkd+aucXJWCfXp3+k77ylhvalplKXCDzlEOb9Mksrxx60A6A6SL7uLPKaRXlf3x6rxvAbQbxXqPxY4Tps5hsNmtNNdSPw4NgeYe2Xe00/AJ0NVRTe1nZwmgUDsVBtO3cLIm7o8j+N0PinzkHWdgHK84fWMPjslXp3IFs0bYuXfyqbFHkPUKjULGGvCgChp6MMFYy5wjxT2x1OtXU0YrHz28o5SS96U71cybn531becyxeYBm+IiMm9oS34Ab8cDuEYcGOk7c5m8NVbp3PU6EMaeO1R15N4j9+ZUC9mb/QocCI9hTh/1BccXH+fhshH4YxYpc9K3Tb2E4XkaqRVLFZpTk=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"If you *never* want to have a null return value, then you'll have to handle retries and whatnot inside your factory method.\r\n\r\nIf you want a single null return value but then have that mean \"recompute this next time\", then there isn't a way to support that - yet. I'm working on it: [https://github.com/StephenC...](https://github.com/StephenCleary/AsyncEx/issues/91 \"https://github.com/StephenCleary/AsyncEx/issues/91\")\r\n\r\nIn the meantime, you could throw an exception from your factory method instead of returning null (and have your consuming code catch the exception and treat that as a null), and use AsyncLazyFlags.RetryOnFailure.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"7842025c-1d44-3d38-8463-36acc819cb57","date":"2017-05-29T14:47:23Z","timestamp":1496069243,"authorUserId":"disqus:stephen_cleary"},{"_id":"7842025c-1d44-3d38-8463-36acc819cb57","authorName":"BastiS","authorEmailEncrypted":"vn10gCgZmVtFZiLql/qXSD2rV+pyv+naMDzL9kfJMEtxQ/ZMeV6NVvleoE6MXuuX2uPe+gwHHItH+U+HoNAZST33h8F5KuH8Z+cpBC6pDT6A2Tbe/KJHSvuHdBHE7g8GlCu8FCKK/qr9Dd/ulIvbr62MHjW0wl4gl/QZy8WRhfU4nNcu45L5fZoEbUne9dn/ipXGT7Lje506j7qNbWCOknNK26iQyZZZnjncw1sBTZLopV5UYPnXFPlbF/YS3rUNo5eBEZYeMv47hckjTAixrYl2XU0Z4SDRjPc0mrHRlTtvvFJfWJ5h8ndD3gIYSmr8ORTL0CIqPBVeCe5NgT8iFzbIrA2/eojKpLG9Qe9UMtjfGD8caKgYS7cCqylZbFiqroPH/eatHItlcgynzmwtodBLco3O5VUpPoeSg/8PlAa6SA1rVkQwAM0QK9P8YtWeVoEun7xV3C7gwZZCk5suqk0evX3HQJV4vo7+SsYkjcarlGiC00K1JDHxyLWzbAUUGjqBjYBja8u7m4kWb1R43oPJ96usSnwWd3gGHoJuoJ4Sokn+XqmGQp3tOdGmbZHuEj19WIDl39Yoy5TIFcsCaWfiYAgtFZHzEMcG+zBmzbZm646chbySuWqq2TzsfC6SxlS5m7MzUfDA4RPTiWxVgw3kRpvuGh7n1l1BqSHIkro=","authorEmailMD5":"871743a29f2406548acaa83c1722a81d","message":"What do I need to change to run the function again when the property is queried and the return value was null? I do not want to accept null values.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"","date":"2017-05-29T10:54:37Z","timestamp":1496055277,"authorUserId":"disqus:disqus_NhGpW5t85b"},{"_id":"10b8ad1b-4261-3eeb-b228-25aa19d7c7b7","authorName":"Stephen Cleary","authorEmailEncrypted":"VAo7EcADuD3TKfJwlZTG7NGogbXLjCbsgRiO4whrrKYQU3nxMnNnoqh1WSGr0/stBIy/nmo9LPWAS0D7DN9jsstCAL9h4L5cCBUbnjOLKPv/3TSujjcIq2wnM2Fh2NrjDZ28ni2ix4dardBUEH4mVuRjlNZYjmXC7E0vdzI/KUNU4iH6L2nkHNcy3QHeuDTFN70r+zkEd0rpRZ4Ljp/Ud7dQLiC0OeM4PMGgKzQlv37YZEyT0hJ6lPt5Nf28Gkd8H3/mr+JPb72KxJPdgK52cHndBFH0FX8SmJZBbQxwWgPXI6L68gUKhzVTXjA0ai0Q1cyeFLfLSns3cUcRZ7qy3pkJqvNU6YB4I/VzsOmM59kdReKz3rBrFnIpZMvtdazW2hinkAykUlua0mxxcxyouZhZWKaNn2z5UVs0d8Z0VekKiLgb3b060+TwIEPBXGn2DGIiZN+doJQi23ZSvuhu/bMiqLOrRTT7Vh2MK+C9nLhcBFErBVGk1tdhgaQK+h9PZdK46L2Do6LUTRAGUlf6J+jR93yK/7L5WvhgO4H2b5Vy78aA/1qQMVG3op82q1vPeoZwoArplGTScddGrrm6KlpApxWiNqhl4hyH2OXJt3xTfhJ9i8zVclCDLq8s919abWK7My0YabQd1lQMrjswLHiQTLBfomfzLaADSHcrExs=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"Ah, yes. AsyncEx 4.x supports PCLs, but AsyncEx 5.x only supports netstandard (and those flags were added in 5.0).\r\n\r\nEventually, this will resolve itself. Microsoft will update the Visual Studio tooling (hopefully this year) so that AsyncEx 5.0 will work with (some) PCLs.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"f30915a3-0d33-3a62-8105-cb8e8ef0c4f9","date":"2017-05-31T12:13:54Z","timestamp":1496232834,"authorUserId":"disqus:stephen_cleary"},{"_id":"f30915a3-0d33-3a62-8105-cb8e8ef0c4f9","authorName":"BastiS","authorEmailEncrypted":"sgRYW2PJhdY11a4V1BaZBfhtqocdOrGLLpeTwLIvvaX1qR02OuRDqgSv9ut+FYQBwE3gAkxuYUZTcVMWvWlgr+HnHdAGtqMJMbaPU4kB2jqFZQU0bs16AtxfrMcIZkrHSkrdhKWbOiyhNbC3JZAlcUvcFyhpaeexe3Q4HbQQRgXwsN8A3tUo8bIlAt1hcT8yMhrh3r4Rs95PLnw6ObynLMQw1ROh94oyDGmKbEdUek9kQJ1o1Cqehh1AD9yQrO0t5vZUPNTocRB6O8iY3mQvjuXxtE6Gor6vKIk4tJ/ip259sSL8eC5T4V/KjcnBf2ZKIJyPrWZQOcvMtNdnutKBYGxo50DCC019i0JFJytn4p0k/OTYp25B8Iku3lxQUznETULA5yPeD8vtGp0gsbBAJdO2XzkeT+mygwTDJTP9+v5L4VzotXphL4SmqepRyCjxUgB28r/axkhqbgY5cqwbP6w4Cy9y1IeSrpmNhPltOBJCopni5VabN+0DUXjse17T9qCniPs05sLeeGYRBMBKpMoyb3uOnF2OQs2rBwMRzFRGm85oDX6ZT3xFDIxdsp28735hsAYSjHYzgLUaU7pVtl9hE6CncUHU9O+lIJbwXA+OZ7LFbJdc85St3jm/EyLovSkYb//2uP9XRDwBMhvevBu6fft4e2NhyYG7XHUkMdM=","authorEmailMD5":"871743a29f2406548acaa83c1722a81d","message":"Thank you for your quick answer. Since I use the above code in a PCL, I can not install the Nuget package Nito.AsyncEx and therefore have no AsyncLazyFlags.   \r\nI will try to get the necessary code from your git repository.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"3a872801-35a7-3a73-8dd9-f0bc420fa8c2","date":"2017-05-31T10:35:58Z","timestamp":1496226958,"authorUserId":"disqus:disqus_NhGpW5t85b"},{"_id":"072b6467-5adc-3582-b275-3c20ce884f5c","authorName":"Stephen Cleary","authorEmailEncrypted":"TdFwPPHM70DEA/c2JqvORDh9L87wBPYiCFdghlBP8a85sJ6WRGmWRIdk8EoMkQ2sJKzRf3U9bebU9PmwM3dpiXmTU1ziBUjFRxpEXXKcf61Ws62KXasDzp4+q7zqDTe0fXAFWkWMi1C71eG9xzBdXOEEsec08DHXXCNI/uiMIYtKWeZqAsN5kitZCUjRLqm95k3FtRTVQ2pl/esvXaFiba4LnODD8UnWRCGFJYGtCWc0ckdc9RrA1/8gkr5kcksZiIP0Dby5jt/vWZBCTrhS6u7Kejh5oFcfE5LvpPVXt1gLLHlV4zE13jIMigr98Uz3Us30nVxZ+DT/OycfEpDuIOQszwEjQHAddPBW7XDO1cdnGrqcZppj0UY/oVokgR4KnjoJvzfCOLIgENSY8+kZtliOclEYogwYlnl9zUjjXpd3cOyRSScRqBMpk0wkTpY5ln4Tk3w6ybF3i8eR9m9SEurwTTogRB4PSJbXaW4vrrPCru41WCUbkqlOqItzvVfxa2y6pSzmlHs0NZ/3b/8IMnAHE4UPs6/EqlvE5cXPxfwcRgAxTGYuWXxXTGZnVcYpjJ76IGGedXpSGQfO9u2VRDHvoYtfc0hbKc887ybq8FquOTnDS1yNVH/SiL/1mkVW+paXk5EKuQccNURgKtdciVAZVjP6Y2aY9E6tna0ryMQ=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"`lock` includes a spinlock, so it only blocks (and thus only does limited pumping) when there's contention on the Lazy instance. So, unless you've got contention (e.g., a bunch of threads accessing the AsyncLazy for the first time simultaneously), it shouldn't be a problem.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"7646841b-dba3-3259-8efb-715bfbeef7a0","date":"2018-02-28T18:36:09Z","timestamp":1519842969,"authorUserId":"disqus:stephen_cleary"},{"_id":"7646841b-dba3-3259-8efb-715bfbeef7a0","authorName":"Nathan Phillip Brink","authorEmailEncrypted":"ptrOeuF1g3ggJs1zY+XK0hepokss2OeMVFxW+5CXlUdaFwVQGwIV+0tLANfHywo7Q65X9Wo5QN32SRAIeC6kgiNDOwFG1Zlga8Z8eHuxK/AJJdw78XjKJUEfOATvxHE1ofgK5k8rsgEADnRNfMcMsiZz+gk0ooKUKUmU8ZeAhxHIuuPo8dqNEfpWHU1qt6h8eV7rvhQxvIHzt2HZ3SmA+gpACr9jFtLCoyVmbpHZXEfdysuwvAcZJNSOjHvrsqm69xoqFMmfR4zG/Ul47QAFQNyk35BHvV0zO9lE83NzY3g0YRZUZyE1+FGkEODsMR7ewuX2Bl23nB/KaTYOGRTaDG93S2f4lCZLMCXWuuR4F307qYE26QD5AyUKZE18YatRDa1jInV2rUq4fLWw10rNNgOgs40K1RLGGJ+ptnC3s3fVBFdc3ZJ38xc7ZBgl+lCw2mLGATCp7AAHDOscbTMEMTwLSFc0YKXnPsKKCIdriJHRQ0L+2wswl0yrFSkeUCZsS7Ugo3cZ2NCw4lqmnIJf7J5AfXTjbIITZqHFFCN8EM2NQeIhyXWQluwM+sKA5qtDCQRtFfvm7Cd4Nj+B9xryNenpn8GW8QgVC7kHIlkgkbYQ9Q/jYwdvsXYik86M/fv33SGK5ZMgaT/vVb0nHNS16f10JjY8WnbsCnRsCtL2Arc=","authorEmailMD5":"a8defe14b1c80bc2bd59a1fab3848cfb","message":"Could the necessary synchronization be achieved with something like `Interlocked.CompareExchange()` (only replacing if the _instance matches the value it had at invocation) instead? lock(){} is “alertable” and can cause issues when accessed from a GUI thread: [https://stackoverflow.com/q...](https://stackoverflow.com/q/8431221/429091 \"https://stackoverflow.com/q/8431221/429091\") (yes, I'm still using winforms, and I recently refactored something from using lock() to using Task+SynchronizationContext just to avoid the slowdown described by that SO question. Also, I’m still using an old enough version of AsyncEx that it doesn’t have that lock(){} in it yet—and I don’t need the feature it supports, so I guess I could just avoid updating too ;-)).","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"8480e4a3-c37b-3ce7-97d0-789d2e76359d","date":"2018-02-28T17:57:55Z","timestamp":1519840675,"authorUserId":"disqus:ohnobinki"}]