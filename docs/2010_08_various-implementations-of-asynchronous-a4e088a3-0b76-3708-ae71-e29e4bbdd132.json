[{"_id":"aef58750-600b-307e-9b0f-c54367e47075","authorName":"Omer Mor","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/05524751715995551821","authorUserId":"","authorFallbackAvatar":"","message":"Great summary. However I wish you'd add Rx to the mix. It is great for async programming. It has a scheduler abstraction (with many implementations) that is great for medium-level async stuff, and the observable-observer-linq story for higher-level abstraction.","postId":"2010_08_various-implementations-of-asynchronous-a4e088a3-0b76-3708-ae71-e29e4bbdd132","replyTo":"","date":"2010-08-17T09:43:59Z","timestamp":1282038239},{"_id":"bca9741c-6c02-3f01-ae71-08a02becb6ad","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"@Omer: I agree that Rx does have some async programming support. It's really designed for reactive programming, though, while this post is specifically about operations run in the background.","postId":"2010_08_various-implementations-of-asynchronous-a4e088a3-0b76-3708-ae71-e29e4bbdd132","replyTo":"","date":"2010-08-20T15:58:18Z","timestamp":1282319898},{"_id":"7de31e80-cfc3-30f5-9c45-3d58c84e6114","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Great overview - thanks, for this! Would you consider updating to include the Async CTP ?","postId":"2010_08_various-implementations-of-asynchronous-a4e088a3-0b76-3708-ae71-e29e4bbdd132","replyTo":"","date":"2011-05-06T12:45:45Z","timestamp":1304685945},{"_id":"1bb8dbfb-d993-3275-8ab2-eb297a393406","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Can you explain how the yield command is used to perform asynchronous tasks? See the last part of this guy's presentation for more info:  \r\n\r\n[http://channel9.msdn.com/Events/MIX/MIX10/EX15](http://channel9.msdn.com/Events/MIX/MIX10/EX15)","postId":"2010_08_various-implementations-of-asynchronous-a4e088a3-0b76-3708-ae71-e29e4bbdd132","replyTo":"","date":"2011-07-18T18:46:25Z","timestamp":1311014785},{"_id":"2f793bd5-df3d-3f48-bccc-e07d5d6c92f2","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, I would say that BeginInvoke is not truly async. These days, I would recommend using Task.Run instead of BeginInvoke.\r\n\r\nIt's not easy to spin up parallel work using only async/await, but it's not prevented, either. So you can use Task.Run, or if you run async code in a thread pool context, you can have multiple async methods continuing in parallel.\r\n\r\nIn general, if you need to do parallel (multi-threaded, CPU-bound) work, then you have Parallel or TPL. If you need to do asynchronous (generally I/O-bound) work, then you have async/await. If you need to mix the two, look into TPL Dataflow.","postId":"2010_08_various-implementations-of-asynchronous-a4e088a3-0b76-3708-ae71-e29e4bbdd132","replyTo":"6ccd9f93-f0b3-3d3b-a658-e489316dc52e","date":"2016-02-20T19:55:35Z","timestamp":1455998135},{"_id":"6ccd9f93-f0b3-3d3b-a658-e489316dc52e","authorName":"Brady Wied","authorEmailEncrypted":"OZVXFhsCj99R/7rMwhfL6nNC1Y7OJ313FKxTYfadfv0s6Yi3uWDRhCyeoNeML8J4abFCfdv35QVAtg2J+2ZtWRY60wbBNNvCFv+8UnFWSR0ZbQveKwoByi6qgAF2T8TaQTqApV/WSbvZRurOG9tOJVzqZT2OIXoeeQZIrnwXEJnyVQmQUQ70FgOO/lKNcAig1GagbXPJz4Fq7QwPWjzZxPkeiGWFL2nrGGTueWHbhHqadqVOT/BXWorjId+PvIYcUnuqddKU53bNQVIz5w/5sQ7AftDdtHI3avSQ8XBbviJZwPXN+4va+mQBQcUgv9WxLryoP1+SGkaopEWvK3uo9+bMeS8kjYJrhlWvYvUBgQeN9J6AivLamr99iK3dwcylectXNxf5kjoGM/sEfBmMeT6paMnwzIVK0CSqKKjk4ozrPk99y064oXeCaXclMkyPgZQEyjtN4Z/3gKjAkKcWjCjchJjKCRi6g+U0Tkcq9/Rl6isha8bMJsU7xPaxPcpFBeG9yjFcSog8j+tvshRJGM+pCc/m4d6AZGfP9WQMeAmyyCykrZEWgbS3ovIpe80nnKBFfUPT+K+bjb/ns6BYX50YOlZ7oUSBX0MSKrMZXY8NkjM3s21+B31o293WP/UylwjtZvJgvvabWmYx90XlPcYpAkd1k4gnA+2AW3EoTgI=","authorEmailMD5":"7ad078a2a3c5e3c161b9405cd6b1c1ea","authorUri":"","authorUserId":"disqus:bradywied","authorFallbackAvatar":"","message":"Is it fair to say that using BeginInvoke on a delegate is not truly async (in the way that async/await is)? It seems like BeginInvoke is really just an abstraction that queues onto the ThreadPool (as opposed to async/await, which if I read your other \"there is no thread\" post properly, only uses the ThreadPool for that response handle piece). In addition, it seems like you can use BeginInvoke to spin up a bunch of parallel work (assuming thread pool availability) that is not asynchronous, whereas with async/await, there is nothing parallel about what is being done. Do I have this right?","postId":"2010_08_various-implementations-of-asynchronous-a4e088a3-0b76-3708-ae71-e29e4bbdd132","replyTo":"","date":"2016-02-20T17:02:16Z","timestamp":1455987736},{"_id":"12280cc0-f126-3131-82fc-f55058612697","authorName":"Shahenaz Sangoli","authorEmailEncrypted":"BI0CJhdc2q8Bla676rsr7wCNYFlFrHMkdSxfalixvPWI9ch3VfX3788cWxq14CfL6xP0dO8wtVpFuI3P2q1Y/9wjFirj2FINHgcuTA71KVGZ/OuFEWZpP/XtHTE7ITAGDLwKd75ecRw1ED1RUHymbDrJqrN7FW1VO52SpRztecYe5A8weVsfeusx6JC979abBekqC3CJA1DcvA8cXtp6jtabCv9Q0lemCLDPKvB9BQzCBzcpI6nMv/fnrsLB5BVc7Ufhm7buyFyquVW+d7J68bkE0UmYLSJIk7e2ecV3wSxEp0qHNzfvCD7dxGevBSzkFubjMsY8QUtV3+uAKfjnONX3z/6FT47z1svRnpcfWDjvUUU4XGAbAMoSxPxv8Qoib73M+PbbFqN/Y5FM+kzq5Qvyaev+hwaQgvep4g88fqhJCWmbxyQmzg+m0N3jWPgQNmDJkKD8Dq1GEyUtE2ueSX4LZmb9sABoAE1R91haNaXNqF32VYyuK2JVGOc3ZlmBYS+HmFFVyQRh9DBlcr0+/VTaIQELPFTE2EjS+XIhys/IzttQFnBJEmiF/r5Z0sPnVG49fRn83P8ZdK6SF4gSxvgSoZmzDaYivKUd+a4DV23KOSYoGikrgsUb+w+9mBg+4P2nq3z+bqOaQedMUMWRmh9fIlBcZI8hORk2Q+69or8=","authorEmailMD5":"031a1f7fd3d4c49571c0c7fd267c136a","authorUri":"","authorUserId":"disqus:shahenazsangoli","authorFallbackAvatar":"","message":"It means when I update UI element within Task.Run, UI   \r\nelements run on their parent context i.e. UI thread right?\r\n\r\nWhat if I start new child thread within task.run?  \r\nOne more question, have you covered your post discussion in your book?","postId":"2010_08_various-implementations-of-asynchronous-a4e088a3-0b76-3708-ae71-e29e4bbdd132","replyTo":"26bb3051-408f-301b-a00e-9ccebd04d10e","date":"2016-02-26T20:53:35Z","timestamp":1456520015},{"_id":"26bb3051-408f-301b-a00e-9ccebd04d10e","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"In the code you posted, `ProgressBar.Value` is not being run on a different thread. Assuming this code is called from the UI thread, `ProgressBar.Value` is only being set from the UI thread. I have an async/await intro that explains how this works: [http://blog.stephencleary.com/2012/02/async-and-await.html](http://blog.stephencleary.com/2012/02/async-and-await.html)\r\n\r\nUnless you mean that `SomeCpuIntensiveWorkAsync` is also updating `ProgressBar.Value`. In that case, *some* frameworks will allow setting UI control properties from background threads. WinForms usually does not, but I'm not 100% sure about their ProgressBar. WPF does allow setting simple values, but other MVVM frameworks do not.\r\n\r\nWith the range of support for this, I recommend not to do it, ever. If you use `IProgress<int>` / `Progress<int>`, then your code will always work for all platforms.","postId":"2010_08_various-implementations-of-asynchronous-a4e088a3-0b76-3708-ae71-e29e4bbdd132","replyTo":"c4fb70cb-d224-3ae3-8be3-fbed40906a24","date":"2016-02-26T20:01:30Z","timestamp":1456516890},{"_id":"c4fb70cb-d224-3ae3-8be3-fbed40906a24","authorName":"Shahenaz Sangoli","authorEmailEncrypted":"IjnB1gKNgFi5zXda0b67TMlKxxEU27tttENIsXZZW8Th0DXGxt2fC34RBkkcGraF+M1M+TU3Oj7JqAYBZKEHnicz0mcih0OqzNG/nsryM0IKFiBPhEeWcvAZ8xmGj5BQ6vx9uTeJA+sV6DkJZKCiZ0qsDxf/84KdKOhQuTv5QfyLajn+iDr9s11YVJ5GbRduZ95T+vfLTTE/FkxzqXiqKyQlJJK1qCkq4tlPgES65FMpI10c52edcca0H0pX7lLI2YHlUzQQq8WqjW8hpIwTAELggaYGwIxJvfMa9k0IplbJgVRutsYiWRW2PtcGErm5g6Z5U0PrgtYkixdArn34OxWLjc9V0xaNNnLzmyazNsQtP7NV1tukHgHrlclq55SMO3cshYGGaj0kDfKFj1Np6XprhN3gJfi/9SZqMMHZhgyPik4WR44b+O0W0jOr3m6KZG5EX01flveDjqJE/RTnm0Yb41csybCmMYcLdjZKMB4xsqCuhZznWtH5FSjuGQpGkQhBC1ioLbhv2j9uo82KiGqZWzwps/wW4W5deuYqinBtJk0u0LIb9rhHZ3kwHnKxu0+1TfPCy+fGhTpZ5hviedDxr9HpF/2c6R4SRA0pPb5XLoyNuweWu/j2YgxjVVqMyyKmAbSqDePj7XlOkxCGLl9rdTRpJ6yCrPj2ZskS1KU=","authorEmailMD5":"031a1f7fd3d4c49571c0c7fd267c136a","authorUri":"","authorUserId":"disqus:shahenazsangoli","authorFallbackAvatar":"","message":"I need small clarification on [task.run](http://task.run) in the below piece of code:\r\n\r\nList<object> items = GetItemsToProcess();  \r\nint doneSoFar = 0;\r\n\r\nforeach (var item in items)  \r\n{  \r\n await Task.Run(() => SomeCpuIntensiveWorkAsync(item));\r\n\r\n doneSoFar++;\r\n\r\n int progressPercentage = (int)((double)doneSoFar / items.Count * 100);\r\n\r\n this.ProgressBar.Value = progressPercentage;  \r\n}  \r\nProgressBar.value updates within the task block which executes on different thread. But I'm able to update the UI element without error. How is it possible when task is running on different thread?","postId":"2010_08_various-implementations-of-asynchronous-a4e088a3-0b76-3708-ae71-e29e4bbdd132","replyTo":"","date":"2016-02-26T19:38:48Z","timestamp":1456515528},{"_id":"ecda43d0-025e-11ea-be6b-ab7117916579","postId":"2010_08_various-implementations-of-asynchronous-a4e088a3-0b76-3708-ae71-e29e4bbdd132","postUri":"https://blog.stephencleary.com/2010/08/various-implementations-of-asynchronous.html","replyTo":"","authorEmailEncrypted":"gpwDfoo3qx5xm76gfzA/ac/YDUOToH8+Qn9ZMFzlRJPoo5HB0kCAPt1zYAs0dig8Ocq4QpJ7NAj4L6kHI41K1bhKt6/itxrywYgh0sscY/KrzoIJbcrN7IdBQztfWv8bWYvfPcuUV+4dYWuuj20GerNWqX+ehfp3GarswoDk644IpdiWlRC1C0OTH65Zq2gcBh8/xIkNgTb7QRrrgJMmTuUu2q0fQQyns0KuxcO7clMWBMnsd7NupUkAi1ZH+IEGlWB2r8N9qzNR37KZiq5uP6KjNxwLHAIfLSa8WTmN4D4kJuQyOYB+APACQlC+FkiBMK1v6kITTvACsELmLlwOfxzRTEktO12tTzyTjyEWoi80zhJj9/elMYNWhLuVVp5R3Afbsdbp4kd3IL1l7rSuDlhBIF/qNgNLIjx2sJpKnJZKyxRt3V5lgmo+vZb6491AMmYlxTrsU1M+K1W5XZpe/N5igdcqsEAzkYnsO+UBIQVhWzH7De0A1La/eG3893D/6bylQ0Hvy888x4hYfsS01SxC3+vHifZXF/1LCb8toSGz2W+zaNzQmo0rNSlB/r/MjS5gs4WTy6/F1swlcsyM8za1+0ubVFIi9wvtcKJ3s7TlnMa+wdOZqCYeqBz6n22m7T2PrrJKT2IUBqYv9J447FBc7zhBSRbd3o4CWRvLj44=","authorEmailMD5":"7b6bdc83f87f217a5d5a8d6011822e79","authorName":"Skole","authorUri":"","message":"Hi, thanks for the post. The statement about \"never a need to create background thread\" does not meet my practice. Saying more, I use TPL library just in limited scope, in contrast classical low-level Thread approach is more suitable if you concern about performance and productivity. It's my private opinion based on everyday practice with high-loaded solutions. Just imagine how you can find the other way to handle 1 ml requests in a queue?","date":"2019-11-08T19:35:31.623Z"},{"_id":"87ce3dc0-1b77-11ea-91f4-bd5a4438eddf","postId":"2010_08_various-implementations-of-asynchronous-a4e088a3-0b76-3708-ae71-e29e4bbdd132","postUri":"https://blog.stephencleary.com/2010/08/various-implementations-of-asynchronous.html","replyTo":"ecda43d0-025e-11ea-be6b-ab7117916579","authorEmailEncrypted":"hUaKQN+OQ91GHhXsyYRYOqOKv9H8NwNsh8SHGiKhTLFmOCJA5ZR86rUtXr0v814K/pcDRqOYErsHIhtwlq2EU5hB9uJecjvDvz+HVffEzH8OyN+EnHSKngETwWyafuRFM2j2oV9nAYlKPWG8gbvbbkecD9WWJsVnTz1RNV/olAApxrWdH1x0b6WL50wnZEtrLtkVVoHxIBS88tR1sLqay+xtkgdsBX5wtQ816+kYpMD0pzi00uG6MYeRItRzlTPRJ1B+9MbWi0xBarG129iJYv1yJA4r9jgAljNS+OtR1gcGBPgL44yLkHhI/iQ6lM1Z4AlgESNAtVc4Iv+qlEJD2nsoJ7Eeb0isGKDZ1QOK6fy+zrOv1vzt2uLQS469dC8hq7oaCigzDLME7ivbVHXHeioNxF6WSwlKYZBrMX7m01p+TNcGVd2j2xwR/s5G/44U+wppEpWXWCRFRPJzPeq9zfxFqOphneWs5xXjWfF7r3Gectze/TnaEmqpQYltwTVk8YhL8/JwjZi09xn3+y40/dP7DW/VARtRd54jzFhhx9U7ZVgA0dOwvu6OwecO+Hi7kWn+8TAQni9qxXUT5lUMkScV4dIthTJFTM6fE7bZGWnzBAz+saGGfvz0rqZNgToNq6Q4IqVWMWmM+NMLVKce0hUxBEDU1Tw4nQAoaWOFznQ=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I recommend `System.Threading.Channels` for high-throughput scenarios.\r\n\r\nIt sounds like you have a lot of very small work items. I've not had problems with TPL handling some pretty significant load; they have some pretty smart partitioning built-in, and you can also [provide your own partitioners](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl) if that isn't sufficient.\r\n\r\nWhile you can always eke out a bit more performance using low-level techniques, this is always true. Hand-tuned assembler would be even faster. You do get higher performance, but *lower* developer productivity when moving from TPL to Thread and from .NET to assembler.","date":"2019-12-10T18:04:38.472Z"}]