[{"_id":"aef58750-600b-307e-9b0f-c54367e47075","authorName":"Omer Mor","authorEmailEncrypted":"","authorEmailMD5":"","message":"Great summary. However I wish you'd add Rx to the mix. It is great for async programming. It has a scheduler abstraction (with many implementations) that is great for medium-level async stuff, and the observable-observer-linq story for higher-level abstraction.","postId":"2010_08_various-implementations-of-asynchronous-a4e088a3-0b76-3708-ae71-e29e4bbdd132","replyTo":"","date":"2010-08-17T09:43:59Z","timestamp":1282038239,"authorUserId":""},{"_id":"bca9741c-6c02-3f01-ae71-08a02becb6ad","authorName":"Stephen Cleary, Nito Programs","authorEmailEncrypted":"omvI9F7e8b7DFk41J9xMKQPEFtJq93kEGTkwY0weKiZmRAgfs7Y5DnIcsu5LlbSjxIuppyzzSdsPRFyN5FFSGwqCsKugRHtJlcBY6HYaxYeHDC2aCsTwVflDDCSRjqefAiINSJ4bRmzxqxuhOjxARt5eZHubLb8M1647dvQjP+W5IiWHnQLFJmtXM4ewYk1jYpUjeEaIlxva6LqIoM91gNDpXcejTFWJN8U3RFuGnua71y4q5f4fypySyZthVk69lkhxVh0Q27A3CQuhiNbQ2ftcuVvXE340trXQ13mr1NixxyM9FSzJfvxfZVnDA5676rOvafVDnV2qC7yAkJzN7aL3K49mHQff6ASt8kozB11frtJLGwwSsid9ie0vDrdSoC/ZfYvk35RA3HKiHm3EWoUnbGfkSmF/xgeXZoALDVtEyW7e+DeAiKaeLXFduFAquGdzkvTHiHWe0ngDnM4M3UcOLy4Dg7olHV0Op9zAgF9FhkFFA59GABSMDtQEhEqlgbDhetSO+Hss1v4ycXhjDfjkWYhklYBa5R7x3TkE5ikutS86KfhvTDL4coJ7ZcMKRnDyhf7PwTZy5VePPmm5AkwF4k1Unhu5KzMM5xcCFOeWFSgiZhDx95JX3TxEbXh/Qw8NjMQYQDLsAR5NbPU1VN55hAQ6diyBrryuOiAxdJg=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"@Omer: I agree that Rx does have some async programming support. It's really designed for reactive programming, though, while this post is specifically about operations run in the background.","postId":"2010_08_various-implementations-of-asynchronous-a4e088a3-0b76-3708-ae71-e29e4bbdd132","replyTo":"","date":"2010-08-20T15:58:18Z","timestamp":1282319898,"authorUserId":""},{"_id":"7de31e80-cfc3-30f5-9c45-3d58c84e6114","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","message":"Great overview - thanks, for this! Would you consider updating to include the Async CTP ?","postId":"2010_08_various-implementations-of-asynchronous-a4e088a3-0b76-3708-ae71-e29e4bbdd132","replyTo":"","date":"2011-05-06T12:45:45Z","timestamp":1304685945,"authorUserId":""},{"_id":"1bb8dbfb-d993-3275-8ab2-eb297a393406","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","message":"Can you explain how the yield command is used to perform asynchronous tasks? See the last part of this guy's presentation for more info:  \r\n\r\n[http://channel9.msdn.com/Ev...](http://channel9.msdn.com/Events/MIX/MIX10/EX15 \"http://channel9.msdn.com/Events/MIX/MIX10/EX15\")","postId":"2010_08_various-implementations-of-asynchronous-a4e088a3-0b76-3708-ae71-e29e4bbdd132","replyTo":"","date":"2011-07-18T18:46:25Z","timestamp":1311014785,"authorUserId":""},{"_id":"2f793bd5-df3d-3f48-bccc-e07d5d6c92f2","authorName":"Stephen Cleary","authorEmailEncrypted":"bbdsLwqktnPLbapXyMP9o8qJihGcMRbE2S5wzePXpQkjvW5Mm9vcDqtg8oDxDQncfMuCEm9MSQ/81HaUZc61WwR4sONYvsTJmXDq7tLVFgOO0J1kBKadAEoqKHME+YMEZ3Y+jKLTyxE2K2nCGS27N0fN04tt5oe1ivLclMRnNy5E90sc2zCy+rvyXDFdZGtwtydjniGU9FN3qPkTuZcDnNbeCrrP9vZOHTqvkjcl0oB3/T2NFcq5AU9UWJLhFRAZEulaS78SF06kr9wmDapVIrcbYkKmOb1xaf5/EqHKeXJqrM1iPm3pE4t57OvcwUwXPdsFQXXWKyZ0612uEQ/TYyOSP7DK8o5+39IcYyGMuuStQM8L9vUWgmYNp0le57cnd3HTgNpgYnYxZ+yYU5qncha9szwbz3uC3uK44LH2BUmBfszgbrMnwdfgRFYya0xjH4r1HQp83pfuIbllUB+eJf7Wg6PJg6/iN4ZiyklrYuCijZSa1Nw3TYN+DpHyHMI3U2am6YG5js+oQqAz7kAtqpDOcphOln3PZYl3vtr2SFpJQR9iYioQh/FajkU0ivMNey7kZLi/37ma5zVfKIP6J4wwSsL5MCkyPzTbko3WGvoNNN0WtaHIrUd0YZYcDpzpipk1Zqt8eoSF7vAycrV7wZczCKiRRME3oTuXpghIKH8=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"Yes, I would say that BeginInvoke is not truly async. These days, I would recommend using Task.Run instead of BeginInvoke.\r\n\r\nIt's not easy to spin up parallel work using only async/await, but it's not prevented, either. So you can use Task.Run, or if you run async code in a thread pool context, you can have multiple async methods continuing in parallel.\r\n\r\nIn general, if you need to do parallel (multi-threaded, CPU-bound) work, then you have Parallel or TPL. If you need to do asynchronous (generally I/O-bound) work, then you have async/await. If you need to mix the two, look into TPL Dataflow.","postId":"2010_08_various-implementations-of-asynchronous-a4e088a3-0b76-3708-ae71-e29e4bbdd132","replyTo":"6ccd9f93-f0b3-3d3b-a658-e489316dc52e","date":"2016-02-20T19:55:35Z","timestamp":1455998135,"authorUserId":"disqus:stephen_cleary"},{"_id":"6ccd9f93-f0b3-3d3b-a658-e489316dc52e","authorName":"Brady Wied","authorEmailEncrypted":"X7c4ZS6x+uL//dWx4P2+4f3XA4Ma+RhOiMfpdqz6lQAUtxwFVdW2vdXuxvXBGDZLrYDkMTtackrp40/tJUup/ohCwkcLjdfA/2iMExa8dd3vCs2vJggKrTgZfDK503Tsw3JqgWzJJTWU8hpds+SosvTpC0pMqMhSSa2bv/9lOWpaGJ7++iJDUd++MiE7EjP8DIb/XcPwVySqdj2fAdwi/rZtXLs/ex5J9MEa772tfEneTlYWouzpFDW7emw7H3QHwG4q1BWh4M86F92OEs6UtWTujn5yglCZCL+u07nA9ugWIB9G4bfyrxEHPH3pYdNCMh7exJdVb3ERc+rIElDuAxbENFR0aw4+UbtHl8UNy7DLLbmKEY7ynYqBDfaxJce6fg1NsNQeazrPjE7FsMULf2t+1ctxrWVTUySTUKSbkTSnUvo4FYt2Q2H0LrS0nLkiHwn2MBm0sgI7lR4UEQyNwLR0RhLzeIk1vlZmmTPRm59Wn0GYAyIWdE12eUe64EypwHNFFlagvNprqraw10jZ7Xqmb8A81b9nSKGF9XhtAf/esX+eamtjhBVHRGY2ftvuc7t4gIs8YtVh8d0Uv8LzRFwuVy+7itplX6ttH85o5J5Jmil5oqFDlcv1JAHqCu1etD7ZMdptzWBxoVsTiR4L4ujuEBDDbuIu529WPhWcLqE=","authorEmailMD5":"7ad078a2a3c5e3c161b9405cd6b1c1ea","message":"Is it fair to say that using BeginInvoke on a delegate is not truly async (in the way that async/await is)? It seems like BeginInvoke is really just an abstraction that queues onto the ThreadPool (as opposed to async/await, which if I read your other \"there is no thread\" post properly, only uses the ThreadPool for that response handle piece). In addition, it seems like you can use BeginInvoke to spin up a bunch of parallel work (assuming thread pool availability) that is not asynchronous, whereas with async/await, there is nothing parallel about what is being done. Do I have this right?","postId":"2010_08_various-implementations-of-asynchronous-a4e088a3-0b76-3708-ae71-e29e4bbdd132","replyTo":"","date":"2016-02-20T17:02:16Z","timestamp":1455987736,"authorUserId":"disqus:bradywied"},{"_id":"12280cc0-f126-3131-82fc-f55058612697","authorName":"Shahenaz Sangoli","authorEmailEncrypted":"k3GEgquUkl+j0nIYOfMCYVwAnWvB1lNhL8GkaqxFEV2ppVwSVqeWVNLdZ/Z8hCfxjQGIvZhTubEyT1kkQP5fvJ5ciPSDoDpqi+IanrLj9e5m+LFPzGOSUZMkej0bf07YxOHvTZAN9ExVqnvgJPMpjVhCg+O5FQB7rJAGXwCIHLEFuygbA4YmcAtrSELRt45JwCLbS1Isub9GCfkBz3JqOhgEN5dZ5bXo0Gn2leX2CakJvsObaDBdc/Omzl6gwpJRrT2shj5krWd0kBd+5vv22nMZGJVFjB9zgYlBDmOoqCzKKGGiSOIRh2pUPYqyjuH57GA+389yDNOnpFD7Tc9oxWw+BAkICufvrj+BYqcBZWeK9KCuQElx5RWmpIDJMTsjGGEawIpdV+xGahcG3LHIqbF2eIsvTgX2lOypwDqbxnJkrd7S8etXY0HAhZQzBM9GMkVt52Ewy0ohYey2MOMPbYVTYd+lDXp4yTrjt2uTnnJsua8ucGW4YhVv1LFySm5KUxnIIrd+fAWsA9usmNKPBna3Af/URuyzpTB8AidwSHZqSCy3Zmfj05BDDqXpjwymAWkA47SIIwlMx3XG4/9IGop0DJLxUHLAIFPHEBRxOGGK78kYmgWSDCIB+p/uhKhA4TFYFFIrCLnzMtZWeTcRRpvRWdtiT2bV3eYd4bAZt5Q=","authorEmailMD5":"031a1f7fd3d4c49571c0c7fd267c136a","message":"It means when I update UI element within Task.Run, UI   \r\nelements run on their parent context i.e. UI thread right?\r\n\r\nWhat if I start new child thread within [task.run?](http://task.run? \"task.run?\")  \r\nOne more question, have you covered your post discussion in your book?","postId":"2010_08_various-implementations-of-asynchronous-a4e088a3-0b76-3708-ae71-e29e4bbdd132","replyTo":"26bb3051-408f-301b-a00e-9ccebd04d10e","date":"2016-02-26T20:53:35Z","timestamp":1456520015,"authorUserId":"disqus:shahenazsangoli"},{"_id":"26bb3051-408f-301b-a00e-9ccebd04d10e","authorName":"Stephen Cleary","authorEmailEncrypted":"jdrsXunmgO9DoA5GBRaKRbinFc3xvfPYo0J3/ALDVgfhwZtqkknixilX7G9w98pRWKsPTUMKNW35XRU44x0zlnlqVYmAcVLBIA9Qi1DAyoHN/OTNl6w2q5rdNfbxX+MT4c6I84x4aX04dq1kOW4ZWepRbOJ3Xyp4kV0G9CkCH17Tts2UUDnuqrwLgJYrqwXo9j0JIr06UpLOcnCGI53Apdbsw5eUm4oqrKP2UfzfOyFzV9+aQjmqhMQ1dpWVP7bwBdJzN0jbDe1lKn/k6WtNdWODmML86aN1DEQ5vI/KDLF4DCsOSbb2Y8IES2hqM/1SjILbEZ9wNtn0N6q+dVdmNbPt6Zpxz/NGLu/WU4VF02SZa+wI0UV4fujgmw4gCEzmpz0mKXPzpeiJYqdlL86Xgf4ZCdjCSiD+f7bdEgq5yusQwu0ZHElmNTEx6B+PMiJTaplSKHnDDLmOqdv1EPjhToYO+uglYMV/2YJYpzdQRv4/fE2gBo/sNAqiRzB2tKsCcAZxEzg9b5RWDsrZTUBjHa72xFS/UrwlQo1kZT11+dR5+RGybScrm44G6LXQPkodLcSGqOqcCIqF6KewqitkmTkx4bRYb4voI7OAZzR2puuxKj4nT0qdPqHej0g8n4P9SzPYrazZ3Sr9sr2BEH8F627oZ4AF2G08IjU/MSo+AF0=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"In the code you posted, `ProgressBar.Value` is not being run on a different thread. Assuming this code is called from the UI thread, `ProgressBar.Value` is only being set from the UI thread. I have an async/await intro that explains how this works: [http://blog.stephencleary.c...](http://blog.stephencleary.com/2012/02/async-and-await.html \"http://blog.stephencleary.com/2012/02/async-and-await.html\")\r\n\r\nUnless you mean that `SomeCpuIntensiveWorkAsync` is also updating `ProgressBar.Value`. In that case, *some* frameworks will allow setting UI control properties from background threads. WinForms usually does not, but I'm not 100% sure about their ProgressBar. WPF does allow setting simple values, but other MVVM frameworks do not.\r\n\r\nWith the range of support for this, I recommend not to do it, ever. If you use `IProgress<int>` / `Progress<int>`, then your code will always work for all platforms.","postId":"2010_08_various-implementations-of-asynchronous-a4e088a3-0b76-3708-ae71-e29e4bbdd132","replyTo":"c4fb70cb-d224-3ae3-8be3-fbed40906a24","date":"2016-02-26T20:01:30Z","timestamp":1456516890,"authorUserId":"disqus:stephen_cleary"},{"_id":"c4fb70cb-d224-3ae3-8be3-fbed40906a24","authorName":"Shahenaz Sangoli","authorEmailEncrypted":"a//7QRxpi4Gn7ncwfInFcF6RKAMY9awIi1nlNaDK8Eo0AC0Z3uKAF+pUcC44irnGSOZ+351QbWGB961qYqZGQIWqC1UFcoEzUbc4d06ADDa4G1YSVYGiCRNhJwwg7E+gArlv70+GCIB+Gn2DSu90gPm+3BlOcZs2MoEKWGAWQNzKDGmJ9+FXEzKQxqC5L/R0A99CK9UyVtwfHZU4YwaprSnL80ISrCTVvTsrfiGftl8A/28AkghrTmJa9HZKsnaZdy8t2rcjWAZygJsqP2YH8gFe+p26fuuLnO+gdyHmIktl0mKW/GnzDwCASCsBiKTWx8xsiZWKEsWgxnz+lBys9UdUVOMeWn5QuR8r0He3CCbe9EkYyH7CiU3fwEx3XSuhNrRm9Dj6tAK7MMGvqOaxvTeApi/XLmg4vW71xYkrfO9dTAn2Tb8WUBr1Q9lzOJxVYSyLRzR0aCKuwxzTOyTz3VYBHMAxd71orMFA2MZqg4pMkIIH0k5h3RbMF+7URTmfWFuB8+6zmUkJy9mmplZerSseYXR4mAtWFRxKV7oxhgIPMJbzapzhdOZYPWJaxyHH/vo95miFGhL1izTxh+rGqG3YLhSuerzIEns3B7sN8XqCCdRUjg7V47SWPDboCGoxecBmh5U+8IVO+GIs3Ci74vFCja9kDPQpW4Zj++mp4n8=","authorEmailMD5":"031a1f7fd3d4c49571c0c7fd267c136a","message":"I need small clarification on [task.run](http://task.run \"task.run\") in the below piece of code:\r\n\r\nList<object> items = GetItemsToProcess();  \r\nint doneSoFar = 0;\r\n\r\nforeach (var item in items)  \r\n{  \r\n await Task.Run(() => SomeCpuIntensiveWorkAsync(item));\r\n\r\n doneSoFar++;\r\n\r\n int progressPercentage = (int)((double)doneSoFar / items.Count * 100);\r\n\r\n this.ProgressBar.Value = progressPercentage;  \r\n}  \r\nProgressBar.value updates within the task block which executes on different thread. But I'm able to update the UI element without error. How is it possible when task is running on different thread?","postId":"2010_08_various-implementations-of-asynchronous-a4e088a3-0b76-3708-ae71-e29e4bbdd132","replyTo":"","date":"2016-02-26T19:38:48Z","timestamp":1456515528,"authorUserId":"disqus:shahenazsangoli"}]