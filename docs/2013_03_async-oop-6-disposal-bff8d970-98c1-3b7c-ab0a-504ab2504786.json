[{"_id":"ee3e0914-d37f-39fb-9ac3-abc6eea495cc","authorName":"Thomas Levesque","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/17821784613704879657","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen,  \r\n\r\nVery interesting article, thanks!  \r\n\r\nHowever I'm not really convinced by the \"Complete method/Completion property\" approach, because it lacks an important feature of the IDisposable pattern: \"using\" blocks. Disposable objects should always be disposed when they reach the end of their scope, even if an error occurred, and the using statement is the easiest way to achieve this. But the Completion property needs to be awaited, and await cannot be used in a finally clause, so there's no easy way to ensure that disposal is complete before an exception bubbles up.  \r\n\r\nI came up with a pattern that mimics the using statement, allowing for async disposal, you can find it [here](https://gist.github.com/thomaslevesque/5936421).  \r\n\r\n(of course, 5 minutes later I found that [someone else had almost the same idea](http://softwareblog.alcedo.com/post/2011/12/09/Using-blocks-and-asynchronous-operations.aspx) long before me, but not using async/await since they didn't exist yet...)  ","postId":"2013_03_async-oop-6-disposal-bff8d970-98c1-3b7c-ab0a-504ab2504786","replyTo":"","date":"2013-07-05T23:11:32Z","timestamp":1373065892},{"_id":"4c63d10a-0f03-3c26-ae0e-f1198f3650a5","authorName":"Nathan Phillip Brink","authorEmailEncrypted":"oj/Wv4yvClpizPIz8Qz4QsSpv+K0o62x27CdNoHSWhiScI3mni6kjfjmCQRrO3bys6Tn5jafZZeq0MLbEursyuafdTMc+OcXD7/R19VHpyWlRxX5iXMvMOTsIH5JMI9ZgFSOnCdnP4QmjRck2blN9qy4iISbmskc7fajHLiEiPbYJWol11EiuyX6NFGUl7rWMR5uoathXs4bTLPvw85h22WVpIOBBOFWb9GuFS9x8AgZ2gcje06fWM4pdrCH8nn/Gj+LTSbl8Mb7jrNdMmVNpz9QVKf3OAe4Avor0fTslvnRtt2e3AxVeCr47EFxMxesHSDyYVv2y9qZQ+2WdtepO+d+oL1RTldZJurcTi6QHweXrsucwiNgCtWt61mtUKDwYchFnrSptnkP1yJLERsNr2GKubEAh9lLIro/Et1XtrMOud6SS3kEX+WsVvPvJ52X34VoZ13Nc+9c3tyMjXxFz4T3ukj3c9K/AzSvkeuIfoXsycXEBmC2k4lT2/KME/rkV6reUGbZZgOBR3f3enIaIowELZ8XO0gRsknOIUzv4QIJ5UFsbFJcb6Cz1/jsUUm0LMX+ZaK9xdWUvzW/eCAeBEuEUyuFE7z8rnmNWcL0hLJRgLq83SwrRy9I7sGbpVaRFBMMWpJxU9kWWgICsxr7xmDV2ptcC4u284umSJdFso0=","authorEmailMD5":"a8defe14b1c80bc2bd59a1fab3848cfb","authorUri":"http://ohnopublishing.net/~ohnobinki/","authorUserId":"disqus:ohnobinki","authorFallbackAvatar":"https://disqus.com/api/users/avatars/ohnobinki.jpg","message":"I agree. Scope-safety is one of the nicest things that `using` and even `async`/`await` gives you. You can `await` something inside of a `using` block and not trigger the scope cleanup—something I’d consider very ugly to do if directly calling `ContinueWith`.\r\n\r\nI think your pattern should be added to the Stephen Cleary’s cookbook. It is even useful outside of just the problem of asynchronous cleanup because it is, uh, easier to fall into the pit of success when the developer doesn’t even have to write `using` where scoping is critical. Also, lambdas enable this pattern to be fairly easy to use:\r\n\r\n await CleanupCriticalFactory.UseAsync(  \r\n async thing =>  \r\n {  \r\n await thing.DoSomething();  \r\n });","postId":"2013_03_async-oop-6-disposal-bff8d970-98c1-3b7c-ab0a-504ab2504786","replyTo":"ee3e0914-d37f-39fb-9ac3-abc6eea495cc","date":"2016-06-29T19:11:13Z","timestamp":1467227473},{"_id":"00d18e89-22e1-3154-85b8-a5e79e960a14","authorName":"Nathan Phillip Brink","authorEmailEncrypted":"j88/T9i/iUhyISr74wQwMpcW21knmIi+s4SpBAfIKXhRmqIlRRhGx5jsWN8NeY1UpJBlimnjbMMbjKGk68AOF/o5KMQmWMnru8oWM9L9jYw/bjNuY/JY4wGTFU3IXDrdWrUQy0V7CYiJz2SJlh0yXgZ1Hh8LRDinhyWuL4/auSlhjndSLBpi8alZfCDLHYH/+NsJkxQZr0ubELeh5UA1Dg8WnO3Y94I0vOjuOgVNu4DJroWyY2LGgCXDxvgh/vfPS//2hHV3Vo8+qosf0jEyo1shafbFl+x98orDHD/Aim3chiEE/B3avuMwN1YciFG/oG7VjfRBwnTvJ3MpSUi3RhmscNKfz6C5zxEafyaf3b41awAj/ipTJBrBi0a5zuiBl0TR4gEiktxEWxeBQuOCxjQVuKYn/3DWK2BE5cvPi7DSVcpxZLGFFs0chgjuaB6nrSUi3lp9oECtSS0nKyQeUDBGiRH1Z4kG+3VKtVnyiw/s8agt+6ed3xBwA46IXmxQBRS4Qn9PimCd8D4s3AIj91qOEqdEH0z9f1Lt3yys5uXvhnP9mD5zMnuhDRo7tLSdvzlx1tEw1s7nXqxUP1YV2gYeXEVKtLhiyfuSYgDOOo45ca56YWh3CU8p9lgZGornqeg1qfPnEDEJjEh4SdaqEob23Ge7vZWiFkXa/Iv3Hnc=","authorEmailMD5":"a8defe14b1c80bc2bd59a1fab3848cfb","authorUri":"http://ohnopublishing.net/~ohnobinki/","authorUserId":"disqus:ohnobinki","authorFallbackAvatar":"https://disqus.com/api/users/avatars/ohnobinki.jpg","message":"btw, I didn’t know that `await` was ever disallowed in `finally`. Your gist can be simplified—at least with a modern (I’m using C#-6) compiler: [https://gist.github.com/binki/6a5b69e28caf9cef291e09002e4755b5](https://gist.github.com/binki/6a5b69e28caf9cef291e09002e4755b5)","postId":"2013_03_async-oop-6-disposal-bff8d970-98c1-3b7c-ab0a-504ab2504786","replyTo":"4c63d10a-0f03-3c26-ae0e-f1198f3650a5","date":"2016-06-30T10:56:46Z","timestamp":1467284206}]