[{"_id":"51ca3f3a-c2b6-3abc-93f9-29b2b93e6f37","authorName":"Mark Zvilius","authorEmailEncrypted":"","authorEmailMD5":"","message":"You describe Post(item) as synchronously posting to the the target block. The \"Introduction to TPL Dataflow\" document by Stephen Toub describes Post(item) as asynchronously posting to the the target block.  \r\n\r\nCould you discuss in what sense Post() is synchronous and in what sense it is asynchronous?  \r\n\r\nCan Post() block?","postId":"2012_09_introduction-to-dataflow-part-1-980c1479-b370-3974-8cf2-c1b8c36b44c9","replyTo":"","date":"2013-03-21T03:50:06Z","timestamp":1363837806,"authorUserId":""},{"_id":"d2d0dc2e-c970-382a-9680-9d052ca47ec4","authorName":"Stephen Cleary","authorEmailEncrypted":"MU5te4FW5RSaIiQwVeVHLg0qvhT2UqOceToUXzE86uaBk1sjRgTFhfnysJl8EYctp1/wLpUqsE4ZXqhd/ZomfMGhXs5gYbQiEmFTH39OC5TRwPFhgfn2Njfn7jQIYRof8fJEWg4B01BH+d00p/GsItjkw9xe0AQV4wf3u9aVE9JHlAhFNmuE0eT6Lbxv1RqUWB0khhGumBZyy/dbBFH4bU9D+otsrwojtPNM+NsdWDK9FscoCwYB7G2AjFEu8dA/8H+UIbbisNDibXb7vVk3JOb5vin/kGHIJro5Sext19jBVdpbkpycwq3v0DKplufqe168Ew+SuuKs8CBpo0WQXz8fYDrw2XQNNk67+3eUy8LBTXRAsea8Bl0WLpfCXOkKY/cqJaRRKiOIM8c2gDzcZChU9RW5bdcu48vVssA2OlZ6EWWRGEeo9dqD6KeekAA1UA+etFAZ0eRKBwCymJUtbAAzTD+hn/W+g49IY32q6w1p96ZpHuqFmpEb2I+cqyMZLQLEo75ysGGvzrV7ZWfOQMn3tsDpQyOmmkZV3mRaczfLLY3GSAW4nrqWl0teDLKX8wZKFBZbEGM2Uz8od9G6Yo+ziPEfr/QQ72ZeniqT0P7VIIQAkY+ETKW1ftsUJjGxHVs7gg8RvoNLNf/syhHPOFnn7eyX1WV0QGTHNpcfHM8=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"No, Post will not block. If the block doesn't want the data right then, Post will (immediately) return false. So I consider it \"synchronous\" from the point of view of the caller. It's \"asynchronous\" from the point of view of the mesh, because Post will just queue the item in the block's input buffer if possible.  \r\n\r\nSendAsync is asynchronous from both points of view: if necessary, it will (asynchronously) wait until the block is ready.  \r\n\r\nIn most situations, blocks don't restrict their input, so there's no difference between Post and SendAsync most of the time. A notable exception is when you set BoundedCapacity on the block options. A bounded block will attempt to postpone any incoming data if it's already full; this is where Post and SendAsync differ (Post returns false; SendAsync asynchronously waits for the block to have space available).","postId":"2012_09_introduction-to-dataflow-part-1-980c1479-b370-3974-8cf2-c1b8c36b44c9","replyTo":"","date":"2013-03-23T01:04:57Z","timestamp":1364000697,"authorUserId":""},{"_id":"c5fdd2ff-e7ca-31a2-935d-89ceebd91f1c","authorName":"Mark Zvilius","authorEmailEncrypted":"","authorEmailMD5":"","message":"Thanks.","postId":"2012_09_introduction-to-dataflow-part-1-980c1479-b370-3974-8cf2-c1b8c36b44c9","replyTo":"","date":"2013-03-24T02:31:20Z","timestamp":1364092280,"authorUserId":""},{"_id":"b6414c54-ad6f-39e7-8c63-ee84e298ee1c","authorName":"Abdul Jeelani","authorEmailEncrypted":"do2vqDr3nor5ZBsSV9ODDCnqTpoqUPulT0LtMyY5FV9P0kkWvv84QL12azheJrBBBjCJs4rveMebRZxLg4pe8YrNveUAMTlI8LjqMinP+Ms4bgRm8CxKC1N4RFrDiufuFHLkEFPJoj2V7eiFbEDTw5vtIgqOPaJMDNEYj9AomIH1CQ02x2SFyAtSczv93CIav9cHPMU+KXdLDHJzti9Nce6EOW4Q7enhUJAsWIiygzRE7MfxnvOHV17l9uoFu8fKtzODJJmL3qQ1MJ8mgOsz/2/Y0OzWGKhK5odUWEHnVRlmCSw/wfX04quLU7d6NBQSc9/ytV62wAaAQs3DrXkt9wVNZjr57qO0z7dlPyvVK2qDzuHRpXSHC/LCEjrwIGlEiloMyrElfyrOMHDRJwPN1TJH49KKVNxWRQm5ZbWayUmcjRbYfZf/cc6pvBXh5BR6XwpXLYwUu6qqYcEHa2maIdmE9RSynjpp/ce1AtIDhl0LegFHEDL4uxDHfdMHkKfST/PHv/qf0tigmCrsTNLnVTgNyRMdjANSr233dmdEhlTblT9gddygYZfP8/t5OZ9yLkdkMFKc4GpZ2hftQIgSJMXRRS6cpSF3hH7+xWgJfh79XvV4LPlB1HaKHJCWkfBNyars1LRgMeRu54i7MSATpk9rEnntBXayAv4FT2Wm1Rg=","authorEmailMD5":"b3eef3823290b09dd3e2aded4192339e","message":"Hi Stephen, I ve read your post as well as your cookbook. I am still not clear on Rx + TPL vs Dataflow.   \r\nIn Rx, If I intend to do concurrent operation,   \r\nI shall do \"obs.Subscribe(item=> Parallel.Invoke(Do1(item1),Do2(item1)));\"  \r\nHow does the above differ from attaching a TPL block as an observer to obs.\r\n\r\nCould you light up the difference between using ObserveOn / a Transformation Block to achieve concurrency","postId":"2012_09_introduction-to-dataflow-part-1-980c1479-b370-3974-8cf2-c1b8c36b44c9","replyTo":"","date":"2017-12-05T05:30:17Z","timestamp":1512451817,"authorUserId":"disqus:abduljeelani"},{"_id":"dc7fccfc-797e-38a3-91cd-76a991ae821e","authorName":"Stephen Cleary","authorEmailEncrypted":"RWzu518tqb9ReChfFmn/fIj3hxRbt2i+XfMNld4pBOyUxnAQ5bhOyYITAkSKzA0bkkiaYqKTvWGerOKGn4A4G3xqUDCoVi5/+L381jbOzbWTHSZASSInGdutZKbag3LlzwrobIK/zegEiEAse7UypXP6ti3jYmhqbMoVYxnHAxMambxFfuJwT3LtxkGZDoVyxlH00FKfnlj1oLhFPUtEvW5aRopPKlZkxFb8GSFq0iMt7UCrA+WXAD4GdrYkEx1DRFz2It2Q4RrWqrN/8JflAkQC4MBAh5kZ7hVF8pPLczWo6x7Hd6wbqjZeBTBQaQKszA1ak4HrS56eeMdeiiLlw4PSiJfvCZtbmBrHdkMbwbWQbKrPo4nKNNAwzG2Nk+aw8tZfMzc7p/94QIasFK01d45R8edCzMYl7pv0TABGETYzreqTP4/C+ackb644K886yMy2DAKAj4XaPr/rszct2aQjV9qv9SWA3DbIPwxSFSyZleSQlsWhAIAgbm5T1dF8YMgZiudBqPiGwImMECcHCHAN4NWXxxT0HoE3ZwKmkuagnXXIhQa2lb8Vr8i9oEJTjK19xXWoJstUzOXR2Rr9WQxBZEFJbnBH6jyLY0popftwGKU5r8Wj6d+KnxFMEx+EOP6RmcGUGRubYHjgKrcKpGLPj7I87cQ7i18fGIx0Zmo=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"You can wrap Parallel in Rx to get synchronous concurrency (parallelism). TPL Dataflow permits the same kind of parallelism, and also supports asynchronous concurrency. If your Do1/Do2 are synchronous, then doing it with Parallel or doing it with TPL Dataflow is pretty much the same thing.\r\n\r\nRegarding ObserveOn, this is a way for Rx data to \"jump\" thread contexts, usually used in the middle of a query so that the first part of it is executed on a thread pool thread (e.g., throttling), and then after the ObserveOn the rest of the query is executed on a UI thread (e.g., updating UI elements). TPL Dataflow also permits \"jumping\" contexts in that each block has its own scheduler. In the TPL Dataflow world, while the scheduler *can* be used on an ActionBlock for UI updates, it is more commonly used with a ConcurrentExclusiveSchedulerPair to coordinate one or more TransformBlocks/ActionBlocks with each other.","postId":"2012_09_introduction-to-dataflow-part-1-980c1479-b370-3974-8cf2-c1b8c36b44c9","replyTo":"b6414c54-ad6f-39e7-8c63-ee84e298ee1c","date":"2017-12-05T20:10:48Z","timestamp":1512504648,"authorUserId":"disqus:stephen_cleary"},{"_id":"d53cbe33-da4f-3a64-b2cb-096926d24a7f","authorName":"Abdul Jeelani","authorEmailEncrypted":"QsT8aDQjhjUPM0PIJpZP9GlKFVkBQgEDts4bdZAZHErlleervKjO7NRpq69v/GX0NllT1GfPr98zbUGca33jkKLvF89APwC1+z4q5x3E+pmKqFDAuzCgO8+6XB0tZhFTvBQIhVjojsBFg5lgwyU2y+/mfQ16rolyhcor1JJSasskAiAJy4T1MfPJHCQwv7MxG8wBSddJ3pWvJAKabR7QAIfsgHTX0ybhFEpiYXrykxtctbaPzuk1VfB4e9epsKvBIs5PwqWUDOVXejiXl6Txi1L/8aq6z3hRuxZ05/VlLLiHASeSoTE3DDyDRYNqSDomsXDsFha2Zt/hM2phOOQxpzgny8eSI0+0YZxGVHpScmYzGq3T+SCZyPWv4Fz4ht2QCRF8edQ6qiXdlt2hhp9jTAx1iCwKwhaZq+6hoe5iwIRIkXMr+4ZhCE4XfB5THFMor3IFQAEH3nUddIiJrg+qa3h6qloogjkoKxx9NYsGPb0Pk+3l4sFadoQpYLB617nflGB5y1c3T6mgK6e0oUBpepN8QgMZ80TU+coUmSvRt1twRTx0OImbpYJd2aiUuS+jYO5yfoModgOkEbQTnFahVqHWffHHndyJSSI0J0GNaJe9R9+YHfhWpeHlKmkE59moGy/+Q7ob9JjLkJ/z22waY5tS1wHdU3suMO+Tsy2nou8=","authorEmailMD5":"b3eef3823290b09dd3e2aded4192339e","message":"Thanks, but how exactly you differentiate synchronous concurrency v asynchronous concurrency,   \r\nIn my case Do1 and Do2 are independent, that work on a received item from a stream. E.g. Do1 uploads the price to a webservice via rest, where as Do2 does an internal domain operation.\r\n\r\nI understand that if my Rx Subscribe needs an async operation then I need to use a TPL block as a observer, (Note: I tried to pass in a async delegate to subscribe method, but Rx raised the on complete event before executing my delegates, means rx is not waiting for the action delegate to be signalled before raising complete event)  \r\npseudo:  \r\n\" obs.Subscribe (async result => Console.WriteLine($\"Got {await result} through Rx ASync on {getThreadId()}\"),  \r\n () => { sw.Stop(); Console.WriteLine($\"Rx Async took {sw.ElapsedMilliseconds}\"); });\"\r\n\r\nEdit: In this I case use a selectMnay before subscribe to await to get the expected behavior","postId":"2012_09_introduction-to-dataflow-part-1-980c1479-b370-3974-8cf2-c1b8c36b44c9","replyTo":"dc7fccfc-797e-38a3-91cd-76a991ae821e","date":"2017-12-06T10:36:21Z","timestamp":1512556581,"authorUserId":"disqus:abduljeelani"},{"_id":"703802b8-3072-3c63-b024-1d8bdea8eb5a","authorName":"Stephen Cleary","authorEmailEncrypted":"IvW4m2IXFLb+GodAo8X1ycFF0KOIr0Dp1FUmQExTxERf7wLxPJv79cq9AsMyAX3xsncpOTSjwuwBy3PoN5ac1mfyF1ICSlOoVQw4msk57EaoBGWL6fFHB5qMERKz+UXZMAna01Zp7/B8rOYsqkf60NDQ5P5SYu1mYTLnTvP62QarpWIMrp0Ewq+th0J3Q9iosGVtJbZM071FRXDxQcIBarrFNrJGVvpYE/hWOPtmA0VVcdrZenVS9knjXHudZerEOBiYugrgv2Y2TFylZ867ORScBjy6MtpHVwmxxXZ+XW09mp1fnkazmOrDSOlDxt/MAMMA74tGl3khxmmyk46Am7f2uhx81gIro/sPaXuvaow0TleidENimeiQbQI6C3ZI+S+XSRW/2XdzyPSRVlbjDnBfxVcPiixGcBeWm2K95stzavi9pqWEybVoEzDmTybhXaAND24tVb6hQ+CahSUbvpNBn5nVkmxOYlTnYVOFc8719xdLVst34uXwRWx+7BuizcnEtvZqQ1BplXLZprtwoRPTKgdWfdooABs/IHnW5AMlKoUiSHpEHypY5gg7kd+1mAQezg0ex8ML68GkIEUPs2Q5caIzMTA85thnmgGbg5WZv+FCkG1EK2wRq6fvv4hfEvV1+0ljn799FT+Q9bvyYSVv41D1n21VmVgCdkGfKHU=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"The question is whether the DoX functions are asynchronous or not. I/O-based operations are naturally asynchronous. This is not to say that the Parallel approach won't work - it will; it will just work by blocking extra threads. Inefficient but functional.\r\n\r\nRx doesn't support asynchronous subscriptions. Or more properly, it supports them as async void methods, so multiple data items can be processed concurrently. Rx is behaving as \"LINQ over events\" in this way, and the subscription is acting as an async void event handler. TPL Dataflow by default will provide a buffer so that asynchronous items are processed one at a time.","postId":"2012_09_introduction-to-dataflow-part-1-980c1479-b370-3974-8cf2-c1b8c36b44c9","replyTo":"d53cbe33-da4f-3a64-b2cb-096926d24a7f","date":"2017-12-07T21:38:39Z","timestamp":1512682719,"authorUserId":"disqus:stephen_cleary"}]