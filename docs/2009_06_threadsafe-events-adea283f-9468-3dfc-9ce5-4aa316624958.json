[{"_id":"5f2b02d7-d04f-33c5-ad83-befaecec6387","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Wouldn't the solution be the following code?  \r\n\r\npublic event MyEventHandler MyEvent = delegate { };  \r\nprotected virtual OnMyEvent(MyEventArgs args)  \r\n{  \r\n this.MyEvent(this, args);  \r\n}","postId":"2009_06_threadsafe-events-adea283f-9468-3dfc-9ce5-4aa316624958","replyTo":"","date":"2014-03-26T17:50:20Z","timestamp":1395856220},{"_id":"a555c063-b953-36a6-9518-52849fbe1a4c","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"No; there's still a race condition between subscribing/unsubscribing and raising the event.  \r\n\r\nSpecifically, it is possible with that code to have one thread unsubscribe an event handler from the event, and then have another thread invoke that event handler.","postId":"2009_06_threadsafe-events-adea283f-9468-3dfc-9ce5-4aa316624958","replyTo":"","date":"2014-03-26T19:24:01Z","timestamp":1395861841},{"_id":"ba02ad13-0455-3e7c-8471-eb87cb53d03f","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I see… that's so complicated… anyway thanks for the answer :) btw. I’m trying to read whole blog since it's very interesting (especially the multithreading parts) :))","postId":"2009_06_threadsafe-events-adea283f-9468-3dfc-9ce5-4aa316624958","replyTo":"","date":"2014-03-26T19:44:39Z","timestamp":1395863079},{"_id":"797e77d9-423c-3582-917e-6fbf3a4a4177","authorName":"sjb","authorEmailEncrypted":"ktZGrVdDCB678gg41auT2U6AWGV7kqVpmc6wBWLKvee7vXZMQnycQpnqIwUtaFUiisLMbM3+dt4woU9FjnQ62Jrd+8DhUXXAYf7n5eAj4Qboy4+QPTv9sWaDNC4IM2ZUZMLp6qbFVUCX+CWUIpfHjp0vF1DnThdOuqlvzStFMjqvvHrJQ3XfdGEWnoCRsdlDKuCjHUE6mXDN6VoCFU9jE6YtWSrNtdre2GS/6X4StOAsKLcdlL0YPq8f45tDbot9YiAYo3pz+b2qA5uInf3l9Hd1CZWICzMgKgUfNs6Y7FopAfbwadwZe9r0i7JpkzL1h9mClj72B7MR3QHNw0Ml3dRD8U1DZO9FmISNeAidpx6C3kfb8DsBNOU3ruMpJTJ9DDyTheLYo+HMYSsUmNUI1dByhz+eitrVYMjs6GEVDT49KoKVONC8WOzWS+eZ3R0ZM7kKlBBayBphJaaGhgaXi0t2d/OxSr7B5dwrO3+JoDox8f2/7aXnzEBz6DmGZih1yY6x3egdPR8ySJa73bmrAY8ZBTkQQvPDjSM8kNn/P0Vfxk/3/HHv0ZmTfP07PoZQ8EPvkguzkhBouM3O9nVtqtqfVIeL7J+MpOFdFQ4eXCAb6T5wWT3TJpJdDSGya8QBpd8YfeA3F/oYRnf7ETq2N1HWrGH5OTBBFuTB5zvU2i8=","authorEmailMD5":"961ac36915b8a21e7cba9d2c54b5d1d9","authorUri":"","authorUserId":"disqus:disqus_yaGF2uMnNq","authorFallbackAvatar":"","message":"Thanks for a great blog posting, and just as interesting today as in 2009.\r\n\r\nI think the first group of failures (A raising, B simultaneously unsubscribing and releasing resources, but the delegate in B is called anyway) represents more a race condition within B than an event-specific problem. One piece of code in B is releasing a resource, while a different piece of B is using that resource and the two parts of B are not communicating with each other on that. I'm not sure that it is A's responsibility to coordinate this for B. Eric Lippert commented on this in his posting, [https://blogs.msdn.microsoft.com/ericlippert/2009/04/29/events-and-races](https://blogs.msdn.microsoft.com/ericlippert/2009/04/29/events-and-races)\r\n\r\nSee also [https://codeblog.jonskeet.uk/2015/01/30/clean-event-handlers-invocation-with-c-6/](https://codeblog.jonskeet.uk/2015/01/30/clean-event-handlers-invocation-with-c-6/)","postId":"2009_06_threadsafe-events-adea283f-9468-3dfc-9ce5-4aa316624958","replyTo":"","date":"2017-10-09T16:11:23Z","timestamp":1507565483},{"_id":"7a00e600-23db-11e9-aa77-ffe40b10080e","postId":"2009_06_threadsafe-events-adea283f-9468-3dfc-9ce5-4aa316624958","postUri":"https://blog.stephencleary.com/2009/06/threadsafe-events.html","replyTo":"797e77d9-423c-3582-917e-6fbf3a4a4177","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Amir Rasouli","authorUri":"","message":"I think Eric Lippert is right, that's the way I was looking at. I want to know what Stephen Cleary thinks about Lippert's view.","date":"2019-01-29T15:35:16.876Z"},{"_id":"96a9aee0-23e0-11e9-aa77-ffe40b10080e","postId":"2009_06_threadsafe-events-adea283f-9468-3dfc-9ce5-4aa316624958","postUri":"https://blog.stephencleary.com/2009/06/threadsafe-events.html","replyTo":"7a00e600-23db-11e9-aa77-ffe40b10080e","authorEmailEncrypted":"SzIAdE8M93Gc4Un3PZAb+wN5+pQyDPAbWsV/bp5RTUfw1gQNBZcnRmfrKgPJtMkTQl9aO3x3igVp01Axv+RxeCaa8YYKL3nBkdy+X8KP8P3YVUVisLOANnZ/JRRW7RVrSB1tssycIa8lL+uKAe+U+BRumxPq/gop7oa9yQY9IRuBj2uSzhFC3QKeJBrnUUb4tK+SSv5BwgF3FwlrkdqZMMiRjmfmLamh6uwGsh0nUOeQkPFTUOSC/HwDfGCeWMAZlhgGugdv1n/jxymyGYYrX6LVuDNv5aezIOyOMkfAb7eDUTrJHwK6LETQl4fJW+Qw8p3RbRZI6Xfz/Uh1MRHFYniJsoafL6r2osGVQ7TBFx7hKnuGEYEky/jUHmqXSvhrQuXvYHHz57yVWehwJ5bJvzgW5pd54WqlWYgir+QILvrtWHXK14Fm2WZKRSpVMKJAL093+uelB3i90ryyUiqUFDACYEE9dRNt46BeBqDnz17PGg2oSH8IDISpz/qQLcloG7i/2qhfMyohTFWiCn5xvE0cgQE9bT1F1AxSlnlYPv4nmGSPdxRLEIUeZhLchRr6X4ovpSJnJ1lEr/qsFCBnkU/f6XymRySg9PwpeJgQVToCK0hK8tqAXJErXq8qI605Lm3YukTqhWfBt3AbyZxjW0EGJKs1nrn7hKABm2w0hUc=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"In his article, he states:\r\n\r\n> The temporary variable ensures that this is “thread safe”.\r\n\r\nand then later states:\r\n\r\n> You've got to solve both problems if you want to do threadsafe events.\r\n\r\nI.e., the temporary variable is insufficient to make a threadsafe event.\r\n\r\nMost of the confusion around this issue is around the question \"what does threadsafe mean\". And both of our articles agree that there is *no way* to make events threadsafe just on the producer side. Eric's second statement sums that up.\r\n\r\nEric mentions a solution you could make on the consumer side, but it's not easy to get right (or even to know you need to do it).\r\n\r\nIn my opinion, the core issue here is that C# events are rather poorly designed, and lead developers into a pit of failure as soon as multiple threads enter the mix. `IObservable<T>` is how events *should have been* designed; it provides a new producer *and* consumer pattern that is truly threadsafe. In my own code, I *only* use events if they are always raised from the same thread; that way, thread safety is trivial.\r\n\r\nThe only point in which Eric and I disagree is whether the temporary variable is useful. It is useful for avoiding null reference exceptions when using cross-thread events, but it is not sufficient to avoid race conditions when using cross-thread events (we both agree on all this). I always recommend not using cross-thread events *at all*, in which case the temporary variable is not useful. He recommends allowing cross-thread events, with the understanding that your event handler must have special logic to detect and handle race conditions.","date":"2019-01-29T16:11:52.502Z"}]