[{"_id":"09a5e7c7-285a-349f-92c5-c1ab284aa5bd","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"There's no such thing as a 4.0 version because LogicalCallContext doesn't support async methods on that platform.  \r\n\r\nThe compiler will work just fine targeting .NET 4.0, and it will happen to work if you have .NET 4.5 installed, but it will behave differently (incorrectly) on machines with only .NET 4.0 and not .NET 4.5.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2013-06-19T22:54:39Z","timestamp":1371682479},{"_id":"cf1c29e2-e5e6-32ad-a81a-da86a752c985","authorName":"markell","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/00249008025035595944","authorUserId":"","authorFallbackAvatar":"","message":"Could you post a 4.0 version of the code? The reason I am asking is because I am unable to reproduce a problematic behavior in 4.0. I have written a unit test, which creates multiple concurrent execution flows and all of them seem to propagate the call context correctly. My unit test can be found here - [http://pastebin.com/tAgRfjrg](http://pastebin.com/tAgRfjrg)  \r\nI would like to know your opinion.  \r\nThank you.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2013-06-19T22:43:03Z","timestamp":1371681783},{"_id":"00642260-13a7-3328-b63f-08d62806be23","authorName":"Gav","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://twitter.com/gavinosborn","authorUserId":"","authorFallbackAvatar":"","message":"Excellent post Stephen.  \r\nTo clarify your point regarding mutable objects and Fork/Join operations... at this point we are simply talking about standard multi-threading concerns; eg: multiple threads writing to the same location; right?  \r\nOr is there something Task/Context specific that I am missing?","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2013-10-03T04:59:06Z","timestamp":1380776346},{"_id":"76fc4fbc-9698-3d58-acf4-72a9b5ef3baa","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"No; this actually happens even in single-threaded situations. Async allows you to do a fork/join (e.g., Task.WhenAll) on a single thread - what I call \"single-threaded concurrency.\" In this case the mutable objects will not behave properly because they're shared between the logical call stacks of the various concurrent methods.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2013-10-03T07:52:39Z","timestamp":1380786759},{"_id":"aadb083f-11f9-3e12-8412-b0373189b935","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The logical call context will definitely work for any \"tree\" of async method calls.  \r\n\r\nThe blog post you mentioned is specifically about a thread jump between BeginRequest and Page_Load, which I know nothing about. I do know that ASP.NET 4.5 rewrote the part of the runtime (AspNetSynchronizationContext) responsible for scheduling work for a request, so the problem in that blog post should definitely be checked again to see if it still applies.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2013-10-17T08:06:43Z","timestamp":1381997203},{"_id":"f7bbdeb6-a369-369d-a961-aa727afd3436","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hey Stephen, do you know if the copy-on-write behaviour also caters for ASP.NET's thread agility?   \r\n(Discussed here: [http://piers7.blogspot.com.au/2005/11/threadstatic-callcontext-and_02.html](http://piers7.blogspot.com.au/2005/11/threadstatic-callcontext-and_02.html))","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2013-10-17T05:15:42Z","timestamp":1381986942},{"_id":"be352561-e1dd-37b9-a1f5-c28787f033ce","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Paul -  \r\n\r\nYou may be interested in my AsyncDiagnostics library ([https://github.com/StephenCleary/AsyncDiagnostics](https://github.com/StephenCleary/AsyncDiagnostics)), which combines the LogicalCallContext with PostSharp. By default it just attaches the causality stack to the Data property of any exception that is thrown, but it also allows using-style constructs to add your own data to the stack, and a Current property that allows you to read the current stack at any time.  \r\n\r\nNote that you'll need PostSharp 3.1 for OnEntry/OnExit to work correctly with async methods. I can't tell from your output whether it's actually getting mangled (the numbers and letters are the important parts). If you're already using 3.1 and you're sure the output is incorrect, it might be a problem with MethodExecutionTag (in which case you should notify PostSharp support).  \r\n\r\nSteve","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-03-18T17:02:34Z","timestamp":1395162154},{"_id":"e4cdedc9-0f6a-36d4-8365-d8ad4dfb7783","authorName":"Paul Rogero","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/18276298439153144212","authorUserId":"","authorFallbackAvatar":"","message":"Looks like Blogger sanitized the comment code. Should be:  \r\n\r\nMain: <SomeWork>  \r\nMain: <MoreWork>  \r\nMain: <SomeWork>  \r\nMain: <MoreWork>  \r\nMain: </MoreWork>  \r\nMain: <MoreWork>  \r\nMain: </MoreWork>  \r\nMain: </SomeWork>  \r\nMain: </MoreWork>  \r\nMain: <MoreWork>  \r\nMain: </MoreWork>  \r\nMain: </SomeWork>  ","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-03-18T06:30:10Z","timestamp":1395124210},{"_id":"ee7fc027-87a4-30cc-b1f9-41b910a7c72b","authorName":"Paul Rogero","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/18276298439153144212","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen,  \r\n\r\nFirst of all, thanks for your posts on the LogicalCallContext. They were very helpful in explaining the concepts. I had an idea very similar to yours above regarding logging flow throughout a tree of async operations. A key point in my idea was to be able to apply the logging code via PostSharp.   \r\n\r\nI copied your code above and it worked perfectly, just like you described. However, I then attempted to replace your using(){ } blocks with a PostSharp method aspect. It did not work unfortunately. The code for the aspect is below:  \r\n\r\n [Serializable]  \r\n public class ClearyMethodAspectAttribute : OnMethodBoundaryAspect  \r\n {  \r\n public override void OnEntry(MethodExecutionArgs args)  \r\n {  \r\n var disposable = MyStack.Push(args.Method.Name);  \r\n args.MethodExecutionTag = disposable;  \r\n }  \r\n\r\n public override void OnExit(MethodExecutionArgs args)  \r\n {  \r\n var disposable = args.MethodExecutionTag as IDisposable;  \r\n if(disposable != null) disposable.Dispose();  \r\n }  \r\n }  \r\nThis is the output:  \r\n*** ConsoleOutput ***  \r\n\r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\n\r\nIt seems that it would be functionally equivalent to your code but there must be something I am missing since I can't get it to work properly. Do you have any thoughts on what the difference between the using(){} approach and the MethodAspect approach?  \r\n\r\nThanks,  \r\nPaul","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-03-18T06:27:22Z","timestamp":1395124042},{"_id":"9276f8f5-15b7-3043-a877-ded2078c8b06","authorName":"Paul Rogero","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/18276298439153144212","authorUserId":"","authorFallbackAvatar":"","message":"Hi Steve,  \r\n\r\nThanks for the reply!   \r\n\r\nI just checked my PostSharp version and I'm on version 3.1.33.9 which seems to be the latest. The output in my second reply is exactly how it looked on my unit tests. The numbers and letters are literally not there. So the MyStack.Push(string) method doesn't seem to be working in the PostSharp version I created. It worked perfectly in the version that uses using(){ } blocks however.  \r\n\r\nI see you use PostSharp in your AsyncDiagnostics library so I'll have to check it out to see what I'm doing wrong.  \r\n\r\nThanks for the original blog post and the reply!  \r\n\r\nPaul","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-03-19T02:18:10Z","timestamp":1395195490},{"_id":"67391f2d-6d94-3634-a20a-342bbc2f48bf","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I see, thanks. So it's something just specific to ASP.NET or rather at what point the ExectionContext is captured.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-05-03T04:16:40Z","timestamp":1399090600},{"_id":"89ee35a5-b677-38d2-bece-19183f51a99f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"\"Yes\", and \"yes but it doesn't matter\". When you call Task.Run, the context is *copied* to the thread pool thread. When Dispose is called on the original context, it doesn't affect the context that was copied to the thread pool thread.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-05-03T06:21:13Z","timestamp":1399098073},{"_id":"98b4b466-048d-3cd1-a0d5-13852b72d9cf","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Will the Context also flow through to a Task.Run() delegate inside the using(MyStack) block? Is it possible that the Dispose() is invoked before the work item is executed by the thread pool?","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-05-03T05:55:04Z","timestamp":1399096504},{"_id":"b7b399a6-c109-3c77-a66a-6637c1b014d2","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen,  \r\n\r\nWhat about this stackoverflow thread (I see you commented on it): [http://stackoverflow.com/questions/14700777/await-task-run-altering-trace-activityid-on-exit](http://stackoverflow.com/questions/14700777/await-task-run-altering-trace-activityid-on-exit)? The user seems to suggest that the activityid is not restored.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-05-03T03:23:28Z","timestamp":1399087408},{"_id":"f8e1fc03-b24d-331a-8cd1-bbdd81571747","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I believe Jon Wagner's answer has the correct analysis of that situation.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-05-03T04:02:30Z","timestamp":1399089750},{"_id":"3be90f02-a6e0-36f3-baf4-d4a7979b0315","authorName":"Flyer","authorEmailEncrypted":"wW7/1KyTKr0NlJESogWHQMavqAJ6NRnBJA+VLPJx0EMOGGZv/kn2XpEHMGRopmcuFEHTC/K9fOxlocEs6WOsV7eZ6cZpzUDLoM2TgQ6/MaAwoQtxe19pYnSSqJMwzkQidGWe2aJS8tHf6BXip/bTCrhU6rEwUBlwS9QxN6mUcKAeiU1f5fFr923Ku1TGNkF3hgBGjtqrz3zGrw92wn5ekyjgroeVMXSYzajxBMsjS8N3r1jzsZrbjjoNVyHUuZlFQCEYZ0nv7PTCp3Ey48eEkhPqpUvCwoxnxUvGbxg5vbWblGWOf0tygugtzq+0fuLqIm2YHiVD5SF7Yw8uqluahddLOxdgDSRBdXw22AFwv4h+qwRZzv1+8niXEuonYeLvHnaJig0AO5pBebzgKT+tdYLdqqxiH8w+4urhsbODiKgKvBioUyzGJ3nEXObp77J1bYuY8H6KoZRB07ztClhVN0j7kdcec51VW9wJMmIHod+AI2iVYaCYAtcRU8dc0WrxpJzzzyZhfwHrDZgSG/3h5Vb90R6cLH6iMCzXS8E3EEY+x4qmmh5P1N+SMNYE3JkfBRoWoIhtasCp6/H5zRkYmRXFxeEgBAAbYKuctMLIfBHEDbsbZaT1rKv3MmbQHiCEYiKD9qW7iGRWYm3ZV+tp6vODPNnQB/p/bzyO92mJVtM=","authorEmailMD5":"2afa12b80aa5dba93b288a50e6e70737","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thanks for a very informative post. Have you, by chance, tried to make this work with the unit test fx that ships with VS? It seems to dislike the fact that System.Collections.Immutable are non-serializable (which makes sense to me that they are)... Am I missing something very obvious?","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-06-03T09:04:53Z","timestamp":1401786293},{"_id":"e1f08703-e2ec-3e62-a576-84d66e98c82e","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I was able to reproduce this issue. Apparently MSTest now uses cross-appdomain calls, which are not supported by this version of the \"async local\" code. I'll update the code shortly.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"3be90f02-a6e0-36f3-baf4-d4a7979b0315","date":"2014-06-03T14:46:47Z","timestamp":1401806807},{"_id":"3ec3ab65-fc21-30a2-98b3-d55dcde86949","authorName":"bman654","authorEmailEncrypted":"h6RRucalLyPIJxDDAi+uv4sB95gKtK+oGTKbt8SD2lY0zdSQIgcV1wE2o3AujLvK7OVWRNN5ZUCQGgO6YZqeK7uSLVfRC8tTFJIBF5k4O9MMDjNZA0ih4M26sw6IVQaxg/97vV6d8OvckYyjXx3D9wvvD70XhXw6onXUx0Z1eObScF+l15+Q2sHSmdRUPkHk1NC++cqzyZDyKhJpaYDNiiuHvToV/sQcGUklq6WfUc9SeF/4vB7XEwMWvPxbQtKsDkjw5kS3c+f8j5lEKv5IqcO9sqV6LCGhxtRE+F5beVj/rg++SYYPGcwhAHluEIJEFfX1rhYH89ZP2XLvtPEJL8K6cU3jer4u1r7/2lNKKhc7TBajMX6KqHp7CESJgryqBgl0Q99HqaLoGIF6mmzlctT6Oxx91prfKkjUgNUjdE5x3rWy19d95dB8ZTQXlAkfARNpXa5B40QtyjtPXUaujI4iUxPsEIX/+lMKPXJbfKGeHKnuV0T2YhIxksu2/DYCtt+1dKWxCcrvi/W6ppLtsLJYNme643M5JsFNmjW2kfmaSoeKA7vHw9WP5U000YjPXKubXKmZG/j/kLFWeievkL7OEVZAmrsMJkV8l7CI2tgIZXNIC0krXLgs4z6wTEn4N9YnTgwHLdMwLI6oRdfsU/p73e4yjW4sKZSXGTaoOWo=","authorEmailMD5":"bb1ffcb8355a833bc34334d75cefeb3d","authorUri":"http://www.palladiumconsulting.com/","authorUserId":"disqus:bman654","authorFallbackAvatar":"https://disqus.com/api/users/avatars/bman654.jpg","message":"Nice post. This really helped me understand how the context flows with async/await & TPL and was useful in my research on how to get Reactive Extensions IObservable's to properly flow context.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-07-01T21:51:20Z","timestamp":1404251480},{"_id":"36934a44-f3ed-37d7-bc25-fdca37729a67","authorName":"Dirk Boer","authorEmailEncrypted":"pquOjDXiar1cvWuv/eXwLgx0sb1S5U2aYN0nou3gKN6BTsSGR572ZRscFsj7WobAecfAM8YU+qBp63z3MQpEaFNURVbqd12+KFWbVwMrsTn47LkCb/TJl6BhAU2hDuLbdgNAsjyKbuwE1R08NM0oOadnbTC9j8+tr5H/DR3QA+qRR+kkHicKIzSwOHAjj2sv/wBUUQHlSkKn//21aLd0IliQ4d4kGzy0jDD8YXDY86NR3LyXn1XmxlFKrpDYXWAB6AoEo7SKP3uUO8OHCRzcZ+DWqj7o9xBDsFTsuhN2inLjMfNAkMe/SGML0ysTQYltclx5jUZnVh2VpeHLJ5uqBX2GQI4VL2T36t/C88j+UK41BQi0YeoEWgiNQl2wQyk+ONPceQ86R8TP3u4F0U7hOUIrG+WdyRWQvqBSdZdeJpiUG3+rV7vz4q/7nFOEvb3PWD0U6yNiKIZleW85H0ThWKsM1KXGqMNg5+S9jriCAZMauuwbO7mI4kDdVuQI4ymPy0vHJ9peNjrlRPcsSX8teMW8upWvNVcRSe9foZTBI4GsbvmZCNHPwTYoCv6qwt16JQxz5JsmiIvcHai26+ZyCQyh4mYA7Z8VODwkO/X4Ov1zZQhXiZ0nuftMM1MywHMPrnwfaOjz4haXsZgrVjxUCkWuj8KLQWcEYOR6B/2/6kM=","authorEmailMD5":"16524861aa558bbd1b2af0a2269d6595","authorUri":"http://poules.com","authorUserId":"disqus:dirkboer","authorFallbackAvatar":"https://disqus.com/api/users/avatars/dirkboer.jpg","message":"Ok, then I'll just implement it, and hopefully never have to bother with it :) thanks again, great blog!","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"45b0330b-49a9-3a07-ade8-80ad78830d2a","date":"2014-10-05T21:06:57Z","timestamp":1412543217},{"_id":"45b0330b-49a9-3a07-ade8-80ad78830d2a","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"In the original post, I didn't actually have a MarshalByRefObject wrapper. The code works fine without one as long as all your code is in a single AppDomain - so if you Push and then further down your (logical) call stack make a cross-AppDomain call, the call would fail. What the wrapper provides is a proxy for the actual stack value so that the (logical) call stack can be accessed from other AppDomains.\r\n\r\nAt least, that's how I understand it. I do not have much experience with AppDomains at all.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"64341ca5-5b3d-3afb-8806-b880350c3531","date":"2014-10-05T16:59:52Z","timestamp":1412528392},{"_id":"64341ca5-5b3d-3afb-8806-b880350c3531","authorName":"Dirk Boer","authorEmailEncrypted":"FjDXLKYznIElb2ntsCTBuYD6Fukea0MKNLrSd2XmpSOC5kSvL0f8G3gcmERtdQGpOHyrT50z8ou/sdj1QDBNeWizpMYgB8LLWstc38G/EKicCaGVyH41cMD4+Q3UEvmrQ7PmwW60T38Sc91Sj4aRFU5mVRrv98Bqhwg9MqvGmKn0X7V5vza93O4LGAovyKk/1RpetCF/tpXKYh1ASrM+ocXD6Kj2hN19/C+N/D8iemuEhnLgZbGPBoBgNDZe7xKqlF7igZG3meuI8cM5B5eNKbBppmYik7RktNoTGUqi4aHeNEmJdLBI4mJlKfGzbu8aT7ADB3vKq1m4XAq/Iq3jUP4ZJETg0DI+Q94D8dxSkHIRLgiM/DkuAVVHLxAbu8sAo59j3UjE2E1WiaZsHHEYfSMRAfamjpDHzQfAyxbRem5T7EmJnk7tX4jo5nfsvnk3mTDx6E1mXy5N3ebGbI3xzOkMV6X44/sFFjZ0u3Wd0GG0Zr6TwwgOaZv1dj/SDfy7J/309H5HyAKZCHe5lrII7C4SEfAatls7yAMSl6zENd/WUv3ikClAWev2dSsqYW22UHk/psVXv0phT9a3AHkwBkR1INYjS/wswpECXetmZ0S1Gc1cCK1LEL5qrC938ZUD6u6YmSMDMrpgSco/ri2MFRAnE9zxwNJBGMRdyuxqs9A=","authorEmailMD5":"16524861aa558bbd1b2af0a2269d6595","authorUri":"http://poules.com","authorUserId":"disqus:dirkboer","authorFallbackAvatar":"https://disqus.com/api/users/avatars/dirkboer.jpg","message":"Definitely my new favorite nerdblog to follow! Question Stephen: do you have a little bit more background info on the MarshalByRefObject Wrapper?","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-10-05T14:42:50Z","timestamp":1412520170},{"_id":"51403dc2-c17a-3cd6-8d09-40199c253938","authorName":"Daniel Bezerra","authorEmailEncrypted":"h5mpDYZc8WI2xBajeRZm7UTuCDI96pZicTcecJxCKXSJUv+ST4FLEhSr8N5Vjotjf3t+nXn70WXnhkOfsGEi/F10T1szzqBPQ3v5Tz1oK8mPjN5qI+Uc3PdZlAW6mG9fiAWiSUjFaMixeUzH2QBXGNcjZkHH9GdXFIIba5frigLjMmipUjim1g2LWUaXBZTK2TR5BOMebo+ojZ79BylWM7TF/J+i0+4scApbi3y9I5CKhvoCHV9uXBCKsRiMbmF2cqcOxcDXPT9m2eOSGqLQpSESVkXQPC1/wbE8KBa6/hhizHgM1CM2YHZNTzVo7cG6VtQWxjPQXDnMovaa0oF8v4QyuLNOTm8ea80FyvX8pN1s5TYrY93EFcjyaf7BSApyjXw+9M1A50EmNOte5J1DvA83dWyngmu7OgtV0ZZAAxOldSCtK/GX8AVAqpOhi1QWT0Z/oIM9bc2K/4WnpVNL9NVFrVHK5ryUUm4phk5+pscNFuCZvKKPj3KnLCH6P6a30UZz1d4KdFXs1ztyCBsm04CzvUFzfJicY1MdkthPJ5mRUq626RpTmnu3/gcQkws5vgHAsjVIKvFwKbBCfrPsysiq6yCJpQ2IRKUohgMZHBTLMQZtkcu3rbBfqarbn7Xvm9wb+CBc8qgJfGsdt9aBPxq9J6BbHkVXv8siKJh1X8k=","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Stephen, could you explain why we cannot use 'LogicalOperationStack' with async in .NET 4.5? I'm assuming we can't use it, because you wouldn't loose your time recreating it in this post, otherwise.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2015-02-16T20:02:34Z","timestamp":1424116954},{"_id":"96f0b64e-c3a7-36b9-a314-6d4ad627e652","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Well, for one thing, this post is a more general approach for \"async-local\" data. It *can* be used as a diagnostic causation-stack, but it can just as easily be used to store other contextual data (i.e., a kind of application-specific HttpContext).\r\n\r\nHowever, I did look into LogicalOperationStack when you commented, and it turns out that it does (correctly) use the logical call context, but it (incorrectly) uses a mutable stack. So it will not operate correctly when your code uses asynchronous concurrency (i.e., Task.WhenAll).","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"51403dc2-c17a-3cd6-8d09-40199c253938","date":"2015-02-17T02:05:27Z","timestamp":1424138727},{"_id":"00997df1-3ab5-3354-b786-a30fcf15c157","authorName":"i3arnon","authorEmailEncrypted":"kjXE/NdVKwRxA5XshaT5rDUyxOK9J/cJujtATosXbdhtMQIUhrHxI3xnk1i4H5sSQRWoeluv0S6PakBTauP/3R/ExMled9DBSyQ55ubzIrL/uq4FDNRr7uv33XaV/m3k3UzDROpg51iMTl2lwuo6mTMGsOn5gCo05TqdDskC5XEaNKlu49yeM1lHIVxjNESAtl8a18DegevnN7fbrU/tYXn/EN/TOuzx8Uims/y2mO9p910IB4RM+nq6NF9O3d+GaZR7RB2C+ttVndarpND7XtQdrE40JGLB/M5Bvm6SS7zxEZs9ZLMgf8XjgXwI5/chFHlCWvwWKVnGcMtbfoimVVHTE+nxspsyLiiKujwJUDrAbdCCGMHGOLXhRFkSR+3IGqT0GLiW4s6jq0VaGRdZQG6LleypKuC7DgSGukIL33YUM+xrC7DCI9D3Ng1SJyVhG3f/2SW+3sI/C5uy7alCqdWpVX2d+CU+goL1gQTRElMwtbQBpQoPZTWCX1eQbfTaVoVbgdkMz+2i2VIndTOgJbrMt2/nRyAB4dLjuC84ROHTgSgAj07YIo3nrhvY4sV5TQEPabe+gPkPgA0o9SFzHzyr85H62rxIkKPVz68rLjQQWH5pb/hgZmTN4NaZ47KNf1/cNqQl/Rg+xxXHD5gNYYefyFrhtTx71H82jLNXC0g=","authorEmailMD5":"0caa455bd74c1d9d10d2af49afa18228","authorUri":"http://www.i3arnon.com","authorUserId":"disqus:i3arnon","authorFallbackAvatar":"https://disqus.com/api/users/avatars/i3arnon.jpg","message":"Here's my explanation on why you cannot use LogicalOperationStack with async-await.  \r\nNot only in a concurrent environment.\r\n\r\n[http://stackoverflow.com/q/28769483/885318](http://stackoverflow.com/q/28769483/885318)","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"51403dc2-c17a-3cd6-8d09-40199c253938","date":"2015-05-08T18:47:56Z","timestamp":1431110876},{"_id":"a9df043f-f5e2-35df-bc30-5dc7cdf2c8b5","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I believe the new AsyncLocal<t> type does use LogicalSetData. The most performant alternative is always to pass the data explicitly - either in a member variable or as a method parameter. ASP.NET vNext always takes that approach; they are getting rid of their SynchronizationContext and avoiding implicit context completely.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"b54def21-e983-325a-b4a4-94d8683f29a2","date":"2015-06-04T12:12:09Z","timestamp":1433419929},{"_id":"b54def21-e983-325a-b4a4-94d8683f29a2","authorName":"katoa","authorEmailEncrypted":"lHA6Y4aoebHDPbKNKU/aPtwSD2YsR0/xgbN/DE3jPO+CtcxEa5MYVil09wqSyTJtWVxej3BK+uPfTOo1wW4pspk+O9M1eRaQP3fIn/ObpykaLNtrjOAtOzOwwvy0Gq2vo7QYfLlDdc75fio2Vn+WsfSuliWx4E1gdoQhbRgc79mBaHvJXTCEtrSrPNHmM13aRgMluJDplrB+KO8mTpHHyMZcikk4VPGAFiuAWRD6wfMFQnm+V4nOdSKbuzB6ynnFHB7A1HnPiCBMywHfw2jasGWZ6y1vRZo9uXXiOmhDhcqE7cF0oy6oTyfrvW5N3XTOXTfg8rxuSfy6m3PoZDKSH63yOMbwCVJCsdscyXtHohNkye7TYBkh7Ub8wJB+49/hMCeGtPYZvG/lixrk38BNa5V9dIm6lIML7lg4JwkEbryn3Zn9xKVDBZ1qfX/OcpNW3aa8g+boC7rc8SyBKAZmaAgo4SHplbIsiFSMD8h7sz92j9xu3BBmeqND3jVSh8SLsRT0pS+Tzz56qR8P3SJXibbfWll67iVPIuTECZ3VtiVyE7kJ5zXrgXYfF9aTogKfLRWS+VDuZNon31hhY59xlnjhF6JIo04MCNh3h0jQhLjbgO4PfXlAUsv9xEpo+fDZE8XMAzfwsTLP1u9kNyOWRitjOcjbpgjc5JBS8WmIHtQ=","authorEmailMD5":"9f514733cf89f11f8504fab9e4e17c2a","authorUri":"","authorUserId":"disqus:disqus_CbudhwIpVN","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_CbudhwIpVN.jpg","message":"How does the .NET 4.6 System.Threading.AsyncLocal<t> compare? Does it also use the slow CallContext.LogicalSetData? In an ASP.NET context, is the most performant alternative to store data across a logical async call stack still using HttpContext?","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2015-06-04T07:41:43Z","timestamp":1433403703},{"_id":"a3cdcf12-a70e-39c2-9b4f-eb274a41add9","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Only one name is needed. The name represents the conceptual \"slot\" for the asynchronous stack.\r\n\r\nIt's an autogenerated GUID to prevent collisions with any other use of the logical call context.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"fac51a1f-7b47-3227-bdcd-1aa07d75b1a0","date":"2015-08-06T14:34:36Z","timestamp":1438871676},{"_id":"fac51a1f-7b47-3227-bdcd-1aa07d75b1a0","authorName":"senj","authorEmailEncrypted":"unjh2jtD9gEKBsA1Vm7R1ifVEF2cs6jJoKPZx76a79+iEUY4/9eJwiAGpxWGtLZzERn3esgKebIsCad9/8NDyLa0O70to1T1ZpJTPQVbbSFpRC/R4wwaK9yiNoW93GpXnTsFQiRSK3NSN4O4hvaOHUog27SLa/yrHIyMIQfseqoUcSU++om5yy0SRDp53jE5DH9fhbFh+71zCChC2LlYuCPXqsIZB5/YcgZA8m/SMMrvcr1Xwe4w7ilJX7wuwCUO/ppEArZR41gteY3o2Q9VTRPLY7FvLwnQq/ueOWaEEbDzjDF8ph1a8Lt2XZRnnLLz7JAX0Ih1/mIuW+ZmIhzJ0DaouWcsDpqmqYcLfDC/J0oSyImFW4kmePGb8tLX+EGTlS1QKFllaIb3IJBdmYL6Qz9RUuOh5syOFKYwLW7ehpUObaJruf23v7pEy9WCiB3msRPDQXE2u2iTl1ZfnTYIp9yFQfcwfNHMictrpvKqB6Us8IBEW0lGGMmxhJmHoLTUew7HfEetlRRxfk+VfJU8GBF3pXL+nQxyiz48qrnaj3drwVijgPRxqiH+DfzDMBARXhadrL2t6XwK8NYvdNpggTIx7zCIOktCznAzHxAIR3bHznd+rMY4YrnPzUrhi0NDmnVf7cF1eYc4mrXL7Wsh62f1S/CA9FKfwH2tB/WcTzE=","authorEmailMD5":"7260d095ae3a0869f217e689864f94e7","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Why it is save to always use the same name for every concurrent request? ([asp.net](http://asp.net))\r\n\r\nprivate static readonly string name = Guid.NewGuid().ToString(\"N\");","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2015-08-06T08:09:26Z","timestamp":1438848566},{"_id":"1e6ec1e7-bf06-3e7f-a405-a6c6878d10e8","authorName":"Brent Arias","authorEmailEncrypted":"sF17uYMvdeXLavlXhBffJYiz8YfuL/wfYnqiLhHtAhSzW3KvVHWiPV6M5bpv3x6L8lANg9yxoF2gqq6M15ufwMABR9G7Koyadny1FtmkJlyc7/CQz1oGLPiLS5/7lZE1UJdldzWd7F8/70FsfOCZHGwCwokn84bgSvCVKl5GIIyVpICcQrM2U7OllHiUziiPkTiqKS5GvTnKHVjOiCXCzzReNPYUE+H7kwjC/3fFatMdZyLS2YMeHlRCjKKcFgThFwJ6ylPBA+VAojewesEWCFbLIJq5ZGaZM3hTMuo5J8LLH+hSXb4BdBTxo3HWufHGrcF0vVCfQqg2gQNi/Ep8QSepX5c+expYcjcwwsemH7Ig0ZdRhSPXkGp1HPdCZj1Cz9bHmINoI+PKpwec5v8YX1C1DgRsIF9gm52MESiEhbUy7ku+hqWvBKbvId7jm8WbW3ZgmD1BysjyFb4D5BNvv7kjTLZQZ37NIw4k4PiEuX3ttIsGfgNyTtg2OWJZMYMlrKM6SxaDnY2CfNCmBV/HXIW8F3wIDKGo41XrNkl9fXc2I6fmtf6XbDGLKnpviQgs91CwmsR3Z5Pfy9yA5+ULgnC2a4ZBi2Whm73qHcRVpCPcCR5YyGKrRsrKlKhEYhlwq451WTNs880Sga4lCxvkp2bM+UEvYN4g42xKLS2V25A=","authorEmailMD5":"0c0a1f54ab0a0911fd931ae5e19a5903","authorUri":"http://www.ariasamp.net/","authorUserId":"disqus:Mystagogue","authorFallbackAvatar":"","message":"Three problems. First you said \"you can end up sharing data two different ways: .NET before 4.5 did not have the copy-on-write behavior, and the copies are shallow.\" There is something missing or contradictory in that sentence. I think what you meant to say was \"you can end up sharing data two different ways: without copy-on-write before .NET 4.5 and with a shallow copy-on-write after .NET 4.0.\" Am I correct?  \r\nAnother problem is that your article seems to insist that .NET 4.5 copy-on-write is only active when using async/await keywords. In fact it appears to work with any form of multi-threading. For example, I built a .NET 4.0 test app (run on .NET 4.5) that merely uses Thread.QueueUserWorkItem in combination with CallContext and it achieves the same copy-on-write behavior.  \r\nA final problem is that your sample code makes no attempt to call CallContext.FreeNamedDataSlot(). As a consequence you obviously ran into the \"...not marked serializeable...\" exception when a thread was returned to the thread pool - which is presumably why you created the MarshalByRefObject \"Wrapper\". Unfortunately this means there are threads subsequently being dispatched from the ThreadPool with a dirty CallContext. I suspect it would be better to revise the design of the sample code so that (1) explicitly freeing the CallContext is an option and (2) the final Pop() which produces an empty stack will in fact free the CallContext slot entirely.  \r\nI'm interested in your feedback on all three of these suggestions.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2015-08-24T20:56:15Z","timestamp":1440449775},{"_id":"744fad73-022f-3c0f-849d-b8319b25a376","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"1) Yes, your interpretation is correct. The two ways are A) If you try this pre-.NET45, then you won't get copy-on-write, and B) If you mutate the data rather than overwrite it in .NET45 and newer.  \r\n2) I've never tried QUWI with regards to CallContext. The scope of this article is specifically around an async-local context.  \r\n3) No, I never saw that exception. The MBRO wrapper was added about a year after I wrote the original code, and was only added so that cross-domain access could work.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"1e6ec1e7-bf06-3e7f-a405-a6c6878d10e8","date":"2015-08-25T11:23:31Z","timestamp":1440501811},{"_id":"f8c8da03-f469-3dbf-9765-a9c5c1942c4a","authorName":"Funbit","authorEmailEncrypted":"P5eBq1hpeJ8AkZxnkm0qyqOt0acCQhV3Jx5IbpsWU/4hZOdk3+vmgLtjR/XZeqc710z4+UWeMnHzHKHYTbKC9vk2KWorK/ZzTPLVHwroGzhswbiejMCN1VWRyj2rw1vf+fb+gp3HtGm7lcpVzmSBFGZkGK6CWWokfoahUh3F54O18PeDo2yLjvw5YBm5Hf06YcScC9kj1mFPZdzAf9NPTVfSWq47jmoKVS6mB5Zd/k9V2InEB6F2q9f4JVnP8O6QBc+O4mN0Kn9hOvSJI82vWNTK7/SvDyqISrdcGU+UGZe/kAZ17dslfvkzfRmb3utPumYFPI3w73flSdLK/iuxyOcWfR1r/5BoXN3I+0pBqXFnLtHGT4rI6xIR9K+Ie1wcuyPi1CrZQ33A8SEDH3xGi+H+9/d4wnGCiVC5/XefT52aflLeG2cyEHGvEQ5oKP8v0dpFmh0eDBFc++YjhgoNHR9fMNhjBOrgXkimNpD7aOU2zYZwCDdEa7Ob6hBN3IARv+FiYG7bP3oF23UrGC0osGcfIVvC9BQV7FdUL1XYwN0hEg+gpgLgd6O5X2X1rAUfrxTu74BoIMMPSynw1YqxXZjP7x/Me9PAxx3ms5FfeIi1jAVfAgzlUURKFgLmJop7iQ70HbJ6tZt+kk7URBeUEx4rEkXuWYjuQjghB+PhQzU=","authorEmailMD5":"1b66f6609067719d158ee9e7187b1f3b","authorUri":"","authorUserId":"disqus:Funbit","authorFallbackAvatar":"","message":"I think Brent Arias was right. On my side that \"...not marked serializeable...\" exception throws when I try to call my managed C++ library from C# code with something left in the logical CallContext. I had to clear CallContext before the call and restore it back when I get result... Haven't found any other solution.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"744fad73-022f-3c0f-849d-b8319b25a376","date":"2015-10-01T05:28:14Z","timestamp":1443677294},{"_id":"445aefca-1ea4-374d-a00c-626bf0a05655","authorName":"Vitaly German","authorEmailEncrypted":"nPQxw2WCt6f8+uORkPC2D49V2153P100rMsWRQljSJw+OIlU3IikNTCO1YSs6f/MWMBoVLQmmcxUa3d4hLx59iywPS6684xvKa2CP1bSTOgl4gESBTFxfHDA7Fnu6CIN/yIpRiKfKfyv5AJN1OzMtVG9uco96hbYp6DsZZ/p4DbceLEx3J8mv38EKabz6IC9U9h+zKu5EKKEfJA5O1PxYuWsZe0gzo2+nlWEGtvuPMqS1fYiszYwl32x4ocMyaQtAxU01RqmETgtbLKNK8TTw7LVHG1Q2MLSphzs+MsbpOSNjteho5N5Pv+hLrgjk2OWlsUYyuPMyqymCrCRRH8oeAIbf+F3P8mglOEHPI3oSsXMlQ+e9RY0dTe0NJnLsewHCPmGwh6Vm+Fw9vya9ecPM+YXVgqrNelNGBfRLJJdbYzG/LTEoPt7Irr7fePwL+jtvHIY6yPquUjOODfLSINCFEJY8KiRP94ITM0F2hcN2dz7GaU8oMpqPZDjgkt1HIe8ViOwemZoDN3yOJFFNZ/RE7QRuSzZw+9d726y+mr/UJd4e7evDHt2EsTnDmx6W3tvg4rTrw3/1g9CPDeyV4zK1r1TMdH0qipcuUuDWOtVbX1A3DiBS9VE3fgRTd19lb+jc9I7UOdJdZ0z98sBDenPmNS03hCafAOGkDdbr4v6eQU=","authorEmailMD5":"90fe6ddcf6ea152316d4e236146a1cc4","authorUri":"","authorUserId":"disqus:vitalygerman","authorFallbackAvatar":"https://disqus.com/api/users/avatars/vitalygerman.jpg","message":"The real cause: CurrentContext.Pop() throws if empty. The was race condition on Dispose() and the exception was not expected.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"c9006c67-bb29-37ea-8ead-e1000085e44a","date":"2015-11-03T18:22:49Z","timestamp":1446574969},{"_id":"85cf54bc-ed72-3df2-8e64-187b258d2c29","authorName":"Jiho Han","authorEmailEncrypted":"f3DBoyriBD4imiHi47kR7rqHA8yjT0QWvMBcbFDAcgmuZlpAv5j/Jpw0no2z5AdqLIwd3qDQfwq6JB/2S3Pp+rF268Dqci6FNXWfy5fRA4LcczNJmGFBkaoQ1oTI6seQXShcxERdDhu6wPo+5qUbIDK9u2igOatOqV9cikSOBKZtv03ziyEFudvQ4PHCfzz+eMmIE2qyeicbEHcHBkdbbfGu9tMnuTCgfLzltTkVcNArwbVejB9bAZdNKs9fh6Pejca3HzPGURmmfFqzobYrTaszYbEQ9gROe/CJfqyfXy9b26s7br1612GefYpIYhdhv5bvtktG0mWq7Mj8D6OkGpeLM0BEiLUBXvTp/SSB8dZ2ikaIG0ZuKqwV8niveJ2XR7kBNsYIQqX51/eVBw8831x+irS6pZpg85E7LEv1EVvVMHQDoV/c0/4tFHlz6/iOJvV+VEe1pQEMSmeTbA/0bi8+mTHaTEaTwF1SmgoMIIvlUcElF86NcWotoDPJwLnrEuGidUFcGe6rN9HntJdXdgZmggEQLHKA9MUzIoDog/D87qzaCKuXOUPW8CaHF0zItNhzBlqvjWUiS6LEuVenoKLIRzoDVnZuF6xxIvty3kniDnzhZqHB0ZM2r6bGGR9u5Cfu9L++DIZbbAD5s76IWA9NFEzV2WnoTLx4KAoA0X0=","authorEmailMD5":"a54c971c6f96a72032c4d8ae77bd6619","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I've used LogicalCallContext for passing down context variables such as correlation ID (a guid) via ThreadPool.QueueUserWorkItem without issues on v2.  \r\nWhen you say that this copy-on-write behavior is new for v4.5 in the context of async/await only? Because I could have sworn this was already there for v2.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2015-11-03T16:13:00Z","timestamp":1446567180},{"_id":"c31dc117-0d09-3c0a-b946-238a937f7ae1","authorName":"Vitaly German","authorEmailEncrypted":"OAR/rk5hrfCVVBF6VmYDooUjqrRpudaWdlKOE7MAG0ohAQWV1IN31s8/S5BJukb3GmCohDaoyygEWvSJR7Qff6wO7jVHsz5lKe0eRKBE7RgK9sebPTxXgJ6jKF2Zp0v1QpeXmgW+V1JNxiWmKQhfDTtWK9bzY1t6AohfpWzOWbLK8/CzawX75YiigePeF6ughCFHrU+3ioaCpAHcUq7fF96nojnUeqAk47gnURWXHA33BajKRfCJont3AEc1rY2y5zEUi2Pz+8p76cGCgGmvBJw+8Ynf65x0TRdLspYJMGgKm7rma/snksGiIrlHUR0sPrXdx4LSqG18O/7ZDRf1TNH3laCZOrSdzrsUTr09Xe04pL2IGOH22K5EyskfN8y8shS2midJusWZ0TFi/bQddXpR8W+tKhPSy3QNaerCB2LSZnz773zZOougS9WGtx9Rn25y6wv7xh+YwPyCLL0+4GtFEvbyuInbByymFs25mirZmcCMGQBMg7sBa4PLWzfrENxN0pr2DjKLzzg4fAqC04Qut5MFrTl/M7TWQbvPLY6+v0OJpz4PQsdZX3RYzW/DLT0xRck3vg6t1NSfgpVyA4VQt9X0PATgs48Z+LslNzicUxqQkkGj7cORuH0gYJCOGTJjLzB78X5ecWMXGnuOQtnUjBGBO0Aw1nn5ybTFCrY=","authorEmailMD5":"90fe6ddcf6ea152316d4e236146a1cc4","authorUri":"","authorUserId":"disqus:vitalygerman","authorFallbackAvatar":"https://disqus.com/api/users/avatars/vitalygerman.jpg","message":"Thanks for the great post. This approach was used to create some equivalent of Nlog  \r\n${mdlc} and ${mdc} mixture.   \r\nThe first thing which disturbed me that LogicalContext is never freed in the given code. This code functions correctly on my Test environment but hangs forever on the Pop() when embedded into the production code.\r\n\r\nHere are the changes which resolve the issue:\r\n\r\n``  ","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2015-11-03T13:13:29Z","timestamp":1446556409},{"_id":"c9006c67-bb29-37ea-8ead-e1000085e44a","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I've never seen a *hang* with this code. That would indeed be very odd, and freeing the slot shouldn't resolve the hang. I suspect you're seeing some other issue.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"c31dc117-0d09-3c0a-b946-238a937f7ae1","date":"2015-11-03T13:23:44Z","timestamp":1446557024},{"_id":"ce93ce2d-aca0-360c-9639-94e89c430408","authorName":"Vitaly German","authorEmailEncrypted":"owjuf270mk52J1QUar9TWNEunSrpIHoLsnm9MWy+F/5hYudsGkly47/dEGtl2rrYzlliOO051evUTrgb/zhGrYqk/oBfV8vuDICOb9bm0teVM1lKEco62KUr2Wignl8ysivRIBXiFJ2kREYNmsPMdgdmLG/hpX9ZNkavkp/zU6KF6TH4JDQLf1hbzVItFwbatwJHn91dyjszK7LedyN1SrmlCwAcx4lckF+7euVkQJvd7D05XsW869j5S4j0DUxm4VTZOBnvvRqPDCLgR5RrhXCVnyCZxsLgQaJ2Tlc3BDR8wIOxirBYn6YdSoUPshv4Nm0S6YdPvCo4JvvaMKQsHOHtg5j910IoL0i+WyniBFmmNDdzJAb30aungB+EQ7SBtE8YGRgwgUn6CMXcL4MCFGf923in9ezU+QQTyuIw/CfXm590N5SmeYp92Jy1YCE/5IlLyAcnIf27uj01fzWjuy9+2OYWCTEZCHHEK6cl3aEu/nKCJOzVwAZ8Vhn6wnPo4HZXGD5Hp6s6W/jJY+g9qmebF3unu2kp3DE/r4qciL9UZQNPnl1sFswX9nO0/a9u7GA64lVUdx5GYkS2fsaCddzuwokdl2fqm4IX27Cwnv+EWeo5ljGtE+62f2XSITfCdDjUiIJ3NAM/1BxOA3KJ2lfsYxQgq31KRCfY4k9LhyU=","authorEmailMD5":"90fe6ddcf6ea152316d4e236146a1cc4","authorUri":"","authorUserId":"disqus:vitalygerman","authorFallbackAvatar":"https://disqus.com/api/users/avatars/vitalygerman.jpg","message":"Yes you're right. This changes were accidentally helpful until debug print code was not removed. So debugging further.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"c9006c67-bb29-37ea-8ead-e1000085e44a","date":"2015-11-03T14:48:27Z","timestamp":1446562107},{"_id":"fc18e7df-8fca-3e6f-8231-21357ac66ca5","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes. There's a difference between inheritance and copy-on-write.\r\n\r\nThe logical call context is always inherited across threads (this is what makes it the *logical* call context; the regular \"illogical\" call context does not cross threads). Technically, the data is shallow-copied. This happens every time the flow crosses threads.\r\n\r\nThis is different than copy-on-write behavior. With copy-on-write, every time the thread enters a method that cares about the call context (right now, this is just async methods), the copy-on-write flag is set. Then, *if* the call context is written to, then the data is shallow-copied. This is important for asynchronous fork/join scenarios, where it's quite possible that a single thread will handle every step of the process, but there are multiple asynchronous operations making progress concurrently.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"85cf54bc-ed72-3df2-8e64-187b258d2c29","date":"2015-11-03T18:00:55Z","timestamp":1446573655},{"_id":"2a3f60fe-02c7-3fd0-9628-826b1bdf89be","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I'm having a hard time visualizing what that code would look like. Could you post the smallest example showing the problem?","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"445aefca-1ea4-374d-a00c-626bf0a05655","date":"2015-11-04T13:39:33Z","timestamp":1446644373},{"_id":"cf5cceb1-faa5-3765-8822-e4538ce3cd29","authorName":"Jiho Han","authorEmailEncrypted":"BGkKI36Mgif1WpfPRx89ntJ1s4/tSyxXf7UBTjdFR6csXh7kLNw2H4k4f9AozySKj1s46CarH1FzAaHWL51Hs2/L8/Ew1uAiNOC7poWTjF+FwQGk7arr7TerXcpxGyNXG4yxGef2wa8OglsmGXDoppHEA+JkzjRbTQ4mUCkP1cOBzoFqM8XYmFlqzJWNmXdDgjq5m8IP8I08FBdEhVwncK+wuskhlPAai++rjnQm2Qvnof9Ykn2Y0C5SRX0rjNOwgBS7T2uuUDAiBFEj8k15uvEfUOLVjFRXKh1XuKC8zCvU9V9N0URgSUwS36yL9K6+1x6SVOku8i8nv8g8EL8OSbAfWTiwoI1gaZFa6ZiVvCLs9Hla6BJSeYRr1bwSR/0HQB4inhvx9Veh/szXWOrTV9sDsutB8sOuEzkBW1wBHqTIy9W9TdvON912i/BKFhZL8EgIawOgej5Ed60e4inVLwKwgV0tgGkxzMtUIB8wmofYxV0sxFLIRcIElrDwqiHQeWpBarshhkwZWdXJcWbZbfGC2+Ce+jHnruDy8yR9rGtRP/Fk6SvnAXo/mn+iNtJ8y3RFXr3E+rxGOLv0XcRTx1WJut6NrKOaa3YRfqdo2GZcA8XM5l8wEmtuFeu37ZFh5B3I+FP6WrwUqyXsg8UozD0ke4y1Vij0iuM4oVbxzg0=","authorEmailMD5":"a54c971c6f96a72032c4d8ae77bd6619","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Great, thanks for your clarification!","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"fc18e7df-8fca-3e6f-8231-21357ac66ca5","date":"2015-11-04T18:49:45Z","timestamp":1446662985},{"_id":"6880bde3-dedd-3380-9008-ccf286152920","authorName":"Mike-EEE","authorEmailEncrypted":"K+eJUJjRkYs3IkseQatUNPFUmJorDGdnJfiHS/r9SW5WF8Yw7VxZ8Ifo4nQiJHJKApGtZM27I3YQKIR1HkhqI2+/YswhFJ4uBhu8/5OkeUBxrX+ylgmj5G8yKgFVMouqHmkCaCT3oL4xtcT3nr2xxVe/hxw0ENGFsQazc96ZfTVjMIn2mBo/TPf5Bg0U0vrsFEDteqC/x+zh/TkmuMlhXjCcTbQ+VM/HqGFbcozt9Cbqq22fyXtuQrCyjaXbA4zoOoJx0ITkA31RMLC0do+370NlkWM6DnCGi41oDYA/6l1zDXGGV2aLBmS9T9Kaij/36CiqtPCK5chsuXkFxEAX+DHr5FnUihouO2cIfuXmRfiXEiVzxfNFV/x9Sphcjbunh3JLJHqXVWn12Gz938NRjBmpiVxoIxN3cjehMZD1LDpPNtlbPUV7lstTwj++VenTszcB66fQpy2q0gxXIzqdI6cJZNQZ/+C9RRrC20tzzx9tJJz2VqL8wO528fs9vuzdjcUi8EOkz6br8Nql9cBnWRVohhNo2SGuqvucI1eg7qds3FbZNuGKI71OOfvpJAudjIlsAbgh7CNAGiwWYIc9Sm7w1hLCffTS9erD5P1Yw2NQ4jB2LT+G45UcOYBa1iIkpeX6F4N2EJPA4DLdyPKQ3seZii7HKAlg7h/BnanJhe4=","authorEmailMD5":"c7ce3b7185ea065d529fa4447263ac60","authorUri":"http://blog.developers.win","authorUserId":"disqus:Mike_EEE","authorFallbackAvatar":"https://disqus.com/api/users/avatars/Mike_EEE.jpg","message":"I am learning TPL, perpetually, it seems. I have done some testing with your code (excellent article, Stephen, as always!) and it seems that the LogicalSet/GetData flows down to child tasks and not up or between sibling tasks. That is, if I comment out the line \"using (MyStack.Push(\"Main\"))\" the data works within each SomeWork task (\"1\" and \"2\") and their child tasks but not between them.\r\n\r\nIs there a way to pass data between sibling tasks and/or their parent tasks?","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2015-12-24T22:53:41Z","timestamp":1450997621},{"_id":"4cb22e67-ba28-3443-b83b-ad481fb0ef44","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"By \"explicit\", I mean you have to manage it yourself. Like pass an actual object instance around.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"617f966d-e383-3387-bc7e-3e2243efc33a","date":"2015-12-25T21:33:30Z","timestamp":1451079210},{"_id":"617f966d-e383-3387-bc7e-3e2243efc33a","authorName":"Mike-EEE","authorEmailEncrypted":"M1LbSaHf/dGp7xGhs4EnVuJ3CnLc3I20dkHF+L58/c8ukuSNuOB0yd12NTJel4ddfV+pIHaV1I3379pIPonAN4iQa4Ohb+yMXIvZY8T28nPErXQ+rQIMdQbl/6mKSaG3aGdG6Y/r7fxkJ2Dmczad9udcIz3LIaRWYqZxKxUKoFwfRou6ZwbqBtYOtF3+f1sOYGiqtKMyAZrcQo1gQnqv8TQEiilOkybtXzZ7+qhaYu54ZKk08E8DrL4AYShunS0mPUIS0L3dlkpztEuFsuRYmAN/1P/Z6pMN5yZPX4ytjlgsPUy0IXM/xcBU3B6ewL5TieyKr94+JA101tZY2LQ6LObv4ld1b/B+mq/1jbGI2jMDCut0szjY5cYzd4gNnQ+VcdN5eLMfrm9+qnnRaCqsIaMTzT//o5KbTMzx2LDe5rWvXa046gwQCvqSDPn2U3VUEkEkH8xwkee8djAoquQhb8aqSv3Ad2SHtdkCjbwcmW20mx0SZ0Y5kwf+uORQmTHRsO7nKxNbZQV5PF5XjhHypo5SlzN4qaxKBDvdaRMK2MdXC5fDnn8wsUiPTzqN5c9MDIktLC5qXXYbTL0eh87NIr+WGGAWSs1kmfeJRCXrjBROEk0mu/TVtjGnN2VLS/21SoGHMFvFGQsk6+WPcZxhbOUfcFlRG/nUMBWYhciS96k=","authorEmailMD5":"c7ce3b7185ea065d529fa4447263ac60","authorUri":"http://blog.developers.win","authorUserId":"disqus:Mike_EEE","authorFallbackAvatar":"https://disqus.com/api/users/avatars/Mike_EEE.jpg","message":"Awesome. Glad to see that I am not too crazy in my understanding then. When you say \"explicit\" can you give me some more details? Again TPL is a rough area for me and I have encountered more friction here in than any other .NET area since, well, SQL really. :P Is there a way to say \"store this data in the my parent's context\" from the child task? Happy Holidays, btw. B)","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"faadcb96-78ab-36d5-91e5-2f5b0730110f","date":"2015-12-25T10:03:23Z","timestamp":1451037803},{"_id":"7538685e-7435-34cf-8862-60033a1cefd4","authorName":"Mike-EEE","authorEmailEncrypted":"VGB76O92sq2O5D9EUBcFMIuJFm0U9bx/oTXP07JLcOY6vcowQbDCbOsjKKnbNPPhdXbmvj5aYbQ+j94vz0nEGNYB8gRd6e1snXkqZniXFM1Ky504AScefzdpDDUTwdM+qD179fo5vKzc+alJd3kzlJ7zT1XaE7YvKJ1wH7DgqbCYqauvw79OVktT5W+Rlqk68lI44mN9shIqTm8/G+zyV8P0WTKge/AIRb+U56eW2Oflca0hcRt0xYYwtgC+3ZMsSulydSl5e76ZM9uQ+Vevbp1M4lZk8i1hcLoFh9HjKNOsjHnIkOcsnwpB1eN68/H0Qou3XNX+FGDK8dm8A6EHy9lWPVc0v+r+E3+rj+wK2T13vtFf8LXmlnO8xB6wb3lUbYPmiIhbl2BvMO83bSyB7d7ewtYn20ZXjT4FU/LSAEy1URP5K97Ton/h6cMbzNaGtvQWzKCm7grf7NQgS/7vkMpWqkkW98MZ15VU7vX/bXtTY9ev6ykmlaPJxiIlg9vYMzN0gOGGer5lCrx9p3ca6bOx4QZjFwSA4ah/CMZk/m1PFy/96LjqH0oHIFjip3jZ+kfYOKxuNTZHiNZXpeZMAqtLHl0ergTFDxqaXz79Z8TAy/bdiLA7vg+82O78O216JRq5VCCZQgzSKeJ9PD9SM2R/xmUr2Zk7n94Cu+amHn4=","authorEmailMD5":"c7ce3b7185ea065d529fa4447263ac60","authorUri":"http://blog.developers.win","authorUserId":"disqus:Mike_EEE","authorFallbackAvatar":"https://disqus.com/api/users/avatars/Mike_EEE.jpg","message":"Bummer, that's what I ended up doing. It is obviously a hassle and not as elegant as storing values in an implicit/ambient way. Thank you for taking the time to answer questions on your blog, on Christmas, no less!","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"4cb22e67-ba28-3443-b83b-ad481fb0ef44","date":"2015-12-25T21:36:28Z","timestamp":1451079388},{"_id":"faadcb96-78ab-36d5-91e5-2f5b0730110f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, the data flow is one-way (parent to child). Any other data sharing has to be explicit.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"6880bde3-dedd-3380-9008-ccf286152920","date":"2015-12-25T02:19:36Z","timestamp":1451009976},{"_id":"520e98ef-c089-3430-b83e-42a3accd03d5","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"It's up to Microsoft to decide whether the LogicalCallContext flows to timer callbacks. I don't control this.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"72e33be5-bfb2-3e07-ad2f-f94706f544a0","date":"2016-01-14T19:07:46Z","timestamp":1452798466},{"_id":"72e33be5-bfb2-3e07-ad2f-f94706f544a0","authorName":"Andrey Tomilin","authorEmailEncrypted":"TP7HKw9Owwel5cKiEUGDVqFocYmLZ3DmkJnxjDqd6zxhh5nylWsw3cl4hSdYaFoKPIXTuBi30l67QaZr8ZWlQR1D+FnEOXMLw5+Z0u/hhtxesnGQ7eYnl1C/1p9ckCpT1JlZGDv+ptSd0o0iPbl5QBmtaPlgd31+zgWn5uzW1Q618F3YTMMtspCgD37+1yvxeIiYCxSlKwS0ufZSBb41z4ZRDD0+ND55/vRDiPnZ2H6EbDzBJ7QsrDzcu7ZGCX1AKe1bfBwdnHJp01CfA2EE45YRrbbsZhb4AihVcaP7eZwPr+UvZo6IHFmp7Oe94QCWlHBGEiQydPp9seC38XY+09Q4uJXgpFBY6dtf3ENxBP4GB1N4ctF6tM8YM42DKUemzvMkkOBtrzFBI/3Q3uPAqEivGAjGBie2bHYz0wOb9FaQRolEQi8QZia06J+GI13aUECRVpvQSa77SP3OZAb3GM856/+Mb+Nsr68tzqN3PS+ORVXyoS8izkOAr1wlLp368XeVhi29/IDu1jWyq2zpd66CVmMSNSFGncnVbj+ApANsBBblymJmhQXuOwYvJOrgeMUorRkP0S99dooUsDgVZWTKCwkWamxEV6QZkqpATR9RF/NfRHvgzZXqn2THJ81K+WNARxwjB3Fwn5jAeEkDSIRkKGh0Rbhc31CysL8qf/g=","authorEmailMD5":"40ff0d4f17fee6de6426c55a6e96a45d","authorUri":"","authorUserId":"disqus:andrey_tomilin","authorFallbackAvatar":"","message":"Hi,  \r\nLooks that there is still a problem when using timers. The below code show it when creating the _timer inside the 'using'. But the problem disappears when moving the _timer stuff out of the 'using'\r\n\r\n using (MyStack.Push(\"Main\"))  \r\n {  \r\n _timer = new Timers.Timer(5000);  \r\n _timer.Elapsed += OnTimer;  \r\n }\r\n\r\n...  \r\nvoid OnTimer(object sender, ElapsedEventArgs e)  \r\n{  \r\n using (MyStack.Push(\"OnTimer\"))  \r\n {  \r\n // MyStack.CurrentStack here will 'Main OnTimer' instead of just 'OnTimer'  \r\n }  \r\n}","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2016-01-14T11:49:11Z","timestamp":1452772151},{"_id":"05345944-87eb-310c-a2d5-4b40303d25b2","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I'm not familiar with timers, but most of the MS code that schedules work follows a similar pattern: they capture the execution context, and later use that to execute the user delegate.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"9e9623bf-a772-3738-8f33-26ae49c319ce","date":"2016-01-17T17:26:42Z","timestamp":1453051602},{"_id":"9e9623bf-a772-3738-8f33-26ae49c319ce","authorName":"Andrey Tomilin","authorEmailEncrypted":"I8CwGl1IPbv+/CYSHDqLOGW+Y47W4M0qCp9+gH0PCRZZ8Tem/l8lwxDBlffpdNATJlQQkM5BYrtu8xGm1/xPvdw5xinreC+AubW++qxOi4wOed61frPRGwgXOnL0U1n3Onf40CTYQAgcOnLa9O75/Mh5AgiqdxfpM2a+v4AoRYUWs+ZUwIO2V2x0kbUmfCE8BbMOXuz1TsVgwRzbvjjdq15SMA48JC6bRM9auY6WTbog19A4ozJwfn4p7fazk2ZQ0TaZKsVJQcGtWSYyiP0EA2YsuU0LVQI2edD5XONhr1XKat0ig5UT+8+KjW+WBrQdZKhTgJM39QqmToEISj7pxyATDP3NnGzM+wGsNSnIG8SPyK/A0nzNcpKS+noP6/Khi3z1Sv5YOqTn7Mu1CXUb5cOwq5rAK4d5QHxyAFeALh1CSY/OKb0m+kjn7S3OI69uCIzlQ+GGmCBL9+rc+OuNuF+70jYYWcwny6DWSfiICN0iIEqhCSPc88g1i+InkKUu+Ww+EkTOOMqYGQS2fYZx3JxbSUK7vPKzS6RXjfmxwa67ye+9c2YaxmPenGBoOGTdmrSPkrZJQFv+OgtrceVgJtIU/s0IKrtAqu9ljPsYfq2GpWbAefw+H+mbFaiVBy63G3B0x2kOTr67b6mj5P955sCivtZUccy4PC7Gw7K7OzA=","authorEmailMD5":"40ff0d4f17fee6de6426c55a6e96a45d","authorUri":"","authorUserId":"disqus:andrey_tomilin","authorFallbackAvatar":"","message":"Thanks for a quick answer.   \r\nDo you know to explain this behavior? At what point timer gets a data from the original CallContext? I tried to search Timer's source (via reflector), but didn't find anything that somehow relates to this logic","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"520e98ef-c089-3430-b83e-42a3accd03d5","date":"2016-01-17T07:54:49Z","timestamp":1453017289},{"_id":"cad9afc8-548e-3241-b259-113ffb158fae","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"AsyncLocal is quite new. If you want additional functionality, I'd hit up @aarnott or @davkean on Twitter - if they didn't write it themselves, at least they'd know who did.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"d4ffbce9-e355-3aa0-ae4e-55e80ce31b74","date":"2016-02-28T13:42:05Z","timestamp":1456666925},{"_id":"d4ffbce9-e355-3aa0-ae4e-55e80ce31b74","authorName":"Pavel Voronin","authorEmailEncrypted":"psFGq7y4LFp5t408YuSxBEeK8dfXDH2cA+YV7UZrBeFVE5TMDbh7ZgdAs9kv93GClzYypGJaAeBXwVnakYOHmr2ZVmd9TbQF1aILJwPuHkVSfkMr9qb+1ReZ1eGWwZFrnbhbWy15yA5wgaPz3YSL8LzwhhNIhfqApQpSbSNcy742GMkQtG4jkirzNAXvNS9CKO+hj1TOq7L5WYRR1rpybCHWgdG0QOkxk7agggWWY+o3Vo/Ar09B9XUcqWy4Y1G9gEat6uJDh9MQxI3kmbG4yBLRssKVWG+wYKAMTS5g+pa7pCTLJ3H1ZRVLn4JzG0/qMLB1YDLwQTc1Eymqa+QuZ8pvGTXxYaXCnEgdB3TJpC5T9QolEM15RWZsdZJVbk/Be/RVFd0GuNxsr7hZAe8HZ50GtUhQwX7XVAydqYbk09ke4El+vQiH2QoRUG4sNqhanGg0JN8xnK4aLU33sviWR7YtXwCYqR22AdtQk6dgEkb0BlwxGFQHzP+k78RJkVtkokqQHRq1obodT+4EpPuIl/h8VNonDI9kA2UaLy29SSNN6FZqk0+J0CBxxHhb5eZtdXXgJRariNNa5jPOQ+CxlJVfvWK/JVCks2RwbEko2XPqmSdjqa/sbWPJAnUL0k+ZKf5A2ETGyn7lEF21K30JptQlI0RLmmaZGU4a19I5KDU=","authorEmailMD5":"b0455ce24e84a5cf7ba132bc7cb8cc2a","authorUri":"","authorUserId":"disqus:voroninp","authorFallbackAvatar":"https://disqus.com/api/users/avatars/voroninp.jpg","message":"What is a bit disappointing with AsyncLocal is the lack of the property to check whether Value was ever set.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"a9df043f-f5e2-35df-bc30-5dc7cdf2c8b5","date":"2016-02-28T12:59:33Z","timestamp":1456664373},{"_id":"8b140248-1961-3090-a548-545c105adbe2","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, it is available on .NET 4.5 and newer.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"f5638a9d-79cc-3fb3-9fe5-3c38592c6900","date":"2016-05-28T14:35:00Z","timestamp":1464446100},{"_id":"f5638a9d-79cc-3fb3-9fe5-3c38592c6900","authorName":"David Mack","authorEmailEncrypted":"TTPA/PomWt68vUuf2emhR45+OHE+T6SrpwOG/OPx42rBCZgffbK4zhqhPJQ01PlQJvxTDZ11Yu+oWI9jAfvqTlQx3cvpmqLXxUy4XIrlwSDnKInLmmcB435pKMY+uqMhDcrTz9jJEnH5YNVpgiRwrqi2YmzRIvP+WKoBSLCOTqln9tIfWv0tOWGyHmLjXXYmkT6Tk3EI1/vqeWN+8erIUNdkb9j7mSct/ELnHEfLaoroTUzVKe7j7lu/5vTTC0tiBcdI3sFtJ+xzO4mz7jQxUiBfVCV0PmOcp/Ou9mRcaEYo4Ntus8gt3LM5mZzbmD2E+IL7IE4144k08NbBnCe9KFJRIfTo9IlBTfyLJpjzMnr3hjWXfXgyETxV+1w6fM0uQrrBtc/BQ20NIDIgSI8OHvYDpaE0OwXEdCwjc889/82kE0QW8wDd6sjJ22rRdl7fdR1h1aJoUNXMmK2UNe06wapRxeIa9scvgFzK7V0TBjTAiF6igE/VXtkAMx5pt/BaQ7bpsyXXL0b11kCBAv4gg4MEdd6GN4uxx5fRLxro3XNdIezgXEslPAuubA1co3hs2ikBNbUHGgYdXaplMhKtmLyMZqil+3U1QIhXE6hNjFpKTFCAs2o2Hle2fZTJKHW7ETWPgzREPCTukrtZlezQ1Q6CqYSVinTKS6m2CanjI4E=","authorEmailMD5":"822a8fd97d95688a122b5d3fa367dbaf","authorUri":"","authorUserId":"disqus:disqus_fZvw93ZFh1","authorFallbackAvatar":"","message":"You say that \"Note: the copy-on-write behavior of logical call contexts is only available on .NET 4.5.\".  \r\nShould this now be \"Note: the copy-on-write behavior of logical call contexts is only available _*as of*_ .NET 4.5.\"?  \r\n(i.e isn't this behaviour available in later .Net versions?).","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2016-05-28T08:38:39Z","timestamp":1464424719},{"_id":"7d31d0ab-c611-3328-9c85-922fc08f219d","authorName":"Ohad Schneider","authorEmailEncrypted":"MtZj4hLiqRf/epDufVOCW/UcmzO6NeOo2GAvrOa3ieq803Sa/FVLR8rWVkpoQZStMZZcYaZCWbbr1ZPdZJkf5VSqIT02qXfuA3JXWEd7ITTQeuOUDpinCPFuqePfhEeNx6lB4CLzZn2FQ00NhcS2g4J/WyTnxUN5xGqCsPjOfz+dl5QioQcwoUbJDpae+UrTd/lad6b6woVGI3m5BJromHggYip+WrRunApl2SlzzRBIfmoRlxKb/pZMXAB6Kvnv7gD+C8UsoTgLdJqh03FKvPlf1ictBDn3VaGaD6BhaIJ4M4UiGztpHF1UcXmbFlVnjCPzfx3bDM2oXBQSHsM3UcLxNPxzcM6EQ1f06XlA/CGseun9lZZTBVD5QQ7iFKWLAMqDKNGGkWOB6L6n7u9cTme0dmR2cNofw7FzPuS0NSft2RCzuxH/4/7g5wbAd7EzSgYt37DI12Wx2XPJjz7kkvXgI+qyQRBawcU9Dqhsx07lSAqr2MV1QBBHRJQT4X4kI7wonZpchoOyMicrrQJxTYCyue5b4gzt8w5bS9fQLmBhuGxpfUBdynNqE7BbRLHh6lwLmlOEvmaMfw56jlyCKeDejdnViJRoAmsrQiz1bMlZtbvGLJUpLY5NME/kALTsd4FIp0BGQCGSefCJ5piD56YhJ55LYkbRMdANfHRTgEQ=","authorEmailMD5":"cacacd08cdb74729cd4a964ced03f62a","authorUri":"https://www.ohadsoft.com/","authorUserId":"disqus:ohadschneider","authorFallbackAvatar":"https://disqus.com/api/users/avatars/ohadschneider.jpg","message":"In this sample it seems Pop() is a bit meaningless, as the popped execution context is never observed by anyone. In each case, before Pop() is called, the caller has already captured the logical context he'll have his continuation run on (or in the case of Main, it's going to get its original logical context anyway)...","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2017-08-12T22:57:22Z","timestamp":1502578642},{"_id":"840b1b8d-438d-3bf2-bfb1-ae6d81c8bf1d","authorName":"Ohad Schneider","authorEmailEncrypted":"COGmAXIxscay+n5PZ+C5Y34ue58fwdKQMfKm5yoy5kh5CZT+O69JWfZWrr2FDxkT8HK2+AgkmrSrLnRN3SmnQce3KuGDHnvcuFyiVUCdhuy+06xRWm4qlmT3p0sSqqv04xY++DQrvKUNgDkIR7fq/Z3N+uWzraVhVJZKrjYlkxNq0vAnWd/U4ATQjSanJiS+YwIxGyO9xAyGNIZETbHQb3EOkF/JDaeCxlKrGHLvrkbAJkTm5Ho0EMsZXgXB7sZt/okYFRZkHUurV26+uUElPLa8bU2KNdiawz/Y+7A5LQ98IdmSlzW4+TD/nOx4wK7636ZY1IDJzXgyhERZy0Tbwd/Hn1EEvZE59sZ6A2hfnaazAu2YH+sec3ygq5PYyQgl1sEvIuXsO+fPKMN48g9bNcsEMeMA+ddr/l/196g3rovtGdEhxgWU+8CAihvetdg+REozmT8j2cbsKwnUuvD81nPCKc1jK50asuN0YAAhYqRKtqm5UStIqK3258Qv69G9Ehvtw+iAkPDTVEdI2h4SDTdLbZQxuI40ij3bvEMwsD84LU2hpCFsgPsUyKbcrfUdTCxXPbPDblscaO1c1DhMtm4Gr3Mlkr78NI9H2mi9iJEAhl7PslepdMHKo+o6Zenm8uTIrEQAvyAjLIB+Vhkn7e/DB0Xzh15dQLIqtR3l+Vo=","authorEmailMD5":"cacacd08cdb74729cd4a964ced03f62a","authorUri":"https://www.ohadsoft.com/","authorUserId":"disqus:ohadschneider","authorFallbackAvatar":"https://disqus.com/api/users/avatars/ohadschneider.jpg","message":"And just before the async method exits, it reinstates the original logical context right?  \r\n (so that the caller is oblivious to any changes that were made in the synchronous portion of the async method it just called)","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"fc18e7df-8fca-3e6f-8231-21357ac66ca5","date":"2017-08-12T22:44:37Z","timestamp":1502577877},{"_id":"421b7a73-d1c0-3012-80f3-fc62e80e6a18","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, Pop is meaningless *if* all methods are async. The example code here formed the basis of my AsyncDiagnostics library, which tracked both synchronous and asynchronous methods, and requires the use of Pop.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"7d31d0ab-c611-3328-9c85-922fc08f219d","date":"2017-08-14T20:04:55Z","timestamp":1502741095},{"_id":"ea9d0fa3-f5ff-36f8-a66e-b999c92ef082","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, the caller won't see the changes in the scenario you describe.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"840b1b8d-438d-3bf2-bfb1-ae6d81c8bf1d","date":"2017-08-14T19:48:13Z","timestamp":1502740093},{"_id":"3570db9c-8df0-345f-95bc-af4053ad7086","authorName":"Ohad Schneider","authorEmailEncrypted":"KzRKTFGQVwq0Vsvu7BAWrEI0+lGS1fvntYy8jJS4jqqxJRQEtKOPd6tva1Z5+JvoOtXXL7lBTi1o6q8+Ajxzo3w5U2ic21HRga6ihwYJC3uS1iCxGVffzHpMV3kFHirLi42hzHUoAw2af7py9RaiRnM7owWuMD1b+vAU85okLHdBNmPBwyEdOxUnqhtFZsOKlHfUwnI53r5dYosK+He6kGJ/oXz0kOOC3l6n5zWAl/qG6hTxzkFs+Zq8h9f4CJzu3I6cABon0K9PAzpv/G4omure/qGirqf8amhvy+vtnGZSfjP08XEfRtfVmEHu6OEKv53TJh/9DU48NyWjUbqiVBQe6HC0+Kf6NVR5KbZN6J/Y8BBbOvl42MHRfXUXCSyJpGHkPBkQWiGlhP6MDZRMkwXlmz7svLY8d25WoJWoxewoARVrNhUhTTFfysQSjWpSGRWdFX+oR4xZ6HhwDsN+4U3Fk0GYT4KMtmgZ7Hjw25Dz9GsraCu50RphM+Tl8PGKYL3vdiOQ1UMY8kKs0q6sj0+JZKqTN6VRhulH4vEwvctlg33jv9f8tk0cG4ltIrZI0EqlbGExTwu6Zb9hjY+tLx4O2+0WKUQEuieM9zdkXnPS7gORjO+jqQ0pq6ZsZawsa28DyJvTZYmNFKgR9L1YEwLdtYobB3C7P4dHTN7HKbg=","authorEmailMD5":"cacacd08cdb74729cd4a964ced03f62a","authorUri":"https://www.ohadsoft.com/","authorUserId":"disqus:ohadschneider","authorFallbackAvatar":"https://disqus.com/api/users/avatars/ohadschneider.jpg","message":"Cool. Small nitpick, saying it's meaningless if all methods are async is a bit misleading as an async method could still contain code like `using (MyStack.Push(stackName)) {Log(\"foo\");} Log(\"Bar\");` (where the second Bar is outside of the using statement).","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"421b7a73-d1c0-3012-80f3-fc62e80e6a18","date":"2017-08-15T09:35:59Z","timestamp":1502789759},{"_id":"7f86f66a-8820-33ff-a875-f2eb6fa68fae","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, that's true as well.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"3570db9c-8df0-345f-95bc-af4053ad7086","date":"2017-08-15T14:32:37Z","timestamp":1502807557},{"_id":"8e4702fc-7ed2-3fbf-a79f-13ae3a0c23b5","authorName":"Keith","authorEmailEncrypted":"L6neEyNLGDU1WuXnJtM1ql64uZ3ziWIrhiS7Ln9n9rrJ/RzZiMyT5Mtyg7vJ5eebgpgG7Rfvpxpub6YS6hkZeLzAgyOGB56yMCGw/9PGYmSOhvPKmcKbPFzKbs5lBsOcVxo28hIS9jzixjlOGfyDjN4VgiklILJcevYC2YcJ1kneiGDjrqk0ZhMPYTks32ob5zKzim897rjiKdMc7XWQL28oZHb+NGVklaQJWGe9kDYPAM271/9+fhuHVv7GKzOgXvUSaNIZ5gI1ohuaVmxwSiRGL5VKRBfX4rRyE3Kt6WEB/tJPGUqFL/ClvI0CfSl4D4VXc2CVup+SpQuUDmSSg41Dkkr0YO3IQw5kMsIiALIxLJ3h/duJMe1ZzD7E38a8AxM3zj2Vc1/8Zr+fyIWCua0Cx74OHrcCxkTbBv9WF20+TZxiUJ8SG1YDgIhWFORPKNbB9HJw9fS0o+XFK6VSxxh+SKNC6pC4HihZPKe3W7XHzhTsGXdeSXdyvtDGUc6OiAG4uQwgzpbvJbQ4LJH7G5TCk/Pf5CsHu+r5tdhpVPKKlMcQjB8Y1EjByf2X+OXDJ3gwh1tFyxfzsBMridOiiUvSs8e071IpPwu5D4BMqC4hFcuVM86C5ZaqEyL9C+TqkRKlqn3ET5qa+W/I2GZSKQNUFAqWB6fnrvBV6Aj1Shg=","authorEmailMD5":"59db4d88b2556b61744ad1a41143e149","authorUri":"","authorUserId":"disqus:KeithLRobertson1","authorFallbackAvatar":"https://disqus.com/api/users/avatars/KeithLRobertson1.jpg","message":">you cant opt-out of the logical call context  \r\nActually, you can with ExecutionContext.SuppressFlow(). Probably shouldn't though. With the thread pool scheduler, you end up storing data in the pool thread's context which remains there as it goes back into and out of the pool!","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2018-01-19T23:02:09Z","timestamp":1516402929},{"_id":"61f24610-152d-11e9-82d7-0bb39bf6d207","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"b7d71cb0-1517-11e9-82d7-0bb39bf6d207","authorEmailEncrypted":"WDL0nvV+x/IzumpeuDTerfS8sVrcXiPyA+LPoTk26jX9WPETzymd6aUROzu2VTOByMctwOqKOxEQrhZkOyaN+POlLTUcMTF2b5D6hGNuJX/AVokCkjXLLr9KEdvAZAyVg79dazB63bcIL8Tjgy3hT5tfYI4shebQq4S6IGTkUhtEnpAMNHiFEPztrW73R/fbHCgkJIYpMarBWjG3Jt5xmgOxeT+2SGY5/gTfoo4Y5qjns/x6ZB4MCq35rEE94qBET8a/UKPpL0hEbc1i5IcL7gdXOPjF9OhX3qUhs0yryjLTO5xTw8HO69BsJZP44R89dsWC9EJwD/01QSwpx5benW5rf9+glRi2t9cpPmWvjSFzn93hqSlUBJGGcATW+iOxQcdg6PuGTLronbwQNIay9Nhyx+IhEMW/4c1M9EyTaSQG4vnmfJn+aLAdh3sq1brUKYed7uer6XdrEc5IZJalzxlVVG+etpM/PyfvCceYYCgI7cZRSYbHpXDMhBlGYGbSamj9ATDR/kdnlYDLVZuP/5N30TF0AGhU4NAtdGujxpNKX+xizzI8Fsta94GDW0aQmILDdX7Z0UAT8XKrUOHfCQVRuXZaUbQy1jqt15FSpfQQ4Tyh6frsGk/mHhfRHoYsc6iGCrWmrFLinzRC+FL9aZSDSwbTsTWT/R0bQm/gYYA=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I suspect that this is due to this:\r\n\r\n> The code uses tasks, but no async/await.\r\n\r\nFor the implicit async context to actually work, at some point you have to establish a copy-on-write scope. In the `async` world, this is handled by the `async` keyword itself; the compiler-generated state machine establishes a copy-on-write scope at the beginning of every `async` method. I *expect* that xUnit's test runner does not call your code from an `async` method, and since all your tests are synchronous, they would all be sharing the same scope. That is, assuming your `AsyncLocal<ConcurrentDictionary<..>>` is a static instance, which seems likely.\r\n\r\nOne way to test this is to make your unit tests `async` (you don't have to use `await`), and see if that clears up the problem.\r\n\r\nIf that doesn't clear it up, try to create a minimal repro and open an issue with the xUnit team (or post on Stack Overflow) and send me a link to it.","date":"2019-01-10T23:13:47.747Z"},{"_id":"b7d71cb0-1517-11e9-82d7-0bb39bf6d207","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"","authorEmailEncrypted":"n8NA/hgR8l+giWefVNwCCdfP157UpuE1QArk2pBaxyLmUrUGBQYiMebOS4XGmFrSBoDDvVFjbOiX6NTFeqWC9b71qZNpJ5DsCaAFu1cQsUII+xVBkSW5Mi4R/hlZoweHDAnbZ1nFtsPlrmxI65gmstMmab7vPN/lo5KtqIKzhbSrQDfjWSy1s4V1kRK1/mh9p3bYZaR9Pe58DcS98tvyahUx6PTgkczA0ccwBPwh5BY9fxkr1LUe0FKNESIew7VGzoePLTyAiCgtY0I6jszInJ86nKsT9+9aJPMtWCWEwLBpmhlenAyvZoCbdJsULzxGisKSkRTLi6gXPGdT6e9ZfCJ94R6l4tq8jIi7M8B4/0M7mGu8qJ7pJYI6uU88AZoj/77VNMKRvP7sJng2X1lK3IQwqxRrMl+b1Z78+nlKa2i0LVsZzeEsM7vBtKPaYBAvNzrfy0OaC8YKVrjJwajIDBot3t8VDYzbuJidQiFfA/WnWv7/PzuVrk72ayi3IshccRmnXujj3ZboD3llIvVeckhSPfWVJfu6ZNurExyUXPZU4RZVXtR7Lu9zuLjG6orEtuOabyDh0uql4qS1yvmCHPaUQP9moow53JSsTl2cJ7FaHcji5n8JfqKzD3O/GFWoYmsf56/xugJBOLnQHBFOqrGlBwcPNx3vlJFSCJOiCR4=","authorEmailMD5":"1f5c48763ae2b49cf16d86d4a99ba878","authorName":"Manaus Lavens","authorUri":"","message":"Hi Stephen,\r\n\r\nThanks for your interesting post. \r\nI am having an issue where I am using a concurrent dictionary stored in the logical call context that keeps track of my registered instances.\r\n\r\nFor each unit test, ( I am using XUnit), I register my instances in this concurrent dictionary. The code uses tasks, but no async/await. \r\n\r\nApparently, 1 out of 10 times, it seems my dictionary loses some registered instances. (The act part does not seem to find the previously registered instance in the arragnge part).\r\n\r\nDo you have an idea why this is occuring? You state that you may only store immutable data, could this be the reason as my concurrent dictionary is not immutable?\r\n\r\nThanks a lot!","date":"2019-01-10T20:38:42.948Z"},{"_id":"5abb6be0-1575-11e9-adf4-89bb71bd4aff","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"61f24610-152d-11e9-82d7-0bb39bf6d207","authorEmailEncrypted":"Qq+dQJs+805SBW1v1TiT6MkxlGC3e8x5j9iAEXHlua6tl+T+Ve5pmr8TAc8aNP46ms1duE1JjI2opD1a3vZsdNN+A8lRnUY+JPDwSdl6FWWJMqdPx4irGiY3SHwYYNnt4wtmogsUXpApULPUHjWunYc0i6LRGrbb+OTjkkVMS2kwwFQCgQyuE44yngLEFeyl102WrnjijG8u5YhTQPF7ANzJ+IGb5z+YQuWgJ8Si8gN8TnANHww25A7UTilLoVmg/FcU1+sNiLnOyN1Cu44/vhASV7qqgD+iu//VjqyQNul5XMiMzDGZX68gp6L0CHyGdOxnItDyunKCf6n0X7EL75rWnDvNPlJsOz9glQV40qqtcHOt9Q4v9R95bz280ATbEbEO1YohNjHG5WjJLV3gb+YR9W8EuU0p2i6RZJowViP/DQOaceRkYlYnywfTTrnyl6CdvylbwW+f8KC/CpddSZTe5t2MHEh6fgrP+ZJJb/HsJtkewJkHS5+aehj/Jy5K2RsNtwQqCRkLGesY3Rg+0l+KxrkggBXuWZ/YCyGRDOjq79yuxRAHAZX6tUz1pzWr3R8VZyllWlL30rQ7jDWeE2WckrrC0f9DtQuGA8VMDEYS9UGGhGj3jIjrnQhD8s/e/kL7hMSeV9yE13JN6eH1NhuLBUS3jFwV03V3sxUjIBs=","authorEmailMD5":"1f5c48763ae2b49cf16d86d4a99ba878","authorName":"Manaus Lavens","authorUri":"","message":"Thanks for your reply Stephen.\r\n\r\nI am looking into the XUnit SDK and it seems that tests are run with async/await.\r\nSee the following class: https://github.com/xunit/xunit/blob/9d10262a3694bb099ddd783d735aba2a7aac759d/src/xunit.execution/Sdk/Frameworks/Runners/TestMethodRunner.cs\r\n\r\nI have opened a ticket with a pseudo code alike sample which describes my problem. \r\nhttps://github.com/xunit/xunit/issues/1880\r\nIf you would like to have a real repro project, I will try to assemble it today.","date":"2019-01-11T07:48:59.480Z"},{"_id":"e00d5120-15af-11e9-adf4-89bb71bd4aff","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"5abb6be0-1575-11e9-adf4-89bb71bd4aff","authorEmailEncrypted":"JGc1HSysusR3VOApeq6B8oJsyXaaXAwoplrOc8GvKeIYA85Y9WX3dQyrZfRaOE9k1y9lEGlkevJtg/dSlLLJE/X/OPnjLEdTY8cX8W1sHahWa+yx8lrdYgAT/mG2Sidt0dHt3sfNYPi38vIGovSn6OAUj/kbzNKwrVbaPaZKZiYSrGKMMGfT4E6csXSkOOKU14ePghrcz7ENx2JTYat41oPdWjmpMh4pJztHMtc7X9LU/DEzPYLwZOKQER2OZELOC9VJcZjY+QVKTfvgevUTe5b5NFMqMsz9nVHq10Zy3WLq5Glzm3qCbPxxW9LdqOvJ9CDvjERIUv7udFJH679zkgrhhwsFYzJPmir7RtTu66vl4mDb3i0g8pLsfk37n3FCe9DCYEd4APg+wUjUzLbTYtGobm2e9h47XjzeXay7XFIv2BQyWpepvaIfakDkVJyoTciSHTzAuuKJzERGKxYfRmOUT0rAtxRJZGhSmGS5LE57an/i1FqnirNbtuaSAxS+eOKsS3LQXVaMNY3Z6gxaJoMwOLHAo5GJyfADDDjhRMHoXasdvLd04AE6Saw/NuZOnSqP8t3cb6dn8vegziQB7eF/wZ//xwGNd+PR/6GFJKF/YqHcdYX3RDW0sYhHNq+ilr8BGvu3EyIU0SxgvSWqk+Heb/Ey+3zhQ7CMfhuMnEs=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I think we'll need a minimal repro for that case. This is too complex to solve by guessing what the details are.","date":"2019-01-11T14:47:53.836Z"},{"_id":"accdd8c0-1807-11e9-88e4-23fa58072734","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"e00d5120-15af-11e9-adf4-89bb71bd4aff","authorEmailEncrypted":"EmALfqDJgOwRkpBCRQoI99O/Onths3m6hUojIuQnic0FzhyXYruWLDGODi89itWrsFmBarOqtEtL++dGdAs/YJRW62lhFL5mWjov5D0G7nnSHgpb+I3Rkm51/IA+cR0FBg5w8pLiwgKfY9KsEN5A3cfBSbDizwbvLKbOKwTahxSXf3xDG0UZllhaddXKvoXFbxwojg7FDBcUsx+BpDKxMs1rXPRzP3PEXMnutuAJj63R7TFxz8vJqinWkq/0DfxOP9tc0hqiDN43GW778olk9QhkmZw4FLC6D1Cm6D50Nbt3VTIbchsX3XwFygoqZxdwvgP+HQf7Jk3nCj39G7JowlHFTRu2Avt3Q9ciBSyVyAwquz7YG1louepGER2vUxUUDtX61xEVpj2vLtt48eYN8MKzlXKGrOsJknWmudU6H46GVId+SvZY2Fn+tK2BnSMfGMu/OnCJU/QSrYwUfJGFlYEBFOvjrHNLbgInU7P6gIBtIlySWt6l3rhCCaeqKW6XoGct203LlPSItFdzZffXjJ4z+2//jTB6NMPx4iWhb/bk7pptBjkIu0KlxkOCU9tNYfuhIc3hNr6E5vHfw7xbzj5QGte6aaxX2ywerKKImQq5lA61ckuP1MPZ7vjxEDm57kSX60Iqccdk8PhpSwsFLYcT4t+R0aCFcIg7+V7KxjE=","authorEmailMD5":"1f5c48763ae2b49cf16d86d4a99ba878","authorName":"Manaus Lavens","authorUri":"","message":"I have created a repro scenario.\r\nThe tests run in parallel and as Brad Wilson stated in the XUnit issue, each test should have their own Async Context.\r\nTo issue was hard to reproduce, however, by testing the amount of registration in the AsyncLocal Dictionary, it was easier to show the problem. (Marking the tests with Async, didn't help either...)\r\nSee: https://github.com/Mauzer93/AsyncLocalXUnit/tree/master/ReproduceAsyncLocalIssueXUnit","date":"2019-01-14T14:21:26.639Z"},{"_id":"1fd40130-1af8-11e9-ba78-3d3ffff9172b","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"accdd8c0-1807-11e9-88e4-23fa58072734","authorEmailEncrypted":"vEQ7zl2+60d7Wd5jNbfysJOrhrKt47JJ1VBuIYiC/XsOezhhfMBtNFfubxiwFtfMBSaabFMOrvB4OJCKxYTVZcx81pPBH+BOrRQxwe8gZj06wwBU4Np+J+RqyYKYZDGapaOG4N7J6zxGVwukm9B/2v5BqyP57BJtY5ibzZvCEgscxjbkwxxTZ4hyDTZS/xUzynbESN6bHf8BB2wPlmDBG0brdE9BqI1VNQTeLW70jHW+Zq7iZ6wAcrEcTLDxTm9zHlAkfw04W+XSsnNxkG1nn+TwlwrbMKrL0FGU52TWr4AXWFoTD7OV0uy4CASgxxPBby2h1VIdi4E93L0pMXl8/g/AAozJfYZGdLEieYXCR2ehCQm7nwUGsv34ByIAKseT9yBQLtwdrXI3UAuXEZmKFTsE1fbT1Ta9EIUEZTL5IMCHIG7TRifrEFUxefvLMXZj2mja1hRdZCzNc8RdzPM2DHtvVX58wNM4ALjf7kMUPAQsLsK2JjB/Ym8fap8ABTwg7u1Rw5dzAieQZf1qxwU5HUMUVpmDAzy0bK3QnFM/VXDfaXC2sI1GEmjCdGOonchr7YQ2Vpsl3M/0wUG0u6nascNNc2GlkyY5janFgpZWlwXr0edo5cEV2hrHqO1Cq2E1PvH0RJR2cCtgk9xA4MLWGtQiAIT8oFOkovV7d74tPn8=","authorEmailMD5":"1f5c48763ae2b49cf16d86d4a99ba878","authorName":"Manaus Lavens","authorUri":"","message":"Thanks for you replies. The sample was not representative for my issue. We worked around by using another implemenation in the Domain Event Store.","date":"2019-01-18T08:07:40.529Z"}]