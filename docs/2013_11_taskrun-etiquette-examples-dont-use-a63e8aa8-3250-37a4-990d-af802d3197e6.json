[{"_id":"0df9d97c-0b2c-3f25-a9b0-b2dc3acbf66c","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Thank you for the kind words. I'm glad this post was helpful!","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2013-11-08T17:29:10Z","timestamp":1383931750},{"_id":"e3d05495-b6c6-3087-831b-0e439b3a63a5","authorName":"Andy Pook","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/15601518097213626066","authorUserId":"","authorFallbackAvatar":"","message":"What would be the \"right\" solution if you wanted something like a Parallel.ForEach in CalculateMandlebrot?  ","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2013-11-08T20:42:47Z","timestamp":1383943367},{"_id":"f0d9b43b-5c26-3c19-adb8-549257a5db15","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thank you for posting such wonderful, insightful posts, Stephen.  \r\n\r\nI especially love your pitfalls series, because each post describes some scenarios that are not (completely) addressed in the official documentation and it is not so easy for an inexperienced developer to grasp what happens under the hood of TAP in .NET. Especially since it is so easy to be asynchronous with async/await, but is also oh so easy to shoot oneself in the foot by lacking of understanding of what really happens behind the curtains. You've perfectly illustrated it with an ASP.NET Task.Run() misusing example and I've had an \"Oh, wow, I'd never think about it!\" reaction while reading it.  \r\n\r\nThanks again.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2013-11-08T16:58:20Z","timestamp":1383929900},{"_id":"396cfe1d-4c3d-3676-9966-e57238c84aa2","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"If you are doing parallel code, just expose it synchronously - the same as the \"right\" solution I suggest above. In fact, my original example did use Parallel, but I simplified it so the threading discussion didn't get bogged down.  \r\n\r\nYou may want to consider including a MaxDegreeOfParallelism option so clients like ASP.NET can restrict it if they want to.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2013-11-09T03:13:59Z","timestamp":1383966839},{"_id":"dd7f4142-a3ec-3208-a34b-6ac720a5c731","authorName":"devtools.korzh","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://devtools.korzh.com/","authorUserId":"","authorFallbackAvatar":"","message":"Wow. 42. It's very funny)","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2013-11-13T00:07:30Z","timestamp":1384301250},{"_id":"ea0fcc1b-6bce-37d8-b63f-d8715379a351","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I do not see the difference here in your final solution according to [asp.net](http://asp.net) - the same threadpool will do the job ...","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2014-02-01T22:17:53Z","timestamp":1391293073},{"_id":"764c8435-b19b-3872-956f-26db3e0f7d8a","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The final code example is only for UI applications; ASP.NET apps should not use Task.Run for all the reasons I listed when talking about performance problems.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2014-02-02T02:11:20Z","timestamp":1391307080},{"_id":"3b109cb1-008b-364f-994d-8fc3bbab28b0","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I have situation where one set of webservices hosted in IIS calls another set of webservices. Not necessarily an ideal situation. What do you think about use Task.Run on first set to call second set which do not use multi thread.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2014-02-12T00:22:50Z","timestamp":1392164570},{"_id":"4622edce-864f-3f2c-ac8d-51220495cbbe","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Currently we are using ChannelFactory to create the webservice clients (there are several). How do you suggest changing to async?","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2014-02-12T01:40:39Z","timestamp":1392169239},{"_id":"47cbc294-769d-30ac-a837-7ee54db3b14b","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"No, you should not use Task.Run in that situation. Instead, get an asynchronous client for the \"inner\" set of services (i.e., if it's a WCF proxy, recreate it in a modern version of Visual Studio). Then implement the \"outer\" set of services asynchronously using that client.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2014-02-12T01:06:53Z","timestamp":1392167213},{"_id":"b121296b-387f-3916-9ddb-e73a5ffb3513","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Unfortunately, I have no experience with ChannelFactory, but from other comments on my blog I gather that it doesn't directly support async. :(  \r\n\r\nI suggest that you ask on the MSDN forums ([http://social.msdn.microsoft.com/Forums/vstudio/en-US/home?forum=wcf](http://social.msdn.microsoft.com/Forums/vstudio/en-US/home?forum=wcf)) to see if someone can give you some more detailed advice, and if necessary open a Microsoft Connect issue to request async support in ChannelFactory.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2014-02-12T02:16:01Z","timestamp":1392171361},{"_id":"cf4afe7a-7b17-3186-97bf-7125cd86eab5","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thank you for your help. I found out you can with a little extra code (cheated from VS generated code). Maybe there is an easier way. See below. No you have an async version.  \r\n\r\nGiven interface:  \r\n[OperationContract]string HelloWorld(string name)  \r\n\r\nAdd Async Call to interface  \r\n[OperationContract]Task HelloWorldAsync(string name)","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2014-02-12T05:16:02Z","timestamp":1392182162},{"_id":"c7354d21-056f-3f7a-8c5b-282f258f87e6","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen  \r\n\r\nThis is excellent for a newbie like myself.  \r\n\r\nOne question though - in your final example, how do you access the return value of the method you are awaiting? (Told you I was a newbie! ;0) )  \r\n\r\nMany thanks.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2014-04-01T22:21:43Z","timestamp":1396390903},{"_id":"4d6bba49-75c1-31d5-a653-f4c56b14ea24","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I would greatly appreciate your correcting the spelling of Mandlebrot to Mandelbrot, for the benefit of us weirdos who love fractals and hate to see the name of one misspelled.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2014-04-02T23:22:10Z","timestamp":1396480930},{"_id":"6e336437-17de-3d3e-bb7a-c4001cf992fe","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The code doesn't show it, but the \"await\" expression evaluates to that return value, so you can do this:  \r\n var result = await Task.Run(() => myService.CalculateMandlebrot());  ","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2014-04-02T16:47:27Z","timestamp":1396457247},{"_id":"8253f2bd-3157-39dc-b061-0687453b7091","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Re: Never to use Task.Run in [asp.net](http://asp.net) - what would you use for \"fire-and-forget\" scenarios? A long-running process is kicked off by the browser via a call to an [asp.net](http://asp.net) page. Instead of waiting for the whole process to finish and then return to the client, the call is returned right after launching the job with a status of \"started it\". The job is communicating its progress by writing to a log/database/whatever other means. The client, if interested, can check on that. This is quite common scenario in my current line of work...","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2014-04-12T10:20:10Z","timestamp":1397298010},{"_id":"a1d61cc3-6e89-3855-9d37-b06c6f2045c4","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The problem with Task.Run on ASP.NET is that it is dangerous. ASP.NET is centered around the request lifecycle, and it simply wasn't designed to do work outside of that lifecycle.  \r\nI go into more depth here: [http://blog.stephencleary.com/2012/12/returning-early-from-aspnet-requests.html](http://blog.stephencleary.com/2012/12/returning-early-from-aspnet-requests.html)  \r\n\r\nThe proper solution is to have the long-running process be independent from ASP.NET. E.g., an Azure webjob / worker role or Win32 service. If you insist on living dangerously (i.e., using Task.Run on ASP.NET), at the very least register your background work so that the ASP.NET runtime is aware of it; I have a NuGet package that does this for you: [https://github.com/StephenCleary/AspNetBackgroundTasks](https://github.com/StephenCleary/AspNetBackgroundTasks)","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2014-04-12T19:22:11Z","timestamp":1397330531},{"_id":"dfee3e52-95ad-36a6-b0fa-2d5316c3078c","authorName":"Syed Danish","authorEmailEncrypted":"vsnpKel6Y5HpCci3/FtVBpNTmamFMTQ1KcX1iQB0+cziilGJuy4m9d2hUNF3BfOXB3mrbvZNsidTn2oi3SIR0IhN2U+S7AyzJ7FqDk403myFM7XHJ4dJsfVgFZUeizhe6bwQjoTLSsR9DqXfLRCoqparFBHilmlF3Nz4W6KgfkTBWk/LJYEclNIO6RL3Rlppza4fGJTunr7fO8St/jaG0H7lkwjto6Xbr690M4Boit+m2jjqGOn6xfg4lla0ahwS9qVRsZZCTtUZ9MTjK/CWop8Z+yDPRq6iyZxsbStPcPl1/BSu5+B+ZRp0qAxYqQ/lxHwk9ZobnB8PnsUev/VmwOVU25zeX9QRQ2Db/olSQrr6dlHFFxuZUKa6NfLndrPJaVQtw8qc0V84PrkvG/uN3GneIG/cBdsUs+MXKNlgVdnHupPvagkHWIwzH2S+TKDl52sbLq/cf8gr5F0JwRXps1n8wrdSbBA7LJJdTpPBwcSonyIWY/IHVdSroCBfl5EU/SeP8rVs+zOixewVkv8djmWVbLKNtRReEjPkYj7t/xqwVRy81p53q4EwsSEI08dXjewgeKC/wYqH2/RRF/T3lFsSbDQP9YGfqvq365iVOBPZt8pBsT6NWaLV3FRCQnEvoEb2yzy/4b2rzpKZW+M6B8JyKhCudodHyAGoXzY6Ms4=","authorEmailMD5":"f42a72d73e8c6f96772b39ef0d661325","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen, thanks for the great post. I have a related question. If we use Parallel.ForEach within ASP.Net and as you suggested to expose the methods called from loop as synchrnous, wouldn't it still create multiple threads using threadpool resulting in similar issues as with using Task.Run in ASP.NET?","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"396cfe1d-4c3d-3676-9966-e57238c84aa2","date":"2014-07-21T19:11:14Z","timestamp":1405969874},{"_id":"2ed7433c-8e66-38cb-a92a-275995b10f32","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, it would. The use of Parallel (or PLINQ) in ASP.NET is something I look at very skeptically. It can be useful in very rare scenarios if you're positive the number of simultaneous users is very low, but most of the time it's the wrong solution. Task.Run negatively impacts ASP.NET scalability, and Parallel/PLINQ negatively impacts ASP.NET scalability *a lot*.\r\n\r\nSometimes Parallel.ForEach (and friends) are applying the wrong solution to a problem, in particular, I've seen them misused to try to do I/O-bound work concurrently. Other times, the problem really would benefit from a parallel solution (i.e., it's CPU-bound), but even in those cases I'd consider a distributed system where ASP.NET just queues the work to be actually done by an independent system.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"dfee3e52-95ad-36a6-b0fa-2d5316c3078c","date":"2014-07-24T18:58:47Z","timestamp":1406228327},{"_id":"128edd00-e15a-358a-9298-e12e5d1ac8fe","authorName":"JayJay","authorEmailEncrypted":"AvcYaVlZunfq01IfAaYQs6PQ5BwB8oqsM5PZDRLoa2U9NvFs6U50v8/4H14cgmumcr+vAuhMzetayAJdU01xdhPxYkvYWq6035sHeodFCI5jEKRMwseTsoM1rorQNdx1GLE2rV5pewGsTwg/YZ4W5/zpox2NOo3cUzlQN/LKPMy3UaAmntsuXxYJNOkS1DZjs1/SsivIOQYxcSOsU4zasYZPzC8EgvKneYIOaQfnnbhPq2xbFNjqh87Ypo1lsmMVhze2/IBL4DbeI9Q+xeew/xObOWTmqbmuJHZnphxeijLJj69rv98AOZEhdioyfIWGcXzxuW9jCbBHZSgEeLaFhG5adrbmbnEHOrqVmibLcsqnfFYQYtiqX4FikIm7cZYm9r7uLAbAFf8GZpEm3+ZsG/CPO4Bh9q/X3uXbgyeAOHppqRSByjgjKidJfHJFV7/g4L5pINvNpoebJn1s0qHrLPdJ1Aa+926sqGFWEe+uk09PePGHcEEoDj6Y3Cy7qxocZUeaLCU0tx4yjSGT3lv9yRtoS1pLWwtlBszF6y0f7EB/4tjE1FqPpvfUPgWFsR12RV8WtvLZCbHsbqE+pDFf4SxonJMph+Ev3iCHxJfWuJ2QwSE477t7b4USynUcPUGpLaN/tx8f/qQX+tZtNxueIdN5bvovpbmAvviYSNX8zgc=","authorEmailMD5":"94650813e5fd38111f3bb5d5e51ed200","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I'm a noob too, can someone post the syntax needed to access the return value from... await Task.Run(() => myService.CalculateMandelbrot());","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"c7354d21-056f-3f7a-8c5b-282f258f87e6","date":"2014-09-24T06:42:32Z","timestamp":1411540952},{"_id":"82098133-c381-3c07-8c6f-ff8266d80345","authorName":"JayJay","authorEmailEncrypted":"Q6omMFLU0OoFTkiQWv3g+rQm5SdwZqIQF+GdLpb8npjCTe3fsX+B2FJWeIny+PJo6mGy9BO9Z+hYAfkAWBCsSa+vx2d+/bLnJbfyF2CAiI63JegDVjCxCDzfAkePXrBhHqBocHIZwKqZd1DKEWDK3E8llimEn3fK3PFtGUo7Qz8PUBJed5gx3y5ZdeZ2dh4WDYyPX980CYnSogvh/P18bHXoi3GxaUj8p7eZK5R53KUujk8jVpq12D7e63Hwyk/kW6Qd/SUOqlr43ap5EZ+0K1TqfTwBc+2N4LbF9XoXN1wc/d/rCQlLk8tKyq4QU3mT9XWsrlRIPbqT39r2K7jDsnpOMQjSij1ErDDUSzbm4tE4mCm7DnE+2fz6N3k6IYYea8KGN/Ue3XunVVRRbZ0MWsUVDajEz/HII4dR+BMtKm3JzTNaDgVW49fMVgTBPORxc8/Wt5lIcHppiYbIZSLHFF0W3ZmDQdRvVrc+AzI5v/iztGWv1/VIwLVWaMbSypAvtbhnRqx5wCy1pVmkMLJFbvMpiYr6Yhq2FKWR03oV1T2UKgRr4kQC8tEOREC+fh0PhoFvSnolNjKkEAuXXcJ7+9MHi69pU1+1q2pqSv3OS+h5lIphhn157lSemg8Tx/I1GCK1pfhIgPop6fPCRRjbOR2RLwj2F9nLZLfopRWbPdE=","authorEmailMD5":"94650813e5fd38111f3bb5d5e51ed200","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"after some Google :)\r\n\r\nvar val = await System.Threading.Tasks.Task.Run(() => myService.CalculateMandelbrot());\r\n\r\nI tried using in NON async method,\r\n\r\nIt looks like an async method MUST have an async calling method.\r\n\r\nHowever, this call works from NON async method...\r\n\r\nSystem.Threading.Tasks.Task.Run(() => myService.CalculateMandelbrot());\r\n\r\nMy question is can my NON async method get a return value?  \r\nWhat would that syntax be for example above?","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"128edd00-e15a-358a-9298-e12e5d1ac8fe","date":"2014-09-24T06:56:14Z","timestamp":1411541774},{"_id":"a15cba39-1a6d-32b5-8355-fb737e6fe478","authorName":"JayJay","authorEmailEncrypted":"FZY2VzACBC1zb2QnB3Ch12k4mVIaEQdaQLdwfucxLpim4y5Barrbz2Gtiut/0hU/ajQ6zI4cdrfgJfzYJLLmRhXRqZsY/UzAYCKpWNYAXC0GXm2j6SHE2DAqP7u/EL+ic2trzRWkIBKgbUDdcHDHQSxxpKMbcCg/2dMRAY7UN+YkvoEkhgZ0dcSlsvokwTEBtv35IWIQ/ozxprIqu4CytGra3o4aIalKjuS43Q+++aLL0THPGhfLjeOxD0wgvX+v+9Vs+RIKqYRwuKUNH2XEqSF0+l/e0xB5o0nEcl35H3APexCqWJZSDGYIwxnXLPyiEfPrzerqKGLENkQp4Ocg03i/Knka5ttDgv0BbO/CjUWMSdkSykp5PI8XkXaMtpsFkp53b5kLer3u7OI1eIlB3+HTa0TCVk69pJYyzw/hbvwPgtWyyuq7VGjFctYkxag2AWaCOeZZ1sgZoS6j9+hvZTh4BM7KAFbBjdAtg8TUuAy8OCFtoMDWo7Bd5N4rmt6NN456LKkfYCg9sj3FNeuohNAKYWNsJXYd9s7MQU4ZWT3Z4nngdIkbYZtWcXNelvDBtwxTyPyJPywNvW9+0LKwwqZIhMdU+0wz6BRswzLpU3D/r+IPMSjLfsG7AOQgjJlLmiOyGUAQlI0CEvX9uHh8kgYX/lQ5CKfiDA4cxG4RlIo=","authorEmailMD5":"94650813e5fd38111f3bb5d5e51ed200","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thanks Google! Hope this helps the next noob :)\r\n\r\nvar val = System.Threading.Tasks.Task.Run(() => myService.CalculateMandelbrot()).Result;","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"82098133-c381-3c07-8c6f-ff8266d80345","date":"2014-09-24T07:05:50Z","timestamp":1411542350},{"_id":"ebde31fa-cfe6-3251-9f3a-673844b81353","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The next to last code block is a code smell, yes. I mean the one with the comment \"Warning: bad code!\" at the top.\r\n\r\nHowever, Task.Run is almost never proper on ASP.NET. If you're on ASP.NET and have CPU-bound code to run, then just execute it directly.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"ec7da148-e068-371e-8be2-f4abc0dc9b54","date":"2015-01-06T23:53:01Z","timestamp":1420588381},{"_id":"ec7da148-e068-371e-8be2-f4abc0dc9b54","authorName":"Joe","authorEmailEncrypted":"U8g2J2cbHZTBcjiXxgKeqeFWYaRj3GqK7VJPbfvW5WiexzJqP/RAGPqa0AQJbL4zacpVE9RFcRnxjU6V84M3VlW5ZBJ0e0rffwYTYnLCD03iz8SqeSbKL7ozcyEyVJMTfM3q/Uqk7CvIpuRrOnAJTUwT+8OU/bm3abSNIafr40xWcoiZlsX3Maw3sY0Graz/cdAyj6G+zENglw7Dqw7oLy7FLFnvMFOU40A9eSHpxmUy+7XHBT6uPh2su2DgxlY/U6DjtHmTHYs/X7esG0b7DHAEsN427vuRxeqybvRM7SAGKVPZXId34WY4p16g0t8ZvDmceNIi/gTV0gxfxXp6p/Cxtd6a672gpvLizHh71ssn5G364i5gV0i6ln+1JJsKz8Jcw8mU0P9W2JLEoPpx0I3VUTaCYG6HIskzEk+7aajGSepYHOa8DOm4ZNrNve1TT+ttxUsgi5slQRkFAjrs6vM3OXnTBniJrnrKh8rnMtg/bZb6YKsKNmdNYXpZunMIPfRbsaG37hIzpbzrJfxnQHDo7w9OrVZ0/cGxkfcuWFQdolulRaArf+ZWm4yOTGqbAZJ5yykXJ1SVLYnPaHD17GxbgaPc6mtxtEbfJ7fKLrkYiz88RAzzu4iQegnpwLbQuLAYnRYBGzGvZAvtKLDxSvWogETeCuuDJn9LVTzPjvA=","authorEmailMD5":"b81336eeee69e3ccfc442e587302c604","authorUri":"","authorUserId":"disqus:disqus_ZRdO2egxCJ","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_ZRdO2egxCJ.jpg","message":"So the method without the async/await kewords (next to last code block) is a code smell, simply using the async/wait with Task.Run is the \"proper\" way even in an ASP.NET context?","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2015-01-06T19:55:26Z","timestamp":1420574126},{"_id":"66c0695d-1ff5-3511-a349-2ca01dd5af68","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, but I highly recommend that you register those tasks with the ASP.NET runtime. More info:  \r\n[http://blog.stephencleary.com/2012/12/returning-early-from-aspnet-requests.html](http://blog.stephencleary.com/2012/12/returning-early-from-aspnet-requests.html)  \r\n[http://blog.stephencleary.com/2014/06/fire-and-forget-on-asp-net.html](http://blog.stephencleary.com/2014/06/fire-and-forget-on-asp-net.html)\r\n\r\nMy AspNetBackgroundTasks library ([https://github.com/StephenCleary/AspNetBackgroundTasks](https://github.com/StephenCleary/AspNetBackgroundTasks)) uses Task.Run internally but also registers them with the ASP.NET runtime.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"c6dfcfb3-d041-3e23-bd3d-148a4ddcf545","date":"2015-02-20T12:57:28Z","timestamp":1424437048},{"_id":"c6dfcfb3-d041-3e23-bd3d-148a4ddcf545","authorName":"Christoph","authorEmailEncrypted":"IKXMoBpAroYC+rnFqXuehoE2gP8L4JTLyLl4KXfKUKjcEnJYYM84BRWHBaWsB5MmU78mGZ8rILd6P2pTHQcK9XyGV8yjRZh3VK6FI6Sjkhc21SHA2oOlmgdv/2PZRVNcwLtWI3wDhdB/bA6VnlGlhHmUnnzrYSGpdFxJy9n1mRP9hOqOehZqHubjH0bl4G8pIi9ifnTkdCAxggLL/HLqybyEdJ3/qDIgur9uS8xhHcneVs67lDSztMuq0bxOB/dDBHPJHYchL06ChlXoT6Sl1tSyPFjVRw7cKFnZEOJ0lCBSwqqTXY7nIaLP7b8SmcTRfBR/5bSJ0VJ4XfZaseh7sQjP009wJ6QLYWgOpjBFWvoRXo01dfSJmjxOmPiwCP3slcFyz19x5YAyFObpRKt+zv0N3iDW7jyr9gJXcQnOtpP/rjTO1341jecfyUBvrSQvkgfEnEMjYCULsThQsCT+UUBMl1/fsx1MJDy7nrQUTI3yS3iVG6sCDPUVTV/flobHNpv4+iMD7d0Txvp9SHaJbkFtaiMz1jaiIhppHQX5OmbxtICstYXEbdevilNW03OsguLEwMNkGDnIaky9qtPdZLfDGl6+NWOEz53qWDvwAlECi4PBJebrOgZbfxm9XE4GzUdSxKj8IIteRv2UA7YukE/t9aj5/PYgvOiV4WyeSCQ=","authorEmailMD5":"104faa3833e870e7f3e923d5da121529","authorUri":"","authorUserId":"disqus:disqus_MRSL3chIFd","authorFallbackAvatar":"","message":"awesome! thank you very much!\r\n\r\nA possible reason i can think of for using Task.Run in ASP.NET applications is when using deliberate fire and forget tasks. E.g. writing an action to an audit log where you just assume it will be successful, the request returns to the user earlier and you don't care about letting the user know when auditing failed. Do you agree?","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2015-02-20T09:55:17Z","timestamp":1424426117},{"_id":"c8ca7b10-bd26-32ce-9251-d00d540beadb","authorName":"Christoph","authorEmailEncrypted":"pyQiT9qT6F/K1apNvt3ymj9a4ltNwsU/oMQok76L4SQHiEBlGL53nMdDe7uzM4MwaxntuIOP9ngGZCT3OtkDVVgYBR5A4dTx9Lrm7AnVnN/cwP8wBxid6H7C2b8BJ681fMdwzKZ4+mZQHtqpLW1J+FvUMc4WwNZRw9RKG7mhTKOrklqmqYWHeCElpTNZ+p3yS89NcFiKS3bjD2r/CCSNaAQLw56gnGzP2FGsA0KCxble+kTCS0arI5QamcpKpM5eDLC+l7IbzmMNc9/BFnUa8cLg3gD1Rt5xRW9BGAeivduES3v96b1wTM/3i18xDLvoNK89prKLBZg5F7AmVgN2lh5hU13h7BHRDz8ifk6CL2ttqgkwoMgFp1WWJ4WnIgEbutEeLOqL9+pD6cfEcPHCRkkhdD044wA5wE+tP4qLouaL9C1NtMKHCwX7lGst+VQSdNapiCIJHTmljYcERLjIOWFXPovL1SchbGP5w9MwIakBauu+XFAGCRvSufzkAg+ZqTymUi6WI4sMIQRSVE328HnKrUc/HkftZHVVuIn+KCQpDg4qTJhFjZNo3D5ItUnYafxNldYhLOKl3Cj7JDT+1eTbuvXjl4W2rBkAMau2X8P7CcQjMI2kOURvhWq+VsDDRZSlw0YdPamBuwWH9BZbP5vF2Od/75rjVt3JRQlcWPE=","authorEmailMD5":"104faa3833e870e7f3e923d5da121529","authorUri":"","authorUserId":"disqus:disqus_MRSL3chIFd","authorFallbackAvatar":"","message":"Awesome, thanks!","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"66c0695d-1ff5-3511-a349-2ca01dd5af68","date":"2015-02-20T15:41:34Z","timestamp":1424446894},{"_id":"1b009269-9fbc-3d74-a18b-787003ae5535","authorName":"Matheus","authorEmailEncrypted":"dV7nwYGqvT7yj/n+3OyX70Y8DaeNXaCyLROXCHz4HDTYszclPO/7ZQX5r7SeQqnH2taOh/YZfOKR4XQNzrwRX7yVEeCRkwC9z7zCWaeziLwanxuCHqFEnq9fs7z/bbBMNI2CwR5gnYxmHTWTfpBOVYnDAaxve40/MUicz2jbtjRDXoVX12yuzSkz3QMf0wPwUjn5I4zNUXwMxYYVvo2aG1eyzPsK6PhD0XS1H7PetH1nsB0NgHReCLywO9MX5oYCjEHLGMLx/mMbjV2XNuJV7ulwLcmGkXQyDIgYpolXsEEnX/Yjx/ov/ICGfZ+5d5wOTBJi4vdcfJRk9doljN10ltLsH07lCzVgRarBecjVJzcjws5/qA1wNNhXZskwvh9K69l9zEwxlo8xOhGD7PVWT3FG6dfkybNjqZP8W2K4ARI+YfYOtz+jeTgJ7T0r6Cpwenjo4OSVhmz9b1882vl5khhHWQ18dc/TwoX3vbE2XC+BHgv4s+9aPNTKsd0auLAHPIBERdVSLgTUIRL7jvvZMnaPqpvKcDcFmkz41kt+r29n1wKg/vme8MLTBngDhxdlA+xpWjxAxizN2lasZV/CSTsP83ZwnK7lLXNKgndCDg3w++AZGF5CDb+N/Q0z7whyW1aa3f5+ZE9EYePcrPikp7uvWfGS53LWFlP3bnkJp/U=","authorEmailMD5":"e62768a581a216bc55c95e1733cb9dd0","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"The way you said about Thread Pool and Task.Run() in ASP.Net Aplications sounds like \"Always code serial, never uses thread in ASP.Net apps\". Is that so? It is preferable take a long time in a \"parallelizable\" code than actually use, say, Parallel.For?","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2015-03-10T18:09:42Z","timestamp":1426010982},{"_id":"4bc9cf90-b3ba-34ad-8ccb-d2dc1c15ee2f","authorName":"Thomas Tharp","authorEmailEncrypted":"DjQYzg7f171h9iuMSP8sKDfBI0EQK5Svtnef8sZhCa3kHHp1/uKUu/OxuvePJM4EJCfSrmC5CiNz8tZtle8+KP4IW3NxJc9gDsri2fApa5hy7q9dYhTIJJ7jKfvyCtciUSST338bC5omPLqrRsItrtzjZiHMhmL5S4B9AuXcJ13qYlRRgRrlL/7M6H1gbLuwoclY2mPt5F7rSHO68C1kb4DVsr7nT5L9FTtoAhfXv6/J2Hy6hSi+z40AdaZs3eRL2OycHUHgeU9e4i4hFrbOVCWbabzYxNW//S3w3gqltSaeIr4LwS4WLJXcoxMZxL4fKjN5GOkaHSEFOQA/h9RAupCPPl25uWMZTGdwycVhU8ag+1mMiHupSVb4mfO+lt5wKLRvGjG1MBzf+6leK+yGsGqb06XYXJsyuwK+J4p3SZY3mJ0zkkKrI2AtOHOQj3WSt+SlXzx7724qOjMqMqVjH1pQRCxxxFkvmnRMxJLBqbBdudH+ajYOw4CJYqyyUtee6JroXE10yXFuM/ECx/hDA0B0hTve/mBrtKTo5ZneasxZGgYpp5CH08U2+RUA3yY7p2NHAI4yYtT6aVyE9IYFqjWVrTPiMJeC57hKJkL99SS1PUg3orpQTjf13vYMLKY9ZtOwXwqmt4Ie4mdQzfDaLpD4PDjXeUI3g7PsydbfcxU=","authorEmailMD5":"3190c7cb5200e38ef7d74502562371ba","authorUri":"","authorUserId":"disqus:thomastharp","authorFallbackAvatar":"","message":"Hi Stephen,\r\n\r\nI have a case where there is a database query that is naturally asynchronous, and potentially long running. However, there is also non-trivial CPU work in the processing of the query results (~200-500ms per query). On a load of my ASP.NET page, I may have to do a few dozen of these queries, all of which are independent.\r\n\r\nMy question is, what is the right way to make these queries parallel? I control the API, so I can change it as much as I want. Originally, I had everything (including the database call) wrapped in Task.Runs, which guaranteed the parallelism that I wanted, but obviously killed scalability (the site could scale up to a few hundred or a thousand concurrent users).  \r\nI then changed the API to make everything naturally asynchronous, which helped reduce thread-count, but ultimately negatively impacted performance for the low usgae scenario (as the CPU bound work was no longer done in parallel).\r\n\r\nIs this a case where it would make sense to use Parallel or Task.Run at the top level, to make sure the CPU bound work is actually done in parallel?\r\n\r\nThanks,\r\n\r\nTom","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"2ed7433c-8e66-38cb-a92a-275995b10f32","date":"2015-03-10T17:33:11Z","timestamp":1426008791},{"_id":"5e2a02af-23d2-32f4-b33a-2dcd21fcebc4","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Hello, Tom -\r\n\r\nI always hesitate to recommend parallel code on ASP.NET. Asynchrony enhances scalability by reducing the number of threads per request, and likewise parallelism kills scalability by increasing the number of threads per request.\r\n\r\nMy first instinct in your case would be to quickly load a shell page and have it dynamically fill in the pieces it needs. That way your request handling is all simple (asynchronously do a single request, synchronously do the processing), and the parallel requests are done by the browser (which is designed for it). But this may be too much redesign in your case.\r\n\r\nMy second instinct is to try to look for other solutions. A single page load requiring dozens of queries and several seconds of processing power? That seems highly unusual. Does the page really need all this data - maybe split into multiple pages? Can the processing results be cached? Etc.\r\n\r\nHowever, at the end of the day, you can choose to use parallelism; there's nothing that will stop you from doing so. I'd recommend against plain Task.Run - as you discovered, there's no easy way to throttle the parallelism. Similarly, Parallel LINQ really likes to assume it's the only parallel process on the system. I'd say you should either use TPL Dataflow or the Parallel class. Parallel works best when you have a (complete) set of data to process over, whereas TPL Dataflow works best with a \"stream\" of data. Since you're doing multiple db calls as input to the processing, I'd say TPL Dataflow would probably be the best fit - that way, you can start processing as soon as the first db call completes, and add processing as the other calls complete. Dataflow has capabilities for throttling, but by default it's \"wide open\" like Task.Run. You'll have to play around with the code a bit to determine the best throttling value to strike a balance between request time and scalability. And document it well, since that value should be changed as your server hardware and/or site usage changes.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"4bc9cf90-b3ba-34ad-8ccb-d2dc1c15ee2f","date":"2015-03-10T20:06:36Z","timestamp":1426017996},{"_id":"84156983-5241-3b16-a985-6b16c6d9d40f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I always view parallel code on ASP.NET with a healthy dose of skepticism. Parallelizing a request (that is, using multiple threads to service a single request) will help the response time of that one request, but at the expense of other requests. The entire point of asynchrony on ASP.NET is to enable maximum scalability by using fewer threads per request. Parallelism would have a serious negative impact on that scalability. You especially have to be careful because some types of parallelism (i.e., Parallel LINQ) by default assume they are the *only* parallel process on that machine, and will try to scale out over every processor core.\r\n\r\nThat said, using parallel code on ASP.NET *can* be done. For example, if you have an internal application with a constrained number of simultaneous users, and there's nothing else running on your web server (e.g., the parallel code won't interfere with a DB server on the same machine), then yes, you could parallelize a request. I would be sure to make note of your environmental assumptions within a comment, though.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"c4987c90-02f8-3a49-8dfa-2badf9d2caed","date":"2015-03-10T19:49:05Z","timestamp":1426016945},{"_id":"c4987c90-02f8-3a49-8dfa-2badf9d2caed","authorName":"Matheus","authorEmailEncrypted":"pu8wBbbHzzYmbAOoBUlPW6BM5msfIkAniVqp/TPo4zIA1uDgaTzvDsDpuJ2l0LVbdxKxxva7Zwlrxa+rbM13kODHZrTPqTDb0Ewidseh/ZXkiOxTJRta6zUHVzCnXlkoHNUJ/e9WFiPtcaJXLoVxfMLffBfFTmPJba1n3gbLDVBv/y/NVWn2noBw0s2ZFO/NAj0SObk7PEC+JALR7taIPktMXWq3inTR3ydUggHpdib6pTs1YLN8GFZSoiwATHRgCvMZbLie7U2Q3gqIis6Fo99YpjZ0AYRpCYSBxc31cWMTsrouauy/Gt7xjte97qCqq0qmQCARa3vkveiEB3TaYWcf/0oNSmBhyVtL+rI1toVuXI5EejOqeXBUooF4/fO7w0ow7CNYbT0ImroDMDjtVjr3bdyM208MmTksM1yhcJTZSWO1BxyviWkI8oqWxDkNkiAjPQoRSCw8oU9+HrZZh4wO2IZ823Iz27muL1Sc+o7kDMK74UbkAlycsB9p9LO8mMo3Qvq4ZrpGUL2H0cY+otDJ6xXIHbUDuso/5VdueecOGKMYvOBb1DO9Qtg4LwTRihH5Wrpy0vjpOQ5UW6qsXAI8nOPcQVHiuOUTlBtAmR9OuW/6hMrWhi2IYdIrIq3kSib8zXvBfGEbVGTM+yOLnAoAr70Bn8Yt9JnKGKPxAAU=","authorEmailMD5":"e62768a581a216bc55c95e1733cb9dd0","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I mean, wouldn't be the thread pool benefic? When you need to reuse the threads for example...","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"1b009269-9fbc-3d74-a18b-787003ae5535","date":"2015-03-10T18:15:28Z","timestamp":1426011328},{"_id":"e95e164e-4e71-370b-8adb-6da17fee3856","authorName":"Thomas Tharp","authorEmailEncrypted":"oRVTihj1YX5ot9lO9Q+3YvTWkdhnDfMp2uCRhbuG2WfsZQIKNF8ucQR+hDPsFgZ4SDDz/mQC4dFmlYBYxDGaQLm3doeTNqwG9HxLRMsliMtF8/eCJYRhU42m6hwbVR9+I5K4Hf8zV5nKioW9sseadMFGb12bULmIflT0BXarMZcXtnjX/KMZ3f4gAkP8abKoc+oyfSKX0nTG8f4ozHWzRz1GGs302PaKgABgxG42LBA0TvjoRHe8Y9HynaCqMkIzeswBVZAjkDsFQFA1vaG5JUMOyMwvC7oDuCSXDuI/ZS6h8k1kWNlcI+3kuBXm2Y667PgzNULECAAzItanbbzRYCcTbH+nvivNX1QV6aPAYF4CTvUgKGeurOr8nojZcLW4iwW23FQMIPwkVLEenSv0aBi4ELRdTQpPoyJ+PWmJUsTfuPoThCLhZbN35Jw1Ycd12IQsIcDGcw8qCUGe5saT0AQy1MythPmf0haPZPD5MV9eeWbtUdtAToIg8JkY2yDnhIk/7UC8iC8E51DQJYN1v3mhCVMtlN9tDtwNOYDe8mOEjqqePj/duKJd8ji7aZKPRG+5hrjYLcbIAA1AMKfZ0pNf9f6HHd6mP1TM38JfTBW52KoicvNiGuej8u5/c/gnZIZpyXd4KOtzJQH9x6U1tNas1/WgMQlhGfNVzbhRNOs=","authorEmailMD5":"3190c7cb5200e38ef7d74502562371ba","authorUri":"","authorUserId":"disqus:thomastharp","authorFallbackAvatar":"","message":"Thanks Stephen,\r\n\r\nI simplified the app structure a bit for the question, in actuality this processing is in a handler called after the \"frame\" of the page loads. The page is a data-driven dashboard, so there's not really any way to split it up into multiple pages.\r\n\r\nWe did originally do the parallelism on the browser side - however our codebase is (unfortunately) deeply tied to the ASP.NET session object, so that our handler can only process one request per user at a time. So it looks like any parallelism will have to be on the server side, at least until the use of the session can be re-factored.\r\n\r\nI will try some Parallel implementations first, since it seems like a smaller code-base change than the TPL dataflow. Thankfully we're in a good position to do load testing and performance testing, so we should be able to tell objectively if the performance gain is worth the thread count increase.\r\n\r\nAnyway, thank you so much for your quick response!\r\n\r\nTom","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"5e2a02af-23d2-32f4-b33a-2dcd21fcebc4","date":"2015-03-10T21:25:16Z","timestamp":1426022716},{"_id":"458c9a29-477d-3c1f-8fd4-0c66f63fbef8","authorName":"Jeff","authorEmailEncrypted":"bM0I7mn8uDGS0XLq759j+P/7TOutcRFnnYBekmFBft4jXeoYP3SqObB38uRCtGnclUjEh8duqq9sj7y65ickHic3zja6sWN8ACKzau0lhESXasMHZmr8WFkDga6TEb2lYA96EfxaOhd2JKcxijQHeGruEUevf1Nt2eo/+3ez4hzF2fB+Nhz5Uhjaouonc360bti2XN4yOMHw8Q9OEEZA2FEi0svoLwwUuOyox6L4wqYvSBbniON64J+smjJa3ZiZ/x7ZNrmyb7+smmX5JPmjLqkSOihsK3gv39K+sCxtJV+ayO6kOZqVLwIQv0uigo/FRet4DNqpERDL2V6226EOUhPhEXZjUC0yqkskRAe4MSIN+JGz02Z+UN4Wt1Q/VmFFTDyP9xWLmL5+Bae3DSBAQ16WqR9heJ6sfBE+YIxnNejC2yunbmhWpKaeK2CNNM3Qwf2EF8wkLsp6u4FA7J9I+gV6i/W3ONa0oOWDaP6MHTW4xY94Fner+nK2+8nN9pUHAFijF+4WqfWTRywmogPqmRgipiVKwH6UL1kkH/QwnOv9/8bJdTZoIFb8sSevbz5+rgCcH5wtZfjYLLyVZ8YaA/LXR9Vu7MEt0lesAe+URixpyTelyYt7MLlqWXaC2a5UliPbIsYqEQKF521SPdkFvKeX2Ouxsuf8fF5dlwfOvrc=","authorEmailMD5":"e4c8bcaf4ce93fb29db47715959dfa37","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Actually...never mind...I realized that question is dumb since the cancellation token may be passed into a synchronous method. The caller is the one that has the ability to call the method async and optionally cancel, or sync (and not have the ability to then cancel) without the library method needing to know anything other than that it accepts a cancellation token which could possibly be signaled, which jives with what you were saying in this post.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"fc376c57-b5a5-3648-80a6-be506f0156e2","date":"2015-03-26T02:08:04Z","timestamp":1427335684},{"_id":"5c5d839b-8f21-3611-b991-4b12fc9c374c","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Actually, synchronous code can certainly be canceled. The normal pattern for CPU-bound methods is to periodically call CancellationToken.ThrowIfCancellationRequested.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"458c9a29-477d-3c1f-8fd4-0c66f63fbef8","date":"2015-03-26T03:11:16Z","timestamp":1427339476},{"_id":"fc376c57-b5a5-3648-80a6-be506f0156e2","authorName":"Jeff","authorEmailEncrypted":"EmJgqGccHB8DSiIVfzuJHjyJq4MSiXBuylA5ws89pw1DmDZ/lJnEpfjNryhMpt/VBqwMaBQrhys6K7FttbFrCWGtXTuJr4kiqQ0YpuG+QHcXX55oHXlDNODdHcI40yudcoE61bIHbHePaQnwmU4GuF9sFP+MyCE0eFjYwU8vYeylFXYs22s/hpxXiZc/GBg6gM09+1xYbBkllpyvfGKwpOFo/DtkPcfWwXxSnRrrCUw5t0b2rxXrv0RP7GFaXkR8hbcY1YfZbez1N4qa9hbuPSXd5p8egFTvvoVoXeEh2qEnk8DaQkQL+m+YEJzDSIlALEu8hKhYiKQWlTqcTRg2nw7ovnjqtIVYxTkztq+jRdoED8bsNkCAH/aD28fpB9UPt2IFxLz2e+SkO+x7plaZsSNPrIqn2O7b/tqAwmjb8sTDF5JdxMUrZHFdchk9uURBsZCliw27saD1qJ1QVtAVg7aetadOnCobRfP8M24YPYpW0xjiZcI/ek0RpB6wbAmEGkWMCGM8YUi84JcU7oO8Pv9AHrK9PN8ZKC5uj1/HrUbn85YrgugjQ8wEOuja5MP3KXcHXzdTJ4gF0/ZoD2iixzTmXhwQq5BvMcLf4woc8xujoSSnG0W8bcIkqPllMRoigLqHNXVcF5k5YEYIbqWO6vQImaGQ5DYVL/cDwbydQi8=","authorEmailMD5":"e4c8bcaf4ce93fb29db47715959dfa37","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"If you wish to support cancellation in library CPU-bound code you must use Task.Run at some level, right?","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2015-03-26T02:04:16Z","timestamp":1427335456},{"_id":"0e2021d2-b737-31db-b698-be091e997d94","authorName":"Stuart Wells","authorEmailEncrypted":"J9oUMfXHrM/mk1wlK3BnIQrJaWxtsybDd5yjShfmQNFZqQNyCvOyG18+Z9G43vlLbR+HsPVfNX3PMXZ0TMq6oWkqHXR6l0a3c26J8W/j3i8XEG39QzjYUxLBnvmSilE3XNglkioEeuT2zjHOllcbStMQ7SBlsbkoftjj1ErC8vHfEtv0xUrguqErun04/I972e0qUWiqrYZYuTsVAjRtO9L1IuOHfOIBhhyRXYAfVojd06o2/Gyz4/G9TSXD6faNCq996ItG11PdVlSmnlOA1giolyiEjiE+926L7T2fqLqaFN5Oy2HYLPlwrlVRkT135tgYqGfymKfP/wcau1St4rWbqu1JROmJrF0ERqjJ+ZhsBdoQ0B9yzpq2xzLabOI9UeJ1kywyfzWJu2gNIdcxlG2U84Q2IWE/Lkt5yNTzyKBBECZrkz0jQH9SsiPjOTlwyViIHNsHD+4SXBBgxSIouAH7ActB+nVeNwjRhv92zEqZUlWHywXNVizGCdkm0AWF0ONTIbAXWugiCAWQZwTJDTPXfdiHIeXxPjC9uIKY6JW0nEUxlRTrpT8T+UewDLBDte9NPAbxT1AZRbQMm+Vax6o0kq9uie3Glt/glTHgOlfKG9Cf5qO0hqMezYAV0sau1awU0vyhvHJ2F3o0b/QtkAIBoS/LLdtFcxhxH+/to+k=","authorEmailMD5":"1f7d6a407bb7495bb3c9669535bd0327","authorUri":"","authorUserId":"disqus:disqus_2cbnUKZGU1","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_2cbnUKZGU1.jpg","message":"I was mid-refactoring using Task.Run (thinking for a moment I finally understood how to implement async/await) when I read this and stopped. Close call. However now I am wondering how exactly I achieve my requirements.\r\n\r\nI have a WebAPI controller with a variety of Post, Get, Delete methods and as part of the call it needs to talk to a repository of some sort (I have an interface defining this repository and I have defined the methods on this interface to return Task or Task<t> with the expectation than an implementation would implement it asynchronously if it makes sense to do so).\r\n\r\nLet's for arguments sake say that one implementation of this repository interface is to an external resource (like reading a file or communication with a SQL Server). This seems a good candidate for being able to call asynchronously.\r\n\r\nAlso let's assume I have another implementation which is storing everything in memory. There is no benefit from making this asynchronous because the work has to be done by this CPU anyway - but by returning a Task the caller can 'unblock' themselves if they so wish by awaiting the Task.\r\n\r\nSo how should I implement the interface that wants to return a Task or Task<t> for the in memory variant? Or as I am seeing this, as a synchronous variant?\r\n\r\nIn my case I happen to know this could be used in ASP.NET/WebAPI or WPF but anyone writing a component for re-use would have to assume that the caller could be anyone. To be as friendly as possible to all possible callers it seems Task.Run is out of the question. I can't work out whether I should/could use Task.FromResult. In short, what am I supposed to do?\r\n\r\n// interface  \r\npublic interface IRepository  \r\n{  \r\n Task<widget> GetWidget(int id);  \r\n}\r\n\r\n// implementation  \r\npublic MyRepository : IRepository  \r\n{  \r\n // note not using async keyword as I am not using await, although Task<widget> is awaitable?  \r\n public Task<widget> GetWidget(int id)  \r\n {  \r\n // Was about to do this  \r\n return Task.Run(() =>  \r\n {  \r\n //...some synchronous code  \r\n return widget;  \r\n });  \r\n }  \r\n}\r\n\r\nI can't just do this:\r\n\r\n// implementation  \r\npublic MyRepository : IRepository  \r\n{  \r\n // note not using async keyword as I am not using await, although Task<widget> is awaitable?  \r\n public Task<widget> GetWidget(int id)  \r\n {  \r\n //...some synchronous code  \r\n return widget // inappropriate return type;  \r\n }  \r\n }","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2015-03-27T12:21:39Z","timestamp":1427458899},{"_id":"3401c15d-d0d5-332c-b804-48723e4d3c8b","authorName":"Stuart Wells","authorEmailEncrypted":"Keo1bfYSMrxY8laoyjNZLmuZE8KtHtg1KavT+aPA1Q76f9Z6nQBBqrV1/saB2PG3gJfggefxzl6UfTh4CS9rNtKWiKUQEQESfEdHrZCCpw+hjBc/h+O6AGCj0wFjjNmg0brvpCaVgmDk84laygbMV/jcxmfQJVG+q7Jg8GvacBfF/NoR7F/71fp8hoIjl1odbAIcEqNLUC4OUiQpGmr6P263JLfy6w0NWAr4SkjmPdWIx8yDCVpt9RdAepY47B15KAAdJNSYs61Xs6aco+cr+XfKQ9JSddViRNb5xdECCOcKPH7hSU6ClE/6nPXRqyMjFdDS98dHgjTH2E1e7hL9AHkk3RFzWQf79egYVs7gIybs9IGWmsyN9RFuHFSwXbD3HAjkdq9oGcpRhWM+Wa3JQ6z92M4SrC4yREpplUu0TULP3FaH+M5rmFAHcA+Hlr4BL6D6OYLEv+p9OT6ag3OehIngXBtmd811do5F3xvpouVRCsr3U4JFI9boQV5lLkqJB5GIg4T5qg/9F98/yQHcWTl7sa7FACjlg1h8+r8vI+BDt0K6KrLGfPlV/K6wH4j3XwU4efRSkzNC7X0R3pjTX3twlft7fn1bV/meK+E5m5qzN69CdCoP1o3AGuD2XSZbD4mJO5M2isQyQJmSnYZ7L5ubaP7XoXnluW60nyoCdfk=","authorEmailMD5":"1f7d6a407bb7495bb3c9669535bd0327","authorUri":"","authorUserId":"disqus:disqus_2cbnUKZGU1","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_2cbnUKZGU1.jpg","message":"Thank you very much for your response. I did however glaze over a bit trying to understand it.\r\n\r\nMy understanding is that I want to avoid using another thread from the thread pool just to be able to return a Task for an activity that is running locally but may take a little while to complete.\r\n\r\nMy WebAPI controller code might look a bit like this:\r\n\r\n public async Task<ihttpactionresult> Get(string id)  \r\n{  \r\n Widget widget = await this.Repository.GetWidgetAsync(id);  \r\n return this.Ok(widget );  \r\n}\r\n\r\nLike this because by the grace of DI, this Repository may be CPU bound (my example) or IO bound (webservice file access or RDBMS). It will therefore work with any implementation as long as it returns Task<widget>.\r\n\r\nMy simple implementation is essentially running like a cache (the implementation loads an xml file on construction and then all gets read from the in memory XDocument.\r\n\r\nIf I understand it right, I don't want another thread to be used to do the repository work, I just want the calling WebAPI request thread to feel free to handle another incoming request while it is awaiting the xml query to complete. A bit like a UI thread handling drag/click while it is waiting...or do I misunderstand something at this point? I do feel a little confused about the availability of threads in the pool to handle requests - if the thread cannot handle another request while it is awaiting then there is not much point in trying to be asynchronous for non-parallel activities.\r\n\r\nIs the following the correct use of FromResult?\r\n\r\n public Task<widget> GetWidgetAsync(string id)  \r\n{  \r\n Widget widget = null;  \r\n //...some code that queries an pre-loaded XDocument, populating widget  \r\n return Task.FromResult(widget);  \r\n}\r\n\r\nOr should I place the whole body of my code in a method and wrap that in TaskFromResult - I am treating Task.FromResult somewhat like widget.ToTask() if there were such a thing?\r\n\r\npublic Task<widget> GetWidgetAsync(string id)  \r\n{  \r\n return Task.FromResult(this.GetWidget(id));  \r\n}\r\n\r\nIf I use the async keyword I can just return the Widget directly although it complains about no using await. Omitting the async keyword won't allow me to return the Widget directly, I have to use Task.FromResult or Task.Run, but the latter causes another thread from the threadpool to be used, which I now understand to be a bad thing.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"ead0957f-fdf9-3f6c-b5f1-dd4bf3811bc8","date":"2015-03-27T15:20:01Z","timestamp":1427469601},{"_id":"ead0957f-fdf9-3f6c-b5f1-dd4bf3811bc8","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The problem you're running into is due to async forcing a leaky abstraction (similar to IDisposable). Your interface must determine whether its implementations are naturally asynchronous (just like with IDisposable, it must determine whether its implementations will have unmanaged resources that require freeing).\r\n\r\nSo, there is no perfect solution.\r\n\r\nIf your implementation is all in-memory - and presumably not long-running - I would recommend the Task.FromResult approach. However, if your implementation is blocking - i.e., it really should be asynchronous but for some reason it can't be - then it's up to you whether to use Task.FromResult or Task.Run. Even in that case, I'd lean towards Task.FromResult, documenting the type well that it's actually blocking and not asynchronous.\r\n\r\nAn example of dubious Task.Run usage in inheritance is the BCL is the Stream class. The asynchronous APIs were added after-the-fact, so Stream could not take the (IMO more desirable) approach of being async-first. Instead, Stream assumes that most of its implementations will use blocking code, and so they made the decision to make their default async API implementations use Task.Run. MemoryStream - being synchronous but not blocking - overrides these asynchronous implementations with ones that use Task.FromResult.\r\n\r\nIn this case, you don't have a backwards compatibility constraint like that, and IMO a better approach is to only define an async API in your interface.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"0e2021d2-b737-31db-b698-be091e997d94","date":"2015-03-27T14:05:25Z","timestamp":1427465125},{"_id":"ed1544da-d11a-3bbb-a31b-e9e5d36b041f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Either of your examples are essentially the same. And yes, that's the way I would do it - synchronously get the widget from the XDoc, and then wrap it in a Task.FromResult to return a task. The only other thing you may want to consider is to catch any exceptions from your synchronous code and return a task with that exception (you can use TaskCompletionSource<t>.SetException for that). So a complete implementation would look more like:\r\n\r\npublic Task<widget> GetWidgetAsync(string id)  \r\n{  \r\n try  \r\n {  \r\n Widget widget = null;  \r\n //...some code that queries an pre-loaded XDocument, populating widget  \r\n return Task.FromResult(widget);  \r\n }  \r\n catch (Exception ex)  \r\n {  \r\n // In .NET 4.6, you could use Task.FromException instead of this code.  \r\n var tcs = new TaskCompletionSource<widget>();  \r\n tcs.SetException(ex);  \r\n return tcs.Task;  \r\n }  \r\n}\r\n\r\nI would not recommend Task.Run, since it does use a thread from the threadpool. You could also use the async keyword (without await), which simplifies the code but then you'd have to deal with the compiler warning.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"3401c15d-d0d5-332c-b804-48723e4d3c8b","date":"2015-03-27T16:24:38Z","timestamp":1427473478},{"_id":"9cb9cccb-a3d2-3be9-bd98-fb9216671b56","authorName":"Stuart Wells","authorEmailEncrypted":"JwjZUuHJTb/nWMOxNg/lOMltxPTZwKws1O8ikjYUebnWyZ6jz6eU3+471+A9v65BsprLIQ+oy+6wbKLA7Nv4e7PyEM7BYwYKpKlD8GzMchOVK20dTDduS2kWMJB8LJNizBir8W/1XfQs/eAcH/gezg0V7uWNGlRhv6ENzGmaWwd0OswWKnfSzmTNT4RztzCcO1vHkkq3XKgHD3Op8+rrdFWUtjMNPJhKsnmRPhrFXIrm5Ota/4R9y+yYQlZA83NWsJUILf8z4iMiIthuP1YzELRrJAzqTM0rsqnDVoh2ve/wJQDvuyjgxRGXHXDnMQd8Aqkz19+k3DYUDB1RNAuAp1bP7pG4ZS/b3phqOFRCwr/K5BHpimN05yGV82Kt5QL1Krrx3swjOmrOXqqiBA2aZx9dVtq+YQqL/LpOd6lE3iggV9LdypW5kHHkYyARMdjnQp/9bYzuf+SFY+749J2+coOpQCG6hTrpjqTEZ7khtPw8nouQ/2HKoL3lqVPtXXE1onOX8WvCshbvOmKgZoFFowgOoscAczOnK3LyGwwRkIj14A5Sc6gm2mlcO0VIg6turl32DZV5m5enCdifeQBrpoLIzOBS6090SjfylCQy3OSoBYcVMDrc4zAW5oa1AOVEuw317sbUKX3KRgNqI/y3YXXbeoSDH3QaEgWGNl7Pmcs=","authorEmailMD5":"1f7d6a407bb7495bb3c9669535bd0327","authorUri":"","authorUserId":"disqus:disqus_2cbnUKZGU1","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_2cbnUKZGU1.jpg","message":"Thanks very much Stephen. I feel much happier/clearer now and can continue with more confidence I am doing the right thing.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"ed1544da-d11a-3bbb-a31b-e9e5d36b041f","date":"2015-03-28T14:27:55Z","timestamp":1427552875},{"_id":"9a45ef91-3701-3f80-a1c1-da8c7011c687","authorName":"wilsonsergio2500","authorEmailEncrypted":"Nr8O3VNEHi7XMo0gp0tYKdwgfcdSUtUAw65LL3mC/UQPLVIMvc0+LvUXB9HcOrEBJm3eplaMuZMvvnFNj+feARVi7EsWi1+HQDTjewFeM9GgChdKQiKxWly0xvD7EVZdykCd+MwunOkUEOuSXC1t/WFRe12i+6qdkAKXkSUOdKatyLqaXRuLX3Vehn+EJLE8o+7SUARoE5T18IQxo3DDUADp6Wr5Pjx1xyxbWlD5Z/5OY5Swc8uqds3PWAaw4187o01xlIeDvJGGdyNO+jpcjiDusKMoMyF6wvkCDxWx1kLZt30XcCu1LKq1RIGOLo0SGUMXgxfGANPME9tIRWuWCPIGSNhjkJMmnik6Y8lxOu7byhVlqWkXX03DsvsmFsaNlF1WgtqP+DlR2UJAYJEZGzZj0uhwkHKLdjyHKixVL+5cbafpVPTz6RkYxjMGpMvaJpaFYhJbxVd5lBtHwslGWB+N99CwdyHZbmB7mQY+PHe02SH9IhVW9vN8BCGjNxBz+94x4gqv/nuVnxWkgI3E9aQ0ErU4DGVBeeaY2oDKZn+FsWUxd/8bPBbCEeL8ETwXF3VS0/FAMlpFwkq7zeGRTUeVkPl1BMekQeyqOv+rBKFUEq7LZiDN+zWFA1KxBNVnqzFDZcSqsYn26vOeMiwjgGqpyvK2bBkD7+KVft6MfvM=","authorEmailMD5":"640b950f4f71250e70818d58b1ed7035","authorUri":"","authorUserId":"disqus:wilsonsergio2500","authorFallbackAvatar":"https://disqus.com/api/users/avatars/wilsonsergio2500.jpg","message":"Hi Stephen\r\n\r\nThank you for this post, I wish I would have stumbled upon it sooner..\r\n\r\nWould a better approach be to use TaskCompletionSource when dealing with tiny blocks of code that we want to make asynchronous? What do you think about this way? Does it have pitfalls\r\n\r\nLet us know and Thanks","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2015-04-21T21:16:30Z","timestamp":1429650990},{"_id":"14176732-07c5-36dc-83e6-d2437f55cb3f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The best approach is to only expose a synchronous OR asynchronous method.\r\n\r\nIf the underlying operation is naturally asynchronous (e.g., I/O-bound), then only expose an asynchronous API. If the underlying operation is naturally synchronous (e.g., CPU-bound), then only expose a synchronous API (leaving it up to the caller to decide whether they need to use Task.Run).","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"72c8cec7-5854-362d-88f7-772c8f069df0","date":"2015-04-22T22:49:30Z","timestamp":1429742970},{"_id":"72c8cec7-5854-362d-88f7-772c8f069df0","authorName":"wilsonsergio2500","authorEmailEncrypted":"AAzOYCaJQ6IuLbNJPD20zfe761QKeWhHfcS6/YHgIH/UDjUjRIlms9dTOcQw0oMZumTUIWNPSdLx95rSvy3u55GHF+PBJ7kF0sgp5kQMTLc9UC+neRCFr2H1uAtC1y1+VRC43pssSR9nItYp1Yd4XvDMw7xCgy218KXOexEHdsKtQPVUQg/bQe59t840+NJU6XtCe4Ce0OELhpXqnRn3OTl2K+d9sgdJCLhJMAmlzMj3MNBbEAS4aCbgbjKJjbJAuCzSe7a7G+74nu9w5lVTlwUTStnzcsaLg+PxIHfpHGhsAuQv3Rh0TrpqQwlpEzE8euhk8i+/9nptpfAxcftosX/F0pQFYV9rR9u19NY1bwHQolz1udNoabXkh9DvIehDfUmLPiXVoMcyw8Fj0KxaWYv/sGXcpKXxVQJo0t0n0a8+r2Nj+3msPqZTYUKjddwuS4ieXf9D/iYyjkfQ+2ggUuUdarxb/4SLyZIX+fwepK1uT+KvPmSdxSHgY47oJxPMBaHkGxZIJqd6oyZwnOj9g9jSjTApBtXaJauatbbSPMdOy+bd45OUIqxiD9LOKc5NIgLIhWDx7A9yoW8Zrjwb2/8AVGbuJOhrQxrZfjtj0z19TPgJeKQFR8OOq09m8fxRCZRR11G+hvFEyH07auanv4SXlS6XLD7ZsEfi3dfgE9E=","authorEmailMD5":"640b950f4f71250e70818d58b1ed7035","authorUri":"","authorUserId":"disqus:wilsonsergio2500","authorFallbackAvatar":"https://disqus.com/api/users/avatars/wilsonsergio2500.jpg","message":"Thanks for explaining  \r\nSo i see in your code how you used await Task.Run for when in the UI thread. But what is the best strategy to make a small block of code asynchronous? When not in the UI thread. For instance say i have a class where i would like to expose sync methods and async methods? I have been using await Task.Run all along, and was wondering if there was a better approach per your post,,\r\n\r\nI apologize if i am making you be redundant, i just wanna make sure I code in the best of ways  \r\nThanks!","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"ef5f9f35-23a2-361b-bb29-7f538adcf8a0","date":"2015-04-22T22:16:30Z","timestamp":1429740990},{"_id":"ef5f9f35-23a2-361b-bb29-7f538adcf8a0","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"There's nothing asynchronous in that code. It's equivalent to just doing the CPU-bound operation and then returning Task.FromResult(42).","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"9a45ef91-3701-3f80-a1c1-da8c7011c687","date":"2015-04-22T21:36:08Z","timestamp":1429738568},{"_id":"f5ad6798-5446-3977-8166-1b51281f801f","authorName":"Prasad","authorEmailEncrypted":"NtxURrTiSgnktEoxgM4tAWEt0j/5f4Xbvni+UMITZrQ3UNAJiWoTXW9d/eYG6gstIPIOQ0CqDsmqWzGumIR6aLUX6yGZYPsiSoBWYI9l1+Im8pnaSyASf93XjtufMQtkjrhht8samgZTEh1+8eFlPWBpbcL+vWZiXq3AJ1ZNnpzwjIawvZM+uYPig2H3BSUHtHux6fs3DE3Q6X5M1ocw1qYSpDsnZt5+aWTSVds3xXCL81qnVMTr1oSdBen7LRQJWhFQABpZQ9uU/In/UoraXS2dGc7iw240F11NdW2WoB2Dv6K4B+kQV/th1QtDtXaB7RqO0nvjl+nQ9QxD+1p2r4W0oaEedrpwF2OV8lE84gtRlTa6ITXQ7Ez1l8YkqpvYYQcdh8egVO5E2BAPdc1vh7NyhtGFL+G9jrKt96mQ5f2avX0dWhAUm2i0PouHgsiZFJWN+A6ffgB52VIPgbSrMN6am19yX+OR30Hvoslq4iapGU4VxPisyB2kv4wtGz5uruhY6i03RlDHBDEm+mDfJCUndsr+yG/H/CcTRH9IguPqej9f3E1mq7Q5VJUH/i8fKYdtFcdrhD6QVTslNnhndIUuHSFozPcBuI0P68vrOfATDgZhiEta7J0DUBY3bzbGHvY3+PPD3pwmYk+YzWNNNQ6M/Qpc0G46LFA9Q3O27Sc=","authorEmailMD5":"ed84de8de17c845d622079117ecf1895","authorUri":"http://www.prasadthinks.com","authorUserId":"disqus:PrasadPillutla","authorFallbackAvatar":"https://disqus.com/api/users/avatars/PrasadPillutla.jpg","message":"Hi Stephen,\r\n\r\nNeed a small clarification on \"configureawait(false)\"! in your example, what will happen if the call(IndexAsync) in controller class(MandelbrotController) is refactored to \"CalculateMandelbrotAsync().configureawait(false)\". Would this put incoming request and corresponding response out-of-sync, like if we have 3 parallel calls to the controller Request-1, Request-2, Request-3 and if all these calls are handled via configureawait(false) hint, is there a chance that response of Request-2 getting to either Request-1/3?\r\n\r\nWe are working on fine-tuning webapi deployed on azure to improve total number of requests served by webapi and also response time to serve one request.\r\n\r\nAppreciate your help   \r\n--Prasad","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2015-08-13T20:00:06Z","timestamp":1439496006},{"_id":"8a2423b6-c86f-3e69-b0eb-9e5cef25e78b","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Adding `ConfigureAwait(false)` would not send the response to the wrong socket. However, I never use it at the action level because of helper methods such as `View()`. If the `View()` method depends on any kind of request context (like writing response headers, or changing output based on request culture), then you may not get what you want.\r\n\r\nAs a general rule, I always call ASP.NET methods from within a request context. So I don't use `ConfigureAwait(false)` in my action methods since they end with a call to an ASP.NET method.\r\n\r\nOn a side note, async/await will *increase* the time to serve a single request, but enables a higher total number of requests (assuming the backend can scale as well).","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"f5ad6798-5446-3977-8166-1b51281f801f","date":"2015-08-14T13:51:16Z","timestamp":1439560276},{"_id":"212d58ae-3aed-3029-b826-14e2de2d4d0a","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I think you've got that backwards. :) Async has higher (worse) latency and higher throughput.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"57430e76-fb60-3e52-a0cb-075ea85f45d8","date":"2015-08-15T16:40:03Z","timestamp":1439656803},{"_id":"57430e76-fb60-3e52-a0cb-075ea85f45d8","authorName":"vetiarvi","authorEmailEncrypted":"apIhQM/9QBGUyUobN46NG98a+6/PzqMO7MZ04sScxvRZ9bpg4OvoTnUva+cplD8TYhYpyw/jwPis8pXYbuPaJgSktvUIGS+oeq0K+v0E91RpNO7XkyXKDfZHB0e8rt4kmd/eYryOyOq4R0PyAyoQ5sKzxkOGB0vU35E89QJD8WZ6Wylgv8HywND/1UcLwcUokFcicbqEt5E9T0R1P8WanxxccygqZuQ62p+HiUXKILvgXK0328qMAik8+HShJMolB2nlDQwBS9h2bk/0NGWTTCoioKhRw2q2Yz1A5lfVRV+zdsJ4DMFmdiKE38ZZnfmSXVz/sCXquvwBD4AR3SdTr4DqbuC7Dw586XtwL5soHC1iwAVOrjlmVYCFVAm+QVzGj/NIkneJVN8GMfHM2nAB8AP+Y4VPRnYjMaR4mKIt8xRZCrCURdwdVgFfFn/B6JoZsOcpuRcwrm9rWEMfsbVgAYp9KoYEXOxPKCEPjN9DJsHy+CbWv/bT0OZN68auG7oaCxPJRXkWDjSzDSw+LAL3mCRUXfgCYw7q/+7iiPbcVcuXU6cSNbFEp6bXCPSUBABugv8sozNvWyWBmZR1Naz13CKHqT0lnNWmxB3PUE9F8RBRbpSZfqhbp0YNRf9QhW4MkEhj/MJwpoRef/EtAY3TV24xHZvJKo4zZEdkmtY3OjE=","authorEmailMD5":"7b6460d94795ae02211b102b0dfe5355","authorUri":"","authorUserId":"disqus:vetiarvi","authorFallbackAvatar":"https://disqus.com/api/users/avatars/vetiarvi.jpg","message":"Yup in general, async has better latency but poorer throughput. However, when used with the command pattern and some offline processing, you might actually be able to use more resources such as other servers, off-time processing, etc.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"8a2423b6-c86f-3e69-b0eb-9e5cef25e78b","date":"2015-08-15T06:42:38Z","timestamp":1439620958},{"_id":"13428b14-1061-353a-a785-9562db8e9fad","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Fixed, thanks!","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"4d6bba49-75c1-31d5-a653-f4c56b14ea24","date":"2015-10-20T17:19:16Z","timestamp":1445361556},{"_id":"3dbbee94-63f7-3707-847b-9b5ff1fcaace","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The ASP.NET thread pool *is* the .NET thread pool.\r\n\r\nSorry, I don't know of a source off the top of my head.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"5a18295a-1907-312f-b16e-d7266852e939","date":"2015-10-20T17:16:54Z","timestamp":1445361414},{"_id":"5a18295a-1907-312f-b16e-d7266852e939","authorName":"Doron Grinzaig","authorEmailEncrypted":"eLZeWE0gW3RBb5w7z31lKlSBtUk6+TW9kQVDPDYt6aiBGW7/9OPvLAjlB4vbvS+XXOsepsJrwAL4C/wEFZozHjvZruwuoyKyiYLCJTxCYfmjTH1hWn3mbUlxNNgSfAQf8ikD8eI/qtvNBUjWOc76jYgyMoLlSSy9K6W8OWgqugsXlsKDRZLuO/am4tPXL5x1pF3DWWqk6DjYCRDqHZAH9oKOYtqZEINWCzOoYsHlTcf2ila5lQK4zJoWnVIiI124v/Hdgd0NjfMhOYBY9veuJSvtTLGwzDnKYz7wTqAYY3NZI8H/rvBKK0oeCmZDKYmgQjQNta6WwMheq9Z7QxE27RcI/yTIH8ocodb3zyXJzjxCJaKbUn2tuFkxs/JYYFf3OfD7ufrED8EBZdlXkR+qrJwZ++3b9K3pBQibinWBQenbBCuDcGTqgB+caKtFfDRIWmuMYR+teNuSq0cFqZ2ATNLCWmjyGuYleeLH6uzWFw7pmuo+/w9e0Oto9c7CR4b08dRasU6R3la1I3krAlLb39s0VqV++3gcbmypFsVuY9zCe81sNJnOYI/S9D6GOiTpPDnnCtNktdKflqsasH3rWROlRU65s9LsJUHds/RcPNaqePrsbOH648GjWIIBKovWorOPCk4Zxp6kf6aFh4EwCg7VE55CMzlEgNONebtAYiE=","authorEmailMD5":"02b2b843388c866cab51a735f817b291","authorUri":"","authorUserId":"disqus:dorongrinzaig","authorFallbackAvatar":"","message":"Hi Stephen,\r\n\r\nI had the impression that using Task.Run in ASP.NET releases the ASP.NET's thread and \"delegates\" the work to the Thread pool (not the ASP.NET thread pool).   \r\nAre you sure it takes a new ASP.NET thread for that? Can you link to a source saying it?\r\n\r\nThanks,  \r\nDoron","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2015-10-20T16:21:44Z","timestamp":1445358104},{"_id":"53adcae2-16fe-30eb-814c-cf56254d4af3","authorName":"Ab illo bene dicáris","authorEmailEncrypted":"EhH1jnVgYWeIzYizqRC3bsAOvgwyN3BSGNTBYd8DiQMAxVuCtGAMsymIddLPCxFlqsUmcj3xwZIBuzq+izbChfqAPqvzDRMcQWJ02/Lpd7q7I0z11zeG1+SFvCdw//HSvJO1WZYpDVQPpmo0c9yBWZo0FGMSUJksH6Hf1zJrk70TBMqjFU+MIXJl9ryMo6jtL6TYHJOdhxCRqlCAkKWdVeYXMa5/Fc6Dd5VTZ8Lpla7D/uQiJ5WZ5O04gD6ZSOlDUMbdL6cblBNsxH7JL+2d6bTfhCq5MuAk7RSTAC6PhPDS7qJvZcJe/03AWaHVCHtQaMvB2knNfo0I7za3Bg5Ghb6lz/WMrzXO10CyvLXudKiQjDvzM7yAknZthWXqa6QucJ/Y7iyik02voyAszZc1ivFL+j26me3CC/A0r0v7nGHXe9qGerQR6fdZlNdPZAkpDb9QcKdRNzy/7JojhiIkfXiVOivpktmIFxL6V5gJGSmGR5bsNR7QlniJYLp6Fq4ghErDCbePP3GWbiR2y7zzWMh8uWxnNVtfaZO3/Ch3VOk8mg7yAQTa64fSyCvvSdb1krWYPQlyHYC4+YC972F/ta1VRF32gqhAVU1Q2FlXt9eq8OADIizB8hM3cLWKJRQ9+thqojshx5GCdVOvZ5mGHicNYxbukQ8Wiz5UPl/CgkE=","authorEmailMD5":"59720fbfa214ebec03629573398f7bf5","authorUri":"","authorUserId":"disqus:abillobenedicaris","authorFallbackAvatar":"https://disqus.com/api/users/avatars/abillobenedicaris.jpg","message":"Every time I study TPL, I'm humbled.\r\n\r\nThe Task.Run() is described as a short hand by Toub at MS for Task.Factory.StartNew(). StartNew() gives fine grained control over scheduling and some other parameters. Use Google-Fu for the article.\r\n\r\nI ran with this notion. But I now I learn that I am in error here as well.\r\n\r\nMoreover, you describe here that Task.Run() is designed for CPU intensive workloads (I think mathematical computation or graphics conversions or sorting algorithms, where floating point calculations are performed by one or more CPUS). I've also read debates between Anderson and Marquardt about whether I/O should be async-y (\"Should my database calls be Asynchronous Part II\"). I have assumed from MSDN blogs, et. al. that when I do Task.Run( -> Some I/O operation with latency (DB, web service fetch, etc.) that I was delegating to a background thread, thereby freeing up the ASP.NET thread to continue servicing requests. This apparently was a big mistake since the operation is really not computational intensive. Database operations are I/O bound and depending on you who read, they are either are/are not usually good candidates for async/await (I think Marquardt gave reasons why I/O can be a candidate for async/await and Anderson accepted these). I realize that all of this is contextual, but the information at this point is quite confusing and it's 2015. I am not seasoned enough to understand all of these concepts, so they are probably clear to other developers.  \r\nIf I have a repository backed by a pre-async-y version of EF, then doing something like this Task.Run(() => _repository.GetCustomer(123); )  \r\nis no good assuming that GetCustomer(123) is just doing a single row fetch from a database table whose server has latency. So, doing something like public Task<someactionresult>() GetCustomer(int customerId) with this Task.Run call in it is not good because it's an I/O operation, not a computational operation unless the called method is doing some computationally-intensive work.  \r\nGoing forward, I'm more or less adopting the mindset of not writing any TPL stuff in my own APIs until there is a demonstrable reason to do so (customer complaints about performance, etc.). I would even prefer avoiding EF async functionality until I get a better handle on this. Toub says Task.Run() is shorthand, in another post I believe you say that Task.Factory.StartNew() is even worse than Task.Run(), suggesting that it is **not** a shorthand with some defaults set for the scheduler, etc.  \r\nI find it all very confusing :) But thanks for doing this blog and the concurrency book. Hopefully I'll get my brain wrapped around this someday.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2015-11-08T00:57:55Z","timestamp":1446944275},{"_id":"f7f673b5-af3c-355f-8bb6-f0564b8aa583","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Task.Run is much more than a shorthand. Task.Factory.StartNew is downright dangerous because its default parameters are wrong (for 99.9% of apps). Easily >95% of StartNew examples on the Internet are wrong. This is why I always recommend Task.Run.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"53adcae2-16fe-30eb-814c-cf56254d4af3","date":"2015-11-08T03:37:17Z","timestamp":1446953837},{"_id":"b9b0b7ea-8f3e-3b98-a3bb-46ea53a27943","authorName":"Piotr Sobiegraj","authorEmailEncrypted":"Mwo1SfI8TVoHSpzs5oTR3neaJvi7FYdaRKPTDn5/OaIDv9Za4QG0Ev5OlPwDRWxodcsMcH6oQjyF8uFL8tU3oszWQukIOa4kqAnRfPvFi78iC5XhHl+iB32roARFprJjG/IZemPgMp6x3YmuDfnwqVMfA0SBAVeV9t3QHXi8pH8Ehkm51wBbjpTbkyk7mMQkv3LJPt8xRdNwNs4t94YaRyf0qhNPfULBMDm4ChXpU7xP4R3YSNV3YRFvBec4g3DIJkiey5fug1jmI1DybiCyDvPCRwbEH2JQSDFew9nuoy96QgC+fzYyJ1MioaDvtYgINwdZ14ce+kfXDGM+NlbtsEZ3BHPZWm56plBG5HjUi72J/4TlyW7ImQ1qsZwsQldThMLji07JJDwXDmydaGEdHxBnj+7QiC4Fomkqv5q2EamoVYjfByoWQaFiS3z76+xB7vEAf72Qaqsykdn2n4F5mAzN/H7tiWfLX0504hEbZtn0y1sqgEYB0CWRarcfYXG40GExH4JiiPiUkKmKFFhOpo6QhMWSd502vLznJJldaCBxFSsfhqHOe7OvStuhvLznn6g0cOFCSFUZEoMa6b2K4EAR1g1lOvHK8lb/Ib5YkNAYsPnWABns2As228myVyc7NGmDKweVJxtqJe+KPl1oSNERGNveCurkHRcdeannNhM=","authorEmailMD5":"f4836065c2b1079021dd542a674a0ec3","authorUri":"","authorUserId":"disqus:piotrsobiegraj","authorFallbackAvatar":"https://disqus.com/api/users/avatars/piotrsobiegraj.jpg","message":"Hi, some info you can find here: [http://blogs.msdn.com/b/tmarq/archive/2007/07/21/asp-net-thread-usage-on-iis-7-0-and-6-0.aspx](http://blogs.msdn.com/b/tmarq/archive/2007/07/21/asp-net-thread-usage-on-iis-7-0-and-6-0.aspx)\r\n\r\nInteresting parts:\r\n\r\n\"So how do things work, exactly, in integrated mode? Similar to IIS 6.0 (classic mode, a.k.a. ISAPI mode), the request is still handed over to ASP.NET on an IIS I/O thread. And ASP.NET immediately posts the request to the CLR Threadpool and returns pending. We found this thread switch was still necessary to maintain optimal performance for static file requests.So although you will take a performance hit if you’re only executing ASP.NET requests, if you have a mix of dynamic and static files, as we see with many large corporate workloads, this thread switch will actually free up threads for retrieving the static files\"\r\n\r\nand\r\n\r\n\"If you’re curious to see how much faster ASP.NET requests execute without the thread switch, you can set the value to 0. This will cause the request to execute on the IIS I/O thread, without switching to a CLR Threadpool thread. I don’t recommend this primarily because dynamic requests take a long time to execute relative to static requests, and I believe the overall performance of the system is better with the thread switch.\" It's about a MaxConcurrentRequestsPerCPU setting.\r\n\r\nSo, there are more precious threads (IIS I/O threads), but they are released by default, and code is executed on CLR Threadpool.\r\n\r\nAlso here: [http://blogs.msdn.com/b/tmarq/archive/2010/04/14/performing-asynchronous-work-or-tasks-in-asp-net-applications.aspx](http://blogs.msdn.com/b/tmarq/archive/2010/04/14/performing-asynchronous-work-or-tasks-in-asp-net-applications.aspx)\r\n\r\n\"Q1) How many thread pools are there?  \r\n A1) There is only one managed thread pool: the CLR ThreadPool. This is the thread pool that is used by the .NET Framework. However, using Win32 APIs you are free to implement as many thread pools as you like. Almost nobody does this because it is very difficult to get it right.\"\r\n\r\nWhole article is worth reading.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"5a18295a-1907-312f-b16e-d7266852e939","date":"2015-12-14T20:08:54Z","timestamp":1450123734},{"_id":"5006ab6f-24d9-300a-9be3-c09d1c399dbc","authorName":"Giulio","authorEmailEncrypted":"pHbNS2Z1AFYFLFV6bBnUfpkm1SVrCzGJnUvuujXqRNWszCkgWbtp4ndO7IjitvawRrVMGaEIlzR04ISSBZHYwKEDT6n/4L5OQPuvnbD4IeFNMG52A8e05yaGDq039nCcr36ibeMMqd+Ad0MKLEOQiEMsqM3KekYqSq4qS4sB9qiribZq/3uGeTCeJphw51cF9N9b21UNaW1BKW+dotqNjorIU/jQS9fTZSbnsMiWkNIHE+PSlHNaq1LbovPBuRm8Twnanaiu/+MGmrkOpKW2+U34ESX0Mc5UemY7DbisH5a+uML3RX9Fn2lwjrk21QS+L7yUslNbEFgi+nCkjQcEnUZ8K/vdumsEakrjCRdAu7i3HT4sNo1mpfsnqhOU9B/lVHvKH9nwzg0gAZaKqdqRHnVPjjbPm/naHx8a0UNaRTUoN8nO6pfVN2a4ksCMr+vc59aim6Q1OslHD8sFMzvXWkzuKRV7/fNIuYVRwZoDDfeO1a+ENaeeJTovdxqJKSFSGE4SMG8EFZG4oyEMIAG6jGYDp5mW45vMnPzqJ1F9DXJTrF4d/1vfJBVPethttik2J6iwxKJxy1kTE9O8PPd2R/lD5Q2I72GvTktgQ9/ZtxOpO7uPh8PaeCspt9NHk3fav7OtflaOsddZQH5AIy4lpdGRBOKKXQLhNNB8vP2VbqA=","authorEmailMD5":"d040d48dc09031501a031acd841cd580","authorUri":"","authorUserId":"disqus:disqus_f9KlsNfakp","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_f9KlsNfakp.jpg","message":"Sorry, as per my comment to the previous article, I can't see any point in using the a sync await in the final solution since the Task Run already seems to solve any worries (i.e. it's not blocking the ui)","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2016-04-29T09:00:26Z","timestamp":1461920426},{"_id":"a04b27c4-012a-3aa7-ac7d-84e497f23950","authorName":"Giulio","authorEmailEncrypted":"DDa9GcFM4vOSdtwSTtvxcRfRZmFYomJZRgoWjSr5KRb2uQQhqgCeQNVGCRi0VapEkvjGFhGHrNtk4e02glswQqnzS890eU1PCxnvGI/mLEC7zDQjYaj5ny1srk1F4XYTWUuwwXV6KXr+q63Ro5efIC2viBBHo9ya6dZCJuVChnAsd3ONk/6H1nmoeRyhFYl8pxsQ6mLte7cPgLFDAN8dBmvQ8Mhe+JFCeAheqITWu0L2yEtS2HUKrdyhLb0TLTY6Cew8ngSSI5qNrQc5JRtPWOz/UVm1J/WrANWC+FBeW7Ax8zvkfPR//ZW4vteSDKLYQ+qI869DDjGQrboVmdHfNYybOP27/HaHTzrhGHimOQM5+U+Rc7omqu7pw6pn2hqZUnyhpzfTTooizAR7o8AHUe8movWkkb+qdMWiEmqj3K+p/2u4QUQhX/Lyab1aYDXxGjYyY+snK6yOM8Gd0q4gu/yWFxWFvbk3CryK9xqFuEFL7Q0hmBX6oZQJdkJFBwXGQ15v2rhJG8rupEnUt1HFLBexny8otRzteQ1d9X1dXEPHYQPfwVpcxHRC3rl6nKq+2/x9FQpCyNYyL6FBWCcTcSThLD6MBqYd6haf7agVQvSxcGxJvACaFNbePkkXDP0wuKvu4wV9fzixzdfETeruq7uyljSCJXYA9oYnpYOYP9Y=","authorEmailMD5":"d040d48dc09031501a031acd841cd580","authorUri":"","authorUserId":"disqus:disqus_f9KlsNfakp","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_f9KlsNfakp.jpg","message":"Thank you for your answer and your time. In fact I'm doing Task Run using the results as \"closure\" in the ContinueWith passing the Gui Scheduler to show those results or any exception. Unfortunately I don't understand how you do the same with async. It is not in this post, is it? ","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"c6d8f7b1-2b74-338f-9f12-fa5370ebf093","date":"2016-04-29T17:44:26Z","timestamp":1461951866},{"_id":"c6d8f7b1-2b74-338f-9f12-fa5370ebf093","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The final solution uses async/await *with* Task.Run. Task.Run pushes the CPU-bound work off the UI thread, and async/await causes the UI to retrieve results of the background work. These \"results\" can be an actual returned result, or an exception. Just using Task.Run without async/await will act like a \"fire and forget\" operation, which means any exceptions will be silently ignored.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"5006ab6f-24d9-300a-9be3-c09d1c399dbc","date":"2016-04-29T12:07:30Z","timestamp":1461931650},{"_id":"4a8e46d0-52f1-388a-8429-87e24051e9a3","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"You should be able to just use `await`, something like this: `var result = await Task.Run(() => myService.CalculateMandelbrot());`","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"a04b27c4-012a-3aa7-ac7d-84e497f23950","date":"2016-04-30T01:37:34Z","timestamp":1461980254},{"_id":"5a75c4f5-299a-304b-a661-fab5f71c4d68","authorName":"Giulio","authorEmailEncrypted":"HexhkWdwS418WhlKd4zG2PE8Lc94IawXP7xbK46yPvCPiwwmBM2ldUvkvXudGiQDtcRelAKnykD42OC9HKRqZkXKTQRXdw+/eUnQZaDmDsMy+negp/ZZluvUC/vU4LItRjjfbHXoZO9wGtChTQH8oWCCnbAcZZjlwctewyhvr1jx3b/zJqucoWvgB7Nh6oWJM8ZzNLwFe69CNnPP1nbEyXU+F/a9gPQiNSQGprGW0IxTtwAs5xEmMoSHdXEROypYCpvEHp/3c438dfBWtNf2r2JK84v5Az+2prR3qCkaMY/zAf4VUB2z1Hc8drN0aYjWfRtXTOvVHv79jGAnnyRry3qmxGKk/5DW/Y8ZcwVBkScNjcHplSsPlM+TQcyobMJxQV8wXHK76y5GyuvNA+/xRkGvZGuN3wWNshqSLND6BU30yMczBNIt+amEXg4Arht5QvcbzXEipI+SH0DHVeAahpAI54ruRgcuB/VKa4u6yZAHsYvGoZ5UYDjT3dykn2cUkRUdnLqrx7x07jfqiOhhhCMq7CxEgjfc65ojw/KoPcLhWF2yJqCF4ZAXSMdbeyfvFKr8QvpbzZJbypmFlMaGvc6iB9HP1a30o0bgSvrWt3eHVCWXCEaH0CBtKKeUWuGdkH5zEsSHoJduDYK7lQ5o1u71mPI31JLpRcwqeJWfLCE=","authorEmailMD5":"d040d48dc09031501a031acd841cd580","authorUri":"","authorUserId":"disqus:disqus_f9KlsNfakp","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_f9KlsNfakp.jpg","message":"Yes, it is what I tried. Thanks. Suppose I want to disable the button: canRun = false; results = await ...; canRun = true; For some reason, that was not preventing double click and I've managed to solve it without async, but with a continuation...","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"4a8e46d0-52f1-388a-8429-87e24051e9a3","date":"2016-04-30T07:37:10Z","timestamp":1462001830},{"_id":"66080c75-34d1-3ad1-8670-27bcc439fa54","authorName":"Giulio","authorEmailEncrypted":"MUHBQ1L8Av94401fuNnpPNkmPx3uJrPEHRP2uNnkICSH2q3NWCPIT7nJZO7q1BROtkzvkwUdvcIk9fSIl+W2Jb0vI0KSfxZyY0nhYsgqwDYF2lMoSnTF0T7FVlyv8duLi0KmZKdtpHJ306coxS6G5jERWJY8b1AThftZNMpWJt3ypuEJjgm/C+N6kK/h10Iu3HcYR9YLKxTF/f3Vvgf/yFuNNN5fky4TAGXWraBVd6p1Bvf4FnS9+7SswLxZPw/Di/JkbnvAAloMLh4ttvp6yGE0wX+9/rPmGIpTmP5Tsfk26f7wMTDlDurJ7u7B0BJZMgXC5dKWOlndOLk0Ez4+ptI1AeFpswI67OlcgKlaZUmjKslXe7xl2dGijobheqSgFkSwiTOlqRfeKmgViJVyPcFzP7Sn7fKSzIbUPyvCGRG0cf8jQoAtl7ucWUtW6iOxMFdHf/XQtK2Ao50904WicGR26ibmyonHO0KAeIt6UX5vWre4EvwbsNPT0uX4/yjm68yQwIpUI//L4q3TrCP1swBqMt839/OEM67ay69s8bh3FJyjEoXbZ4g+oTvm+pCwT7tcalEE2QO52riSLxZ8/bPFbtqBzcUnOuevuV/im0J+ZTvsJ07syPJEFt/lhLcp+ZrYW1j4HbEFIFsrPExOLFCJ40df2Itm8u5ij24COAk=","authorEmailMD5":"d040d48dc09031501a031acd841cd580","authorUri":"","authorUserId":"disqus:disqus_f9KlsNfakp","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_f9KlsNfakp.jpg","message":"Update: Well, I think it should work the same with async await :-) just asking confirmation here [http://stackoverflow.com/questions/36956334/async-mvvm-how-to-change-notifytaskcompletion-result](http://stackoverflow.com/questions/36956334/async-mvvm-how-to-change-notifytaskcompletion-result)","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"5a75c4f5-299a-304b-a661-fab5f71c4d68","date":"2016-04-30T14:55:41Z","timestamp":1462028141},{"_id":"9e8f9b09-7f89-3a42-9764-cffd8d0c0fcf","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"In this case, the deadlock has nothing to do with Task.Run. You could replace the whole Task.Run with a Task.Delay(500) and it would still deadlock.\r\n\r\nThe deadlock is actually due to the use of .Result from a UI context. I explain in detail here: [http://blog.stephencleary.com/2012/07/dont-block-on-async-code.html](http://blog.stephencleary.com/2012/07/dont-block-on-async-code.html)","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"af2ec481-3bca-3477-9372-34c716f6e698","date":"2016-05-11T13:22:40Z","timestamp":1462972960},{"_id":"af2ec481-3bca-3477-9372-34c716f6e698","authorName":"Mike","authorEmailEncrypted":"SKVIan7xuWm+xDGRkdUufE8kC1yQaqwlBlB6c/iGXO1G5x8wBGeyLgdop5mFMlJwR4vguM/HAcsuLrj+HU49mMGzAv23CmlTwhiiHMtUoe4I0p/9kNs0n88T/7t3iQrF+11zpaCAxAfxdDQ39Uz5mSjsTLY+LtTjPHD4S2tEu+lceZNf9gY+Bo9CTyGZTwCHuNT8Yp7YzSm6owYf2FV3wkygTQj8AvmqSP36+Ch2ZaLlxeMJq6JDoQ2HprAi4Dj0W13Oc45mQUIoujGMOGEPH5ljmEdEdyf/P6sWlirRgoo/q+0kEXKvuEkSZYZ/BKwn4UzO7WfT4QeMoKBasXFpwwkY0jglE8/2j/nBhbuCKZ6Vdn3ZfiN4h5Rh2EkvtbIuwniKMIWkZfkrAVz6d8caplP04LJKJxlijUtTUMIcdd1g1CxdI0HcTX3kjFPhEvomCvNodt7aSQzIxQcAidEbwBCrBEucwGe6aJia+ETI0eE8wUBFxrmnAqlEYATB9qFYe3+4EJzQYOstkAOaCYhJadba70qzHc12I89dvFRA/L660cf/wONcvNq4bGrinHJEsC2m2Dw9wdAXJ0Anj/aUbMjDQVmZ+Lbt4tq4uCn2HnD1nBg8m9d+267MWdQjFyonwIXyVY5LfgoeFEEu+UffN+wwYlGDMkiJE1VOF37vhN0=","authorEmailMD5":"d9df2298132d23d787476d08346c0b84","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I tried another \"wrong\" example, i expected that the UI will block until the result is calculated. But the UI will block forever and the result is never returned. Can you explain that because it is a riddle for me:\r\n\r\nprivate void btnDoAsyc_Click(object sender, EventArgs e)  \r\n {  \r\n long result = doAsyncWorkWithResult().Result;  \r\n MessageBox.Show(result.ToString());  \r\n }\r\n\r\nprivate async Task<long> doAsyncWorkWithResult()  \r\n{  \r\n return await Task.Run(() =>  \r\n {  \r\n long res = 0;  \r\n for (long i = 0; i < 1000000000; i++)  \r\n {  \r\n //Calculation  \r\n res++;  \r\n }  \r\n return res;  \r\n });  \r\n }","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2016-05-11T11:05:14Z","timestamp":1462964714},{"_id":"ebae0389-7a14-3c34-8881-cbc06157a0a2","authorName":"Mike","authorEmailEncrypted":"MDYxu5T8pre3mqw8lE9UBXgIWqfIK9E0zxBAPDDzEl+lr/Q0Uvuu2O8CLmf11bvGdWTKFb5PGorV4dE5RzDlI3R7BE7D2hWtgK38ECJZg11EHwvGf7EIdeQ2HqZsqhzH3Wv1wgJlMaS9xjBgwjb5FaLXOVMwYg/HLepF0yzZWhshAlLazsrcECxKHxr7AkAddYbg2wKIQSONkrT55OA/LybGyYesyqbPBiEc1vCG8hlvVfh+HLyb+vAFqOWaIHjvhi9rBDuFaCmHaQD4KgREmGVfdOqCIzaKHs3OMlcizeCVvR/hOmdofomYIhuQfsBDvb7bVUM8oToo3uMuXiCBDl6cVyM9RPGLi6b+wCk0Fe/0xo5YJltudghK319N3J7p5IR16uNlVRop3MDLaVcFhP3MH/R7jRy3XmxLF511vN6P24bwcdWU1djI3R7g6+NmI7US3izX2IV+QWAayRsxWsgIwHbbWkD1PEpchKpuXytAxUG3M4td4fkGJ3IhbOvTLWs6iUccEnQYCkclDH5V8GYVQ0qwOWhfvIVw4W3ngYDMYy18+Zt0N3o1eZTuZXR1F/HM0v51IrsXldDouSx6IJ9hUFQGnbsJ5xBF/rJ1MOt9i9W8bhQSkZ4Rd7uevL0tHmLVBKndCrMz8t+0sCOtan5pfIKX5UDQPMw1scplHbc=","authorEmailMD5":"d9df2298132d23d787476d08346c0b84","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thx, this helped me!","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"9e8f9b09-7f89-3a42-9764-cffd8d0c0fcf","date":"2016-05-11T19:09:36Z","timestamp":1462993776},{"_id":"37d1df41-5d2c-3d4b-91ad-4cee83d6e4f2","authorName":"Avi","authorEmailEncrypted":"llf5TMkZTNYEXU5OBKiwY0soG5ZYWittzCAYDuQYz+2EQBGqGJdBzd9mjesHArghVrskXBJPX6Owov0b+IZdnhpmmZmH08fuLDvGGd8wN4Sn2XK82VqUxZco6tx05HwkbkasKB1qJddN7oV/ILXBBcnoTNRAQmDvX86YfITKgoCwQ919kFgnZnIYIWcE4WoLBgcCZYXPaxKPYZWdDVJMTjB9/CyvDVHjWah3q/5pnQ+N9qpCwke3irdtyURbTRg5te7IDu5qOm2c4/bQ4lulfGue925m85b2BwmJy72BscJxxUaDvlrP23cauQZJJfuFE5Gs6IJkpo/bRUEHkjzGhXkYjk+pPO6nXuIHfkcVpGvPx7H54j27h8JIBk8XpKbc5YLQbwbdDNAmMbJC7G6AbJlY3LUMOdjF0r7eHmw99e1QRT0nUopspwq77RtL2RWOXG1ebKkEsOCk0pFHX0vLBvSILPoYOgIirKimCWRwJoLxZw+k8Fa4qDLWRUJldqGNfWRgO1pPG07dLiY4/n9dfFLd4V38HPgkp/+k3RLhK4U+e5QBNwHkBx5vo3WglwkQw3j3h5jIrp0ve+p7HkDfpj0y29RoCK5bFylVqi1quiJZ/1XYc9M42nauXWyINMPLo/ikNUq1Ar144wjqNCLsJku0HtKywUP4YBAbLQMFGf8=","authorEmailMD5":"98f19d70948a72ca4a5a99b7afb49494","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"\"That’s why one of the principles of ASP.NET is to avoid using thread pool threads (except for the request thread that ASP.NET gives you, of course). More to the point, this means that ASP.NET applications should avoid Task.Run.\r\n\r\nWhew! OK, so now we know what the problem is with that implementation. The plain fact is that ASP.NET prefers synchronous methods if the operation is CPU-bound\". What I understand from this is that by using Task.Run() for CPU bound on ASP.Net code we might mess the Thread pool heuristics, so it is best to run CPU bound code synchronously. However, what about creating actual threads which and run the CPU bound code on those threads. I'm guessing those explicitly created threads are not borrowed from the ASP.Net thread pool","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2016-05-23T23:57:10Z","timestamp":1464047830},{"_id":"7016fa64-ba62-38d3-90bf-88c772b2ac07","authorName":"Avi","authorEmailEncrypted":"ZRcl28He8zix3piQdeDb42SqGxosRqBiLjGMdddTl+XZWFoRKC6cxH2MJwtUBgQVQNoNRH+aMTp2eI31jQBBWFoteGrxuSrXrUc9BiMSP0y2kLRvJzjiGgV7jlrHcLTLxLqYx7cmixb4uich3zzDr67zIB0bItsvYg5VQC/gj9c0QO1r8IzqgsJfllQSVSmVY5MNYwxNKvfTjlgNB2oQRIXMk4GpwXXAfbQy4PX1n5VXjNgPOqAUgwlUk+Zcv4iqVbQe1oiF8XJTCA5+AySnhPXLLl+Ch9AzxP0vQyxjrjVoiYPVAYx9fsBu+2l5e8gakpxjctr7x2dUcH7zH5qe3SB1iQq5KxPJm1AEQEmtPC4bt9Jh0phsE34L0FgDdSL/vfz5kvff4J7ehwjZXit3agxB2U0B/5ZtnE2w8MPWEmHYyKeFMGCUKBr2o4pqamdVJcGAgpraGc0t0HSBtjQz45uy8pMUuJT4IfPHUdK8gJX6uCEYE/OITYstzMKGO5Aoe6rjsYtJ3CRSm7WyODhSoMTmxzSlbRi5MLNmppOuwL2lqTOJ3qDCKhkuZCpSE2Pp6HRXZfS3el2piHIO7b94+QI8MEGL7WxngamIyVzqLEiqV54nNLC4Y/YoD0jh9fc9nujCQcpaWEsFviGP1yatCeLAVdQxp9xRAcQvDnhMX/Q=","authorEmailMD5":"98f19d70948a72ca4a5a99b7afb49494","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"So, let's say we have one thread initially that is the request thread and it is executing the following pseudo code\r\n\r\nController function()  \r\n{  \r\nDoComputeBoundwork();  \r\nOtherthings();  \r\n}\r\n\r\nIf there is only one thread which is the request thread, the processing is synchronous, it will execute the DoComputeBoundwork();and execute there for a while and then go on to execute Otherthings();\r\n\r\nNow, let's say we were able to push off the DoComputeBoundWork to a non [asp.net](http://asp.net) threadpool thread. The main request thread is free to execute Otherthings() while DoComputerBoundwork() is being executed simultaneously in another thread.\r\n\r\nWe are able to do work in a parallel fashion instead of sequential. Please correct me if I am wrong or I am missing something(which I think I am).\r\n\r\nThank you for your patience Stephen.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"b1e393be-2011-3fc2-95dc-a0a7178cdc4e","date":"2016-05-24T20:50:50Z","timestamp":1464123050},{"_id":"77cda795-102d-3345-af82-5aac09b6a4f3","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The request thread is fully capable of running CPU code. If you \"push\" the work off the request thread by doing `await Task.Run(() => ...)`, then you're taking another thread, scheduling the work to run on that thread, and then freeing up the request thread - instead of just running the work directly on the request thread. So it causes a thread context switch for no benefit (in fact, this technique will run slower and take up more resources for a short time).","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"e9674175-f2d3-3ef9-82b2-ee54f97b14ed","date":"2016-05-24T19:08:38Z","timestamp":1464116918},{"_id":"af89ca05-2ffb-3c9b-ad21-b69e01d44dfc","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"True, but why would you want to? The request already has a thread.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"37d1df41-5d2c-3d4b-91ad-4cee83d6e4f2","date":"2016-05-24T01:38:42Z","timestamp":1464053922},{"_id":"b1e393be-2011-3fc2-95dc-a0a7178cdc4e","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"But you're still using a thread. Freeing up one thread by using another thread is not a benefit.\r\n\r\nWhat benefit would you get by doing this?","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"e6926ee4-ee81-3a1b-9759-61f247e00d02","date":"2016-05-24T20:37:19Z","timestamp":1464122239},{"_id":"e6926ee4-ee81-3a1b-9759-61f247e00d02","authorName":"Avi","authorEmailEncrypted":"tdf+WpF/nkxfnKpFIzz6bzvVQhI0IWOX4Y05Rq5mzbc6AGk/SHhFo7T0smYa54DVs8fbM1ePJ2SDkomcj/XGB9ZVmqmYd/e1wqlD0C1dg0usgc6dnreCB6Q+0h+xflHflPh7ZeVTheuobe2bGJdzL1N3RyXzxC4VNLWw1fUhEQA1UZzy1nA4aoT32JWVsjUrrPIsZS08X/GsYxUL04vxsG1s//ZoBVQgGtRLOeb9kqhlPlsJW+RdDk9uvlkMNOA3Dgd7Yczyj9S792iKczyXXLKU+oxJ2ipCp1pmikKf0oo+XP2z+t6U3BqtqLHYsVVWtb8O17F60AKwAVf4xOcG6JSuxj2hSqZCisTw2kYK9bsAecYhXJcCxBeyt3I1rbbgFouQ4dpFMTrgIpQWTdN1clEcqxp09lCqrKt6Sw2dnk78rmpY92gxPKOnipxeK3b4gLYZWctktbYphnuk4mcjEDT7zl/xVPIM7IEFLTJzqGz6Clyzlstq6SRpLFfoO6/mciolWtikdwBFzAd7BZMQr5PF2apJcPUb38rD1z0w52xjj5rTCcEn2hyqMdQJDqhFncUF35dOmMe1T9sQKu1T0+PlHlFUqWG+nUBlL9Q+2x8a66gRBG1g9uQ1xF6x5PjgdhcSyoP/m/Wf5vu6vg40mL2oq6aXUMzKSl2PMqKckRE=","authorEmailMD5":"98f19d70948a72ca4a5a99b7afb49494","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Yes, but by pushing the CPU bound work off to another thread, the request thread is free to do other stuff,at least that is my understanding. That to me seems beneficial? However by doing the await Task.Run, you explained that we might ruin the [asp.net](http://asp.net) threadpool heuristics and therefore better to avoid. I get that. So , my question is instead of running the cpu bound code on [asp.net](http://asp.net) request thread and keeping it occupied in the cpu bound code, can I not push the cpu bound operation on to another thread(which is not a [asp.net](http://asp.net) thread). So, we get a win-win, we pushed off the computation to another thread(and the request thread can do other stuff) and we did not screw up the [asp.net](http://asp.net) heuristics because we didn't push it off to a [aps.net](http://aps.net) threadpool thread. In a nutshell, can we push off this cpu bound thread to a non [asp.net](http://asp.net) threadpool thread and free up the request thread?","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"77cda795-102d-3345-af82-5aac09b6a4f3","date":"2016-05-24T20:21:26Z","timestamp":1464121286},{"_id":"e9674175-f2d3-3ef9-82b2-ee54f97b14ed","authorName":"Avi","authorEmailEncrypted":"BkOvUj8toIvyiIKz1aF4lBMO2ePqv5y5ZWfz6vZeqFFfGOTk0RMoJbQBmXXNAcsKbBsgImdx+nT4ucxhec3M1jxMDUDXYxy38Q9nNUSJbGmnqKBzoYSg6ksZUO2hhu6mZvdQqPAo5WXI4O1lab5OiQODkRa8vv43Y+x2XJ1e6Q3UeQ+wPuiZzjS+A9VozYZN55xJ+IRc9RhW5wcF0YBzmf8J19/QiTA0opVYQc8qgCGCVZ0ZxTY6uWR2axAX6YkBYP0HI5JxjDR84yqcOR49LIuHVLiqKsrOqO8BF/L+7iIMl7wxd4rZWghsgZ2TRunzvEkbKRIjFRQR46H4ijgL+j+K4u8hQ8ffrnWbRxPkJAZiRsxSYSTtxarJ6EDzjI7O/3SV69J6bnEp0497YvQugflvhPms1epiFOjMkXu1oY70d9vpB9Nr643Vh1QZNHfQGDe6E9/GO+/vq9+2rnr0RWTKIh1XAUbrAOtNy21IhthJu5qInyXjVisFk1jo5snk6k/jim1eQyYVOLpqN5EZS4RPklPduRP2lYBSp8B/7qf65ZguYM4NDg1er+4CZ5pU6Ix6urNYQFP1o3Q/oGxT7z1Y6Ex4QCBy0tabKbf5fz1yPLo6RjOCxRFH/RYfFtFXeBMgfsp8y8hik1bAmGZfPaD6mb2rnWZiTU7exFm0voE=","authorEmailMD5":"98f19d70948a72ca4a5a99b7afb49494","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I was thinking I can keep the request thread active and \"running\" and run the CPU bound code on explicitly created thread. My intention is to keep the request thread from doing CPU bound work and be generally light weight? I think I'm missing something here?","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"af89ca05-2ffb-3c9b-ad21-b69e01d44dfc","date":"2016-05-24T18:58:23Z","timestamp":1464116303},{"_id":"36ae78dc-33c7-3d22-83c4-4cd48c5a3de1","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"OK, so you're talking about parallel processing (not asynchronous) on ASP.NET. This is possible but I don't recommend it.\r\n\r\nThe reason is that instead of having one thread processing this request, you end up with two. If the second thread is a thread pool thread, then you risk throwing off the thread pool heuristics; if the second thread is a manual thread, then you have the added cost of creating and destroying a thread per request. In *both* cases, your request ends up using twice as many resources, and this can cause scalability problems.\r\n\r\nIn theory, parallel work on ASP.NET should be fine as long as you *know* your number of requests will always be low. In reality, I've tried it twice and had to take it out both times because it was too easy to bring my server to its knees.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"7016fa64-ba62-38d3-90bf-88c772b2ac07","date":"2016-05-25T11:14:10Z","timestamp":1464174850},{"_id":"39785bc5-1d30-330f-8ddd-f770777046c7","authorName":"Avi","authorEmailEncrypted":"MvGspSVoizv9fncHqxfFbAAxtTlVeQZnGaM0Gc4f8cwiXcdykyK4CsricJHHsre+6jnNsyyfeNEmGICQBbqVFWYRBBaqfyV3XhRPHcIxvwqwxLjCghv3dR8ObkIt7TfBoupWSFOWOlyo9D+DEJ3fKj7TnYqt1AV4nbhz+/MAEk2i6QJE5epXWLYcVR+DYfJl6ut2sXRjVvmRcLKlT4uCnriHMBTljMn47KXtMuhgVfgnfjhKw85v7V85HXypBs/Osv06//gPiz7yzHkY9Vq8Eij1EC/DA6FV1i4fUD+EA5Fv/ISi25GxQI8e+lF17Qn2RYuQVBT/TYdgTd8fHK2OFt5MXut/L33IW5mkka6nYqAPQnsfu8wDpwFOwnPExryobAJHWQ+CfnfcfVVfXs65wwPJ8YSryZrKQgdyt7QkkdP00UOGDg2HdVGd6Cfb7f3Jps1c6jhC+0fXxTgOrYEczeF3SwS3EtuiE5maIxWhbX1JfKideAxDkX83ONoj9ICtIDRWN8gXtRmN4xAXEzmjPduYnQu5cGo2+rEDzD2z62DIyBjr7HsuoTI437f91Qz4WO3bSLG0RJ9vc4mZ+R1mLvYGgS+XvOSFwG6dDYS/UtvB9dAOCC5mHwSuyliKVnhnS3+d0Q+w4Secy/E4mC2LOvDABiE8ag4BtQWeoWzzIeE=","authorEmailMD5":"98f19d70948a72ca4a5a99b7afb49494","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I see. Now, it makes sense. Thank you for all the knowledge Stephen. Much appreciated.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"36ae78dc-33c7-3d22-83c4-4cd48c5a3de1","date":"2016-05-25T20:22:27Z","timestamp":1464207747},{"_id":"8281da45-f3af-3251-acd5-afdbef5b6fe6","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I never recommend it. It would increase the response time of the first request by decreasing the response time of other requests as well as limiting the scalability and responsiveness of the system as a whole.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"9e224bf9-9d4a-3c86-a443-122e52f40c38","date":"2016-06-05T11:06:51Z","timestamp":1465124811},{"_id":"9e224bf9-9d4a-3c86-a443-122e52f40c38","authorName":"Phillip","authorEmailEncrypted":"jMevVHjZ4GnYSB0jcTuLefvdXdqWXfJFomNaWHlLs4/QabXdPSgPB6G+RK0zvm/bFinE6P8wQb/S2FA+xKanhX7TEOjA0Pu+DnDbHQlDefLRqsbzvCDsrAe+c7DKVZvtA53rmnb/YFRHmqfpKBf6d5/9wt6g8QEFqMMfB9xoAgcZWzED+P9VxOGLArYWm/gX4PzWNVKQNCRSJDa0sCnvEvFXMRvSrep9w8P80vxt/YZ5TxE+FaMpJ+Q+iWhVyH5SPEzP9FqoOEDUnVtIGJqqUUxd1mEG1oExuGyqWHT69t4in4U7i/7yvW/rreVPhp5Fwp/f2rZDwEbuVyDjYEUakR3lbdnAk9RA7+1TuW3zXTxSHDDAju2ix6KeXiGmRuqnhhk5JuY02o7jMwh9vCPIJVe6M8YFspaXe6jMaBAiI/ghX2ydQtAhhLOYUJ+cS04Tqe6xoslfr7vTuy6pMSFMXV5lJRsaSgaMeTb7zsR7+dXcvd8xq7nAO7gsEr41y+RaMp7H43laKvdCEzQ5yU8UPHIWqXe19cG0M+nqCT5nmbyfIuNBk6r++iL36mkFn/iuURV7y1S7qZLjul2U+xl0mbskYmPb5p2mcxq43ZPm3p0L6Y1S3DSvbicvJVF1pWLrZasXq8M2cruRFrUkGFmWPjsDQlid18CPIEKbhrx2Vc4=","authorEmailMD5":"13d98c6af46beb3dc6aaf180b836dcb6","authorUri":"","authorUserId":"disqus:disqus_tcm8RMrFV2","authorFallbackAvatar":"","message":"So is it a bad idea to use Parallel.For/ForEach in ASP.Net? I'm assuming part of the parallel work will be done on other threads and the current request's performance increase will come at a cost to the speed of the other requests?","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2016-06-05T09:15:45Z","timestamp":1465118145},{"_id":"abf152e9-0f9d-3d40-8ec5-9b1a688fe896","authorName":"Paul VanRoosendaal","authorEmailEncrypted":"eKY4WvSPNl1SNqGO8ajJ7wlgVqomu+JBBqyYJ8AgfpsQrAaN7FfvUgHDGzyKgB46s7nQ/ocDzYwhhAQUZ6ktZMKZun5vX0JmoiZhTvj+J/nwD7P5dXcWnFq5KFoier82zyKMlA0Inr0iOfaJ4iXTIMowvgCnUAC27iEZS/kiYD7pY8S6/x0qdrOlsT5BKMEgX8wQZYMFs/8+tbqAzqM8KE5mqCNixXvYcBzt7EqKnVIEyPO0RVrnrhOjYnL0XVfD6qP+XrC68LAvCWLDWBkydY8dn242mfX9mDZt6l0b5nSh/dsA2OrXIgv/3nH9krnMu/CAC02s8Iowkgg+zmm0TfgcTFru/3oPRWRoWCsgRnVBe4ypLtD5qh6495qrQLkl3BCo0e+YLP9rPeCfL98Q1HuGi/kNiMC9fhLsBEnVy3RjR+nq3ZGBbo3QM7nVPnm80u71cb45FXpmNMIv9C5JmmpzaXjCrii+ATvS/bS6V5cwd7tnzuhAtyKuDVd+GM06+hi9GNBHieMIhn9X79op1Lvg0fqvI6Af9Zt8Z5eElhYq3CW/re+Q8iUvETWIq5Wbo5fCiNVgBHTLMAnXXLgYE2NF0UT5T9hepYkKC9lK78w9xnYa32wMSjI1RRFfoFPWYXtEUQZvLgm1cy7wu7cLBXxP3BA82kp1Vqj4Ji6wVxs=","authorEmailMD5":"fb3a426ccc87b01d12e98b5c1f494f0f","authorUri":"","authorUserId":"disqus:paulvanroosendaal","authorFallbackAvatar":"https://disqus.com/api/users/avatars/paulvanroosendaal.jpg","message":"Good article Stephen. Is it fair to frame the problem differently by stating, \"I'm trying to offload some long running task so that my web UI is more responsive.\" With that mind, I can then expand my options to background processing frameworks like HangFire and Azure WebJobs. So instead of Task.Run, I call BackgroundJob.Enqueue, or, I serialize an item and add it to an Azure storage queue where a WebJob picks it up. I realize these approaches represent progressively more work and more complexity. However, the benefits are huge from many standpoints.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2016-06-14T02:24:37Z","timestamp":1465871077},{"_id":"c379869f-2e4e-3147-a380-d93569a81f69","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I can see what you're saying, but I'd say that's a different problem with a different set of solutions. At least, that's how I approach it in all my writing.\r\n\r\nWhen I talk about \"UI\" in my articles, it's always referring to an actual Windows UI, complete with a message-pumping STA thread and thread-affine components. There's a lot of confusion out there where developers working on ASP.NET apps are literally thinking they act just like UI apps (I blame WebForms for a lot of this confusion - I've always taken the stance that abstracting away HTTP was a bad idea).\r\n\r\nSo, I treat \"returning early from ASP.NET requests\" as its own separate kind of problem ([http://blog.stephencleary.com/2014/06/fire-and-forget-on-asp-net.html](http://blog.stephencleary.com/2014/06/fire-and-forget-on-asp-net.html)). One significant reason is because Task.Run is a horrible solution for that problem.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"abf152e9-0f9d-3d40-8ec5-9b1a688fe896","date":"2016-06-14T09:32:27Z","timestamp":1465896747},{"_id":"3caec149-8dd4-3a00-b07f-acf33bc0eebe","authorName":"Giulio","authorEmailEncrypted":"dBsAfztzsQOhXNLeGiBoonoDmCVGTtQQf+07/W4x2Lmjv7+dQJ66xwmaH76uA0UGQqq9luOQGeLMgzhOvzwU3qUvlj+S30QUqMVM832oyMoWr+PudENjlzuM3OTB2ZnGRiOLLTYqcd7dH20ivkmPadxgaG/fkIaP3VUjHKk3HVjvYmttlzd9u5PNxDXcPLI62r3fQkP2MmG5/wFkDse/qJO8TpHBNSsqM2wdHMAVD/WhJa8pS7+x980S2N7Imh3LLQlNLdeyOiEr3bdYJsZQ2yYZ0FV1uRm6eTaZ+D8gWXtJ8XPnwdX6u1eIBderkOlhTGJeAZb/m9wKlel1HhnT/NnSMj1GFxcPPAdVCS1KyMVFTL0iLMWdYVOhQhusAgtXYr+r+gQIh1oEt8RVeac2QxdMaw5TU7qh3l/XRr56Hda+Cn898yW7xPmeIKtySAmOWfTQKzNqq/1hxVTCgpjlgjhapNjZG9Ey0vUdBiWQz2KhNgMuJjnkY+fiFBUbOwsFkTLUkeHJg8LPT2iOa+Q98EW6TFHneA73nEQC4b5JSli4A3jGDHFH0dp500dIgdOZEuiu9R1GwJq6pyDmbq0DDXErIGl6+znUOofbWKwxMGRpmy7f6o+63FwnXtocuc0H8lzbnGMqZj6issUoAc3yrt/lGP+qjYxTnW9flTeVM9I=","authorEmailMD5":"d040d48dc09031501a031acd841cd580","authorUri":"","authorUserId":"disqus:disqus_f9KlsNfakp","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_f9KlsNfakp.jpg","message":"AFAIK thread safety is the main and only reason why windows GUI is STA and a message loop is required by COM. Anyway, from a language standpoint and abstraction, Web Forms are not to blame at all: all the HTML and JavaScript related quirks are really an awful limitation for pure ASP.NET views. It's in fact understandable the widespread Unix like solution usage for the Web, e.g these comments in Disqus, based on Django - yet another web platform with its multi threading model. Is \"Do not use Thread.Run\" more an ASP.NET specific tip than a truly generic rule, applicable to software architecture?","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"c379869f-2e4e-3147-a380-d93569a81f69","date":"2016-06-17T21:15:45Z","timestamp":1466198145},{"_id":"5df8308d-f054-3731-a62d-e71c747523bd","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I think ASP.NET MVC and ASP.NET WebAPI are vastly superior to ASP.NET WebForms. They embrace the request/response nature of HTTP. Combined with ASP.NET SignalR, Microsoft offers a complete set of tools for building modern web apps - without WebForms.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"94e93e49-bb71-33a3-a427-c1a3a7716586","date":"2016-06-18T14:56:29Z","timestamp":1466261789},{"_id":"85838337-c96d-35e7-b970-eff51981cc76","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I would say that \"Do not use Task.Run\" is a good rule for any scenario where your code is hosted in an already-parallelized system.\r\n\r\nI'm not sure what you mean by HTML and JavaScript being limitations for ASP.NET. It's a web server, so I don't see HTML and JavaScript as limitations.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"3caec149-8dd4-3a00-b07f-acf33bc0eebe","date":"2016-06-18T01:42:58Z","timestamp":1466214178},{"_id":"94e93e49-bb71-33a3-a427-c1a3a7716586","authorName":"Giulio","authorEmailEncrypted":"FplK7QnzY4Nm1e14TF3g4D7p6ramQrSIjgelKD7uExXZFvmXuPxcO6o76Prp0VPs5/v83wZmT9TNiANJhjKl7Xu654QpBbaujnGVjPtl+bP+Jk6nBLDzIDlVqVidSx/P9E8Ogx8pYIMKHuuPCp8CyFIB7sYuBQwqfIyR36gxx6PVRgSmlzH5/ArkgQhDsVdQA1uKeK1L3+EHCEegD3eFiOGcgGhaiH5D4TguAzzcD/+KG2gwxzilbBaPJ41JVZPOqoMLsdJZ5qXgNbRjWJMbGaEwjrIJ5dmthk7YztzzySJglhwgqDVKFgB38Q5Lmasvi2jmFBuQrSpXS8RF+gMa8ecGc7dZkasJXXWkOImziy2ubppeHdhaZksoBYAkagE9sZW5UOz/y1qGyHEwSH241jkMKCeEssmJTeKw7QFozTcbb3PrXwEX7lqIA+1+sGy90ZBF/bXBt1GqtESR0Ajt/gcECbUj88swVraRH18KydyL8Oqggjf13XBUq5V6LprgiGTgUyzW+pr5ilyb7PYA0Swn7BEyid68MBpIqI/jVfBOcu911ar/l+T5CfDkiVV26lp7jvE8IDlFfl7X1rYmSZG3vr4TxOqd7a48egKKoGjK3mH2O+sXzDMFn6JEyIqd0My9+GHS+FJ5xdu5XIC69s220l0r3+TuYlYMhw4Na6M=","authorEmailMD5":"d040d48dc09031501a031acd841cd580","authorUri":"","authorUserId":"disqus:disqus_f9KlsNfakp","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_f9KlsNfakp.jpg","message":"I perfectly agree with your definition of the scenario: when your code is hosted in an \"already-parallelized\" system. What is strange is that usually one needs a framework to support application specific parallelism needs: again in the example of Django, it could be like developing asynchronous tasks with Celery...\r\n\r\nWell, it sounds like you don't see assembler or low level language as a limitation for a native desktop app: why do I prefer windows presentation framework (or Qt with C++) in that case? Sorry ;-) I'm kidding... I mean without WebForms there's no Microsoft alternative to Twitter Bootstrap and so on... thus also for parallelism and scalability it's easy to hear about a differrnt approach like nginx, Node.js, hadoop, etc","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"85838337-c96d-35e7-b970-eff51981cc76","date":"2016-06-18T05:41:52Z","timestamp":1466228512},{"_id":"f005b8f5-ff5b-3c01-bd15-6b27f2a6e9eb","authorName":"Giulio","authorEmailEncrypted":"FQvsEXbE9H93yu8OKl+2MuCuepcmpHKwVHfMuIojkUuUEAtraUli89xOAMuqmQAJjqURmQVzKIC79onZwmnhahX9mWJxx+P/Nb2TWyOYbW25P8N/sEaM0Wme1JVeG1MuH1Z91XmUwX8fn1cVQ2EsMuCKSSAYrGFP5Nq+MCy45kYdODh3C1ABg5bBnu9UHOYnyWSdAXjt8kjJfq9qw0dpZogi0KLBKZkg+Oexj5gYRDwJ9dlCuMb9I637Kgrjr5BUTlM3n/gHQS2Wp3IZrpJxmdreVlZE26N27jttsBCo90RRgPjT3LJREnjaWeHYFWouiY3d01buLJwHGPg35vjtsyM7WNCmwaswzptFvRvermcwbhheTAKulUoAZHC+Ykz7l0Lo1KgpoVrVGIQPMHO9cjQEgVOQzkr4WNUiLTvP/kJbVIHKan+ud3RlFoouzDQRXxBdHk3WcEGXmodIRP1L1S/HIyKEBLwi6zxT972qbfRGh+85A2Rlf18M9v1WYXBbVPaDqVSV9NvoOOB/qpKvb4Ao2e1m3Z+qQ9ggT3S4zc67XpG+RyBec9YaeHIGQCehxpxJF7TM4NcsJfiUtE7Kj3kuFM7mxAtT9qUdrLbfcQnrnMjWjTS0SpcVbm5D86qqzZNFdFOeC2p5VVO8lZQ8ExV19LNcficYjzQgY9Mch3Q=","authorEmailMD5":"d040d48dc09031501a031acd841cd580","authorUri":"","authorUserId":"disqus:disqus_f9KlsNfakp","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_f9KlsNfakp.jpg","message":"Thank you, but - sorry, my last reply - let me ask you some details to better understand: what about the *responsive* web Frontend? Starting from MVC, I guess you choose Angular, then (I imagine) you can't add jQuery and JS Bootstrap but maybe the UI Bootstrap version replacement?","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"5df8308d-f054-3731-a62d-e71c747523bd","date":"2016-06-18T18:10:03Z","timestamp":1466273403},{"_id":"54c1a3e6-14cc-39e8-a096-785cff4a29de","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"You can use any of those with ASP.NET MVC/WebAPI/SignalR. Personally, I prefer React.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"f005b8f5-ff5b-3c01-bd15-6b27f2a6e9eb","date":"2016-06-19T12:08:54Z","timestamp":1466338134},{"_id":"adaa592a-00b8-3cab-8d87-7923fa46a938","authorName":"Jaider Ariza","authorEmailEncrypted":"XlVaorPIHXBMmSXEQjyjQmgprVzh8zquef939x8Tny0mo25AiXx6CzOppdoD9w13+fqCi2Vw1zIlG0B8xs7HqUh5iZ8OvbOl11R1Wgsh841oA7S2wwwiHi5q+7v4YDMAK9C/48NglIjSejsNI6Wpx3CWdajCWW0+9sV0FABPfBzsf7s6VN9RhnmA4Bj51gqC+sFIZObi45UsrBjuhOpwiElgN91ps43Dcn/qkFearnsVL0X7rjHtqzvIR1ZPPiWos3T5FMp7Sm3wenLBiOq5o0ulkNazxFkJ93YJFVluH4ldcZ5Fs+V5k90pmLAbVvj2/vd0gaVr8r/clCJM8/aeni6L8X+bGI5n0v2U/MWSR2qJiloHU4jKDlCEYwhc6lUK35Ir+llsNB+4lbMzKfwhBYvyppJBH7L44jojGKwWTuTzRd++1rpWdbOK6NpH7SQ7QytkY89Mf+QZFunP4gAEbye2tIT2zBMDFEDT8wLw2+sJkjx9U1NqAS3q2ghit53TK2Zk7NcBd6za7pXB4FiDFpsZwkDqPck9HMW0D0gug41ng37zj6npi6Ihos4j5ofupGVtIS/RNTpAhOvaUlpdlfdgT8qOMq6qP5ie53dqAWOP8t8O8JqtzOWZ/9WEwbzyGxIDkwDU0yBaPRsH49zCvD7HHzRET4/zQxAlyctFKzU=","authorEmailMD5":"faa17714bc577d1061f33e21f1d83551","authorUri":"","authorUserId":"disqus:jaiderariza","authorFallbackAvatar":"https://disqus.com/api/users/avatars/jaiderariza.jpg","message":"This is interesting! Can you provide more information about this. Thanks","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"5c5d839b-8f21-3611-b991-4b12fc9c374c","date":"2016-08-31T20:38:05Z","timestamp":1472675885},{"_id":"bc83c246-884f-3bec-9c5e-3f83ff83941b","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I'm planning to... eventually... :)","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"adaa592a-00b8-3cab-8d87-7923fa46a938","date":"2016-09-01T02:56:15Z","timestamp":1472698575},{"_id":"0e2c8e47-55a7-3623-be0f-30a8e8b9e065","authorName":"Antonio","authorEmailEncrypted":"F7o491t/+EgCwKnlIoQz9RZdpf+MK6qi2Q+Icsv65fy89FfPbo9DXddqzQ82nzI/7iYAmPICJvxWXXGkwCcvi/ydnpo0Qm6PjHOXh/nAFPjLWd1A62qJEV8zv9oq6W60qrTLKV8RVxVL0y160oYOVj24s+s9PmYyALnwd1GWjLsowJRZm9HCCWgtKCPd/NLntw3NiV+/tStwmsGDPZNKT2asyEfuHvyLtWwsmL69yrsJbFXfqFlDKbs50+fA6XN1M7W4zS2zIbgTNyRL2lalIlcyOuEKmQioLyL5qhAdswhO1zr6Oix0r/W4JtaU7LgDwNcxK1dNZ0jgjUF8ernOjyAREj5AMSep+Y+QHNFkAyjb0PBV45HClMMSQSSU2glABWhO1sWnCyr0UjhV/C+gtTJbUjatNP1eN2aMSTPc6MOPTXRyQtwgv1yMdl3DqMBmDD7EF6WVsRoHyHCXFWopxYynEiOsa45T/UCbW1qzfibqVVv6OPYz1s3MKbFOLrmXPIb70TwI9o1/+O9Zi2v4B2QZHRCreend+DAVmWucziq/RbLPqsbc39kp+zJBeIDlO2fcEf/NF+ilj3SSiC8N43g4z5u8D/N/VFlHBbByUhx9kZw3wL07Yev5gTpZuxbj60uyy0L96ZFDBUDbSu4b6bOZ5TsoIYwdZb8LrfzyorA=","authorEmailMD5":"d10ca8d11301c2f4993ac2279ce4b930","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen,   \r\nWhat if I am implementing MVVM? How can I reuse your advice above, if I end up writing an event handler for the [button.click](http://button.click) in the code behind? How can I use a viewmodel and still let the UI layer being responsible for not blocking the UI thread? Ty","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2016-09-16T23:32:25Z","timestamp":1474068745},{"_id":"6ee330ca-2ae7-39fa-ae09-568b25934856","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I have a three-part article series and a helper library for using async with MVVM:  \r\n[https://msdn.microsoft.com/en-us/magazine/dn605875.aspx](https://msdn.microsoft.com/en-us/magazine/dn605875.aspx)  \r\n[https://msdn.microsoft.com/en-us/magazine/dn630647.aspx](https://msdn.microsoft.com/en-us/magazine/dn630647.aspx)  \r\n[https://msdn.microsoft.com/en-us/magazine/dn683795.aspx](https://msdn.microsoft.com/en-us/magazine/dn683795.aspx)  \r\n[https://github.com/StephenCleary/Mvvm.Async](https://github.com/StephenCleary/Mvvm.Async)","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"0e2c8e47-55a7-3623-be0f-30a8e8b9e065","date":"2016-09-17T01:34:08Z","timestamp":1474076048},{"_id":"6fd9548f-6654-3101-b050-5f0544a9061b","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"That's only true for controlled components that manage their own state, which is not idiomatic React. For more about controlled and uncontrolled components, see [https://facebook.github.io/react/docs/forms.html](https://facebook.github.io/react/docs/forms.html) For more about different kinds of state management, see [http://jamesknelson.com/5-types-react-application-state/](http://jamesknelson.com/5-types-react-application-state/)\r\n\r\nRob's definitely coming from an assumption that two-way data binding is better, and shows how React is not as good as Aurelia for two-way data binding. While I totally agree that Aurelia is better for two-way data binding, I disagree that two-way data binding is better.\r\n\r\nFull disclosure: I use both Aurelia and React regularly. They're both great frameworks.\r\n\r\nI'd recommend asking questions like this on Stack Overflow. I'm only at an \"OK\" level for both React and Aurelia, not an \"Expert\" level.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"c20227e6-bca0-3315-af34-cab5fe710454","date":"2016-10-14T13:28:21Z","timestamp":1476451701},{"_id":"c20227e6-bca0-3315-af34-cab5fe710454","authorName":"Giulio","authorEmailEncrypted":"jxnDlt6Co1Zz4mVocrwMIMyNo8Zq8no3iqCpHv80xewvJOZx/R+R3ZyO2Knsf752fyCaYZvobmjeovL0QJf8NfAAFau7Tiessk4A507RkhK5A5I5RLuHgNkdxtOTuhz3essUa4kQa1CaEH8PNMc042h+5VvhisPI6jpp15PDorCNjaGZc4LwcLzFfvwqgpMBP41Vpkj3nysSDWqJ5RSwecI6vuvaSMIqyRVT3cYh0AqLGFDAweTQRwHI1IM7Ua+0tIee1tmtkeI5uUb3Ce1NJPmBWppWr4DjG3Z3P5VAD4VTTFPpK532AoPdDVmeIVQzli81YdDxWUVKPwGqLsOjTO95DTJ0YGLHzBvNnn1WEW4ok7ryg8mFZIFHbmdPkywmaZAI/dNJ7Q+BpcrPQNTIjHYa7iT7iyiUb9VMMerAHwDZMUehSLIFONaxjfzdjHNv8KTSggQ+ckJcFz2EfSFel/gVTZxv1wfbCjOKRT/VhKKG7w9qiQzPcX5r9XEUakeMM9oQykT7g4GpXG9+GQekcvcXHWRYgwqBXvhs4hpCf0rkMQfel78zjuiZ3SMP/cnQSzJyhI4P5lAqIXdw8xz4LKMiztT4McukkX5X76zDdW91r1w57MPxRYUZ+WyunlKLfhYF1KkLQ93QOYNjrXWfSzIBoG/9g+DYIWzqHeOW3Rk=","authorEmailMD5":"d040d48dc09031501a031acd841cd580","authorUri":"","authorUserId":"disqus:disqus_f9KlsNfakp","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_f9KlsNfakp.jpg","message":"Really? I'd say instead that React wants to supersede MVC by introducing unidirectional data flow...\r\n\r\nSo how do you manage two-way databinding in React? Do you need to manually wire up the events? :-( What do you think about Rob Eisenberg's comment here? [https://www.youtube.com/watch?v=6I_GwgoGm1w&feature=youtu.be&t=1591](https://www.youtube.com/watch?v=6I_GwgoGm1w&feature=youtu.be&t=1591) from his \"Choosing a JavaScript Framework\"\r\n\r\nThinking in React, the whole Async Action paradigm needs to be redefined (doesn't it?) and it becomes much more complicated (than the C# async counterpart!): all those async action creators + redux thunk middleware... e.g. look at [http://redux.js.org/docs/advanced/AsyncActions.html](http://redux.js.org/docs/advanced/AsyncActions.html) ","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"54c1a3e6-14cc-39e8-a096-785cff4a29de","date":"2016-10-14T11:44:21Z","timestamp":1476445461},{"_id":"dc294082-f26c-340d-8276-6093e5184e69","authorName":"Giulio","authorEmailEncrypted":"O86n985feqhyWYXHNk2AN0D1LZa+1jWUjCY8hSoEoOM14mX5i422aFhVRXOA9Aizz5RhpLZx2XuCBnRoxD/CoiWLA4xsFuzA3qCk2dm6ewsQR2/e+PFs0Wg6M3fI8ZISc8QYCukFESh6HxE7mS/m3254D66HJuf65EGGNmB7CgxWw3Zp+KUDzo43GV0NLEExm0XYGj3F9yQqFnbhUPUlpsbVBGW8agl/oORBK19RJAXjt9+/4SYkQEEKEQvSMugaxVLcisgw7Tyusu7tY4bkivw4xXTMoK5SueCdH/KN1ht4hLFo6I2HhXCLlvBirt9L+M3x350c39JOUJSXkdB4vvf0xxwiUlHz8C8cxVyqBxj5Yzz1UrJdsQsEqgnxXdHci+ZZaE+I7MT3/VaZp8IYMRSRs8AyASn9yTYY2btZZ245nxkliyMQaqS7g86aYUz2mcI2tI+vhtIMkfo+HcVYrP2+HppOZ6MsNOopUrlA02ElWHNFMGhCWSf8rG6w/qHswc9e98pLx5MraetqarPZKfyVRRP3wNKwkiLreTsiSyxDqHrLSoMpX6GhiXoRAsVO7ZTqGuZfN6aTp/z02ZyGcjLsQsGCts19v3fHfDy4o3xyp2iGDEMrM3EIGqZTq2d/jmHB9ZgCcBjU5NKtQyRVIMgzGmDhUiy9QPLSYXbn9aQ=","authorEmailMD5":"d040d48dc09031501a031acd841cd580","authorUri":"","authorUserId":"disqus:disqus_f9KlsNfakp","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_f9KlsNfakp.jpg","message":"Thank you very much for your kind reply, much appreciated :-)","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"6fd9548f-6654-3101-b050-5f0544a9061b","date":"2016-10-14T13:35:54Z","timestamp":1476452154},{"_id":"3ca897b5-12ca-3eb2-ac0b-82b5234657d2","authorName":"Eric Rey","authorEmailEncrypted":"gM79lsb8+fAZfYG1xy9RORBq73g7/IkiniZ9FwRSQiqFuNUi6oTl8Xgz4CFWDWFUEvmSNlnerVB+jMapoXrZmvg4zSsYdmmLRuWDksrqK6qibohgwxJ+8wEeQnoNxZUiXnAP1HiyUrLqY39etFC/IgewJYcHyPSNrk3xfl8QJN5EyntptgDZj2gh6WY1WoX0TYsmWV5u1tnaRWE0WCGR3AKa2mOb5f8mKSG9Z+KPaNHH7QCjZ2vRlkhMVkopbIPKZxWwu74o7wceSdAeg/DjHlKm/ardD44O3dkV4ZMPlWy0OhLtUUqG2Yk9djb7GZkz9At70pkzM7dSQhMBUFXcKIJIq2dl+ceeVzG4QBRm4ruWJN34PaOVdW0EhVKD0GN0Rz7Q1bNeXTFS9OQTbGgOiLFXMzQ9wLaPZMQJv/OHReEv16ACezWn8ltwRKvb+oUfsMrK6BncPS18xoHQpDwR8z/R5KndNOGstQ1lVFubOTVo/P+KVoNuUpsX5YdWaPetvYbU4zSb8Wf1+i0EWAMwhnKGLgf8oZu/Agz2lCaFM4lgGmzeSf2Y6+5IK/UDPErLGvmWsqu9pIbb3qO48hg94XJKKUf4rQ3SRCczRL2cxug2WAA5eVjyKb29WgHZnz23RJQAY/UzCDuQiReApDEfFnD/4brkaDRsFT8DvC+2Edw=","authorEmailMD5":"792f0ba41abefea3485d6caefc678c90","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Does this apply to awaiting async methods that are not implemented with Task.Run as well?, let's say I have a Web API service that uses a repository in the data layer that makes calls like this one: await cmd.ExecuteQueryAsync(), I know the current thread will be released to the Thread Pool and a new one will be assigned to finish the request when the results are available, I have read that this helps to scale up the service, but how is this async I/O operation different from the CPU Bound one in terms of drawbacks ?","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2016-10-25T20:33:36Z","timestamp":1477427616},{"_id":"ab74d4eb-bb78-3a13-a22c-e53900c85f66","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I think you mean that asynchronous code will also have the overhead of a thread context switch, and that is correct. However, it is preferable to blocking.\r\n\r\nIf you run a CPU method directly on ASP.NET, then the original thread executes the code, and then continues.\r\n\r\nIf you await an asynchronous method on ASP.NET, then as you stated, the current thread is released to the thread pool, and when the method resumes, a thread pool thread is acquired to execute it (which may or may not be the same thread).\r\n\r\nIf you await a Task.Run CPU method on ASP.NET, then the Task.Run takes a thread from the thread pool, and the original thread is then returned to the thread pool. When the Task.Run thread finishes, then the async method is ready to continue. (There's actually an optimization here where the thread resuming the async method *is* the Task.Run thread). So Task.Run on ASP.NET will cause an extra thread switch and throw off the ASP.NET thread pool heuristics (since there is a thread pool thread used to run code outside of a request context, and then returned to the thread pool when that work is done).\r\n\r\nIf you block on a naturally-asynchronous operation on ASP.NET, then the original thread blocks, using that thread (but doing no useful work) for the duration of that operation. When the operation completes, then the thread continues.\r\n\r\nAwaiting asynchronous methods will cause a context switch, but this is almost always preferable to blocking a thread for the duration of the operation. Yes, you lose a few microseconds of time (asynchronous requests *are slower* on an individual basis), but you gain significant memory benefits as well as faster responses to varying load, which enables much more scalability.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"3ca897b5-12ca-3eb2-ac0b-82b5234657d2","date":"2016-10-25T21:01:08Z","timestamp":1477429268},{"_id":"850046e1-da6b-3599-99cb-14f47651aeb2","authorName":"Eric Rey","authorEmailEncrypted":"HfITmX/AE4KoFrhWkDbB5ysDmaMjNUbPL80uQGLQe84LdVMTqLlUaDTFWVf/VD7WtOANrKKRuIdXYHcW/1RMW78pPl3sZK4pxR82BEUPocIlXWNv17ts9viC15gr26zQ0LdPOE9zB4K97VoJMQTOh4t4+XFHjxhLa/59rQqFP1W6qZ9YkXYlQkXhXoqSJuZdt2M5scuBoV5amoxntzMXKzpX4PAD+jmWJek+pDeRpPIMa6cPKPsGGQn033ONEDmDnSOC4cX299bvDecdiCfm0RV+/6/+f8T83PhD7MkPN/CIJcywXpaNdSKnkWQiG1IivmW89pBvMW8dgtS+Dg4dPirjX+sG7qNIGykMNBcM4KT++7Ajx/xeUHla8EASBNutWYcVsUkjn7A+UARwtVjVR+H8H9wXO8GOB6n+nJrBbKSukS1+ADzTy/jJe9qF2rxZE93OZq2TAsq8gEWoPqzUFyjzKMgvWXWOSLlsZkzxMC27LWD20IF3vejm5VR9dDiY3q/SLkMhPmwph8fhk4ULb0Pe6G3sWVsiYJ5la8PTf5B/FnjZMHB6HJn2XnrsbDbBRjzTBGhlCdnFvulZv1zyBndBBHVexMPn+HU5AUY2Pmz5a2o5czP3JXsgUJ+AYJsT2nhrEibtpe+MjVF2IMqs3g7+mboiOhOKIgqjxBpiA/c=","authorEmailMD5":"792f0ba41abefea3485d6caefc678c90","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thank you very much Stephen for your exhaustive response.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"ab74d4eb-bb78-3a13-a22c-e53900c85f66","date":"2016-10-26T13:58:53Z","timestamp":1477490333},{"_id":"4442b79f-c628-36b3-a995-b4bf81acc56e","authorName":"Nathan Phillip Brink","authorEmailEncrypted":"iBYzVvF7ASYL6tvsM40uDbK/qIi7kmuwAgBGczY8GBOcy4m1B/21pDSF4Jtfl6wNnahAf5YjMo/uqXsrSYxN9DuAdGSrsG2bHo+FsDyUpjieYF6tAOccsh8iGQmTpanarl9VRdDnlN9ivdF1Bdzh1hwhoxC5AI/jcFPSvA9zpso5hXRHX1brsJIcZIIHaH9JwkLS0quUn1/qHf4UUD3Zeq+ruBQu23/VUpETIWOoX4euLmQEmZPG2c1jJHE+btlaaS+vQ0m7ge+3aW83jW1mnhUDtotwT4VZ0NMguyNsu2Ujqcs0E62i49AD7rgYC8PUD7NjNVb8R4nJC8DxwUEYuJ3qdQ36wUbH4s1zslL1YabFGPvfaXEDet3COC665jb2wwAvozO3lijtrxc6KlKAxWF1cmtio6nSuqmBxTDK512FUZZjYcL053jkKkqdy0IswWFs5mgMcLjSqpq9Q7vYwHRtROToh/D4ycsht1x/8zNEzcFjr7oJAsw+/z0rGXMUDwShwMGnRn8YNVRSUT7KaZ3MR3g5tE7lYCLoWTtQXBwROrQ+o9ErUaI+T4AfHphq6AiMK1YhOHkEXl2ztzFpHj8b8Sw4YvJPhRws09pBBOE+zy3vK8yEBkep07TxUeLKSXXIcPFC4W3Cx91RqezgrOrDtrmqlkBu0bLUoWejXbc=","authorEmailMD5":"a8defe14b1c80bc2bd59a1fab3848cfb","authorUri":"http://ohnopublishing.net/~ohnobinki/","authorUserId":"disqus:ohnobinki","authorFallbackAvatar":"https://disqus.com/api/users/avatars/ohnobinki.jpg","message":"So what can I call instead of `Task.Run()` to get my returned Task to magically execute inline on ASP.NET and go to the threadpool for winforms when `await`ed?","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2016-11-07T23:16:55Z","timestamp":1478560615},{"_id":"bca506ae-0e38-379b-958e-c8963e987ae2","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"You can just leave it as a regular call, and document that it should be called via `Task.Run` from the UI thread.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"4442b79f-c628-36b3-a995-b4bf81acc56e","date":"2016-11-08T06:02:39Z","timestamp":1478584959},{"_id":"5a7dc694-8903-3e21-9b62-34fae0d2c741","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"There's no UI thread in web apps.\r\n\r\nAll network access is asynchronous by nature. The client can be synchronous or asynchronous, and the server can be synchronous or asynchronous - they both make the decision that is most natural for themselves, without regard to the other side. (Exception: Browser clients *must* be asynchronous).","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"64c85f15-9192-31ce-b559-3b4779fa8b5a","date":"2016-11-27T23:57:54Z","timestamp":1480291074},{"_id":"64c85f15-9192-31ce-b559-3b4779fa8b5a","authorName":"Soumen (Rimbik)","authorEmailEncrypted":"EE2YegmHbDzzCxOF2xCVIQm88cYAhfTM+4ySrhdlCysMzjxJzfxTAADUP4dSDtK7anJGOzhlRkjQWVpKC9F0jy/qBi8JOzB6RpJ69dVXCzg2Bh/AoI3/JlKOUwbjWXFkTOhSLdl/oPbC+Quo/0FO6HuTxeDnsYKwpQ1CjVnPBraXqQ0YOEetpF8dcL28LatIhDkRw3uGHBY9icDqZDV2zWsxAM0ocf+mZVyMxLu2OpLZ3l6ncpzsatiEt4MDbj02MK+tBEPozRnFMlLnmcVWVGNe6XJ4LjEEwNy3nAO7xwBB7uDq3ZfBTkcm/I78uKaPHt+rog2L3hRX+16GsA2sTYR32DIsjPuOPT9F05D+Jey3NjcKl3sksxiZ3UMYtifeO9bGjXusWRceXBBbyJ/QZZoVmvbQjvTzxP2WPrBJ3NybE/q/obUpehPLhUrXdxCAsfCXJwLFHTiM3W4TaWwvagDh4OoN3tO4gbaM4JSjByiwzbiW8HyK+eFt/uwZGkMSa4cI9iVRAL4TNKG6kDGKvNbw2TkSYOQxGe4zIhAZZEBm6dPVLyfnx5crwBzupgfaExFXxLC6MC99zWgseEfV65MuVPunLpOSbc2M9WgNNMpAHMb8ZdBrFp+JX8+slk58DV2qDWS8uhkgZQJH4RQCvOF3Cdg2xdbjewF30hMhqbU=","authorEmailMD5":"07ac5362c00d77a0e1d888f927668f91","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"If the concern is UI thread then:  \r\npublic JsonResult Foo()  \r\n{  \r\n}  \r\n// and call using $.ajax with async: true Jquery call, then no need to write even Async await in controller level.\r\n\r\nWhat do you say?  \r\n- rimbik","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2016-11-27T10:34:38Z","timestamp":1480242878},{"_id":"847f4194-ea84-370a-9c29-1325ea733eea","authorName":"Soumen (Rimbik)","authorEmailEncrypted":"urT4PDw/ChKQhLezMYqfLVltEASf240CrKcGaMICZs4oIw3FH7Vab0jONb159p07MbRH+kFEJ1wii9k17Z5qgPP9oZlTOkHtPR9whFPPUm9Zsk2zgoSbyK7AdU629CJyeOQ8u1dWO32FvXywLZePm9uXWBF+MkUKFhlQLHxXUbV/42seuS1GRmNsBt1U4VXo+aXDzS5fAnhCWeGtNAdbIsov5EWi60l7LdF7CZ1YJQJdNqQCLzhU4wTRhdYWMZuPK9DXEFo7f7ji1ZlTHQNmeBrqCQA2/4EdY/n2oit0qQxEMAUtfja68e1UDJctWLZWuJVPipruuLHZZjLCX7rURppr/8IfJCrDEMEH6M69csaywcz9eTUTyyWN7qhuk2vrHkdDWtAzQH4SkoSUwHOZLQk3BkidFlJhSb6C/RrdQYKHjgSP3evNvGUndtkFOmz90g+HcgN4vNisS0UpEm/viYpgf/Muu9Kz3uMUbziDkObb5WZ61B/lQfr6HVmf/oM9co6bp+BxgIlLSLQBgXlfxdDfdgR/joZYx3gg3wRtorhKS9vz4ImFxr0N/S6k7VvRdnd2G8+RvAOK8uiqSQC3aPi2Yyg6gKpeVlwrXCF7Co89qTtki2YJP8jbqGhiJrORx54Tb/T8DJf0E0PWMVq9JCqMyJHCCxD13Dl9DYpdLWw=","authorEmailMD5":"07ac5362c00d77a0e1d888f927668f91","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"A solution for UI non blocking thread (no use of Async Await):  \r\n// Server side (MVC controller)  \r\npublic JsonResult FooAction()  \r\n{  \r\n var response = SomeOpt();\r\n\r\n return Json( new {   \r\n Ststus = true,   \r\n Response = response   \r\n }  \r\n );  \r\n}\r\n\r\n// And call it as\r\n\r\n$.ajax({  \r\n url: '/FooAction',  \r\n async: 'true',  \r\n dataType: 'json',  \r\n success: function(data) {  \r\n FooActionCallBack(data);  \r\n },  \r\n type: 'GET'  \r\n});\r\n\r\nfunction FooActionCallBack(data)  \r\n{  \r\n // do your opt here with the resule received  \r\n}","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2016-11-27T10:40:38Z","timestamp":1480243238},{"_id":"e9cf9d09-2ae6-3e18-9b89-0f93f033d64f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"See my followup to your other comment.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"847f4194-ea84-370a-9c29-1325ea733eea","date":"2016-11-27T23:58:39Z","timestamp":1480291119},{"_id":"80acc5e2-21aa-3f6d-80fb-709a6815cb24","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes; any kind of UI application would have the same approach. The idea is that you can use Task.Run to offload work off the UI thread, but you want to avoid creating APIs that *look* asynchronous but really aren't.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"98bdc182-b2ea-3205-8893-b6c3845cd6dc","date":"2016-11-30T14:25:13Z","timestamp":1480515913},{"_id":"98bdc182-b2ea-3205-8893-b6c3845cd6dc","authorName":"Resistance","authorEmailEncrypted":"gQAi7xqViShZ7YXx0OnTLzQRU61e9hSl5wRBWzpEN/PoRLd4xFoWpeQxf3rTtdh7mb9pa/vrPVvG5QMcrZdCeHY+iuXs5f1hPuntShxHe86VEbAjkY+MR19F7WYnCHUlKFD+iudq7fycG31mLEPcz8O7zXJdcvEn5xtIm905bGf0MZD+WRXALbj/OkFOXyIctMeqEY4+kOjDcqlPrbFGnRn4PTc9iX5Zd17SOBXyTez/KFYNTXphLzYzVHE1gKTOHOMNPNKW7Nf4LV/sbmwuMgA+9ar9Pjzk8E/KXk/qykWgLSTtNlRgagqa8GTXOxmuHlSpFykjITFDAkkiN5I4BsBlM6nAw+C5R7EeP8D3uhzlA5FBF3y7d/K2RnunKfqJoSJ1T0bCJa9QP14nQO1j+gQxEyu+2aKdZUFrl0vXeXHr77azOhvxAiJj34D9PHmShvF4rtrCsc/R0NGFDe847W0Fav1YVEL+wrHRZCzmPf7G23diPtAMU3W2ySec6hP/bOB2waSn6wZef0oZX05LYoye9Pr6i5HG/OOpMmSNecLZLUW5l/6uAoMRBi/1PMdY8k6It8kdS5tBdqOWvoGmNy/VR3VKjPcACTHDemKq4C9ITmp0MIFlAxZsbffOUvVrSiCzWwoxDa/W7gDAUpbDmGbJBJTGRFTjjKwA6hcwbko=","authorEmailMD5":"70266aff3107f40779ec2d64028a1f43","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Does this also apply to Winforms?","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2016-11-30T11:18:17Z","timestamp":1480504697},{"_id":"06a93d2c-c741-3e39-91af-7c37e3c572e1","authorName":"xleon","authorEmailEncrypted":"C4UF1bRzzIsWrC7NaVdchJCpHdHlomjzw0bSNedb89qjGtRXD/RPMb6h48qHjjkwQg4huIwOCriSSDZrb+aTYIUr4DD0Ip5Y/e+dxheocnrm+yA4ayMUSKeVlsZKaCXtZvlZgTPKMtl/V5Ke4oXMmlhFsf6scqN6wV18UW8o+ywO0zk+BZmNunNnc1L0JNpB7h5A+BP9Mew/iwyTs0g8ZpFZKa/jr+Lm88187aMRCFn6I3PXX2VfM/3AQ6k7hxsY9AK6yYdwMaeZqekvqbpLB7P9KuYK5rBYIrrpPbRS3uwdinf/2R+cl/VM8yYC1f7PwUfXOoff7cq4w/UPkQK7ZfI7bsm74bQjefCUHDAmiPu/yXrC0g+deJlsd8CRMxrBvNmOydYoR4BlO8X/wMQ1DAuc+0mT90eZ9uAiRbEgEAHHc1rUhfMEMEBvC3wIh/V5adgr/iiU362ySuWZWeLtnHy9ZunKJNRQOCK9WwAEqdSyCo/qJXcOHMKEZwsbTdtYECfU5c1rsZxayOOIy0Wp1Wj+uusyYzANw6JvrG1PO2eLD7QcyarQ1W6prcH42ZurcwkMV5gmUuPVMjjBk9APT4F4pffcwioCLbASxhLeIgh4urHW8MsbcFLHNb7sc3ZJsT+8Eg4Br8WeDtX8NvyT5VwklBHb+iq5D8wTBxjztrA=","authorEmailMD5":"b9371d959d3460b285f7f5f679a45c73","authorUri":"http://www.xleon.net","authorUserId":"disqus:xleon","authorFallbackAvatar":"https://disqus.com/api/users/avatars/xleon.jpg","message":"Nice article. What do you recommend when calling myService.CalculateMandelbrot() from a sync method (i.e: view initialization)?","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2016-12-14T21:38:36Z","timestamp":1481751516},{"_id":"ae227531-5f1c-3043-8f35-b08a864cb7de","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"If by \"view\", you mean a UI element (e.g., WPF control), then I recommend:  \r\n1) Initializing the view into a \"loading\" state.  \r\n2) Calling CalculateMandelbrot via Task.Run.  \r\n3) Wrapping that task in something like my NotifyTask type.  \r\n4) Using data binding to update the UI when the calculation completes.\r\n\r\nOn the other hand, if by \"view\", you mean an ASP.NET MVC page, then I would recommend just calling CalculateMandelbrot directly.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"06a93d2c-c741-3e39-91af-7c37e3c572e1","date":"2016-12-17T13:41:48Z","timestamp":1481982108},{"_id":"2e3e342c-567b-391b-990d-78ac00150d06","authorName":"Anass","authorEmailEncrypted":"TeplSmvm+vuoNh0J/o3cuNZMOvbwwo5edaz2pJO+GgDq+7ZhzT0VO2rTuQARRmf9bQbr+esuO90FHkDjCkg4B6X76K2MHbTMKUrpLNzj1Vr3WeISlGSnA+cQnJT9CcTjjVhYiqCDCFcObk1Y5qj03agY+GJxHWWWvfUAvI93Rn2UopyFTi6mWgnoI4u+LZYW6t8nPfFDmhNVv84F0J531XeA1xDSwvRXSrvc4zEe+easi/Vtgidiu7SSh3xrxQ0eMXB65A3UHqsoOnCS5S13eRxsJJaMpmxKlyUXunzuAMvQRWPBJMa9/y3JCPcCebIWeXliC6/PyFd3oC/PCQh+7sGDl8B9Foc/oFklIbKg2eyFQkBW797tmfHTF5Oq1T0XmRlg5DrYoGZkK0k0OBHQCbSn5bO6ZmI+m7kvDwpAPMIw7mQpYnnty6HZLIb/WGhzAn0SZm/PnmabhNwv1U2OLuzbmTAnRczK7ox2bePEilqycFsJYYm+zQfCFgut9MyGi/R74cf1vP1YhmSDOQ5EKqXpE4J876JtQ660g4LAOW7FZz3TXCAY7vlpRtbhUvXFsLj9dCvMW8Rux9xpmpYh3ShvoNAR7nGanv2XvkJ0xLp5uPSueb7KnFVKuPHx5Ccn1o2psrfT2CeUV/5+S3hnU6ew8+wxOtLDQ96OFJmBKXg=","authorEmailMD5":"343c038a8c2069be216a1bcbc7841636","authorUri":"","authorUserId":"disqus:disqus_AuwFHyA9Nk","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_AuwFHyA9Nk.jpg","message":"I guess that the ASP.NET thread pool limitations mentioned in the article no longer apply for ASP.NET Core, as it is build on top of libuv which is specialized in handling this scenarios in both Node.js and ASP.NET Core, also the fact the ASP.NET Core has a new architecture different from the one in ASP.NET which is also designed to deal with this scenarios in an efficient way. I would greatly appreciate if you can correct me in case I'm wrong or misunderstood something ?","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2017-01-03T17:47:55Z","timestamp":1483465675},{"_id":"bb9d4296-6fa5-31df-9e43-fa9484267826","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I'm not familiar enough with the internals of ASP.NET Core to say. But I would expect that it uses a similar thread pool system. Regardless of OS or library, a server thread pool will need to have some heuristics applied to avoid thread churn, and using Task.Run could throw off those heuristics.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"2e3e342c-567b-391b-990d-78ac00150d06","date":"2017-01-03T17:53:46Z","timestamp":1483466026},{"_id":"d8b2917e-f565-39c2-a220-208434f96c90","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"CPU code is fundamentally synchronous. It must run somewhere, so it *must* take up a thread, and this makes it synchronous. (In contrast I/O code does not \"run\" - it just waits for a response - so it is naturally asynchronous).\r\n\r\nSince the code is synchronous, it must run somewhere. If you call it directly, it will run on the current thread (which is bad if the thread is a UI thread). This is why the UI thread offloads it to a thread pool thread.\r\n\r\nRegarding \"Would it not solve the problem of blocking UI by just calling the calculateMandelbrot() using an await?\", I'm not sure what you envision the code to look like with that approach. You can't await something that isn't an awaitable (e.g., a task). You could mark calculateMandelbrot as async and return a Task, but since that method has nothing to await, the compiler would point out in a warning that it will run synchronously. You can avoid marking it async and return Task.FromResult, but that's just the same thing - it still runs synchronously on the UI thread. You can stick in random await calls with Task.Yield/Task.Delay, but that's a hack (dependent on client hardware) and it's still going to run all that computation on the UI thread anyway. Or you can wrap the entire method in Task.Run, and this entire blog post is about why you shouldn't do that.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"dbe84c1b-38ba-398d-98bf-f5fe98efcfe2","date":"2017-01-29T18:37:25Z","timestamp":1485715045},{"_id":"dbe84c1b-38ba-398d-98bf-f5fe98efcfe2","authorName":"Shibasis Sengupta","authorEmailEncrypted":"KK5KaTZ3hxtSCeoioSIzUehxdiafp/UzmDNtEwYsva/smNsaGlsPNc5sfYAsGI7yZNY5x1ML+BJ58nmJZ//LLOxFTGfRt/2+0A6sBoidVSFqovCgVL18z72bw3qGa+WwUQcHCz+ZOs3xnNNgWq4zTD1B2JFoXn/U9nfiZ7ruxPejcIoA5+CcWPwdhj8gzYxIyvzcZHXqC7WfY1lZQyTl0mHyXhem4v6v/QQnh69ygEHjzozdAiZAQP8Ijg+ZcTJI/TexSETdE5+74r4xz0ry+5VtaeWTcle2tkJJjqd3c+r8ouYfLqa3G4eF0JN2rD37WouQRd27VJbRp5Pg6W5zhaKW0/nG3RX0+qtiWkyjOjvQgAWKAwqszJpuMGr1Wo9UWhqUaV6ZaY3oAO1cV2Uo0x8/itPIsv68xLlqKqx8098LkPfv1McS3Z0gccoTpS63dx+u+lBHzNeJqazlhdZAs48JPiHjtuaDaSQmZ5X84eOqah9/aQ/S6oZYOaUHz0vx6PBHBoBiCSAPGvHjm0GrE+nGJ3fdEb101mMZDKmkCXT7ngXsLsGu1T91fQxsQTPdqmvBJ4GrGnSsOswYprdbQJrB6DO2gjFIz5/6XqgjXbqZrIMTWVqD0oqnlvt5yP90UrtTPR7K+PkO0ZguTtDLkurjGIUnvmapZs3SQMOa8Ps=","authorEmailMD5":"287ebcc391ebebd6332aaab93403ffd0","authorUri":"","authorUserId":"disqus:shibasis_sengupta","authorFallbackAvatar":"https://disqus.com/api/users/avatars/shibasis_sengupta.jpg","message":"Thanks Stephen for this wonderful post. I though have a question.  \r\nIn the final solution, you are still using Task.Run within a async. So the Mybutton_click still needs a switch to get a thread from the thread pool (for the call to Task.Run) and hands-over the operation to this new thread,right?  \r\nDo you really need this Thread.run? Would it not solve the problem of blocking UI by just calling the calculateMandelbrot() using an await?","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2017-01-29T03:36:44Z","timestamp":1485661004},{"_id":"c68f41f9-9512-382a-a05d-0f4be7cfd11f","authorName":"Shibasis Sengupta","authorEmailEncrypted":"UhkKlpLhGjVvyYvUm89N5q7jXKoNm05egXD7zkoLXrwwxDdld27VzZpVQKjEZs+lvfdQBXjbLShCwxFaaAFqH6DrK6UTbyQ6HQB2zUO4SAHRSuIFwW4RBjE+tiZjiHSXeNR2Z057+kYwbgYzBfBm0OSSvw/d3LtRmvs+/QCS5e9niY6XL+JJaB0lwOnSMDmoUYKaQTUeZqbDVXKt54Ytyb6aaN9RdSxr6Pa5uL5/ASkow5v0C3m1ef9mDpDmnMXRMYYvvEnfNylXMicZyHe14F+sEnnFWIA94bOklh0/+DmZ0C41KBke3kK7TnwvGUJZlVOQCcLw4NSZ0K30Ld7qADMz8nDGd/eqWfWZtXXorXS7POaGZjVCTp/HCZTNWxFfhqEkJ7PKqDortTq2YjK573tPPVRRkiWtFyQeLImhqFHoqOLsp3PsU7S5TvLvYTv2cCzntGuyCfSHaAC821Z5nEtYmpY2lbxrXRnsMp0fYzKp3FSmlkydCzUbK+CYqBJEDdae0LMRWhsQ0g1un+bjk49/w4K4Ex/cok6dWzDOI77m540Id+dBcRjJUo59a2PIrj10pI3q/pYaDEHTABj2635CSBavV9aqbcoM6eEoF/j0RgKBknriCz7jeuQTbUrcLnIuc2NJN+x9be4pSsUZazOopFqYKAwE4ASxWX7SHmY=","authorEmailMD5":"287ebcc391ebebd6332aaab93403ffd0","authorUri":"","authorUserId":"disqus:shibasis_sengupta","authorFallbackAvatar":"https://disqus.com/api/users/avatars/shibasis_sengupta.jpg","message":"Thanks Stephen.... appreciate you taking time to explain it a bit further.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"d8b2917e-f565-39c2-a220-208434f96c90","date":"2017-01-30T12:23:15Z","timestamp":1485778995},{"_id":"1f631b52-80e2-300d-89c9-3e7c582f3611","authorName":"Mike Lockwood","authorEmailEncrypted":"DVhEygIoWBQTi92wikoq1z70qbmLUBWBXD5hX7/tqIOjnzSdDmtNyGURfH73mbRzs5Zw6Sw2jtZWcIpfZZUJIOM5eOHKLgopBn1qXErKQFJQ7YcIJF0hkEfbnTTOvcUfNa3indM1APh90mMYwEaqmW/CsV0qdHn7PxfwJQpkuxGBXKbeyzfCfXdeLkuqg4VzlmbvB1/zWuhFVrXc8ji6INpqA7clA4wm0SoXqYvDMBmLfltju5RmW7Z+8+YZ3HITkxS6NTesGDhd0GcbfNIITDrIvhvk3wF8KWhPaTdoCfNeXk8efK91ErTdRYQliW2ORmuEr4Gjgw1dkDgXPRD6WasP9PP7lEp6ZW/o+IPTC43/wsjOFjODZ/JwPqpFQbER0Yr4qgG45f5PwbjgXK+PRG8KVN6iEBJ6bCl+prWdFZPpagEc+KqovapQW2yiYRNtmyHMVjWms/XsE89AAuKMTiPV1VZYwETNzSsoWutGlDgmln+wUbJ1h+ExohG0QVtGD5+MW/ASCogWwP8XSiaaGhu6mSPPRnFZ+HcvaUOJ/K4arVPc2Dm9oA49vkLIOWN3/7kbWmBqqnqvp5XmBfQ4ovb1y2+SP8ZDRZcX9jH2SRVRRuqwi+5KnNOtzN+RxH1jGla2dQdsXirDixjBQ9QPBL4GhQvfpS9FlWZKy4bvGhQ=","authorEmailMD5":"1d6adf1ef1268f3b583e976cfb1b80ba","authorUri":"","authorUserId":"disqus:mike_lockwood","authorFallbackAvatar":"","message":"So I have a question about status reporting. Using your last example how would you incorporate status reporting. I read your other post about Tasks vs Backgroundworker and understand the use Progress<t> for the status callback but how would you implement this so that both your Application could use it and the Web App? Would this require the methods to be duplicated so that one contains a parameter of IProgress?","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2017-03-20T16:13:45Z","timestamp":1490026425},{"_id":"75316956-e95c-3908-8e34-27b37bbca760","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I would have the core method take an IProgress<t>. By convention, the progress parameter can be null, so you can use a default value or have a one-line overload.\r\n\r\nRegarding *using* progress reports, Progress<t> really only makes sense in a UI application. On ASP.NET, you would either pass null or use the SignalR implementation of IProgress<t>.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"1f631b52-80e2-300d-89c9-3e7c582f3611","date":"2017-03-20T18:00:51Z","timestamp":1490032851},{"_id":"29aa1e76-9daa-354c-9904-65286f7b82a3","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"It's exactly the same as the code smell described in this blog post. It's definitely an antipattern. I don't see anything that would make it an exception. [http://blogs.msdn.com/b/pfxteam/archive/2012/03/24/10287244.aspx](http://blogs.msdn.com/b/pfxteam/archive/2012/03/24/10287244.aspx)","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"2cab4ba1-6a68-3aa0-bf77-97018cdaa2fc","date":"2017-05-04T15:50:47Z","timestamp":1493913047},{"_id":"2cab4ba1-6a68-3aa0-bf77-97018cdaa2fc","authorName":"Chase Florell","authorEmailEncrypted":"kFeh4dRRM4vs58bC46AZoMf+7zFyPQke489Do56ahsyqdx4kXfzf699+s551axgHhUuFH0PEvQZd6mbiuyYGwsYQYc5Hxgh0me9A7sOfMjxMNnBRjqElxVKtmC7fc5ifVCpFYgvlrMmvrCbY8+iV3ZqSAcSlHP3yJ1oe7UMpvp46fklM5EVego6p9mJ4YSzC368TDdvIUl7iNjvLPYR02OOeL12IcbomL6Ecsbiqyc366o1T2+P03lHI0zceLo9pYmTqTn9IZBhVU3guwAfZ/6o6hoCh1z3rvtxWP8XLRrEGoH7K9VdWVGa/ty7Ejd5OssrcaGx1hDf5BWQ8qCw03ewactZ8DumU/rWFH7z6fVmXU+zSYJ2smiLv7eo+eJALIm/Ho3YQJbJbaUk26Z7aJRORCKq5yOM9n+SlTyYpYel9pXvbQhZdaPq/xWRsuA6Xmsvn3U3z7hlXyGAmXwmgJStNMhC6jZIbtMS2bTI82Tg+yJYuI1vcWOMBvR0aVw0zGHmKSnOWyt1woNOJI9zAzr6HRaUUPAPKB8EehZJJglFLi3dKOG6WokC+oRJ+nAYYUFb1qALuKXEEQVgIMz6g/j0QfIU9eFaxXyVJ0JS24MsZxb765o6l2rgGL8yL/S0HLn0HciY6G0syOUhVzZUKAmMURF2uDsVoih5cCx46ZXc=","authorEmailMD5":"9ebf02738be8b03e5688f0b27a545ab9","authorUri":"http://chaseflorell.com","authorUserId":"disqus:ChaseFlorell","authorFallbackAvatar":"https://disqus.com/api/users/avatars/ChaseFlorell.jpg","message":"Hey Stephen, thanks for the detailed explaination. I wonder if you have any feedback on the following. It feels like the code smell that you described (except it used Task.Factory.StartNew instead), but wonder if you'd consider it an exception to your rule?\r\n\r\n[https://github.com/praeclarum/sqlite-net/blob/74b6651394b59e122960945131a9b35648f19b88/src/SQLiteAsync.cs#L101](https://github.com/praeclarum/sqlite-net/blob/74b6651394b59e122960945131a9b35648f19b88/src/SQLiteAsync.cs#L101)","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2017-05-04T05:02:12Z","timestamp":1493874132},{"_id":"56de1776-a1ba-3c42-8300-4a7e0c555c84","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"You shouldn't. CPU-bound code is synchronous by nature, and should have a synchronous API.\r\n\r\nIf by \"IO/CPU\", you mean the method does *both* I/O *and* CPU work, then I cover that in the next article in this series: [https://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-even-in.html](https://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-even-in.html)","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"db987788-33e4-3ed5-abf1-1127071a2fe4","date":"2017-05-04T17:38:29Z","timestamp":1493919509},{"_id":"db987788-33e4-3ed5-abf1-1127071a2fe4","authorName":"Chase Florell","authorEmailEncrypted":"B5xJ3cmG7sa987+IsSB3KSBIAv5CYiojT9Qm6C8RjQMEbNvJfF7oTZFOFLWoXbKKS+yplOT6Ja5YvnJyp19AoF/c9nXobVDmG0oKXfiyIElWJ6SDVp1BTW/dOYwx3XSt9TEgWdM+F3fqnAiZLjg9ZKa5bG83ywA2D3P74x4vgiaoIbpr1UfGbqZtzTxlOShT2R3UUG6sg4KefmJ3IADVia5/kYoNWVGXRFuHCMVEhdjEw7X4p5KvFnYR8BgVQuvcQHp7/6x6ud6GowTBC9L0thplp6Jcv3m4cH9aCgTqLNpDvybBYPYOCakeWtMb9rMwizOPPx5Eow8EzSU+oYRJ46zEB9eI8ie9YdqoaNjSSQJ45MhBnKVErX2N4NuCzWYqm1r6Sv+6EbICtvqnweoqQlygJv1wtHmPTtsbQAeuEyawnMeGE7LBV3OL/RGLDDZjKveqkKxSCNzBIO+Lm5Qo0gz01vsz5H8XmjBGajHizqdSG/hhZ7cErgptgizBca9CHM7Dy4+9n5dDDlmBAFQ7RnaotcOEauM1/YTpCV0JxX8esxbplBEMUix9o7ppoahO7o6FQ+sfaNoQW0Vyq/T6EjUgQ0NdO7dWgsttF/woMGdDf2+atQ2QeZAYcUS1ugWXV2+N5det0JK3TwcmGaWTM1AyimXYvAZ0Su2jW51LWWI=","authorEmailMD5":"9ebf02738be8b03e5688f0b27a545ab9","authorUri":"http://chaseflorell.com","authorUserId":"disqus:ChaseFlorell","authorFallbackAvatar":"https://disqus.com/api/users/avatars/ChaseFlorell.jpg","message":"agreed, for such a well used library I was quite surprised to see it.\r\n\r\nDo you have an example of how one would properly write IO/CPU bound operations async? IE: If I were to write my own low level API to interact with something that's CPU intensive, how would I write my library to expose the operations as async?","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"29aa1e76-9daa-354c-9904-65286f7b82a3","date":"2017-05-04T17:10:20Z","timestamp":1493917820},{"_id":"21a6be5f-fddc-3c3c-89cb-d92be0defb25","authorName":"Roland Harrison","authorEmailEncrypted":"azJ0fSu8VGniE1UXdu5DcyDr7mZ8r8AwJwlEdW80MR/Bh1EFXbcfmny1ZPBTq3WytyNVCFdu8FxnqkyByGsgecR1ydSmGhwrW9tGI6OMcpyl7QDKQRAmbVhwNvMiEqyumjDt6On7h+jvQ0A7QC60seSwYBTr75L2F6SaXTFxDq5nu6QwXiXDbAwUlLpmCvEUZnj13YRp5knNSVdYpgEz1XndY/Kt8GWAzVRwCLKLBb1SQw0DKjlz1H5uF/nyz8ET0uCwysefIidZp1a8GU7e884+K+cm5gxoBXninnZCWRvpKJiQBvx4qDWJFzBy3zW2sTE7rQLIzhD286GrFqdNb+5EER6PC+QqF5TkhzIAIwX+2OHUJ7lSmK2mbtXZIDkyn7/v/Q/M2yCdayzZZCVE0vUVXP+QZpfWLjAX1kp9ddiAs4ZrvJPtqAN6jQjzfTfSI3iflbSJgRiZfw4zAO1uTslGtQruuKZzfZr6gniMjwwPkREvRfkwIrvQPKoHTb1dqUPpXlpctttZamLTbtytsiFLHaepPeNFLHSviGb/w1VPovWcNCuoorVGX9RTEApSr0v8lLBdUo32OeUgIwpcA+uftmaPy0dOynswbn2Ew7qx3r9JSmvC/HFUzrNFjVlROfAHhVHxY/oLcshHRtBkNCFYcLu/dw6xU6ebzmYnuKk=","authorEmailMD5":"b8570cde8f8a6a5de4a2d78c4389dd22","authorUri":"","authorUserId":"disqus:rolandharrison","authorFallbackAvatar":"https://disqus.com/api/users/avatars/rolandharrison.jpg","message":"Could you give an example of where the typical Task.Factory.StartNew examples go wrong?","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"f7f673b5-af3c-355f-8bb6-f0564b8aa583","date":"2017-05-24T03:11:23Z","timestamp":1495595483},{"_id":"dc95f81c-ee4c-32a4-bff3-70b4e8d3127f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Any StartNew that does not specify a TaskScheduler is almost certainly wrong. See this blog post for details: [http://blog.stephencleary.com/2013/08/startnew-is-dangerous.html](http://blog.stephencleary.com/2013/08/startnew-is-dangerous.html)","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"21a6be5f-fddc-3c3c-89cb-d92be0defb25","date":"2017-05-24T12:03:11Z","timestamp":1495627391},{"_id":"3b95b965-60d1-3e07-8d91-229007c48fe6","authorName":"RonnieOverby","authorEmailEncrypted":"BtR1jYivYpYP4bT6IcB0xF/Q/cc1mIpa4rGnSqJKdjClkwUVgjZLFpm6FflfH5DwqV+b6MBB4M4ThkuRXGZPkH79nN5uZ3EpU74nrhidtmDRRPFvtzqyLkU55BOrkLsqsdKU1xRhZqUB+8y/8HpxNx1Y87ixBe//gT5Sc3Dck56Ldm9Px3lj76hU7oUItUZzKjDUiLHgS2v77+atjKaocAjwiyjbfBf4uWle/MiDOkQSsz19Q0p1s3kV7Z9Y8xPfjOTwLtELovKF8JbxOEIUqhb0YN9zd0xwkYosIcwFBuZRGMlQdQm82r/N6ZJchvnC6Ij8sPGdWUXB9kHkg71B0ZAlsAlXHjiHnnO4+3StPjCTGEoHcIiTW/ESJPNfbavHK1OnFTsybNksXOEXC84fkMpB6RpVlk+yDiPmwQ8mkf9/C/RXtqgnNu+On7eXow6qTmgiem+3Z+6kZ9KGOZo7f9siIG21+kv1xIQrh3rBnq2H/GVK9WzFFvXB29Vna04JmXVnFPFN6MVTvwkKYPt3k+FNE84qKe/0iUTYUcuw3St69SjQBgptv0QJwf2s67exV976KfxGjsCuLmY4l8I9hJv24FK2FTuOwCePnD0Vc4cEXt8kNBMVCzrJkLiZMexxX95zWA1ROdkcCcS2t/svtnPX7uDpq8PuK0UdJqY7xcM=","authorEmailMD5":"805e562badd03fde5a760b4a0d83b066","authorUri":"","authorUserId":"disqus:RonnieOverby","authorFallbackAvatar":"https://disqus.com/api/users/avatars/RonnieOverby.jpg","message":"I kind of miss the days when we just had threads and the thread pool. At least I knew what was going to happen and why.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2017-07-28T02:08:57Z","timestamp":1501207737},{"_id":"cd7d4f46-6959-3f9f-bbfa-717ea029cdff","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"If my response below isn't clear enough, then post a question on Stack Overflow; it's much easier to ask code questions there than in blog comments.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"d4cf6f6a-3c87-3e62-ab4f-9844be468125","date":"2017-08-14T20:09:22Z","timestamp":1502741362},{"_id":"d4cf6f6a-3c87-3e62-ab4f-9844be468125","authorName":"SHYAM S","authorEmailEncrypted":"N9tiE8MKh+kXHtSImoH28TUJ5dMmsa7yshEY/zQZfi8D9/oQpfpk+qk/jFwEvKXUcQZV/0qQooTdbQsZ4jB/+VRMnSDVJ5mQPmKyIvvJvmJ2v96iPfeSV5nKt3IWXxYXTEdlm+QO8y7PgRFXMoFWAeTFJAgbX5qohg+ZGJnOe0MyM5qxKJXyGFnzwnqgksvudXrMc/riF5q5Lz/BkpABqHEKK0VzcPnEqb/a6pLL1TnmYGsK3oQD4IcjfJgguG0L8PfS5dBEEJmhQhFllmS+f0n78+K0Wz+0JoPpjU9rtNzNuJipGY56Q9QkYBi6kmM9nlcrahkwlQRKLmU0qT5o+dns/3SxVlZg7Zs8awKDIXe0odIM4oaWlWTtXr+K+uKOaGegtzqlhi35kFXQ18VBzOB2jSfZkb3GAYA+Py8f6WdLmVuas7aISktyPN9ucqM4A3TjHG5fbtqI27crPPsxTK8CymnQ746MjMbq1CsNvuPsCPB7Rzx+xKkCItAT4rwHnY0s/0tek1pmnhDDufrUEpqiS8CVEfQAo8+RLR6mYDtG9ca5babF4560/5r7ABAbvV2LOjtokmdWM6NZQ1nXhDgAtx3i+NAUQALOu1+Y0v54hD39XNwJb+0h1qBKhJ8hDvP7u/IIkNR9AvbIM7Xe5pcNVHpmgQ/Lgk2gVlpTYFc=","authorEmailMD5":"302c587a8c4d1b8c6a8ec6291f1438ab","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I wanted to add one more point, actually these multiple DB calls do populate many properties of one class (e.g. clsPlan) and methods are being called in a one method e.g. LoadPlan(). This method also does costly CPU bound operation after DB calls(once clsPlan gets populated) to set more another properties of same class. So, in conclusion, my call hierarchy would be like OpenPlan() Calls --> LoadPlan() and several another method related to view... LoadPLan() --> Several DB calls (private methods) and in-memory manipulation to populate clsPlan object.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2017-08-14T07:53:08Z","timestamp":1502697188},{"_id":"da90ab1d-2c6d-36e4-813d-dd62d07d25ba","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Since these are I/O-bound and not CPU-bound methods, you should use async/await with Task.WhenAll. This will make them all run concurrently.\r\n\r\nFor more information, see \"Async Composition\" in my Async Intro post: [https://blog.stephencleary.com/2012/02/async-and-await.html](https://blog.stephencleary.com/2012/02/async-and-await.html)","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"f14bf2a8-b238-3ea1-b6d7-0987667891f6","date":"2017-08-14T20:06:31Z","timestamp":1502741191},{"_id":"f14bf2a8-b238-3ea1-b6d7-0987667891f6","authorName":"SHYAM S","authorEmailEncrypted":"Z2pGtT9zjBY0ecKbl/zWoyL/yv6xUBINzt+gECmeJYzov+5U7w2PVwKsGdbVTGvKhB+VVu4NusjYQor/+pOe8/dpHc9xd/CWqUj6aC/H5Xxnf1zkreFxWO+VasFD53T0fi3rrdl0+5RLojN44vdI5mk1rpS6DKQr/INVyrjd9WZVGCnh8mrzvHF/YeUJCDYdEgORbw6vq+b0a1kcE5wnUEyPQgjkHdeXi6Ox4gJnDQ+N9TqduqIbLsqNsSZPP6C1WDttKObyKde+/ClZKTh7tcCYfuTuM0FzNfyz1HGrebe+anvEz1+6dInqqW2kcU6joCAgyPHW5F13RkR2GGg+d6fCuyt9J00yyYGukxc1OOy4lJdj5iS/35FY+XJ6dEBnjqbd9YWMoqqVU5vdU/V7O8v/fLqGaDMTXiYBO53+0N0QiCMfyeZX0z0lv4ro1fmT8Hd0k8i7OT2OscC1tbavAXgf16Oamt3FkeYjgTv+QsFJ9icLSxJJNKRzHDzK/qd7L1N38DHWGJDKVpyjQR2s6rCXWl100AWTK0JUHFH3oloxU0eIi+XGG5kY/vweDa205mPYXvBOLEgYIznCJEmwbL17srpoAZt4S946mnoR6rM4mCKDVBB4Q8t1yDq5ClXgZfHEEArEbSg2gGjgxKY7TBmxhBWIhaZ9/A7jzqUBkVc=","authorEmailMD5":"302c587a8c4d1b8c6a8ec6291f1438ab","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hi,   \r\nIf I have mutiple getDBMethod()(around 10 and all are synchronous) Instead of in-memory method CalculateMandelbrot() , then how can I call these DB methods in parallel. This project(Window Based) is already developed but having performance concern so I started to refactoring the existing codeby using Async-Await.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2017-08-14T07:38:47Z","timestamp":1502696327},{"_id":"5f25e192-5a90-3e88-87cf-e1aea6299637","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"For any kind of real performance improvement, you'll need to remove the DataTable completely. If this update can be done server, side, use a SQL statement. Otherwise, I'd recommend Entity Framework.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"715a06c4-59d6-391f-955b-56c751d6a738","date":"2017-09-01T14:51:38Z","timestamp":1504277498},{"_id":"715a06c4-59d6-391f-955b-56c751d6a738","authorName":"SHYAM S","authorEmailEncrypted":"fiOu+ygx4ZYjgGTdN9LZlwxSVmRu9bZds1LjbOoF4s9oi+qG3MKPWo1FpTfA91HvU/p0/YMV1Kq6r55j00z/F/W+zlW0gvRzFAybDLqcRKnuTLVacrlqN8bHQrpPQiPSwGa5g5cl+HRmkRhElGeGiSmQ1f928aBTzBwLg4/kXLZTjQy1+Td7MtFt/4Pu9Hecnx+bJBS5+6AozU5x35XRzGOVtkSS21GufVz2xTXUsK2nZ/gZzEj90M4teEmJP4qQx45zgwTPIfxnXdLQyBdX47+q+Lkc2Lg7JVbfGIeBDgXOoIaB6LvqXQXO4BCxUikN2mj75nLuDC0/dVpTHi48NITj8zmw3XqzwsdMKD6o3bLagYJSBHG7bsHZFD+L6H7KHBe9pnbjHqokB4+RV+9X2Ogfp73ECP0rldxn/lgVzyvsYbZ8mF75BUoqy4ALtGkTs710b+2b+ZWQis8YDmPOkv+fdxV1OejwIIMys46XXOLtl7EorlVLnUnpF0sFiBeTbJpMC/vUwF6pBGvIqUV3BiSoMHORr62Kzr7R7KxU2i9eZNlG8xwCqit41EvrBCZUm+6YfTxg9W46JIDz89XaGn7AQOHaWvDMn8iu9aXjkhyRNOxjtIwu9DkzxKSi0TaPZzsa6RVFADeFy+i071yyqdc/4wBIzQsmqIuyA4Dp/Wk=","authorEmailMD5":"302c587a8c4d1b8c6a8ec6291f1438ab","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thanks a lot for your answer.   \r\nHow can I improve DataTable iteration with million of records, in which I am updating the records(cell of datatable) by some math calculation (e.f. cellvalue= (b*c) /d ).  \r\nPlease give your suggestion because client is asking for performance improvement.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"da90ab1d-2c6d-36e4-813d-dd62d07d25ba","date":"2017-09-01T13:39:45Z","timestamp":1504273185},{"_id":"9e40f266-a67a-33d0-9675-3ae4c6ad419c","authorName":"Anoop Thomas","authorEmailEncrypted":"i4nmnMGnAWssTk120vyWZLAi6q4MqEmwi8YJKn2Em7qex7Ops0vtrdKn9eRN9CAPyJNew6nxcjpCWBviwhJk44d+iD1x4bm/hlwM+BYaHNwRD6Re9j2vd18TXEj2F5mszjI/SMmnGZBroPbw9f7fVYN1BHxyji+wttnxC60ZRNDgkwCT5zFxc7cRDQe1dDy4fOliWL3Pr1NKTzyNRLo7p5bGcMrAx0DHVoAglyVveOZ1mBKM3kEhRYh8cLc0+EexMbGLFvyp8quAf3I0Z0pG9Xd/Iqd6Vg4N8Fz10xykxVSmoUaSCJSQVvL5D8ebHdPQaYdF8FWrTEdJi+NwfNRiUxpiTawhDwQCK7p/s3hBUc3077Zu9G5TCZM8oqgrJcrzTaEYAom2GQYgelwoI+rI00hlZY4SeZY9Z2LpODZto0AqZwsKV1SFIYh2bSDyZf01TGi5i8EzMAZJFqyzEeXO2BVsdKO2X4MskkrndtwLIn5X6crJiFQowOYk6a9sMjP/iHNdn5OLcQK158s/80EOSW5L1Y7bxKM+O31US63nW5oEICQ0qfOrTsc+QJDbXEKjqcEYdkgceW8+SCZTwQV3gzf+Y8W4ue10CI1r27ywz+sPj2YA2xFTbXQmCgL3UfHboFempHkR1leZUqHfoNyBO2An65fQsrsdwcyqAW2HBSE=","authorEmailMD5":"9bb9e60947145b135f5e8cd8a9e6a191","authorUri":"","authorUserId":"disqus:disqus_gJNBTjkFHI","authorFallbackAvatar":"","message":"Hello Stephen! Thank you for a clear explanation about Tasks. In a current application which I am working on, I am using the technique which you have described here \"using [Task.run](http://Task.run) to call methods\". In this case I have a question. The method I am calling via Task does not return any value. It actually selects or populates a database table. Therefore I haven't used async-await. Is it a right implementation?Will it have an effect on the performance. Here my aim to use the Tasks is same reason as in the example. I wanted the method called by the task to run in a thread separate from the UI thread.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2017-09-13T20:13:25Z","timestamp":1505333605},{"_id":"3b3352da-269f-3269-b230-4d32ce0920ca","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"You should still await the task returned from Task.Run; this will allow you to detect and respond to exceptions.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"9e40f266-a67a-33d0-9675-3ae4c6ad419c","date":"2017-09-14T14:30:47Z","timestamp":1505399447},{"_id":"d24b4127-2baf-33bf-a461-566d1a85ce47","authorName":"Filip Cordas","authorEmailEncrypted":"vuhPvoucORlfVZdpETmLYTW8KCJEGV22sNhyU34a9wpsNZJk/jIsYsbowfOvyCsAJOw6mytnRbGVjrpkUgEUYsBOEzhy7ctwMqyHxLzFErYiCrlsw8Rz5pIluuLQyR4DKlLc84Bm0Bt03W+pxTna6XaOVRT6MqM6itDY5PqgmwmsxSOZmMCMeYc0cXyuUgaq4lTsL2HJHTa5E++Dt68CLsVEwJxhYhO7mS7vSOTL7UvlVeYX/zj/BAdyK1/lJILDPnfwPb3/xLZcwnYEXJQF+tqZ3LbNClRycsBESN9d0rpGV2pFvi+wgwfgtRRTg/3IGJ6m9CJgpmXa9yBiCu/EYR2eppO4QYSG+/ed3nmkwZf5Db3yNyPiaJq+g3ghSbnIN2BrIjYHFpTBSZuC8GeWq2k0P52RjXNkwzYd08jEEhwmJYTizc1emxu7xj/nzzdcDGzNvRl2d1tonOlOtUjvypf9135k9etBzGWFBvzolwdclPgYjyg/AZPdMA5fAMsTKSUKFUmp308B93qrCZhw9P0WNn8wIAQeaRVxO+p3e/Mv+IJDpnCddASgj1gokM7aUR99AqTDdDyuGR7NCelJwYux3lQNib1fLxu8kiWiFEVtWQt4TXJwyJslw3k54IAzsQTdRSIYS5ZezYXOO3a39XhL0tWPuRpictbCeX6S/4w=","authorEmailMD5":"5a0f72bd57a0cd7441313cf75d048196","authorUri":"","authorUserId":"disqus:filipcordas","authorFallbackAvatar":"","message":"I think you should just rename this to threads don't increase performance. Even in the none [Asp.net](http://Asp.net) example the code will be slower on a single core processor. It seams to me this is just for people that don't understand multithreading and has nothing to do with tasks. Threads by definition decrease performance so I don't understand what why would it be a surprise that this is the case with Task.Run. Making things parallel is what increases the performance. But I am more interested if this is really that big of a performance downfall or is it in reality a micro optimization.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2017-09-25T10:10:09Z","timestamp":1506334209},{"_id":"36b0a164-4433-3a2b-a0ed-efcded40dac0","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"This article isn't about performance. It's about a developer who wants to write asynchronous code, and attempts to do so using Task.Run, when the correct solution is to leave it synchronous.\r\n\r\nThreads can increase performance. Even in ASP.NET, you can often use parallel processing (multiple threads) to return a single result faster - but at the expense of the scalability of your web server (so I always strongly caution against it).\r\n\r\nAvoiding Task.Run on ASP.NET isn't a micro optimization. Devs have to go out of their way to use Task.Run and make things asynchronous when they should be synchronous. So avoiding Task.Run here isn't an optimization - rather, it's *not* doing a pessimization.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"d24b4127-2baf-33bf-a461-566d1a85ce47","date":"2017-09-27T13:29:47Z","timestamp":1506518987},{"_id":"50e2989c-bc75-34df-8416-429a0df8278b","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"My point is that using Task.Run to implement a fake-async method should be avoided because it's wrong. It forces multithreading into environments that don't need it.\r\n\r\nIt can also cause performance issues on ASP.NET in some situations, mainly dealing with heavy load or saturated thread pools, and especially when the work takes more than a few seconds.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"bc813a6d-7eaf-3938-b500-3ce5e92ac48b","date":"2017-09-27T21:46:18Z","timestamp":1506548778},{"_id":"bc813a6d-7eaf-3938-b500-3ce5e92ac48b","authorName":"Filip Cordas","authorEmailEncrypted":"f3eIv+ovrJluHW3O1h/Pl0GPeipuR4f6CqGr2LeHbIiftQSFn7RoRNPadsclPqBiegQ8Y11vnJaxu6rb8N/gc0SD3miy9Z3uzF5SRbjEWmKbDmQ+5fj1bZlqTs/N/ufF1IZVhUkztk/JXvEcujFeLQFfzteix/50UeRIIU7UCqNSJ0YDA6JOn6/SDlPnWRMb/6k+6Ubhp8pKxAuKfL2gKytbKsPNhngjfTvUUkxhQpVNLE5pQO5VO6kivJlUAajTVW5HONktO9n79LDwjNWNDmiz3n0Kjcd7K/gLWPRiC1pFIyVjnxidAG/sFQMjNb7wIbY/gxoH2ZqrDn2H2fbV4BeY7Gy8Ry0CA4PZNNmgloDFLijSSed10HZD0jbgOaplBTgP79vT+fJCoNiQvki4HmCtKJfQb+FqQoDhwwn1D0bRoF0rkPnsAHVYDUNRyCnQxgG9Z8KTiL71a/p3ntXfiLn6HjkVUHDDDZKgcIziAJDj8Hh1lpwTi4Zsg2m/Veh5MX2Z73ylB1A/qFEf/yHaqLmbk6l8BEnnt4rP9nBrrgP7JFlrOrQMlzNYapshSi41DXP+Ft/zA7eF50PJPe63F7OXL1SiTnZxujet0hSTYOmqI6d5fd2xiz1kPpcaNti9KBjNvbf06+ETU6bVYbSD3NpUGG0oQaa3kT0xXmM7RfE=","authorEmailMD5":"5a0f72bd57a0cd7441313cf75d048196","authorUri":"","authorUserId":"disqus:filipcordas","authorFallbackAvatar":"","message":"No I do get what this post was about I am just not sure if this is all that of a perf issue and should be avoided because of that. I mean linq is slower that doing things in for loops but I won't stop using it . Do you know of some tests that show how much of a drop will you get under high or low load? From all the tests I run the perf drop was minor few milliseconds per 1000 requests I didn't do anything to fancy just simple calls with http get on the same machine so I might be way off. Creating a thread will have a big impact even in the UI example it will in fact run slower then a sync call, but if you have a multi core processor it will run in parallel so your UI won't be blocked and it gives user the appearance it runs faster. But when it comes to ASP.NET the new threads will all use the same thread pool so in most cases this will just reuse an existing thread and not create a new one. This dose have a perf impact but it's not as big as real thread creation. And I was just wondering is this a real issue. For example in a single thread javascript timer function was used to split an execution loop in other to let other operations use the processor. Even in c# parallel != thread for really intensive math operations that can be run in parallel you have Cuda and other graphic engines that will run much faster and they don't use threads.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"36b0a164-4433-3a2b-a0ed-efcded40dac0","date":"2017-09-27T16:31:57Z","timestamp":1506529917},{"_id":"c360807d-30c4-3ddc-b986-bc9d48282819","authorName":"Filip Cordas","authorEmailEncrypted":"nvsyMuPSJy+rDHeQvKSLQi2jl4v6PRF0tQTG4Y6SmQ6Mhho02qTyx4sMh9/MUpFZxiAefMSIKWz+AIT8CiU1VjMfRDBttTkdsvWHzfUkUEDFCBM+MsBvnodhex0M+Dxg5HC970THGybPvPW3kQP2aNR0AEAKxMLLZ/veHlFr93ogd86S/OlbodNR8rdQBu3vXcBhJeLJ0+PNZF7KM6yJjf3/x8NXkGDJeAjIFp27zOHvic2ZsyZ2edJ5Zk/TMyd2kyp3CvMzW+rQKhDgJ8hFZSV3K7GSNqQpeN2+1D1TY7wAN+It6ChjI183eQFS5mtBkalJv5jdpL6bmZRksoYaKJekD6Ec5Rs7bylzfgF/Mr+ZLqbIODjQGIlRFTZVyiozj0ooYSLspBSqyFrE05fYCwZQhSQPMtsbeSr0XGNANWjLXKVFiV3XWM8PRGcnVTxpwLdRkQeiUlxXZkdfdnDTcxaGT3Ic9ou38NxYwTvhTBswoOWz/Mm71LoIkmsmnX2RbofXC6QZHlK1uEVmoFRA2eEZ2MAoGElGIXOYuNP09Tnk+oKNyPPmpsO/ZQYo/cq2KThPq2oJGmey76mmmO+KVOqg7bwhh3AAuze27TUJvJjsiP9w657tuQWuKXWgSzL1M3VE3iQNGhScOrA9PQ7E1aIb5QfevhmhuqOa8jqcatk=","authorEmailMD5":"5a0f72bd57a0cd7441313cf75d048196","authorUri":"","authorUserId":"disqus:filipcordas","authorFallbackAvatar":"","message":"I don't know I just don't see this as that big of a problem. This is not a 'fake' async method it's just as real as any other method it's not as optimized as it could be but I have doubts about how bad this will perform. For front end apps this can be a excellent solution to deal with how different platforms handle background work, that way you can reuse your ViewModels and have different implementation of the service for different platforms. For server side you could still use this if you don't care about micro optimization but if you are just copy pasting your UI code and think you won't have problems this is the least of your problems.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"50e2989c-bc75-34df-8416-429a0df8278b","date":"2017-09-27T23:07:27Z","timestamp":1506553647},{"_id":"cb39059e-653f-3739-b7e6-12e7f145d530","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, I agree that it's OK for UI apps. And it may or may not be acceptable for ASP.NET apps.\r\n\r\nIn particular, Task.Run is OK (though I would argue not ideal) for abstracting platform implementations of operations that should be asynchronous. But that's not at all what this post is about; this post is about operations that are synchronous.\r\n\r\nThis post is dealing with the common problem where devs assume *everything* must be asynchronous. I'm searching a list for a string? Wrap it in Task.Run, and now it's an asynchronous search! I'm summing the values of an array? Wrap it in Task.Run, and now it's an asynchronous calculation!\r\n\r\nIn cases like these - where the operation is synchronous - wrapping the implementation in Task.Run and pretending it's asynchronous doesn't provide any benefit over the recommended solution of *calling* it via Task.Run.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"c360807d-30c4-3ddc-b986-bc9d48282819","date":"2017-09-28T13:42:32Z","timestamp":1506606152},{"_id":"1fe8efba-1885-37cb-ae5f-312b77b4b092","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, it's still a bad practice.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"3b35d465-3ed0-39d4-8551-37a8342fc13e","date":"2017-11-01T18:40:02Z","timestamp":1509561602},{"_id":"3b35d465-3ed0-39d4-8551-37a8342fc13e","authorName":"Zdeno","authorEmailEncrypted":"X14UqsDpEXNMw+yBo9ahG+TY4KIVvXaz4t9kjSTUc+sNuAMSccC/bQMX/lnAwBSSdT6hf8Iqg+/LNdOl1JFCk3YTpEwUbX1lOHSGGevr2GRwB8RSCJb7+YxlYJeAMEy6J7hdAk7lXNY1Wj4tYyWjjwJmzKwcFciJapRbmk5GNN7ZUhfSJmwoS+cScfgXAzsUu9CiQwNrFiS9x4UpStbgCCVjfRmOFJeOXVxqdFggODbmYxKyNH7bgk4iS3L5rPJAe1zXV5yrV4M62HwEWiJ0excTDnW6pwafaT0PtFCOCxHy2ZXc+IfUf6g8usy3/hmRQefs9XZeuizFzxV7ZVO9l6qq1RLU0kM44wUGK67fxxsbAdTvE5/TzypCu89/6hD1oltD32q9mmx7ibCSWdmu96RWU/tp4LVl3skTWGrJT9Vr6g5JSj1qTu96IkE4CHnnPMKZU4e8fJOUzaeCCIK70+Qr1Wh63vgD1EDv34vlpPRtnD4oKZoO8MuzBHRN3zNS8pT9u6YWdzEUTzISal7W4dnwpWP8ZHP1IL50nr3NQ+tdRUt9mxDwnIaO3FB9URnmo8y6iMZ2x36PEL7ZbyYnKEcogSLBVOfcL28lMtlkABCx9VG9S59KK/UEK/vtv5298wp0yTPfoYVQCFike1wMZjHXD7kWKHPOMnx0wV3QIEE=","authorEmailMD5":"dc0ec3e4dafd2207137ebe76d765b8b2","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen, Is it still \"Bad Practice\" to use Task.Run in Asp.Net Core 2 scenarios? Because Asp.Net engine doesn't know about \"borrowed\" thread? Thanks.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2017-11-01T08:09:03Z","timestamp":1509523743},{"_id":"ce2da673-579d-3b11-8611-14ec537f720f","authorName":"Denis Malyshev","authorEmailEncrypted":"iSa5PvKoXCwW1mUliJEc5WTiuJZdqYPMtLujaPunixf7y3AjryCG73Z3T763P0tD7RRgF53YfHQYUd4X0t7tITKUQ8Ea75rvIgRX2wWidq6k6t/H/nGK8j0joE3+GPDwJm+/x5F0y1ra2myM0/sYLRz8sckB6x25H1ltXGtIk9CMw/iGWO6tCbhHZnsmqhdIx9jOv4o5Kg5m41FnOjLTUxnoVxDd6mtXUGoM+EzXrHFOyyVttI2QYkJo8aNCb3teA/3YDf53oUcirP3f7b8NFoe0KmljjgVngQOpWUZOCJ3rtRSr7GO3vAow1NMtVarjFBaqPpnBOfm1yHciw61pv9HS9Y/EVRE2OUMtfUdtrjLIxgUqCTyp9Eteclm/b/suV/v0B/zVcOUzscpqWO5yW2upyaUQnssQygTDwtj/BgNF2HDWqOscyDsv4XeAyklHbNWS+D/fkXY4GgIztF2pGhPaUCTqz9ICiF0tzJ2YhCxzGLP6YuS9hbQxvaOs/yOFFODYIlsU+wET77Mn4+++ZLvudCuK8hg6J1HADP44QElNho3j7YWU+ju2EMlt7QPDX+uMZQj0LEuwiKWotzMpansWHwr3L03zMtpCcMRyI0tQYvFspnzHyHxTGDR0pshcti9j65obzfVCbg2SrK76L6eUss0j87fQMA94x2SAedA=","authorEmailMD5":"6a436c69165ddada62380ce86e81007f","authorUri":"","authorUserId":"disqus:disqus_P2wv3ihRJI","authorFallbackAvatar":"","message":"Hi Stephen, thank you for a great article.\r\n\r\nYou wrote:  \r\n> More to the point, this means that ASP.NET applications should avoid Task.Run.\r\n\r\nI have a question though. How else can I make File.Exists call asynchronous in ASP.NET app if not with Task.Run?","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2017-11-23T12:10:58Z","timestamp":1511439058},{"_id":"ee950e0e-c3fa-3fbd-b506-aa75c40354d6","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"File.Exists is an interesting case. It's a method that should be asynchronous, but it's not. So you just have to call it synchronously. Calling it with Task.Run will not give you any benefit.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"ce2da673-579d-3b11-8611-14ec537f720f","date":"2017-11-28T13:33:45Z","timestamp":1511876025},{"_id":"0893ef3b-1f51-38ca-9213-11e9c3dc4f9e","authorName":"Mark Wood","authorEmailEncrypted":"MN95Iuoil7iWs39bpF9/B1k4N49CPH0a/GFgOBh4jfVy3F95k4Gv5Fh/uSi5cDdO3Aefl+JawV4xtFnXqleGvNggxHcp6vu0XNVEr/8n5vNzOskGtL1Rg6t030RSm2rb6avS0Oa1otammgP9enHidmtRhD58AROCU0Lsn/V8JDAP1+zbz8yO4s4XV3h4P4NuDUtNgkaqYilGTGEoWqBhgSpg4svOZQSlVV/42MsVuBdObuuga5/HuC9ZMFY4P5KsfaNPUQZ/RnvBVnnBaPxjBrXe3KuwTpPXcvCPYvS5LE/dYTfZ4RvANXPMNNeN/OQAXsrl4Flm/v3Cf2Q8ec5LpbEuX1y0niHO5JKjYgGWiyl17Pjz41EtdLfNkDnqWNFl2Z6lEi42hieSTsLFvkav6ARPZrVazvm7wsGeS44Y9LHSIDqQ//D9EFZ/WwluijfGxIpTv60l0MTPl/3mPzbXHdpB1tLcOqG4AI4mxekjARKi84NRAVsV8M124XHQxJdPCQF3lXrRAxKoPsjI+uZxIgmKHsh3clcKiQx4J0r0ITPsyJ8x+AndITCDR08xBbUNGLES6fMFuSCGrGB5UA0hgvx6P5pecdMi2DnH4XnzBl2QsDo1eUUM3TYzxV5Yct/j/xSYT+AqnNe8M2VvcPM7OyFZlSNqSQOwj/EGAOhJeVo=","authorEmailMD5":"35c619f3abd4883d7c123fb584feea98","authorUri":"","authorUserId":"disqus:disqus_djXku1fbK8","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_djXku1fbK8.jpg","message":"I have a web service that, in order to respond to a request, needs to retrieve the contents of multiple files (Azure blobs, to be precise). Since I'd like to reduce request latency, retrieving the objects in parallel would be desirable. Having the entry point make a bounded number of multiple Task.Run calls to retrieve each object seems like the most straightforward approach, but based on your comments about avoiding Task.Run in server methods and for non CPU-bound activities, I am wondering if there is a downside to this approach I'm not aware of.\r\n\r\nThe retrieval of each object should be relatively short, well less than the couple of seconds you speak of, so perhaps it should have minimal impact on the threadpool heuristics?\r\n\r\nIn my limited testing, the parallelism works as expected, improving performance with no observable ill-effects, but I have not put this into a production environment.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2018-01-03T17:58:33Z","timestamp":1515002313},{"_id":"20831182-ea6a-3e18-84c3-04b75389ee4b","authorName":"Mark Wood","authorEmailEncrypted":"iP9gR3ptnT6cK38vvGgO7unEMo2nU/466YCIL7TkMSovhPKADzkZT6CGPqs58g3d0Sm/SZ8H62TnT7kznjYxUoRTuBfuER7tz++95vaGFgd/NzirydhbuLjvDENS3Ro9K7of6OFFX+sWNlpVL8kpJMSDLjv0dVcuDLtLJjQPbbL2/C6gFRNyozNLvdfIdmh2t6A7ZkCxajRgdiMPG2PHTbfyky8d07YQA8gaq2+pTm75tgZSQFWlLJ1W+UZ+hKZDZHXVbonnlNWvVipc5cqlsQchJtSv1TZ2ihdUAr/IA0ty8k9S/na+CuLdaWRdIE2NA8hbw6qiPRguMfsu9UtSV3K6bdm3B8afjTlqREbebRcNJ56PVQ5xaaeYJ0WbFwchYK9zAZvkZ5JAKnjQ0ws6JHcaiG2L9RcssMOXgXfxzS25mu6+VgqRl+KjZ0hcJ1v3RhpEDxZwmhrXcaYmY2xYkrdm7DeqB5O/xU7C/o1W7yebjISVyl9aRqcyRInY2ZLHRQAhvZjhCS8nubVifmwbSKANnFzUtUaoDVRKnidejREimE6/C7ROugDznGAXqPp61Cko0SJVAVLj/aA3tSS2PCY1JlPJzxSeOJ9eWcHVbFHYBA2igvzj65vsBtbl7eq5iwR5Wk7hFw7/RJWEnvwfxNvHqc/OXmgdu8FgOTMcVos=","authorEmailMD5":"35c619f3abd4883d7c123fb584feea98","authorUri":"","authorUserId":"disqus:disqus_djXku1fbK8","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_djXku1fbK8.jpg","message":"Thanks for the response; it's greatly appreciated, and that is indeed a very simple change.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"fff513ab-5516-35c2-974e-9e56483afa47","date":"2018-01-03T19:38:41Z","timestamp":1515008321},{"_id":"b00b5b8a-4933-3e39-a909-60240440b631","authorName":"FCin","authorEmailEncrypted":"RQETPOYEyK7kA1J2Z3G9dRcvT18jNkQxKoWWWdq1rvdrDEdiXDUeE9fN0ZZyZoEx3WfSh2Gmnc03e626J2g8iakX507V7LhXA6racTkFR0tkI8sIihDT+KT9Rw4uX+Ifj3fXmNlv7Cp8gryFk9tDgPzesGoOJM1wPTEI1ojG+xVwTy3WTuobi4iM8KurxnBrR2QAzlohJp87wlAsMiksOAWRsqKngcaDJpiSfIB0ddaN0hX9wkc4eE7AqVi5wUCkDfvrH2r1E+fMvoiXNJ6PBgLXvu5NBeRhZ5gwDRv162gYsn80SEsq6Uc5t7wTPTsXIhyRXNPDoPDgEx0eaTWTlfFOsKbVmOm2/HGAu1wBgZ3NlDkQiLDvmEVEbHU2lqTX7DVz100fed1VUblOkYdea0OjYXb3ZjlHlyXYMvXrrOwCSabuto6A5rgZ8e9K0d6/N1MsfCK8jYQCz7zxHzfQ2Z8hkwgcrjBW9Ls1il6qFP+HELMs7wZJ0JUo8ri8MBLYMnphVSHCYiqOZdjCp2bCiQnHOcBSVny2gke/HgTF35jJr/eZvvivzkzwveL1UvLojBdgpUt00MsYaWMAlfL/QAeZsY4g++ujhE9JorNh3EZq+qN4V3OVnb834D20SBMnOjiEuPhlgJo4kJT7umv0HIFo58gEDibj1zwuhyMQl44=","authorEmailMD5":"e56519a197bbc3bdcdc2a72523dcfe60","authorUri":"","authorUserId":"disqus:disqus_Tb8tUtqeBY","authorFallbackAvatar":"","message":"Hi, I'm a little bit confused by the second and the last piece of code. They are almost identical, except in the last example the caller is responsible for running the task asynchronous. So how come that with the first approach you lose a thread and in the last one you dont?  \r\n In the 4th piece of code you wrote \"Task.Run starts a task on the thread pool to do the calculations. The ASP.NET thread pool has to deal with (unexpectedly) losing one of its threads for the duration of this request.\". But the last example also uses Task.Run so how come it doesn't unexpectedly take a thread from the thread pool?","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2018-01-03T20:24:06Z","timestamp":1515011046},{"_id":"fff513ab-5516-35c2-974e-9e56483afa47","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The problem with using multiple threads - even for a few seconds - is that those threads aren't available to serve other requests. Since your operation is I/O bound (reading Azure blobs), it should be straightforward to start each download (getting a task instance for each download from the Azure client API), and then await Task.WhenAll on those tasks. This will give you a fully asynchronous approach.\r\n\r\nThe asynchronous approach will reduce your latency for that request, while also not reducing the responsiveness and scalability of your server as a whole.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"0893ef3b-1f51-38ca-9213-11e9c3dc4f9e","date":"2018-01-03T18:47:00Z","timestamp":1515005220},{"_id":"985b1f3f-eba6-38cb-9d96-3f9792c0405a","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"In the last example, the only caller shown is the UI caller. Only the UI should use Task.Run. The ASP.NET caller would look like this:\r\n\r\npublic class MandelbrotController: Controller  \r\n{  \r\n public ActionResult Index()  \r\n {  \r\n var result = myService.CalculateMandelbrot();  \r\n return View(result);  \r\n }  \r\n}","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"b00b5b8a-4933-3e39-a909-60240440b631","date":"2018-01-04T01:58:10Z","timestamp":1515031090},{"_id":"5bd16eb2-12b7-3830-b417-223ea2737495","authorName":"swguy","authorEmailEncrypted":"qzWCRsA2PoWD4154Cd6DgXmv0v5dArQZzOSoRWZ9DQccCbzVFtK8rmPwc53c9q1fPsv4/89lxMwYKguKkn37IJ6kq1kMH2lPe8sPMu5h4t0E10gqgjuut7J+ict6q/alm9O7lRUFX28ba7ZEu1KGz6HATvsdTWrCVWmhYpJI9uYjk6W8I1u33wPOIQRrgmTuA1RpM5WXXNM3yxSWi165xc4IBquuyJHFIy8UO34llJQg1RpjT731/pnW3TjiwgdGZt9LcflRmcvr4/M+AwY21QqmRYY3HsqNxc3UBuckFmgIrgnWv7RN07Deh83TUl9pcDsy/mWoZsAICNlzPUWADyXvFpeka69fopB9nH2k2DuIzRXd0VRAhUfoX3CFt3cXXVhycKOGZISkw44Hj+1IIcLqo6uH8AamekegK2NFXUOMqdr9PgiisNFLktWIfQFww0VZzC4hpqVcgEIPw3HiPLjdrpEDTyLeyVuEkgOzI9AAVY4Mlh93VDVYU02ZCpAA7pXATyXaYoqJpaynLUHnufy/smNujn+5g9Ge7GhaBMD99u3bOicqqgoK3Wa9e3yoME7hf9ABDj6B0dOTYY0Cgdzsik6E/1H0UrXDxalWAGccNO4rkYO4ljCmt98B+rkuNRTuZ4wQqdaTJW4WbKRNpPpLj2DDUCIG7RCfEBj+7y0=","authorEmailMD5":"dff31c2dbf470bf2bb52b4475a55bbb6","authorUri":"","authorUserId":"disqus:disqus_AotfLQLpFq","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_AotfLQLpFq.jpg","message":"Hi Stephen - Thanks for supporting community with your work on async\\await. Your right way seems to be in contradiction with this - [http://www.ben-morris.com/why-you-shouldnt-create-asynchronous-wrappers-with-task-run/](http://www.ben-morris.com/why-you-shouldnt-create-asynchronous-wrappers-with-task-run/) Please take a look","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2018-01-12T01:05:02Z","timestamp":1515719102},{"_id":"9f28d167-7db6-3863-b01d-91b952052bd9","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"No; we're saying the same thing: Task.Run should not be used in the implementation; only by the calling code (if necessary).","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"5bd16eb2-12b7-3830-b417-223ea2737495","date":"2018-01-12T14:10:50Z","timestamp":1515766250},{"_id":"43735249-20f6-3b4d-96ba-f43cf5f40c31","authorName":"Emil","authorEmailEncrypted":"XEwmbz8b7CTSLrfisGJQj3TQDSj0SUChP6u4EemMutRqvLs4IRuRNSr6S/fWHwXAdYiTSrmDC1qLyA7fRAbmgdEK0EiHPlz/Piih54Y3hrQc01AlV9DSZLdgOsHUMynC2dMU1GWLUGbQ/Qj0CkAqz+HBP+MVSVt61+/yvEd2fJXkzgvxrynAnafl65RpKD/NLR4LftIKGrQS/R5apFhVE9rXJ/uIn/D/RhNSgdPeIiRheZJ0j6qq5THhg7kDIC2eeadNf98qEraEEfnuMF0m+gczhcQ/JDgUQJr/mmrCk5c1z1OeJCUnXPZ8Ph2y+8Ohd5g5wf13/F1MI264C0nUUHeXWDqASmu+7b93nAcxeuxXMFRHAtD3Cv3QC/EcjmzQMD7wdiMFZalf6aA5kIjLbU5njy6ofz+i5siclMjjfYCAJFLEXQ91P1KgC72Z8fNtRtN/nwB2Sjt1NmIErN13MAZYA6xHYbN6SLLBzO1s9OERGTNO58z4666HpGDIrqyiTag/l7Lk4IHamZYBIgztXKCrC5IwbV2LMxT58rcoBDxGFpkc/JJyZMQdl8v//yX2V1L3gzjP4Idt2tkLlPQm8rh74cubng5J3szTNGGJ7+bdPdgeCBntsUDfFAlX9oZ+D08SulI0+y0MzTggc0wKCkoDZ9jqdYz3uBTM6cQvuZI=","authorEmailMD5":"0da2f1f5c2e83c6a2fd2291f28651175","authorUri":"","authorUserId":"disqus:disqus_C3jMJB6Ih3","authorFallbackAvatar":"","message":"I'm also confused here. In the second example it would appear (to me at least) that you are still on the UI thread when you hit this line: return Task.Run(() =>","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"985b1f3f-eba6-38cb-9d96-3f9792c0405a","date":"2018-02-25T01:44:43Z","timestamp":1519523083},{"_id":"6b926083-32b8-3840-9980-343e1bc9f07b","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The `return` is on the UI thread. The code inside of `Task.Run` is run on a thread pool thread.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"43735249-20f6-3b4d-96ba-f43cf5f40c31","date":"2018-02-25T17:51:18Z","timestamp":1519581078},{"_id":"af71f6cd-2902-3f9f-96da-38d126786be0","authorName":"Joshua Austin","authorEmailEncrypted":"LLbHU79SLR8QlRT5YIqwEYY6n4jNQhpQp4OPNoYoCWl1k4Wl7JbiLzpM6dqIEhid1M7da9dV3AyZ7OPg14Nlf/TIdyp19FF9tAwzQ/ZQqbOxObDSA70PMFiGohADBX6IeEMOZeER1R+w1qBIGwShb/WCOHWf4MseoukoryD+Ra2GXGkJi2+MD3YO1cyS6wADI9iGYtrKzGbCfyWtvSZQBNviXAgwc5VDagx4E9xv0SPeL1Rn1icnxBtLUAi26gS8Z/Uiuw0v51LSUs6g9QUvO7N+onvPKBlH8S3iNa+d1I4RKQBT1O3Hk2RAc6XN+Rfzyveis39DIiTIW+SfIUKF6vRlm9osi6jPPwlGj+urvDuqVrqf6QDOgyjds/asoHVkaDZT+ZPHq2oUEhDzP72ZOR3k9nPGgOCLu/Q/KCCKBQafY5Vf40eyQZm3B/9RGSfXDCRwNY87lRaE6fw+HaMAToqIavsVNBzPuUuuKM0nGWRsYj+BemiEgv/9Ijy+bTL9sXN0bHQcLO+1QS/Sneht5zQt9kq+/2+jrCV1XkY9ubCJoHeu9LAOIKt/AuT3c295rxSCqYkepW/joUI3QMl5KRSsc6nWs04edwew7fQAKsH6+4sFr84XfngHaQPAMGIZUr9VFw8hfTTfrUV2Jcb4LoqmVgvKIMHyKoWu8JcouSw=","authorEmailMD5":"cd8f6f5544b9bb3faca4580aac71ed8b","authorUri":"","authorUserId":"disqus:disqus_NNQAdRCoBK","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_NNQAdRCoBK.jpg","message":"I am not entirely clear on this. It seems to me that, whether it is an IO operation or a CPU bound operation, that a thread will have to be spawned at some point. Whether that happens internally as part of SaveChangesAsync in entity framework, or as a result of me calling Task.Run() somewhere doesn't at face value seem to me like it would change how [ASP.net](http://ASP.net) deals with the thread pool. Either way it seems like ASP.NET would have to deal with this \"The ASP.NET thread pool has to deal with (unexpectedly) losing one of its threads for the duration of this request.\" scenario.\r\n\r\nIt seems like it would be good practice to abstract away the call to Task.Run() as in your \"Using Task.Run for Asynchronous Wrappers\" example. Similar to how there is a SaveChanges and a SaveChangesAsync, if you don't want to use asynchronous then don't call the asynchronous method.\r\n\r\nIf I am wrong, then I have a fundamental misunderstanding somewhere about how this all works and would appreciate some clarification.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2018-04-25T19:16:38Z","timestamp":1524683798},{"_id":"cc37b857-b392-3a86-b1be-684d3d87202b","authorName":"Joshua Austin","authorEmailEncrypted":"jecOlGvs0YrJkQlXFlGZz+Kr1k+PTFw+1lH9FH7DdwCdEeGi10jaaxzHkoyjMWL7jhbhjV4c5tedP3RovZK4FMryH9o1HG65eVV+nfB515/H6ZbMykLkrg6vJzaP6KMiCwhhfpBNsIeWV/hNPwObHwdzHqQlOj5nJvEsmCmHAl/EX6URh6tx+iz0EuuyeuuKi2hcY9hpct8MXpqh3khxWdkXZCgPj3fRgSwaViZ/PzqyJi10K34KPYuTxAsEW7jP4l64ngjXgolp6jVnflg/3WHjgZN885657J1sCchNHmwa0fyki36tS+mCWagbCxUAX+Wh8+qo7rWfsJ0ssv0l/6BMs3FaQs3HCzj618MSPJ53PEJxH+p/Y2LWoPyXdKj6n+cYmIv4chUY1SiKm7G3m2pqDLkULGYU8GouXhYT6HU9H8WVNm1ZraQt7pprQVcyxRvSpkFoU6KY7Apzr6aNJHm5Pzy/rric2mxB8Ahh1zOX3HNAcQmTmeoSb5AG9mmFUfBkMtVFhA/J4dM5uBsY6qA4PsfNy/6KaHzxumUA1mtZqaE/Z0f/3u8tJyQ6e26ziijt7F7hD6/kipkTPnfMDQ+V0snyKoBKoOWboKmQgJal7h2FVyvhwkqcWwlDjzbMMPmhUoa/5b6lcxutBmmaCUkzqqsBJnOZc6AEXWvki4I=","authorEmailMD5":"cd8f6f5544b9bb3faca4580aac71ed8b","authorUri":"","authorUserId":"disqus:disqus_NNQAdRCoBK","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_NNQAdRCoBK.jpg","message":"Ok, that makes sense. So, given that with IO operations there is no thread what I think you are saying is basically that as an API developer I don't know what another developer's requirements are down stream to make the call to run it asynchronously; kind of like how one avoids try/catch in class libraries unless there is some specific behavior/reason you need to catch - you leave it to the top layer to handle/log, etc.\r\n\r\nAlso what I gather is that there is no real benefit (in fact it could be detrimental) to doing a single CPU bound thread since at very best, the request will have to wait for it anyway (making it in effect no different than not having a thread at all). If there were multiple independent CPU heavy tasks you are saying to leave it up to that application developer in the UI layer to make the call to do a Task.Run as needed.\r\n\r\nSo, one case I have been running into doing development with Xamarin is that I often need to call async methods on a method that doesnt really allow for it. For example, a method called Device.StartTimer springs to mind.\r\n\r\nI make a call like:  \r\nDevice.StartTimer(new TimeSpan(0,0,5), MyMethod); // Run MyMethod every 5 seconds\r\n\r\n// Returns true to queue timer again, false to cancel timer.  \r\n// Because of the bool return value expected, I cant make this method async.  \r\nprivate bool MyMethod() {  \r\n Thread.Run(async () => {  \r\n await DoDatabaseOperationAsync();  \r\n Device.StartTimer(new TimeSpan(0,0,5), MyMethod);  \r\n });\r\n\r\n return false;  \r\n}\r\n\r\nWould you say the Thread.Run is valid here? If not, what would you suggest to be able to make the call to DoDatabaseOperationAsync? The only other thing that comes to mind is calling \".Wait()\" on the task. It seems like that would be a much worse tradeoff.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"de829fc5-546d-3262-aa9c-644f2911a51e","date":"2018-04-26T14:56:34Z","timestamp":1524754594},{"_id":"de829fc5-546d-3262-aa9c-644f2911a51e","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes. The key aspect of truly-asynchronous APIs is that there is no thread: [https://blog.stephencleary.com/2013/11/there-is-no-thread.html](https://blog.stephencleary.com/2013/11/there-is-no-thread.html)\r\n\r\nThink of it this way: EF's SaveChangesAsync builds your SQL and sends it out to the database server. It then has to wait for a response from the db server. What's the point in blocking a thread just to wait for a response on the network? So there's no thread spun up just to do that - that would be silly. Instead, it registers a handler: \"when the response comes in, call this method.\" You can think of async/await as being event-driven, because it is. (At least, when dealing with I/O operations).","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"af71f6cd-2902-3f9f-96da-38d126786be0","date":"2018-04-26T02:29:01Z","timestamp":1524709741},{"_id":"39bf0e97-815b-3ef8-a6e7-383f368d223d","authorName":"Joshua Austin","authorEmailEncrypted":"g3GpH2ygG60zM/4JGxSzISLvxbn3AiCmhk0WpkpQi2Y53WUbm4Ekg3iYdetBNOmFdlHISBqfjhux4aCT7pdo1tKpnn2HhSQdyLvPyt6sJ2g4KlKyHpRjqtSbDf1yebHrmx+aJ5SEFCRnJcdTeM5eJJK0LpzvrcX9Lb8BMlj7Usyev209jCzlXhX0CiNceWFKOWxvPziUhvCRv0ujZ966EeYI7YnKBsW1M+ckLDwm9NjdIEPQYl8INxkZNMBIqBp7A8W5z812IU7kPsDBFY5dPUeZJ17FlQY5xXahXXHI/djoORG70G66FuRlDIpbAHeJ1zaQkCqTDZYQ7C+wyLcLK/GPYMNm+6LpvwyQpzM9eRsdnM3tBo9qtXk67TkcDnYztbfoUUFYbouY4cJDBi0XTSimrgZ3FAdCQpDf094cWsJBzAlvODGMA3nnztVT6MeB4iZn+T7HyvAULfZsBAqHQN2U/byhrrF/0+77HRzSsFY7ITQbtVyMSLC9SZUeTVYWgVZRgZt2Em4COueu/d9449ipIw7oliVgXkDznUljgyF5PwjgUv5hpHOM2/zR96kx7VkqwwwB8GAKJE4KoBRPRuVBAwE+xKKuLe+i1LBFVxdCk8PTTLQbQYcQIjMPi0eq2AVxbYMI3LJ7SPsTD8EqoO7G6OJD2RbOVYWNNns8FJM=","authorEmailMD5":"cd8f6f5544b9bb3faca4580aac71ed8b","authorUri":"","authorUserId":"disqus:disqus_NNQAdRCoBK","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_NNQAdRCoBK.jpg","message":"I wasn't aware I could define a method inside of another method like that. Obviously this should be reserved as an absolute last resort, but it solves the issue in that it doesn't fire off an unnecessary thread, and I can retain the async functionality without blocking.\r\n\r\nThank you for your clarification, it has helped me greatly in understanding this async stuff.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"e52a4660-b627-3f4e-8fe0-fbbf544c4ad4","date":"2018-04-27T15:29:14Z","timestamp":1524842954},{"_id":"e52a4660-b627-3f4e-8fe0-fbbf544c4ad4","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, in the general case, your I/O operations should be asynchronous, and your CPU-bound operations should be synchronous. Then, if you UI layer needs to do a CPU-bound operation, it can use Task.Run (or Parallel, or however it wants to call them).\r\n\r\n> one case I have been running into doing development with Xamarin is that I often need to call async methods on a method that doesnt really allow for it.\r\n\r\nThis is an unfortunate reality of working with APIs that were written before async. Due to the limitations of those APIs, you do sometimes need to resort to hacks: [https://msdn.microsoft.com/en-us/magazine/mt238404.aspx](https://msdn.microsoft.com/en-us/magazine/mt238404.aspx)\r\n\r\nOne of the principles of Task-based programming (including async as well as Parallel tasks) is that you should always observe the results of your Tasks (unless you're really, absolutely sure you don't need to). As an example, the code you posted would silently swallow exceptions from DoDatabaseOperationAsync, since the task returned from Task.Run is never observed. So if your database operation starts failing, your app wouldn't even be aware of it.\r\n\r\nSo in this case (Device.StartTimer), one option is to block on the task. This is a hack, forced upon you by an outdated API:\r\n\r\nprivate bool MyMethod() {  \r\nDoDatabaseOperationAsync().GetAwaiter().GetResult();  \r\nreturn true;  \r\n}\r\n\r\n(this only would work if Device.StartTimer executes its callbacks on a thread pool thread, not on the UI thread)\r\n\r\nAnother option is to use async void. Async void is for \"top-level\" operations such as UI-thread events, and should be avoided in all other scenarios. In this case, you could say that the timer is a top-level operation, and use async void as such:\r\n\r\nprivate bool MyMethod() {  \r\nasync void MyMethodLogic() {  \r\nawait DoDatabaseOperationAsync();  \r\nDevice.StartTimer(new TimeSpan(0,0,5), MyMethod);  \r\n}  \r\nMyMethodLogic();  \r\nreturn false;  \r\n}","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"cc37b857-b392-3a86-b1be-684d3d87202b","date":"2018-04-27T14:28:05Z","timestamp":1524839285},{"_id":"89b00f50-ab8f-11e8-b6e7-61e1106727d7","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","postUri":"https://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-dont-use.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"","authorUri":"","message":"Hi Stephen,\r\n\r\nI am running a task using Task.Run. This task is kind of a background task that just waits asynchronously for items to be added to the queue(Calls ReceiveAsync on BufferBlock class), and then processes the item. Since this task is an ongoing task it has to keep running and I do not await it.\r\n\r\nAll of this is part of class library which can be used by any client (console app, win forms etc)\r\n\r\nI want any exception raised within the task to be rethrown to the client. However, since the task is not awaited, exceptions are swallowed.\r\n\r\nIs there any way around this problem? \r\n\r\nThanks","date":"2018-08-29T13:29:21.873Z"}]