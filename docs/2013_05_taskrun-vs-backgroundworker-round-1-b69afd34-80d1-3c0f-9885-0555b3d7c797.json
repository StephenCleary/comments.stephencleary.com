[{"_id":"2510044d-7ad0-3242-8b00-b626f67fca82","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I do really appreciate your work Stephen. We share the same interest in digging deeper for better understanding.  \r\n\r\nSince there are no active newsgroup for C# (AFAIK), where do you follow technical discussions or read about it?","postId":"2013_05_taskrun-vs-backgroundworker-round-1-b69afd34-80d1-3c0f-9885-0555b3d7c797","replyTo":"","date":"2013-05-12T16:15:15Z","timestamp":1368375315},{"_id":"a8cacc37-cddf-3b04-96be-2080d6719635","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Long time fan of your blog, despite much of it being over my technical level of understanding. Always makes me start digging to understand more about .NET and asynchronous programming. Keep it coming! Peter","postId":"2013_05_taskrun-vs-backgroundworker-round-1-b69afd34-80d1-3c0f-9885-0555b3d7c797","replyTo":"","date":"2013-05-12T01:05:14Z","timestamp":1368320714},{"_id":"cd3e883a-d914-3723-aef6-51577f63c6d1","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Thank you, Peter!  \r\n\r\nI do strongly encourage asynchronous programming - I believe async/await will be essential knowledge in just a couple more years. By that I mean that it'll just be *expected* that everyone knows how to use async/await.  \r\n\r\nRegarding the technical level, I decided at the beginning that my blog would be on the \"harder\" end of things. There's a lot of places out there that cover the simpler stuff, so I figured I'd try tackling the harder problems. Also, any time I found something that wasn't sufficiently documented or just took me a long time to figure out, I'd write up a blog post. Some of my blog posts here represent 2-3 days of solid work, experimenting, digging with Reflector/JustDecompile, etc.  \r\n\r\nSometimes it's difficult to explain the harder concepts, though. If I am ever unclear in what I'm saying, please do bring it up!  \r\n\r\nThanks,  \r\n -Steve","postId":"2013_05_taskrun-vs-backgroundworker-round-1-b69afd34-80d1-3c0f-9885-0555b3d7c797","replyTo":"","date":"2013-05-12T16:09:37Z","timestamp":1368374977},{"_id":"f64a4105-5527-3c27-8449-4e1182458237","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Is it guaranteed Task.Run will always wait to run succeeding code after it has completed? I had the impression it would not wait, since it does not return anything. And isn't it Task.Run offloading work to the threadpool, hence it's another thread that will sleep?","postId":"2013_05_taskrun-vs-backgroundworker-round-1-b69afd34-80d1-3c0f-9885-0555b3d7c797","replyTo":"","date":"2013-05-12T16:12:35Z","timestamp":1368375155},{"_id":"199dea03-6550-3884-b9bc-7af331018150","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"That made a lot of sense. Thank you! :)","postId":"2013_05_taskrun-vs-backgroundworker-round-1-b69afd34-80d1-3c0f-9885-0555b3d7c797","replyTo":"","date":"2013-05-13T12:28:33Z","timestamp":1368448113},{"_id":"28100cfd-154e-3987-814e-d706cad4495d","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"That is a good question. I have often longed for a good mailing list / newsgroup where C# experts could discuss things. I have not found one yet.  \r\n\r\nSo, I get most of my knowledge from following others' blogs. I have over 200 RSS feeds that I'm subscribed to.","postId":"2013_05_taskrun-vs-backgroundworker-round-1-b69afd34-80d1-3c0f-9885-0555b3d7c797","replyTo":"","date":"2013-05-13T08:15:38Z","timestamp":1368432938},{"_id":"91c9cdeb-e508-3185-b2b9-4d14f0d7fc30","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Task.Run does return a Task, which represents the delegate you pass to it. So when we await the Task returned by Task.Run, we are (asynchronously) waiting for that delegate to run to completion. Any code after that await will run after the delegate has completed.  \r\n\r\nTask.Run does put its delegate on the thread pool, so yes, in this example a thread pool thread will sleep. This is similar to (but not exactly like) the behavior of BackgroundWorker, which creates its own dedicated thread.","postId":"2013_05_taskrun-vs-backgroundworker-round-1-b69afd34-80d1-3c0f-9885-0555b3d7c797","replyTo":"","date":"2013-05-13T08:11:57Z","timestamp":1368432717},{"_id":"913a4548-9831-3772-b9ee-94336b60138e","authorName":"Phuong","authorEmailEncrypted":"vYThFR2+DGMYO0BsaZh3QBoiG5chmWBUmN8h/mNUnJcc9na63WX4Q9EkB1noshWhzQ0l44ddZ2rduN6ATiJURM8LBnJyMb95GMUprVu5ct8Ze5EpyfDA3IeVbLABx7qWSCDPROlVp/bPhetYQ9kYitMraRgkdLDD7AVEX1+Ya/NjHGPGB4dN6xmo1cnDFBBIsy9brHqPquFqh6+iGJaMTXXmN6maUxO2K5MMpJJMGT/EUugUyP0qTp5uyAs65iA+XWHHRZkZVn4rG8dqk8VgwQV9ikfGS0oG1MXiFv30f0U9oSTSJzyyzFXKwNUq/WDkRLbPWWW5fa5+Bk267larKy9GmDsOFpRT82WynNFgECukPt54GxlUAjyPTCAgETo4CfHYXZt+QWeyUM52yXU70LxeBuXbqpn9tzcKT6p4b9YqKgeRDRAF5JOx2nqYK3MfEs7YJJ6PkbzvE1FDHl5inzlpsokq4kpvJaPNbeQHa3ARaet3MLkzPVweGdP2W56q/rApQbZJW01UBywJJLf+VZnpPugm79FkPHCC2xpy+L4KytIvvqCoPg1el2/FK0mr+ycp3zelfoBTAb6BAnBbTdMM9d2Qd/3ahOcA4OWhXspcT1XfhCVlgUQk+1pxoZsaY7gBjuisodcznddjCD9dUL82AgB8cWYQ0kKYV9gGRE4=","authorEmailMD5":"5caa292ea13d730613cfdc70d61b7958","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"That's simple and straight to the point - what the difference between BackgroundWorker and async/await pattern. Thank you.","postId":"2013_05_taskrun-vs-backgroundworker-round-1-b69afd34-80d1-3c0f-9885-0555b3d7c797","replyTo":"","date":"2014-10-11T02:35:09Z","timestamp":1412994909},{"_id":"644763fe-2607-38f1-9868-cf75a3e5d7e0","authorName":"Bilal Fazlani","authorEmailEncrypted":"OqkVWDu1ApR3Bc++IHk01WRp0Gt4gFfzLoXvvIclgVJ5w4LhpH7HT86gyucjRX/1PCdGOFtHKKG5NOFijRdWo+t/Y6X4rXuENXY+Ot7WNNy5fbyp6lkK3P4y4QvnXfNcFbIOkeo0xrIb4yfQH4RHUHEl4qxmFVxs5hbNI7qnYywPc6MboTsTpAI95ljU1LyPUPuO7V3qkgM/hAx7tOGQTSFXBzljgMcENgkthiiUGrPPYpnWr1v1wf5TpC38pZ8chMlQpNOb8sLyPvYIYZ8i4/1X8HPtHU5PziJfMj23/mBMfKUwss7a/iz8xLtI97EPc8zWSYfTeUG7deY6/B3RgyDJswlnnk61jsYpmSrivvZ6hDkKQcWmajuKQhgKjskr/8Ec9+BJ+ViZikki+wBbYb+lF5dUfPY4l/kxQCGZVyyh5yOAPCvJO8OwnCLOAbSmgNonZ30uxG5YIvEqDvTPqsUcg3Pot8XF6FEgQkXZXWW5DLYbEo1/DslWT2SnaLhAaYdL75AvfFrwmfJcbhR1jK6O8ZV+/YRH4fCwN+BfogcpkdUIJMcbTWOe/TAQwbXRfIl0TRuAmyT5cxHqhiWwYlwsOVGCi47KWiFxhSPK6E8DeurgHRAP9HG8IqK/VqHPRgpDnatE98ozHVoDcSN7CH4nLFt8dmgo3OtVaetla64=","authorEmailMD5":"329381200b3974c701e3a84cdbf3a440","authorUri":"http://bilal.tech","authorUserId":"disqus:bilalfazlani","authorFallbackAvatar":"https://disqus.com/api/users/avatars/bilalfazlani.jpg","message":"Hi Stephen,  \r\n\"The core problem that BackgroundWorker originally solved was the need to execute synchronous code on a background thread. If you’re using BackgroundWorker for asynchronous or parallel work then just stop; you’re not using the right tool in the first place. The core problem for BackgroundWorker is to execute synchronous code on a background thread.\"\r\n\r\nJust when I thought I understand parallel coding in .net. I read the above statement. And now I am afraid I am in a position where I am asking myself.. Doesn't background code mean async code ?  \r\nCould you please shed some light on the your quoted statement. Thank you.","postId":"2013_05_taskrun-vs-backgroundworker-round-1-b69afd34-80d1-3c0f-9885-0555b3d7c797","replyTo":"","date":"2015-03-03T09:45:06Z","timestamp":1425375906},{"_id":"ba48f75f-1e9c-3f59-88a0-d1020226051f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Not exactly. The term \"asynchronous\" implies a freeing up of the current thread.\r\n\r\nSo, you *can* call BGW \"asynchronous\" from the perspective of another thread (i.e., the UI thread). It's this definition of \"asynchronous\" that MSDN uses in its older \"Asynchronous Programming Using Delegates\" documentation. However, this usage of the term \"asynchronous\" is actually for executing *synchronous* work on another thread.\r\n\r\nThere's also another type of work, what I call \"truly asynchronous\" (and on my blog, whenever you see the term \"asynchronous\", I'm referring to *true* asynchronous work). This definition of \"asynchronous\" also frees up the current thread, but it does so *without blocking another thread* ([http://blog.stephencleary.com/2013/11/there-is-no-thread.html](http://blog.stephencleary.com/2013/11/there-is-no-thread.html)). It's this definition of \"asynchronous\" that MSDN uses in its newer \"Asynchronous Programming Patterns\" documentation.\r\n\r\nBGW cannot handle truly asynchronous work.","postId":"2013_05_taskrun-vs-backgroundworker-round-1-b69afd34-80d1-3c0f-9885-0555b3d7c797","replyTo":"644763fe-2607-38f1-9868-cf75a3e5d7e0","date":"2015-03-03T13:35:52Z","timestamp":1425389752},{"_id":"1c9a8228-e998-348a-8c0d-ac1003e1ffa5","authorName":"Fahad AlShammari","authorEmailEncrypted":"HM5SGzgpvf3GHlvyzDCbHjehJhMW718hzkakRr/+NKxE+H8FFfHJzPl+IqhM8yCo214m5Y0rm4Z3p4QlfCADcQJxVKi0wnl9b5jHRhHeeNr6KhyIL3p7xL4qFFPrjCLWaW4lRhvwMaiIw+Rz8cFqKPtyLhvkmiZnsFuO2s0y2Pb9cWiydWx3Al5Xq9jCxOQvdvsJChWxzJkN1cHUvTysXEAMbKnq2ccR1++Qa4EychDCT3EmQr2YTbYUtu8co1m5/KVinkOG4oaNoXQMkOBlTKDD0vny0Snhwc31v/POrWUXLDihVGPARl8Xv+FQVB+olNfrRc5NR4TIaPeY/mC2ZOuOcfB6h9TcZR0UTOnaK8Mhu/77po4b/wOxYS4e3/F60X+G2UWPaPz8B0Eb2XxJtHKDSFW2DHDugHqldfk6whXe8oeoBk+273a0asHJ3TFin77eVhvHuhtpT7JEn2aaaW/kntcQ3mv3FRkdNzWU4EvHDAF0e1ReyzMf6LbPF332mB/XOqwXZMjHy3Luxpx3XQb6iai8598iNmuLT93hNO/gAFg16mRdFBkhO+8l8BsYR8sCN/EuL2p6yiWUsKTgaLUiD4Mb7ou9YUdqApbyldGtIjC0p8Qj94MYova2jypDazXYcrB6MpGVbcvYxAY6+azSBxzdDYF/x9+BjAAo62A=","authorEmailMD5":"727e2b98ca32cd4a8eb4b21d84b2bf61","authorUri":"http://www.alshammari.me","authorUserId":"disqus:fahad_alshammari","authorFallbackAvatar":"https://disqus.com/api/users/avatars/fahad_alshammari.jpg","message":"BGW is async code but it is sync work.  \r\nKey words are code and work.\r\n\r\nThere is no relation between code and work.","postId":"2013_05_taskrun-vs-backgroundworker-round-1-b69afd34-80d1-3c0f-9885-0555b3d7c797","replyTo":"ba48f75f-1e9c-3f59-88a0-d1020226051f","date":"2015-04-09T09:46:39Z","timestamp":1428572799},{"_id":"ac3d476a-bc32-34eb-8eb5-2dce217c898f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Ah, yes. There's an old pattern where you can call TaskScheduler.FromCurrentSynchronizationContext while on the UI thread, and then pass that to ContinueWith. But there's some definite pitfalls there: [https://blog.stephencleary.com/2013/08/startnew-is-dangerous.html](https://blog.stephencleary.com/2013/08/startnew-is-dangerous.html)\r\n\r\nUsing Task.Run with await/IProgress is just a lot simpler and cleaner, with fewer pitfalls.","postId":"2013_05_taskrun-vs-backgroundworker-round-1-b69afd34-80d1-3c0f-9885-0555b3d7c797","replyTo":"efce3550-074c-30c2-b26f-1f68b38d3722","date":"2017-12-18T13:30:43Z","timestamp":1513603843},{"_id":"efce3550-074c-30c2-b26f-1f68b38d3722","authorName":"NotAChance","authorEmailEncrypted":"NPAc7U1CdeRpIqRhm3v2g0cWgSly35x9LldMUMIsqZB5sZQlW3Rc1uEp9V+HG9MyZ4NM1asuZhuJ8AREELHGFslEMGbeXvei1p4/XdxdRBoEwgKVfIRjtxmwlLyy5DLdsvxlRolR4eFPPuXnHq4ILQHf9RqsZfJp1SlDQ+Fxrnnv8L7e99Il+YM9UhrcqClNJrlf8Iwg1NFpcHS7Zw9rK21vrS76MSbMz96ukx3baFn1C+UrUtcaBz3fOtoaYr5rpEh0uwEnrEpXGf6L34Xt1cgPuIbHcof7nVGHNhRs30nj/ZgjVTyqd4SUd1wuQhn8fm9Q4f/9TofxbjHTroz5pkQarh0TZhaxzgOz+7BJAWbCdQ0O2R9PElCk59RCWoOq+Ml6kY57anhcQCJXlLFNsUBjd0lbLK31hn6gIoJZhV5668lyolU4g9Glzrieq5mHKmFWKDJUp3HdcTXdQVcvYU/L1X8UvzNdkRzxLQIkBhZ+zQqF679HqAHhMobyqk3LkN+U8GpMJKPB1BAEU/npViuEQxz1k4nwen32rCS9gu94SIypzSiwvUmW/FY+vCxObtK3L1OZ7CYKrlVrCc8QsguTEPZDwtISWMomJ1pJraDHv4ejCEjWXlEPpRjLbIaAMphOIk0JujOA2ZPFCc0aOhOAgeecydIwKN7a6T+kd8s=","authorEmailMD5":"f05133a9aef915405a55748d64c3c360","authorUri":"","authorUserId":"disqus:roland_graham","authorFallbackAvatar":"","message":"A very useful piece of information, thank you very much. I've been trying to use Task.Factory to execute some long running calls however my issue comes in with the ContinueWith() function which also runs on a thread separate from the UI thread, where RunWorkerCompleted() doesn't. This is all good and well unless you need to navigate to another window or shutdown the application, both of which need to be called from the UI thread.","postId":"2013_05_taskrun-vs-backgroundworker-round-1-b69afd34-80d1-3c0f-9885-0555b3d7c797","replyTo":"","date":"2017-12-18T12:50:54Z","timestamp":1513601454},{"_id":"007f62ee-f12b-3fb2-af31-59171ca95b41","authorName":"ALIENQuake","authorEmailEncrypted":"NKrtKs7nBoR4wlD16fqkOjRGkYjTiL+PN5eMETD0DLWL587xgBt+O8q+oLOaKma9+Y/8vpFN+G0qhaPnRmnvEnvCAmL+FxfpTkIRpIqxXyeSz330BCsCKLK2T7BJKxu2AXdHv6f3dkfI8+UWHbSC6XzY0SXA33tRJGuOk2Ged2CbgHcS6nTRIIhVRRxT49OjQqy1fOy/CdWZlFEF73FkBOtruS+qwvroRnFXO2GiPtp5uEwGP5gi3FoTLXiq8qMC7e0QI3ib5/qvkvAVAERLLmGs6GbZDGep02heI88sA81S8hBxsRmsE+ukZ9jYFtpmE/VraqxQkVIfA7fZTtWxQMO3vJwq28lYTGjM1is0mkLcu0lMnnNxz1S4knXmrdjcPqJl7dtkqnb6zQfXJddwV+cAlAKHv4CavLseuyuhKygeERNNkI4LqLPrtE4t9daWfIWSzT1zsEfa6M4QZ1FT4aLX4yde8K9yAgb7U12+etUiY1N71sIE2CeWhUHfKp3me5u9vjxa38+wbWCr1PRJXTDtwMlqBBcPSYhXlZtvoluemm5YLHXRvm5jUlOhtyeifjZlPeyOVNZD6GnMCHU81gHsNpvHSnS7D7PJrTm0oZmPtWNopu3Dm8M3+SlKViKWv18lukNiWqIkX0PT1cOAie0L2wal2DnFK8zp2qKnzAU=","authorEmailMD5":"1615ddcb56c2aa7ac30c25b4fac23032","authorUri":"","authorUserId":"disqus:alienquake","authorFallbackAvatar":"https://disqus.com/api/users/avatars/alienquake.jpg","message":"Article is wonderful but WTF is \"(_, __)\" ? Really? It couldn't be more cryptic :( It looks like two different size boobs. Still, great investigation.","postId":"2013_05_taskrun-vs-backgroundworker-round-1-b69afd34-80d1-3c0f-9885-0555b3d7c797","replyTo":"","date":"2018-05-12T07:22:28Z","timestamp":1526109748},{"_id":"bb800753-ade7-3bf9-8119-74f1dd421e8c","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Ha, not my intention at all!\r\n\r\nSome programming languages allow _ variables as throwaway. \"I need to have a variable here but I won't use it.\" C# 7 recently added \"discards\", which is practically the same thing (but not for lambdas). Hence the standard \"_\" and nonstandard \"__\" meaning \"this is also a throwaway variable but _ is already taken.\"","postId":"2013_05_taskrun-vs-backgroundworker-round-1-b69afd34-80d1-3c0f-9885-0555b3d7c797","replyTo":"007f62ee-f12b-3fb2-af31-59171ca95b41","date":"2018-05-15T01:43:02Z","timestamp":1526348582},{"_id":"dd378841-d802-3cde-98c5-9554b9a52493","authorName":"ALIENQuake","authorEmailEncrypted":"cnY5nud9XqtCbJj/3cNhqS7PVB1rir9JziAl33gf6KPl677GWDPPMs8+UOT7lIeICXu6d8ve9orwEkbokE5mpR0PJLAeiw86ShQIKAEkg+5If91EXfpJprGwyMuVBmp3jffualAEM+fHnN4971c/4daN3LDyE81u7WmYUaecFaXb/faKqa+afVcLYaFho6+xomAN/pOd25Xmeqgaw9r8cQj7zMTd1wTAnaZTfnSPgYyop/C5iKm4rVsuXAQ5Syn9pwcfjpvNByKm4atAIiyn3/dm8xo/VAfTm1m/2fIOZkhEWx8FPeCiJXP6GpVX/J5vUXcq6f70OLmMvgIzSnNUHrmA65qEBR1OlSJgu9UbVACdCDg5nzJRIfakCf7diKh4ZhXo1QSumGpdOCHbS9i6HHA54dqJLACDqcXjFc/wCh5u2MZ5hCxxs2kfjX1SnUWUFkkJx4gT+S07fBQ+iHFgR/6HrjRwDVCBvzxrHQ8RxXePHPUuFuWEktLmXlEuIjWZsnZo0EgUXlaVtjmmLhA+qYIKwALV+Xwf8mjTcwoQJPlV+si73SMBufAy/3KnrvWB1NuGVJcXVAQ+TqMXsmK4YqkN+I5deK1IMjDkKmS5/uw9I1pdllDaEyTfgnqu1fjEbg4gORjwoHYCGL/paLyheF736XmzG400i2xnONuVvFs=","authorEmailMD5":"1615ddcb56c2aa7ac30c25b4fac23032","authorUri":"","authorUserId":"disqus:alienquake","authorFallbackAvatar":"https://disqus.com/api/users/avatars/alienquake.jpg","message":"Ye, now I get it. Thanks again!","postId":"2013_05_taskrun-vs-backgroundworker-round-1-b69afd34-80d1-3c0f-9885-0555b3d7c797","replyTo":"bb800753-ade7-3bf9-8119-74f1dd421e8c","date":"2018-05-15T20:42:12Z","timestamp":1526416932}]