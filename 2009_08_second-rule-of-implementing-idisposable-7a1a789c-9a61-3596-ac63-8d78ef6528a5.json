[{"_id":"389a91f1-bed8-3046-9c47-c1382dbefd23","authorName":"Jasonium","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/13789588800496107873","authorUserId":"","authorFallbackAvatar":"","message":"What about classes that inherit from an abstract class that has managed resources, and the the inheritor also has managed resources?","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"","date":"2010-03-26T02:49:58Z","timestamp":1269571798},{"_id":"43c68fae-7361-3190-931f-641e0c83086d","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I would then implement Dispose as virtual, and call base.Dispose from the derived class' Dispose override.","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"","date":"2010-03-26T11:34:38Z","timestamp":1269603278},{"_id":"3a81f0a5-3562-3549-b9e8-d5d7aeef1211","authorName":"REing","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/05933750119090584081","authorUserId":"","authorFallbackAvatar":"","message":"Great writeups.","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"","date":"2010-05-21T09:05:38Z","timestamp":1274432738},{"_id":"b2e24950-f8bb-350c-bc85-19bbde94b136","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"@Rodi: The design here is that SingleApplicationInstance owns the Mutex resource. Since it owns that resource, it is responsible for freeing it.  \r\n\r\nFor this reason, the Dispose method does not have a bug. It is possible that someone may introduce a bug during refactoring, but the Dispose method as it stands does not have a bug.  \r\n\r\nIn particular, I would say it's wrong to have Dispose check namedMutex for null. This implies that the design is that SingleApplicationInstance may or may not own a Mutex resource.","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"","date":"2010-05-26T20:41:48Z","timestamp":1274906508},{"_id":"e93d1bbb-3154-31b6-b014-79169bbcf8ff","authorName":"Rodi","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.rodi.nu/","authorUserId":"","authorFallbackAvatar":"","message":"What if the managed resource instance somehow got to be null? In your final example if namedMutex == null then you get an exception inside your Dispose.  \r\nThat should not happen and you should be sure to set up an instance in the constructor, but I can see some day someone screws up and you got a nasty bug in your Dispose.  \r\n\r\nCould be that I miss something. Please correct me.","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"","date":"2010-05-26T18:21:14Z","timestamp":1274898074},{"_id":"16a7e6c6-918e-350d-ad2c-a41adacf9cf3","authorName":"Rodi","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.rodi.nu/","authorUserId":"","authorFallbackAvatar":"","message":"@Stephen: Thanks for answering. I guess it is mainly a design thing. It's not related just to the Dispose method. If you need to test for null in the Dispose you should have to test for null in every method where you'll be using the instance. It should indeed just be so that it will always be instanced and your unit tests should be able to pick it up if some other developer screws up and deletes the reference or disposes it too early.","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"","date":"2010-05-27T12:38:05Z","timestamp":1274963885},{"_id":"48a1968a-44b5-3a93-9b15-776e10c5dce5","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"....instead of implementing IDisposable interface if we write a public method like  \r\n\r\n public void ReleaseResource()   \r\n{ namedMutex.Close();   \r\n}   \r\n\r\nwill result be same???","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"","date":"2010-08-05T17:41:31Z","timestamp":1281030091},{"_id":"ff61bc39-9cbb-37a4-a8e8-12fa9d7679d7","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"@Anonymous: not really. The advantage of using IDispose is that it has special language support (clients can use the \"using\" keyword instead of try/finally with a null check).  \r\n\r\nIDisposable is the standard way that every other .NET programmer will expect you to release resources.","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"","date":"2010-08-05T19:21:12Z","timestamp":1281036072},{"_id":"36bf1a1f-57c0-3a88-896d-2c9aa42bc346","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"What exactly is the benefit of not coding a test to see if mutex is null? You speak of whether the object owns or maybe-owns the mutex as to whether that is the test for good code. I call BS on that and charge you with misdirecting a lot of inexperienced programmers. The fact is that the 1xCPU cycle it typically takes to execute a BranchNonZero (BNE) instruction which your IF statement represents means NOTHING in the course of your applications execution, but it does mean that the developer understand the following:  \r\n1. Software Processes are complex  \r\n2. Software is maintained by groups of people  \r\n3. Software is maintained over time  \r\n4. It is more important to be explicit about your intent than it is to have the next developer divine your intent by thinking that your coding values are somehow universal  \r\n\r\nWhen I read your code I see risky vanity. When I see code with the IF statement I see code written to be bullet proof, designed to live long in a complex environment and owned by a team not an individual.  \r\n\r\nAnd dont come and tell me that that contributes to bloat either. You will lose the balance of any respect I have.","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"","date":"2011-04-08T02:43:16Z","timestamp":1302230596},{"_id":"79f06200-bf98-3df5-b44d-6bebb7a545da","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"@Anonymous:  \r\n\r\nI don't include the \"if\" check precisely because the Dispose method should only dispose resources the object owns.  \r\n\r\nIf an object is refactored so that it no longer owns a resource, then Dispose needs to be refactored too (this would be true even if you had an if check).  \r\n\r\n(BTW, I did not say to use an \"if\" statement if the object maybe-owns its resource. I never encourage \"if\" statements in Dispose; an object either owns a resource or it does not. It may share an owned resource by owning a reference-counted Disposable, but this is rarely needed).  \r\n\r\nOn the other hand, *not* calling Dispose when you *should* can cause some very difficult-to-find bugs. Many classes *require* Dispose to be called, no \"if's\" about it (pardon the pun!).  \r\n\r\nSo I claim the \"if\" check makes the code *less* robust in the face of complex software processes and team maintenance over time.  \r\n\r\nWhat the benefits are of having an \"if\" check?  \r\n1. It does not help when refactoring. Changing resource ownership requires changes to Dispose regardless of whether there's an \"if\" check.  \r\n2. It does not help with robustness. If it actually avoids a null dereference, then you've only introduced a much harder-to-find error by skipping the owned resource's Dispose.   \r\n\r\nOn the other hand, I think *not* having an \"if\" check more clearly communicates the designed intent of the code. That is the reason for my recommendation (not for performance or avoiding code bloat ;).  \r\n\r\nThat said, you are free to take my advice and toss it in the trash. I am, after all, just a random blogger. :)","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"","date":"2011-04-08T18:24:34Z","timestamp":1302287074},{"_id":"0fc55458-a4c2-376f-83b5-d806b1794ff5","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"So as I understand it, the class never sets namedMutex to null, nor does it allow anything external to set it to null. Therefor, it knows never to check for null. You are doing away with unnecesary flags and checks. That does, however, delay GC until the instance of the class itself is set to null, no?","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"","date":"2011-10-17T22:50:25Z","timestamp":1318891825},{"_id":"141f1f6e-15f1-3f71-b655-02256be6b115","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Not in the common use case. Normally, when Dispose is called, the object is about to become eligible for GC. In this case, the object (and its namedMutex) are both eligible for GC by the time Dispose returns.  \r\n\r\nYou may be interested in this blog post I did a while back: [http://nitoprograms.blogspot.com/2010/02/q-should-i-set-variables-to-null-to.html](http://nitoprograms.blogspot.com/2010/02/q-should-i-set-variables-to-null-to.html)","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"","date":"2011-10-18T00:00:03Z","timestamp":1318896003},{"_id":"1617c929-afba-3435-a1ba-cf72ef98478a","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thanks. I don't really care what happens during exit. I can't crash in a kiosk sort of situation. So it's what might otherwise leak in a long-running app for lack of Dispose calls that I try to catch from looking at plain text logs written within the Finalize. One logging call is all the extra work I do in a Finalize. I have found a few missing Disposes this way. My intention is to eventually remove the finalizers and conform to the rules you lay out, but for now the finalizers are a handy tool for debugging unattended systems.","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"","date":"2012-03-23T06:37:28Z","timestamp":1332484648},{"_id":"23447563-274a-3ee1-b01f-a306755c941c","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"I've read a lot about the dispose pattern and these rules. It all makes good sense and it does make my job easier, but only if I am perfect enough to always call Dispose in my disposable classes. I find, however, that I want to add a finalizer and GC.SuppressFinalize in Dispose anyway because I can put logging into the finalizer to detect when I fail to properly call dispose. Is there a simpler, more elegant way to detect failure to dispose for an application in the field?","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"","date":"2012-03-23T02:34:32Z","timestamp":1332470072},{"_id":"f780dbd3-cc22-3342-9b28-c6e36ed7aaf1","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"There is no easier method that I'm aware of.  \r\n\r\nMost logging methods may fail from within a finalizer, especially during process exit. Console.WriteLine is guaranteed to succeed, but pretty much anything else may fail.  \r\n\r\nI have (in the distant past) thrown an exception in this situation, crashing the process intentionally. However, all of my more recent code just ignores this situation. AFAIK, there just isn't a good way to detect it other than in a finalizer, and your code is so restricted in a finalizer that there isn't much you can do even when you do detect it...","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"","date":"2012-03-23T05:16:46Z","timestamp":1332479806},{"_id":"b1c413aa-dcba-3106-ab4f-a93bc1bc4c8e","authorName":"JCDrumKing","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/17980783173531248886","authorUserId":"","authorFallbackAvatar":"","message":"My class owns a managed resource (an API connection to an external system), therefore I am implementing IDisposable. Due to slow performance when making the connection, the connection is made once in the constructor and I expose a Disconnect() method that delegates to the api.Disconnect() method.  \r\n\r\nHowever, I cannot be certain that users of my class will always call my Disconnect() method, and I want to make absolutely sure that the connection is closed when my object is disposed/finalized. Even though I do not have unmanaged resources, is this a case where a finalizer (and the full Dispose pattern) is needed? Otherwise how can I ensure the connection is closed and I do not have a leak?  \r\n\r\nMany thanks","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"","date":"2012-04-10T20:53:08Z","timestamp":1334091188},{"_id":"7d481fdf-aebb-345c-a3af-fb46185f9132","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I would say it depends on whether there is an actual \"leak\" or not. What happens if Disconnect is never called? If the system as a whole recovers from that situation (e.g., the external system will eventually detect the connection is no longer there or just times it out, and if the external system allows other connections from the same source) then it can be treated as a \"managed\" resource - it's inefficient but there's no leak.  \r\n\r\nThat's probably the best way to go, because the system as a whole must be able to recover from connection problems. The only other situation I can think of is if the (client-side) API layer itself has some restriction, like only allowing one connection per process. In that case, I would lean towards putting in a finalizer which actually (intentionally) crashes.","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"","date":"2012-04-14T02:12:19Z","timestamp":1334369539},{"_id":"5be6b65b-6611-3f6d-b839-906d881b4df2","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"You're overlooking a possible scenario with your advice to avoid null checks in Dispose().  \r\n\r\nYes, *if* the IDisposable resource is created in the constructor of the class and is never released until the class is ready to be disposed, your approach is fine, because the IDisposable resource is guaranteed to exist when Dispose() is called.  \r\n\r\nHowever, there are cases when that is *not* true, even though the class is still responsible for owning the resource.  \r\n\r\nFor example, if I have a class that can be configured to do something at regular intervals, it may create and own an IDisposable System.Threading.Timer. However, if that functionality is not called into service, the Timer may never be created. Or, maybe it was used at some point in the life of my class but turned off later. In either case, the Timer object is not guaranteed to exist when Dispose() is called; therefore a null check is required in Dispose().  \r\n\r\nAnother scenario might be when an exception is thrown while attempting to instantiate an IDisposable resource. The resource was not created successfully, so it will be null when Dispose() is called on the owning class. There may be other IDisposable resources besides that one that need to be cleaned up, though.  \r\n\r\nIn short, it is possible (and in my experience, somewhat common) that even though a class may own an IDisposable resource if it exists, it is not guaranteed to exist when Dispose() is called. Therefore, a null check is required in Dispose() to avoid an exception in Dispose().","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"","date":"2012-05-26T02:27:26Z","timestamp":1337999246},{"_id":"ab8c914f-77e0-364c-9ac2-f51a862ab217","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"No, you should NOT call Dispose in your destructor/finalizer.  \r\n\r\nIn the context of this blog post, the objects in question only have managed resources, not unmanaged resources. In this situation, the Microsoft pattern would have a finalizer that essentially does nothing (it would call Dispose in a way that Dispose had no work to do). It is completely wrong to dispose managed resources from a finalizer, and there are no unmanaged resources to dispose.","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"","date":"2013-11-15T18:21:14Z","timestamp":1384539674},{"_id":"e4fc2d74-3edc-3185-bf0a-effce6d1a0de","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"In fact, you SHOULD call Dispose in your destructor, just in case the person who instantiated you fails to call your Dispose method properly. But as Stephen said, you must take care not to throw any exceptions in your destructor, as they will not be catchable by your application, and therefore will kill your application. Please see here: [http://msdn.microsoft.com/en-us/library/vstudio/b1yfkh5e(v=vs.100).aspx](http://msdn.microsoft.com/en-us/library/vstudio/b1yfkh5e(v=vs.100).aspx)","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"","date":"2013-11-15T07:46:52Z","timestamp":1384501612},{"_id":"0906beab-2068-3b80-a7bd-2af903725285","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"OK I must be missing something here: who will call Dispose if the client doesn't? The GC certainly isn't...","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"","date":"2014-02-06T16:40:12Z","timestamp":1391704812},{"_id":"74b24748-ef41-3b65-8afc-1fac6447e0af","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"It's the client's responsibility to call Dispose. If they don't, then no one does. The GC will invoke finalizers, which will clean up resources so there's no resource leaks.  \r\n\r\nHowever, some types require a Dispose call for correctness (e.g., to flush a buffer to a stream); those Dispose methods *must* be called by the client. If you try to call Dispose from a finalizer, it runs too late, and you'll end up with a race condition that could potentially crash your application.","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"","date":"2014-02-06T17:39:08Z","timestamp":1391708348},{"_id":"585b5a43-d51a-3296-8dc4-206d08fa60cf","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"My pattern is simpler. The example you posted has a `Dispose` method that is only called with `disposing` being `true`. The MS pattern allows for derived classes to have unmanaged resources, but as long as you follow my Rule 3, you wouldn't ever need that.","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"dfab0a7a-c648-38b5-b124-9513ef941e6e","date":"2016-11-17T16:09:37Z","timestamp":1479398977},{"_id":"dfab0a7a-c648-38b5-b124-9513ef941e6e","authorName":"aggieben","authorEmailEncrypted":"I2QnmzcQjjnfc0wPrSdWY2aMbSND3MRNNm/72JItc+z06u0ZTAyXmdgQA9hlp2Ng6AtAsV3JRaJVfNtK0GYDwMvr7pi9BLZcGsC6BvpAj2tunKMFWMLNnq9eGBfdCvPAS34QxY7r1UDtXJgK1MrOg16R1qbKh7QtRkhvMx+mmd5IiedDpSpYEWT/0BvzkCWrJb97ONQS2GVQh4PQOD/hDVmU4MVd1dCSUOJ0IYjU+UiNYy5Zxp/tpq+9WzNvh4erE+ru14XxNwDdEsJf1YCe6JT7WOjYulP8ylOmFi5ioWGO+RTeItF4wa/bpmjg+cOiW814eZHyvnxDg9ZQk3I4oXJfL5wlM9o+phlckIzNP4+SZM/7HJli027DSynnJ0IOjqKYqy5CVipg2TXWH6am+vexhGT6+6ExdyQUkVgaFXH/5xg0AZ0mA0tpblo034gLqEuUlELDB4MX5h+ZGQ+i5ssq1OD75YVKUQ/8HUxbtQM36bM0NZiMWiW/IWXR4rzAl8zEhwK3vF6Dj+gcAm4/fidZ7/i4HHEZSFFWm/HUU1EgF478zpHcQQ7bIGpZ2DJhEH4DlE9LxUuFqNP5JY6AV2RrxOgw3nSQx8JeV/wHaH/aOkrPsg9Z26X2Ac79X5qwqsLCqfe0cjwS/zOZYwoGFbuyvNNGXeSwrVhbe2u6kSI=","authorEmailMD5":"3fbc237a51acf024e65ae4da233f58e2","authorUri":"","authorUserId":"disqus:aggieben","authorFallbackAvatar":"https://disqus.com/api/users/avatars/aggieben.jpg","message":"Stephen, how would you compare your sample implementation above to the basic dispose pattern described here?\r\n\r\n[https://msdn.microsoft.com/en-us/library/b1yfkh5e(v=vs.110).aspx#Anchor_0](https://msdn.microsoft.com/en-us/library/b1yfkh5e(v=vs.110).aspx#Anchor_0):\r\n\r\n``\r\n\r\nIf `IDisposable` is transitive, then why what benefit does this pattern provide in the case of exclusively managed resources?","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"","date":"2016-11-17T03:16:03Z","timestamp":1479352563}]