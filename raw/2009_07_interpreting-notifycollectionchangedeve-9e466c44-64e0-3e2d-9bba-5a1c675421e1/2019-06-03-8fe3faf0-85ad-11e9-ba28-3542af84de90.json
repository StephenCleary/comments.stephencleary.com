{"_id":"8fe3faf0-85ad-11e9-ba28-3542af84de90","postId":"2009_07_interpreting-notifycollectionchangedeve-9e466c44-64e0-3e2d-9bba-5a1c675421e1","postUri":"https://blog.stephencleary.com/2009/07/interpreting-notifycollectionchangedeve.html","replyTo":"0d9196f0-3dde-11e9-9b2a-91601e299ccf","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"sjb","authorUri":"","message":"Apropos the problem of a time lag between the actual change of the collection on the thread pool and the UI notification of the collection change â€¦ most of the NotifyCollectionChangedEventArgs variants include enough information (together with the current state of the list) to reconstruct the state of the list prior to the notification. \r\n\r\nHowever, Reset does not. To help deal with this, what you can do is create a Replace event args where the 'new' and 'old' lists both contain the state of the list at the time of the Reset. Then you can poke Reset into the private _action field using reflection. This way, UI classes will see the Reset, but the information will also be there to reconstruct the value of the list at earlier times. Not really ideal, obviously, but I don't feel it is a big risk because I don't feel the NotifyCollectionChangedEventArgs class is going to change. \r\n\r\nThere are some UI classes that seem to require Reset instead of an equivalent Replace. The TreeViewItem.Children in UWP is an example, I have seen it choke on a Replace of all items with themselves but it takes a Reset just fine.","date":"2019-06-03T03:13:30.730Z"}