{"_id":"0d9196f0-3dde-11e9-9b2a-91601e299ccf","postId":"2009_07_interpreting-notifycollectionchangedeve-9e466c44-64e0-3e2d-9bba-5a1c675421e1","postUri":"http://blog.stephencleary.com/2009/07/interpreting-notifycollectionchangedeve.html","replyTo":"7c72c010-d7ce-11e8-a9f1-05b1ca7b5c0d","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Steve","authorUri":"","message":"That's a coherent and straightforward approach, it makes sense. You know that whenever you are in a property or collection callback then you are in a UI-affine class. \r\n\r\nYour comment challenges me to reflect on why I have property and collection notifications in my model in the first place. Although I'm not using Template 10, I am following the approach of their property view models, which is that they are attached to the model rather than to the view. Rather than have the model user have to call a separate method to update view models every time they assign to a model property, it makes sense to use a PropertyChanged notification in the model; the view model can listen to this and issue an update event onto the UI thread.  This also enables automatic validation and it connects well with the use of notification change tracking in EF Core. Starting from there, it seems natural to notify collections in the model as well. The general idea is that the model entities can be used in any manner they allow, and the view models will then take care of themselves. \r\n\r\nWhichever approach is used, the hard part is the time lag between when the collection actually changes on the thread pool and when the collection is notified on the UI thread. If the model can truly be used in an arbitrary way, then potentially there could be several updates to the model collection made on the thread pool before the UI notification goes out from the view model. Therefore, the state of the collection as seen from the UI thread (during the UI collection change notification) should be different from the actual current state of the collection, because it has to correspond to the data in the lagged UI change notification. In effect, the UI thread must have available to it a lagged version of the collection. Fortunately the collection change notifications (other than Reset) carry the information needed to calculate the lagged version of the collection from the current actual collection. \r\n\r\nOf course this is not a problem if the collection can only be updated in a limited way or from one place -- only from the UI, for example, or if it is locked while the thread pool is doing something that will impact the collection. But that just pushes the responsibility out of the collection and onto whoever is using it.","date":"2019-03-03T17:59:13.672Z"}