{"_id":"d017d653-d0b5-35eb-b361-bf4edf584c04","authorName":"Erhan Hosca","authorEmailEncrypted":"dd9nIjGoSMPBTccIw94bSAW5ET1yVq6Gfi8sfd/AGknRrM6IFbHG5FiQuya0kJznPs4n646vr4zlRPNC97odhFf7tTCINmGoRrXBGYump40dlXMfQFxqYgH5OtwfJx7ypvNUdoYuomAbXdMfQJgfjN0lZFHHfFgaBqB1LIKRmN3co92qVg/z2Uy/TWJpGTpSAyPdBnfvc7AiM0Ey8nhOFE5KP9HQxqfoDSRP4kjFJqqcXkzQTRBQq7Khx3hqhIDysDsa3c1XWjoGBzYXrHZORBwF9rt2N9bGWveyCTGDyLENTyMZ8dYCBjYzmaHnFXkWZtv4Bqw7fkrYsIBAFEDC5eG0AeWraYuLU1HIOPKaEOKyfm/849cPggiDiblzUUIu/56r53UJ1Xp+KfIUsObZjxsGIhfy9aZN9swoOe6Bulw6vdwbT7Z/Klp1EsV00al3JWWD9uDu+Y/1QPA2iz2f73W8fOT9SONqO/FLmwtiItraEISd5/vmVhqMTB2D2VJr1ylD/Vls/Mp3p94lk0MAqf5zw2WHHlttfHCsJM47q3ZWvUvVVMvoQCK4LTDU0pVrfrQh3IArRzehlesuVD/xqk6YdFBbiZ3AHbUEjdOWDQ2rXOT1HftHAswOjPeOhLSlXF46MdLjNQM7PQk58vzrHQ7yZ+TJvzMFGMWBoXnZfOI=","authorEmailMD5":"6de15a85f6dcb189fe5d743ee597f79d","authorUri":"","authorUserId":"disqus:ehosca","message":"I realize it's not exactly the same and the purpose of the MSDN articles are to highlight usage of TPL.   \r\nThe async behavior illustrated in the article is essentially a UI/Presentation Layer concern. I can't think of another reason to decorate your ViewModel with async methods other than providing a \"responsive ui\". This design decision will have a profound impact on how your unit tests are written/structured - not to mention the case where you might want to re-use the same ViewModel but perhaps without a UI, where we're not concerned at all that it takes a few extra seconds but we're concerned with performance and would like to minimize context switches etc.\r\n\r\nI guess the point that I'm trying to make is this: If the objective is to make your UI responsive, we should handle that concern in the layer that is responsible for it. Our first line of thought should be not to think of writing async code in the ViewModel (which brings all sorts of other concerns with it - as much as TPL generally making it much easier to deal with) but to look at the facilities available to use in the stack we've chosen for our implementation. For this particular example, using WPF Binding with the IsAsync set to true gives us the responsive UI we're seeking all-the-while handling all details of the marshaling back and forth for us and not allowing that UI concern to creep deeper into our design.\r\n\r\nThere are a multitude of valid reasons to write async code, but if we're using WPF Binding, keeping a responsive UI is not one of them.","postId":"2014_04_announcement-msdn-async-mvvm-articles-b2165e1d-7e99-386d-b481-ed64583f3ab7","replyTo":"344cf908-395a-3512-aa38-abf0ba0f9c49","date":"2015-09-03T14:47:46Z","timestamp":1441291666}