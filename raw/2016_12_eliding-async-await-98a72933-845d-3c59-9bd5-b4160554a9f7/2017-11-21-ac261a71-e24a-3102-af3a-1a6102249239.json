{"_id":"ac261a71-e24a-3102-af3a-1a6102249239","authorName":"Joseph Louis Lagrange","authorEmailEncrypted":"QjAdzxowZlRCFMjbrppIpzjEGmy9A+zxdMoSGApnZ26ZNUBP3Brb6Pd0HUJxNbWO0KLz68vGrz4/5GJ5AyE0cS8JojmfqcIzMjuWC6mlJEA4+R+HSEIBEdSkjuCHEgKJirybGZ0/7ffRD7MX1zSNP7xwPKqqeI+w1X+rYTbMVzqPNodruxjog3zSqW1sa+eSaxWpqxs5DdwaxbqdcEs2LClBpOUOaJccxRtuzckL3rhyEdsm1VeC+S0yV8fhipzGgtUEcz3fyHKrzjoWutTj4BImlK4+btWOEvpwW0xr4OLVOiiib0pJcRlyHkzTo5IBgBAYet3YVea60dNgXuKXP+Z/HWMwMnrrHMPB0puHfpaQJKwvs075pxMtx6hStqJ8cv6zZc6YJXVS12sHnzr9DwgbDy0mEXjgx3zNCSlUxOO1YBEfI8tdE9IWY5v08aO6xFJhv+QHv6kuKJT4zkgqU4Xq+ydMAxzlR9DWbiLpTZ9dY53QV8hT0p+XQboVNKdAGCH26/UXGrAwtVmW4HE8X5kjRn+DcFCdk4WgrWxxj2oxIZXgV7JPSKK0m3CW3lMeFxVXtGzKBQMAiTk9Nmg7QAHcuk0JuDG6ZuwsOaxAdAbfN7LUtabnMvQDyLxh5r3oF4Mh0VIYCFm+en7SIO2A3geKU6F0RYDf95CxHPyzWxM=","authorEmailMD5":"7e6002f0e0c986706f0d834f7db3c134","message":"Assume there is a class library MyService with a static hybrid asynchronous method HybridWorkAsync. The \"hybrid\" means that the HybridWorkAsync contains both CpuBoundWork(); and await IoBoundWorkAsync(); statements.  \r\nNote that the etiquette you explained in another post, the CpuBoundWork() must be not wrapped with Task.Run as await Task.Run(()=>CpuBoundWork()) in the class library (implementation). Later, UI-based consumers have to invoke MyService.HybridWorkAsync with Task.Run as\r\n\r\nawait Task.Run(()=>MyService.HybridWorkAsync());\r\n\r\nto maintain their UI responsiveness.\r\n\r\nHowever in this post, you \"suggest\" us not to elide async.   \r\nIt is confusing to me because I have two choices when invoking MyService.HybridWorkAsync in a UI-based consumer.\r\n\r\nawait Task.Run(()=>MyService.HybridWorkAsync());\r\n\r\nor\r\n\r\nawait Task.Run(async ()=>await MyService.HybridWorkAsync());\r\n\r\nPlease kindly let me know which one I have to use. Thank you.","postId":"2016_12_eliding-async-await-98a72933-845d-3c59-9bd5-b4160554a9f7","replyTo":"","date":"2017-11-21T09:39:07Z","timestamp":1511257147,"authorUserId":"disqus:joseph_louis_lagrange"}