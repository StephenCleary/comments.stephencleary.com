{"_id":"b4bd0f86-c643-482e-8b0e-43f10db6d568","postId":"2024_10_cancellation-6-linking-d183af6f-9310-342b-976f-b17dbdd21c65","postUri":"https://blog.stephencleary.com/2024/10/cancellation-6-linking.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Daniil K.","authorUri":"","message":"I want to highlight something about the last example:\n\u0060\u0060\u0060csharp\nasync Task DoSomethingAsync(CancellationToken cancellationToken)\n{\n    using var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);\n    cts.CancelAfter(TimeSpan.FromSeconds(10));\n\n    try\n    {\n        await DoSomethingElseAsync(cts.Token);\n    }\n    catch (OperationCanceledException ex) when (cts.IsCancellationRequested)\n    {\n        ... // Do some recovery specific to the timeout.\n        throw;\n    }\n}\n\u0060\u0060\u0060\n\nThe \u0060when (cts.IsCancellationRequested)\u0060 filter in the \u0060catch\u0060 block doesn\u0027t let you reliably distinguish whether the cancellation was due to the local \u0060cts.CancelAfter(...)\u0060 or the parent \u0060cancellationToken\u0060. \n\nSince \u0060cts\u0060 is a linked token source, it will be canceled if **either** the timeout triggers **or** the parent \u0060cancellationToken\u0060 is canceled. Therefore, if you want to know whether the timeout specifically caused the cancellation, you need to explicitly check that the **parent token was _not_ canceled**, like this:\n\n\u0060\u0060\u0060csharp\ncatch (OperationCanceledException ex) when (!cancellationToken.IsCancellationRequested)\n{\n    // This was likely a timeout triggered by CancelAfter.\n}\n\u0060\u0060\u0060\nPlease, correct me if I\u0027m wrong.","date":"2025-06-28T00:04:05.2178359Z"}