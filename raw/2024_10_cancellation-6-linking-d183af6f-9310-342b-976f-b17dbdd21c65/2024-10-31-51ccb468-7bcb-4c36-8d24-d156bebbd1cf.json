{"_id":"51ccb468-7bcb-4c36-8d24-d156bebbd1cf","postId":"2024_10_cancellation-6-linking-d183af6f-9310-342b-976f-b17dbdd21c65","postUri":"https://blog.stephencleary.com/2024/10/cancellation-6-linking.html","replyTo":"","authorEmailEncrypted":"O2I/MU0uZ90ZaCGW/\u002BmWvmjr2L0CpbIaa4OFx/ZsROOW/Q331WwiSWRw2t79hOyAVGrwzKGcSV2bqpI9Xvb1Zi1vq2S21tbudhDjeEoW81HQHGmQlQC/lZcwyIjK6Z7EQe\u002BkcWkLhBW3YEEr9aJUe\u002BCDXeWrZAzp0mI1ZEKBWY2J1rEdMEx2TR28QtMKNU510/GQLsWbkwDmeiALjeXg8RuwXgLQnvC/aimO/pCH2adN\u002BnoySQjgQ67MM8T6fsbwOSeFE6BDCB15sT4g6qxy9tvxR9toWR1fUIE\u002BOvHEfRg8iY62uyMaTvMW3pI0OYu5gEY3Bh1hruNSd2or8saJbdoVWssJ4bdjwiNHdNQTggSnC8OAuzJaaOQ\u002BmL6f6jAsXT9iariO/ubjLKVMEUP7OxoKiSfQr\u002BfIL44lmM8H\u002BoE/n7Eti0TTB\u002BociKUHMihUCo0Nmp\u002BEsUYuSIw56bzskUPpu2icQD9/Wx4r\u002BHpPY41KeC\u002BVueLbROt6RLD\u002BanoVEPTf7pjY5ld6Sxi4zvayv/ZOxYGvCi9xjxOuC7jbNw6eFmlrEhtWWYWZfkxU\u002BSW\u002Bl4dHTftoKEbU9RHf1hPw71knOO2eUzNWmIFKddmUVMoqbjQdqk9XRv50wpwdGhkIGaYKeZSGDJGCql7rB4Mx/1enp2f47JbQpRuQtdmY4yY=","authorEmailMD5":"7bcbf5cbd8c19ed27fbc04388a1a2f48","authorName":"Sebastian Schumann","authorUri":"","message":"Once again, this is a wonderful article.\n\nYou mentioned the pitfall of monitoring the wrong cancelation token. For exactly this reason, we have specified that every cancellation token must be called \u0060cancellationToken\u0060. Nothing else.\n\nIf you create a new \u0060CancellationToken\u0060 with a linked-cts, the original cancallation token has to be overwritten:\n\nYour first sample would look like:\n\u0060\u0060\u0060csharp\nasync Task DoSomethingAsync(CancellationToken cancellationToken)\n{\n    using var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);\n    cancellationToken = cts.Token;  // Prevent the wrong cancelation token from being monitored.\n\n    var task = DoSomethingElseAsync(cancellationToken);\n    ... // Do something while operation is in progress, possibly calling \u0060cts.Cancel()\u0060\n    await task;\n}\n\u0060\u0060\u0060\n\nThe same procedure is applied if a delegate is used which is passed a \u0060CancellationToken\u0060:\n\u0060\u0060\u0060csharp\nasync Task ExecuteWithTimeoutAsync(CancellationToken cancellationToken)\n{\n    ResiliencePipeline pipeline = new ResiliencePipelineBuilder()\n        .AddTimeout(TimeSpan.FromSeconds(10))\n        .Build();\n\n    // ReSharper disable once VariableHidesOuterVariable\n    await pipeline.ExecuteAsync(async cancellationToken =\u003E\n    {\n        /* Your custom logic goes here */\n    }, cancellationToken);\n}\n\u0060\u0060\u0060\n\nWe have to suppress the warning, however, which is not a problem for us to prevent the wrong token from being monitored by mistake.","date":"2024-10-31T06:58:21.8903489Z"}