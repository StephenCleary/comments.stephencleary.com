{"_id":"e52a4660-b627-3f4e-8fe0-fbbf544c4ad4","authorName":"Stephen Cleary","authorEmailEncrypted":"dQkElANa5VwoVfFSiNoZqQMaBSHlJ++sSclrYRuXLRttWljmBLdAX3xviykputQaEfb6UA6Wx+2k3ztF0MC4BoRX02dTjMBYnRtlB5aZ+KbdGYvx+arD3j8qRwldKxMm9X+8ApVkZo+aT82j179dXoMu+ebOKkooFm69h7GN5uqw9IurbHzcRozuvMX53rvgdhxKFSsQMhaF161lEemerzFJZNBOjis5RDxm1crjIDs7ftXtv5mGu3rrTURDeyteBytpxUIbq+xmBFSc9T7gywoihEWgqpB65MbtAJ0Lvjp+6RMhKDZ6to1cbbzzQcJNECBQeVjDdS7lBDH/6MDTuKJN+y7AYYRe4I88dy5EsBZlHYfx73HVwTbvQIBlO693aQA9gJkoIe/EKtQnnV1s0HEWtsj46ofWk3dOzdopaMI31PH/herUO2CPxHNc7mRqY+lGuZJMSh/mPxRNythByU7q3NKPz4iwbttTfnsZpWO+q3YD/dXyzW7IaN18XycQZI5Dc9W69l3Igo/ZvsQk2k3Q/GBc2gHFaTiJV6YJaNB+clqIkIhqpUGtYA6aPmyMksLIPptta8Gli/drXpy+sPqF5fIgg3mZcUVe+sh28XjyYO3P7hza2BUNsxCuhwxyhNTbxub4mT6mitxumxXJTwROkOtPjh56wYAPk1g1zoU=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"Yes, in the general case, your I/O operations should be asynchronous, and your CPU-bound operations should be synchronous. Then, if you UI layer needs to do a CPU-bound operation, it can use Task.Run (or Parallel, or however it wants to call them).\r\n\r\n> one case I have been running into doing development with Xamarin is that I often need to call async methods on a method that doesnt really allow for it.\r\n\r\nThis is an unfortunate reality of working with APIs that were written before async. Due to the limitations of those APIs, you do sometimes need to resort to hacks: [https://msdn.microsoft.com/...](https://msdn.microsoft.com/en-us/magazine/mt238404.aspx \"https://msdn.microsoft.com/en-us/magazine/mt238404.aspx\")\r\n\r\nOne of the principles of Task-based programming (including async as well as Parallel tasks) is that you should always observe the results of your Tasks (unless you're really, absolutely sure you don't need to). As an example, the code you posted would silently swallow exceptions from DoDatabaseOperationAsync, since the task returned from Task.Run is never observed. So if your database operation starts failing, your app wouldn't even be aware of it.\r\n\r\nSo in this case (Device.StartTimer), one option is to block on the task. This is a hack, forced upon you by an outdated API:\r\n\r\nprivate bool MyMethod() {  \r\nDoDatabaseOperationAsync().GetAwaiter().GetResult();  \r\nreturn true;  \r\n}\r\n\r\n(this only would work if Device.StartTimer executes its callbacks on a thread pool thread, not on the UI thread)\r\n\r\nAnother option is to use async void. Async void is for \"top-level\" operations such as UI-thread events, and should be avoided in all other scenarios. In this case, you could say that the timer is a top-level operation, and use async void as such:\r\n\r\nprivate bool MyMethod() {  \r\nasync void MyMethodLogic() {  \r\nawait DoDatabaseOperationAsync();  \r\nDevice.StartTimer(new TimeSpan(0,0,5), MyMethod);  \r\n}  \r\nMyMethodLogic();  \r\nreturn false;  \r\n}","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"cc37b857-b392-3a86-b1be-684d3d87202b","date":"2018-04-27T14:28:05Z","timestamp":1524839285,"authorUserId":"disqus:stephen_cleary"}