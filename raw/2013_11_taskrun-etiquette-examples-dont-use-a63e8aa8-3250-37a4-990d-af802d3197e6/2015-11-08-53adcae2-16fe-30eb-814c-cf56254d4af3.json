{"_id":"53adcae2-16fe-30eb-814c-cf56254d4af3","authorName":"Ab illo bene dicÃ¡ris","authorEmailEncrypted":"EhH1jnVgYWeIzYizqRC3bsAOvgwyN3BSGNTBYd8DiQMAxVuCtGAMsymIddLPCxFlqsUmcj3xwZIBuzq+izbChfqAPqvzDRMcQWJ02/Lpd7q7I0z11zeG1+SFvCdw//HSvJO1WZYpDVQPpmo0c9yBWZo0FGMSUJksH6Hf1zJrk70TBMqjFU+MIXJl9ryMo6jtL6TYHJOdhxCRqlCAkKWdVeYXMa5/Fc6Dd5VTZ8Lpla7D/uQiJ5WZ5O04gD6ZSOlDUMbdL6cblBNsxH7JL+2d6bTfhCq5MuAk7RSTAC6PhPDS7qJvZcJe/03AWaHVCHtQaMvB2knNfo0I7za3Bg5Ghb6lz/WMrzXO10CyvLXudKiQjDvzM7yAknZthWXqa6QucJ/Y7iyik02voyAszZc1ivFL+j26me3CC/A0r0v7nGHXe9qGerQR6fdZlNdPZAkpDb9QcKdRNzy/7JojhiIkfXiVOivpktmIFxL6V5gJGSmGR5bsNR7QlniJYLp6Fq4ghErDCbePP3GWbiR2y7zzWMh8uWxnNVtfaZO3/Ch3VOk8mg7yAQTa64fSyCvvSdb1krWYPQlyHYC4+YC972F/ta1VRF32gqhAVU1Q2FlXt9eq8OADIizB8hM3cLWKJRQ9+thqojshx5GCdVOvZ5mGHicNYxbukQ8Wiz5UPl/CgkE=","authorEmailMD5":"59720fbfa214ebec03629573398f7bf5","authorUri":"","authorUserId":"disqus:abillobenedicaris","authorFallbackAvatar":"https://disqus.com/api/users/avatars/abillobenedicaris.jpg","message":"Every time I study TPL, I'm humbled.\r\n\r\nThe Task.Run() is described as a short hand by Toub at MS for Task.Factory.StartNew(). StartNew() gives fine grained control over scheduling and some other parameters. Use Google-Fu for the article.\r\n\r\nI ran with this notion. But I now I learn that I am in error here as well.\r\n\r\nMoreover, you describe here that Task.Run() is designed for CPU intensive workloads (I think mathematical computation or graphics conversions or sorting algorithms, where floating point calculations are performed by one or more CPUS). I've also read debates between Anderson and Marquardt about whether I/O should be async-y (\"Should my database calls be Asynchronous Part II\"). I have assumed from MSDN blogs, et. al. that when I do Task.Run( -> Some I/O operation with latency (DB, web service fetch, etc.) that I was delegating to a background thread, thereby freeing up the ASP.NET thread to continue servicing requests. This apparently was a big mistake since the operation is really not computational intensive. Database operations are I/O bound and depending on you who read, they are either are/are not usually good candidates for async/await (I think Marquardt gave reasons why I/O can be a candidate for async/await and Anderson accepted these). I realize that all of this is contextual, but the information at this point is quite confusing and it's 2015. I am not seasoned enough to understand all of these concepts, so they are probably clear to other developers.  \r\nIf I have a repository backed by a pre-async-y version of EF, then doing something like this Task.Run(() => _repository.GetCustomer(123); )  \r\nis no good assuming that GetCustomer(123) is just doing a single row fetch from a database table whose server has latency. So, doing something like public Task<someactionresult>() GetCustomer(int customerId) with this Task.Run call in it is not good because it's an I/O operation, not a computational operation unless the called method is doing some computationally-intensive work.  \r\nGoing forward, I'm more or less adopting the mindset of not writing any TPL stuff in my own APIs until there is a demonstrable reason to do so (customer complaints about performance, etc.). I would even prefer avoiding EF async functionality until I get a better handle on this. Toub says Task.Run() is shorthand, in another post I believe you say that Task.Factory.StartNew() is even worse than Task.Run(), suggesting that it is **not** a shorthand with some defaults set for the scheduler, etc.  \r\nI find it all very confusing :) But thanks for doing this blog and the concurrency book. Hopefully I'll get my brain wrapped around this someday.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2015-11-08T00:57:55Z","timestamp":1446944275}