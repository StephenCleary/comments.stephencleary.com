{"_id":"75413eb0-d59e-11e9-a060-892b2dcbd404","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","postUri":"https://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-dont-use.html","replyTo":"5c058420-d50c-11e9-ab7b-33d7aa1519e2","authorEmailEncrypted":"rUsyRnFyuJVVu+Dk9CwwwT5naoOhNdxZYIL8JiPS0L5XvGA0EOf4Yfioe5nGgDL1w/EUsWnZveRXxSDXN/DYoiMiy/McfpF7Mj9vGQzkTaJW8sP0Jf7N5/gd9EGF/WbqlMgKKGGnmNQDcnjKcVPpx8wH1NF32kjvLRrydMSYfyvZ9gKZF5AgP2lYo7sq7i7VCoIKKN+nsAiyhMzQR9uff6KVdEc0x5twhlCrfDXd2nr6I9XBd7BMOz5KJpHmWq7D/iNyQRxJ4kVUUMsKBft/OpaCLMLgXt1Y7CpJqxwuNtYtfsJstxywkhD+uwIH+xZBK6jSLLAtG6Ldyaa/ZrbkK36a9MzBqfyv/UFJLpnl/4Vmjfkl/a+GqphkroRgGHzleJ4iqa9vqq+fSLGDgWNh2ppFrmGdd8izfmfBbCAVJaM1X7zvkiug2/0gwPO2rRdIKsbkS5b83502ixUM1RiqQdLkvnpU/IFjnb4yjnFjVFuzw7j4iAsCCLlO9fp21oY5ZVrseoXUBqXe9S/bjBJsbt7712/AdAThBmG+HXeGoUx8VQGEnjBHYAKzNEIjaXgM77tstKbByd+Gq3Y/V0lgYsZSPdwPYXwwyJI7hb7KHSmdywlpTdN9cwqljetIeodCxbhUaycs02hhnSXgO2B3mYa7uF6z5GFxsBN3WhTKmyU=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"First, the guideline against `Task.Run` is primarily to prevent \"fake asynchrony\" - methods that *appear* asynchronous but actually just run synchronously on a background thread. This was a common pitfall for libraries at the time this was written; today, it's generally understood that this is a bad practice.\r\n\r\nIf your library is specifically about CPU-bound processing that can be parallelized, then it is appropriate to use `Parallel` (or `Task.Run`) in that library. You just need to clearly document it. If possible, I would structure the library's API so that it wouldn't do its own parallelism, leaving that up to the consumer. But that is not always possible.\r\n\r\nFor CPU-bound work, I find `Parallel` or PLINQ to be more convenient than `Task` APIs. They are at a higher level and easier to use IMO (once you find the right one(s)).","date":"2019-09-12T20:46:56.511Z"}