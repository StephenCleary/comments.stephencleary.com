{"_id":"5c058420-d50c-11e9-ab7b-33d7aa1519e2","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","postUri":"https://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-dont-use.html","replyTo":"","authorEmailEncrypted":"tfgkzDV/mlnzsRBs8arAIzY1ACqPl6/YUDH+EecA0w1q21bHnN2UNdNAttnbYR4d3FS/k/NQIv2jFKBDwTLAB/qET2KHJKLbpNbN+OJmOSfPD/a52bX9KCXLBghteEyt0MoXUJhsh0LhgQlbRew9GG1hCHSvQ3qhzp0f+++mwabaSiJaqSDdOiPCWCiyanYa7A39OIKg1fr88bwprJwCyEoWuTjA12ux3AidX0acrnQ9fWF4AfaqQTeOuIA4MfDlH4zDO+UmlYW6HXSsecwomxSJ2z8+SzK19fRbJhLdki2Uj70aRh7IQaIqmSDrPiru7EtRRLLv1FDmODnBElqIvifga3t25geyyRnvzDL+OAcJZ2QRvWRyGpiizIqNTnyXx2zR6yAnFUJoqYGJjOjZiKrX9ja5esemJ9ZVDNn7vUoGOlNkmexFptrcXlzaz4TPXT16nM2Z8BV0HD3QUb9bv9E7rv87tWctLG/vf7Q99XrlrLpP5Q17Ym8+5WraSs8DLPE4oaDRst2DPtGKDrV6oD2E8JaId/awf4Bnf5qmoVU66Fe2Pbr3vL29+AiDDfTE04/gXY0v1KAekND2eGKbO5ea/d3cELsz61Tn2KroGsPC4wX1hzGggefY83WSRLxVy5Jh/WR5Pk1CE0ZvpjOtvFWF2pDaxyX6K8SxOJ4Erhg=","authorEmailMD5":"751f64d6d9606c3c35b0a4fc85df0182","authorName":"Justin Swanson","authorUri":"","message":"Hey Stephen!  Thanks for your continued work on educating everyone on all these amazing concepts. 8)\r\n\r\nYou say explicitly \"do not use Task.Run in the implementation of the method; instead, use Task.Run to call the method.\"\r\nThat makes sense to me, for most heavy things, let the user decide.  This seems to follow the advice I've heard a lot of other places:  never use Task.Run() in a library.\r\n\r\nMy question, though, is how to do parallel CPU-bound work that is supposed to do the work on multiple cores using the clean API tasks provide.  You suggested in an earlier post that perhaps you use Parallel.ForEach or something and still offer it in a synchronous method the user can choose to Task.Run() on.  However, the Parallel library is not the cleanest API to use.  I'd much rather use the API offered by tasks, where I can add multiple tasks to a list of work to be done, and then Task.WhenAll which returns me their results in the desired order.  Is there really no place for multicore threading that makes use of the Task pattern, where chunks of work are offloaded to threads via Task.Run() and then collected via WaitAll?  I understand that in an ASP server application, you need to be aware of the resources you're using, so you want to limit concurrency via a parallel max concurrency parameter.  However, for an application that simply wants to calculate something as fast as possible and burn as many cores as possible, is Task.Run() + WhenAll still not a proper solution?\r\n\r\nThanks much in advance!","date":"2019-09-12T03:21:07.720Z"}