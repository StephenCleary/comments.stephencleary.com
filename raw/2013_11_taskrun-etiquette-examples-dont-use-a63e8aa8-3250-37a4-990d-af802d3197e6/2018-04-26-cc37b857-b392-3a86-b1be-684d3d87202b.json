{"_id":"cc37b857-b392-3a86-b1be-684d3d87202b","authorName":"Joshua Austin","authorEmailEncrypted":"EXZx06HiqHhE861ZlpJoIZZYn3jLkxtrPH3u+43gVYjdamczj9JWYhE6RlTGxfU8Gz3u3ey1nKR8oUo5Hdfz2OzTvxmZPxXi7bVoxXABP8bss0wJ8kz82Ie2W3u3r04SO7lyIy0fqu6qnmhITNTgHUu+TCKI2V/MGhIubvocX3afcMyOHiFimChyGlAr1Zykf27mPHf0ep1OV4CB+NMkSS6cWsw2oVJgrOuYLyCO5JsfffJ0XbpCbx7X1Hg9XR7bIBLmM1Eqa5PqU8OeVcnvcljIuPMErluP0EbwLWAEdSitroofjv3EuPMtbTYIkkpBWH54CkTlow5rHYeTvnf0098NVkpJfSep9CFxkmXQFDVdXnyP+MiYLUgi0OkXyiYXRjBPEuMnA8cWz2gAFElwvETgPQHjcgQI+0R2H6/67GKsP9lxfmFtWNVqMTKfXZBeZKInBy63Q3Z0Px5CFxjBe8a0aNtCGdatWxFjhFXpUXeCPn8guCW0gDxJHrETbFxvK0Fuq56lpwDPSWUls7aX7lStObm3U+DR1Bm71FU9alntL+kowWvINLPVCFBWKJ05CyxbuRijzkUIGRe7XsSi8yqdWHapCQJehjVTUX08KVhCjWN0i4cHbMmxKNiPBJV4IIRButde5kWz1MRJvAV0XECpIhJGAXug0pglCV4n6F4=","authorEmailMD5":"cd8f6f5544b9bb3faca4580aac71ed8b","message":"Ok, that makes sense. So, given that with IO operations there is no thread what I think you are saying is basically that as an API developer I don't know what another developer's requirements are down stream to make the call to run it asynchronously; kind of like how one avoids try/catch in class libraries unless there is some specific behavior/reason you need to catch - you leave it to the top layer to handle/log, etc.\r\n\r\nAlso what I gather is that there is no real benefit (in fact it could be detrimental) to doing a single CPU bound thread since at very best, the request will have to wait for it anyway (making it in effect no different than not having a thread at all). If there were multiple independent CPU heavy tasks you are saying to leave it up to that application developer in the UI layer to make the call to do a Task.Run as needed.\r\n\r\nSo, one case I have been running into doing development with Xamarin is that I often need to call async methods on a method that doesnt really allow for it. For example, a method called Device.StartTimer springs to mind.\r\n\r\nI make a call like:  \r\nDevice.StartTimer(new TimeSpan(0,0,5), MyMethod); // Run MyMethod every 5 seconds\r\n\r\n// Returns true to queue timer again, false to cancel timer.  \r\n// Because of the bool return value expected, I cant make this method async.  \r\nprivate bool MyMethod() {  \r\n Thread.Run(async () => {  \r\n await DoDatabaseOperationAsync();  \r\n Device.StartTimer(new TimeSpan(0,0,5), MyMethod);  \r\n });\r\n\r\n return false;  \r\n}\r\n\r\nWould you say the Thread.Run is valid here? If not, what would you suggest to be able to make the call to DoDatabaseOperationAsync? The only other thing that comes to mind is calling \".Wait()\" on the task. It seems like that would be a much worse tradeoff.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"de829fc5-546d-3262-aa9c-644f2911a51e","date":"2018-04-26T14:56:34Z","timestamp":1524754594,"authorUserId":"disqus:disqus_NNQAdRCoBK"}