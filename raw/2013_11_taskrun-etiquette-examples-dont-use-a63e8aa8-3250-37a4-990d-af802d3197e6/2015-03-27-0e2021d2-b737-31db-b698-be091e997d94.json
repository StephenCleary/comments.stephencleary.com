{"_id":"0e2021d2-b737-31db-b698-be091e997d94","authorName":"Stuart Wells","authorEmailEncrypted":"J9oUMfXHrM/mk1wlK3BnIQrJaWxtsybDd5yjShfmQNFZqQNyCvOyG18+Z9G43vlLbR+HsPVfNX3PMXZ0TMq6oWkqHXR6l0a3c26J8W/j3i8XEG39QzjYUxLBnvmSilE3XNglkioEeuT2zjHOllcbStMQ7SBlsbkoftjj1ErC8vHfEtv0xUrguqErun04/I972e0qUWiqrYZYuTsVAjRtO9L1IuOHfOIBhhyRXYAfVojd06o2/Gyz4/G9TSXD6faNCq996ItG11PdVlSmnlOA1giolyiEjiE+926L7T2fqLqaFN5Oy2HYLPlwrlVRkT135tgYqGfymKfP/wcau1St4rWbqu1JROmJrF0ERqjJ+ZhsBdoQ0B9yzpq2xzLabOI9UeJ1kywyfzWJu2gNIdcxlG2U84Q2IWE/Lkt5yNTzyKBBECZrkz0jQH9SsiPjOTlwyViIHNsHD+4SXBBgxSIouAH7ActB+nVeNwjRhv92zEqZUlWHywXNVizGCdkm0AWF0ONTIbAXWugiCAWQZwTJDTPXfdiHIeXxPjC9uIKY6JW0nEUxlRTrpT8T+UewDLBDte9NPAbxT1AZRbQMm+Vax6o0kq9uie3Glt/glTHgOlfKG9Cf5qO0hqMezYAV0sau1awU0vyhvHJ2F3o0b/QtkAIBoS/LLdtFcxhxH+/to+k=","authorEmailMD5":"1f7d6a407bb7495bb3c9669535bd0327","authorUri":"","authorUserId":"disqus:disqus_2cbnUKZGU1","authorFallbackAvatar":"https://disqus.com/api/users/avatars/disqus_2cbnUKZGU1.jpg","message":"I was mid-refactoring using Task.Run (thinking for a moment I finally understood how to implement async/await) when I read this and stopped. Close call. However now I am wondering how exactly I achieve my requirements.\r\n\r\nI have a WebAPI controller with a variety of Post, Get, Delete methods and as part of the call it needs to talk to a repository of some sort (I have an interface defining this repository and I have defined the methods on this interface to return Task or Task<t> with the expectation than an implementation would implement it asynchronously if it makes sense to do so).\r\n\r\nLet's for arguments sake say that one implementation of this repository interface is to an external resource (like reading a file or communication with a SQL Server). This seems a good candidate for being able to call asynchronously.\r\n\r\nAlso let's assume I have another implementation which is storing everything in memory. There is no benefit from making this asynchronous because the work has to be done by this CPU anyway - but by returning a Task the caller can 'unblock' themselves if they so wish by awaiting the Task.\r\n\r\nSo how should I implement the interface that wants to return a Task or Task<t> for the in memory variant? Or as I am seeing this, as a synchronous variant?\r\n\r\nIn my case I happen to know this could be used in ASP.NET/WebAPI or WPF but anyone writing a component for re-use would have to assume that the caller could be anyone. To be as friendly as possible to all possible callers it seems Task.Run is out of the question. I can't work out whether I should/could use Task.FromResult. In short, what am I supposed to do?\r\n\r\n// interface  \r\npublic interface IRepository  \r\n{  \r\n Task<widget> GetWidget(int id);  \r\n}\r\n\r\n// implementation  \r\npublic MyRepository : IRepository  \r\n{  \r\n // note not using async keyword as I am not using await, although Task<widget> is awaitable?  \r\n public Task<widget> GetWidget(int id)  \r\n {  \r\n // Was about to do this  \r\n return Task.Run(() =>  \r\n {  \r\n //...some synchronous code  \r\n return widget;  \r\n });  \r\n }  \r\n}\r\n\r\nI can't just do this:\r\n\r\n// implementation  \r\npublic MyRepository : IRepository  \r\n{  \r\n // note not using async keyword as I am not using await, although Task<widget> is awaitable?  \r\n public Task<widget> GetWidget(int id)  \r\n {  \r\n //...some synchronous code  \r\n return widget // inappropriate return type;  \r\n }  \r\n }","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"","date":"2015-03-27T12:21:39Z","timestamp":1427458899}