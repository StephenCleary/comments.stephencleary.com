{"_id":"ab74d4eb-bb78-3a13-a22c-e53900c85f66","authorName":"Stephen Cleary","authorEmailEncrypted":"rnk43o5wq4AA2VPRivzIq+8bkPS4gTsMMLqYxbCjumJJRvkkoWPiW5H9VmfTOlyeoJ47VLWQLJxlSbpwtBB+TUzEBW3pvFgJThFJVTmn5OxQo7rLnO7BpZINcspm+9roist4sEu8QEf4Trwz48nIWHq1RlgW9THemSX3fB94nb/2mClYU9RmgtFx/DziqxuCzkIg2YRiGpV1f4+/4nmaEGbYkDDFjgSGXrJ80qxAbIkhl8od39izXZ5KMVrUSxlmEhzp1kNMUH8QmVHvMA8F1/si/VlShHLOqXdAJiiczookTh9LAdQykxsodsBo9JJHH2Bu++uJMT56FVN/yhVn5KaI2W5KYSqDhtoOarFTbCOZkmJfX61/0iwiezOVEgMJCn2GnxamieN9P485yGe00f2ZEuQgFxWCQln+W6uEZCZU0LAeP2MmntZ+I7ZOakyAgOHNk9plIJ/gJlg2em9Cim6J67yy4ioAqoQhu7z7HX/lq9HiIhiOtJnq8QfEnKfSEfzZbQ8XUOGCTSx0Md11GtyAm2o2+PlNYG8ZGcTxkgWFMKtXe8G50eDNJAV/O8wih1337x5lfZkUT/iuovWC88h0gQC3L7wfHsecT/+2EtU/gAVYjvgekrhpPwensVAGX7WDut9mSdmDBmHH1HD+BHg6Xl+39qLdpTux9XWclKk=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"I think you mean that asynchronous code will also have the overhead of a thread context switch, and that is correct. However, it is preferable to blocking.\r\n\r\nIf you run a CPU method directly on ASP.NET, then the original thread executes the code, and then continues.\r\n\r\nIf you await an asynchronous method on ASP.NET, then as you stated, the current thread is released to the thread pool, and when the method resumes, a thread pool thread is acquired to execute it (which may or may not be the same thread).\r\n\r\nIf you await a Task.Run CPU method on ASP.NET, then the Task.Run takes a thread from the thread pool, and the original thread is then returned to the thread pool. When the Task.Run thread finishes, then the async method is ready to continue. (There's actually an optimization here where the thread resuming the async method *is* the Task.Run thread). So Task.Run on ASP.NET will cause an extra thread switch and throw off the ASP.NET thread pool heuristics (since there is a thread pool thread used to run code outside of a request context, and then returned to the thread pool when that work is done).\r\n\r\nIf you block on a naturally-asynchronous operation on ASP.NET, then the original thread blocks, using that thread (but doing no useful work) for the duration of that operation. When the operation completes, then the thread continues.\r\n\r\nAwaiting asynchronous methods will cause a context switch, but this is almost always preferable to blocking a thread for the duration of the operation. Yes, you lose a few microseconds of time (asynchronous requests *are slower* on an individual basis), but you gain significant memory benefits as well as faster responses to varying load, which enables much more scalability.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"3ca897b5-12ca-3eb2-ac0b-82b5234657d2","date":"2016-10-25T21:01:08Z","timestamp":1477429268,"authorUserId":"disqus:stephen_cleary"}