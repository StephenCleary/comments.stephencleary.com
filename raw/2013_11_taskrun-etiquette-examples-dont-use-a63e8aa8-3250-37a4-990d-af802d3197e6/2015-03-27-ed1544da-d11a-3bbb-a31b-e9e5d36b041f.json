{"_id":"ed1544da-d11a-3bbb-a31b-e9e5d36b041f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Either of your examples are essentially the same. And yes, that's the way I would do it - synchronously get the widget from the XDoc, and then wrap it in a Task.FromResult to return a task. The only other thing you may want to consider is to catch any exceptions from your synchronous code and return a task with that exception (you can use TaskCompletionSource<t>.SetException for that). So a complete implementation would look more like:\r\n\r\npublic Task<widget> GetWidgetAsync(string id)  \r\n{  \r\n try  \r\n {  \r\n Widget widget = null;  \r\n //...some code that queries an pre-loaded XDocument, populating widget  \r\n return Task.FromResult(widget);  \r\n }  \r\n catch (Exception ex)  \r\n {  \r\n // In .NET 4.6, you could use Task.FromException instead of this code.  \r\n var tcs = new TaskCompletionSource<widget>();  \r\n tcs.SetException(ex);  \r\n return tcs.Task;  \r\n }  \r\n}\r\n\r\nI would not recommend Task.Run, since it does use a thread from the threadpool. You could also use the async keyword (without await), which simplifies the code but then you'd have to deal with the compiler warning.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"3401c15d-d0d5-332c-b804-48723e4d3c8b","date":"2015-03-27T16:24:38Z","timestamp":1427473478}