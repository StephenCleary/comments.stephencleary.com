{"_id":"d8b2917e-f565-39c2-a220-208434f96c90","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"CPU code is fundamentally synchronous. It must run somewhere, so it *must* take up a thread, and this makes it synchronous. (In contrast I/O code does not \"run\" - it just waits for a response - so it is naturally asynchronous).\r\n\r\nSince the code is synchronous, it must run somewhere. If you call it directly, it will run on the current thread (which is bad if the thread is a UI thread). This is why the UI thread offloads it to a thread pool thread.\r\n\r\nRegarding \"Would it not solve the problem of blocking UI by just calling the calculateMandelbrot() using an await?\", I'm not sure what you envision the code to look like with that approach. You can't await something that isn't an awaitable (e.g., a task). You could mark calculateMandelbrot as async and return a Task, but since that method has nothing to await, the compiler would point out in a warning that it will run synchronously. You can avoid marking it async and return Task.FromResult, but that's just the same thing - it still runs synchronously on the UI thread. You can stick in random await calls with Task.Yield/Task.Delay, but that's a hack (dependent on client hardware) and it's still going to run all that computation on the UI thread anyway. Or you can wrap the entire method in Task.Run, and this entire blog post is about why you shouldn't do that.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"dbe84c1b-38ba-398d-98bf-f5fe98efcfe2","date":"2017-01-29T18:37:25Z","timestamp":1485715045}