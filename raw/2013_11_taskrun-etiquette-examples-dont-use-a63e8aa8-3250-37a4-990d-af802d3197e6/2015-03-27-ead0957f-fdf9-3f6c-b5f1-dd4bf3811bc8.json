{"_id":"ead0957f-fdf9-3f6c-b5f1-dd4bf3811bc8","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The problem you're running into is due to async forcing a leaky abstraction (similar to IDisposable). Your interface must determine whether its implementations are naturally asynchronous (just like with IDisposable, it must determine whether its implementations will have unmanaged resources that require freeing).\r\n\r\nSo, there is no perfect solution.\r\n\r\nIf your implementation is all in-memory - and presumably not long-running - I would recommend the Task.FromResult approach. However, if your implementation is blocking - i.e., it really should be asynchronous but for some reason it can't be - then it's up to you whether to use Task.FromResult or Task.Run. Even in that case, I'd lean towards Task.FromResult, documenting the type well that it's actually blocking and not asynchronous.\r\n\r\nAn example of dubious Task.Run usage in inheritance is the BCL is the Stream class. The asynchronous APIs were added after-the-fact, so Stream could not take the (IMO more desirable) approach of being async-first. Instead, Stream assumes that most of its implementations will use blocking code, and so they made the decision to make their default async API implementations use Task.Run. MemoryStream - being synchronous but not blocking - overrides these asynchronous implementations with ones that use Task.FromResult.\r\n\r\nIn this case, you don't have a backwards compatibility constraint like that, and IMO a better approach is to only define an async API in your interface.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"0e2021d2-b737-31db-b698-be091e997d94","date":"2015-03-27T14:05:25Z","timestamp":1427465125}