{"_id":"3401c15d-d0d5-332c-b804-48723e4d3c8b","authorName":"Stuart Wells","authorEmailEncrypted":"XLMRHnTRKLkmL6GQGQZnwT5q0nzn1tQGIymLLcF+voOdSf6HWcTIZlUQqV7HEjJlETg91uEDLS+M0AsLpmSmvUWf0xvAhDQOgxc5U6s/9dsypoLNPkYQumjV64TFg9aERb+gjNi1Ppu58f6IIDnBCt1KCQZIdK6YWkvk6qdviIWNs0pDdTltKNnTOtrpI40OSD7+OsdByqMJDajx76LWn/8/+AxGMH+9sUmXgIM+RMZKjHQHMq9cNNqama7taUZw2rtwyhhu0pkpHdwWewiFmNdrVDE5Bun6Ouu1g9f38LJAh+6ldOA+JQhVfjSsqJAUp9sUrYm0vuaKMl9Z2gbfGVOjuIPXyAcINFc7Spfl+sofLN82HppX+H/xwUoLXhIxS6d7n3Y+vsKmk7stLv+fDQzrBn24MOh2Gc48c2xOTZxygCX5lxj1DmsLuiR5jn3EDP3YTrMGvCEunBpSEqA2ygOp+gdnrdi7KrGSeYJIAoaOL0ZZoqgcVkNQ4cwjQSgbRHF6FPslsujkrPhUoL2m4Fv+6BNk4Cz3ZTkoJ7yYo0nECIYzvFPAuYlR0S/Fq/+XtfDdjWe3uhBLgUmv3c4Lx8u3QhVWGwlBfLH6DdhMi/Bq6NBCum9EALnDjnkb51EanDRQPuKPmZUuZLX78dJhsH0hhe3vIX4gzM67H8OR4Sc=","authorEmailMD5":"1f7d6a407bb7495bb3c9669535bd0327","message":"Thank you very much for your response. I did however glaze over a bit trying to understand it.\r\n\r\nMy understanding is that I want to avoid using another thread from the thread pool just to be able to return a Task for an activity that is running locally but may take a little while to complete.\r\n\r\nMy WebAPI controller code might look a bit like this:\r\n\r\n public async Task<ihttpactionresult> Get(string id)  \r\n{  \r\n Widget widget = await this.Repository.GetWidgetAsync(id);  \r\n return this.Ok(widget );  \r\n}\r\n\r\nLike this because by the grace of DI, this Repository may be CPU bound (my example) or IO bound (webservice file access or RDBMS). It will therefore work with any implementation as long as it returns Task<widget>.\r\n\r\nMy simple implementation is essentially running like a cache (the implementation loads an xml file on construction and then all gets read from the in memory XDocument.\r\n\r\nIf I understand it right, I don't want another thread to be used to do the repository work, I just want the calling WebAPI request thread to feel free to handle another incoming request while it is awaiting the xml query to complete. A bit like a UI thread handling drag/click while it is waiting...or do I misunderstand something at this point? I do feel a little confused about the availability of threads in the pool to handle requests - if the thread cannot handle another request while it is awaiting then there is not much point in trying to be asynchronous for non-parallel activities.\r\n\r\nIs the following the correct use of FromResult?\r\n\r\n public Task<widget> GetWidgetAsync(string id)  \r\n{  \r\n Widget widget = null;  \r\n //...some code that queries an pre-loaded XDocument, populating widget  \r\n return Task.FromResult(widget);  \r\n}\r\n\r\nOr should I place the whole body of my code in a method and wrap that in TaskFromResult - I am treating Task.FromResult somewhat like widget.ToTask() if there were such a thing?\r\n\r\npublic Task<widget> GetWidgetAsync(string id)  \r\n{  \r\n return Task.FromResult(this.GetWidget(id));  \r\n}\r\n\r\nIf I use the async keyword I can just return the Widget directly although it complains about no using await. Omitting the async keyword won't allow me to return the Widget directly, I have to use Task.FromResult or Task.Run, but the latter causes another thread from the threadpool to be used, which I now understand to be a bad thing.","postId":"2013_11_taskrun-etiquette-examples-dont-use-a63e8aa8-3250-37a4-990d-af802d3197e6","replyTo":"ead0957f-fdf9-3f6c-b5f1-dd4bf3811bc8","date":"2015-03-27T15:20:01Z","timestamp":1427469601,"authorUserId":"disqus:disqus_2cbnUKZGU1"}