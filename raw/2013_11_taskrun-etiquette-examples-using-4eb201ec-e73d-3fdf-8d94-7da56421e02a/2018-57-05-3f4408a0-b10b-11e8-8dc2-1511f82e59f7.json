{"_id":"3f4408a0-b10b-11e8-8dc2-1511f82e59f7","postId":"2013_11_taskrun-etiquette-examples-using-4eb201ec-e73d-3fdf-8d94-7da56421e02a","postUri":"https://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-using.html","replyTo":"2eb94a70-b108-11e8-8dc2-1511f82e59f7","authorEmailEncrypted":"KXobnKdebcDcaWrADQaTPGc7vjuMpdGVFrfxhcP6rncmThQ+6RGIEmRMK8vTjpUAa/6wc0izCVrfk6Z/txAbwWwv2PkUfcOHp35BlM3VkL0tf7Xy5QLz1i/6ilgTOZA4aHa6Z/o5QVkWndVFXsVYPvAdZmV/Pzi/rCddotcHS38UuadxWW+mKVzY70wFNOpc9lps9HrLjEv7R7gcQ+5sbOOvzc07Ka6v55FDfCUyPRIVzdxvUa4N0j7SyokrNiFuAHafpunIPlt6b+Q4L14Ilofex5iFXnBWHyISXKBJuxwsNTGAoovbr2ko+kZOqS5e2AuXsKC/TNN7UpsLPrTEyciGfDn/kCbD0X9l+p0lhsgQqo48/o4p6iO5bNg2zVtw1StM+W8Ysd/xA0mUj4BJKj6oSa3YBLyS4L1riDMvSFOIL4CYi3BcgzP4bxIV94+uu25l0DF5Ov8bYAvTshEiVFGxZKsNK8bnuzHORRuKvRjUfOHR9ZclHqLCmpvNitiqndF9aL7tzfVBqdQlYuRvEb1qpLEcIHnk9wxRT9Q1rGKd4jofBofFeR2dmPFmvICFTNm+WiqBjVUVRuwyITDTbqwl58NxJA5YQbkwTHSunw5WQsncHEjTGGseRBFAEo+vSTzQnq6rFq5wez8CbhUZho6YPsv3Gtjxr2fVVk5OVMo=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"In this case, the first thing to do is send a request to the library maintainers for asynchronous APIs. :)\r\n\r\nIn the meantime, what *you* have to deal with is a synchronous, blocking API. Wrapping it with `Task.Run` would create what I call a \"fake asynchronous\" method. In an ASP.NET context, you should not use `Task.Run` to wrap it. That would just cause a thread switch for no benefit.\r\n\r\nOn the other hand, if you were on a UI thread in a client app (e.g., WPF / Xamarin / Windows Forms), then using `Task.Run` to wrap it would be acceptable - it would give you the benefit of freeing up the UI thread.","date":"2018-09-05T12:57:30.428Z"}