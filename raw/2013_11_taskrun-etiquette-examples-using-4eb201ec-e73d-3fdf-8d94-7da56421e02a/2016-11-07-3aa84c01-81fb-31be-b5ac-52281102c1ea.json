{"_id":"3aa84c01-81fb-31be-b5ac-52281102c1ea","authorName":"Nathan Phillip Brink","authorEmailEncrypted":"Dg8o4bI/LLp2IxhZumlqYi9kD0o2k1s5sc662bV6sDRFSbZ8nIfolLmhM399kFMcIiR/++I0rkeZuxu2AS+KDHVFYY6TB9EA+dvko4o3KKVgY3dbKByFy3neTjh2e4jFJWDtpkcCV04DXPKMMCIT+DthXf0+ZzHAP13HmRuhFXLE4GMdzHxJVFZOFbVnwxCxuwmBhNj+7YR16nDAVxmMziVG63pkDrV3aiMIJU6DSMtxk9ekrdMxGky21zvU0YkYOb520wd6fUd6llt6CEFzW/r2AJi5l5eFBT/Em+oFLx2W2X/5RqRgGpIoQt1AZbFlxIydkAuoBnAc4OrsCm4zitjmIq/Tyc8ud3Ak54aeWR102j58AFeBAvgYaCa5bTQw13KYtllNg2j91z1M1MO5BZkWkVSP7h90NUDa/QvmaMq/LbWfFqr5oZEe8rHvhplmzvQALfvU0gKo/Mdizw4QIT7RsVm2RB2ay4oZztZtPsYS5yIDK2t3jXMC4IfOPWZSj41GXfu9S3XraooZvFirxCeRgY9EMtgyHGS+pliHeC7126+Myq6qLASm5VGcvKQNzY3DS7PPFuwYCmP6OR49YsbTyQl1CYaMw8BUibndWCXW9cvgTzEssRPqh+HQvO1YCtvVgCYGsDtbcr4Eho+NcIhpe+Bm+rSALiPBBmli0uw=","authorEmailMD5":"a8defe14b1c80bc2bd59a1fab3848cfb","message":"What about blocking things that have no async implementation? Like `File.OpenRead()`, `File.Open()`, `Process.Start()` (which I assume has an implicit blocking `PATH` search). I’ve heard that some of these functions don’t even have OS-level support for async and *require* sacrificing a thread if maintaining application responsiveness is a goal.\r\n\r\nI understand that just using a simple `Task.Run()` would be bad for these if one is really properly putting CPU-bound work on the threadpool because blocking calls would just sit there preventing CPU-bound work from running. But is there perhaps a way to create a custom threadpool just for such calls which have no async alternative to keep the main threadpool performant *and* keeping the main application responsive? And, is there a way to keep my code concise if I try to do things “more correctly” like this?","postId":"2013_11_taskrun-etiquette-examples-using-4eb201ec-e73d-3fdf-8d94-7da56421e02a","replyTo":"","date":"2016-11-07T19:27:55Z","timestamp":1478546875,"authorUserId":"disqus:ohnobinki"}