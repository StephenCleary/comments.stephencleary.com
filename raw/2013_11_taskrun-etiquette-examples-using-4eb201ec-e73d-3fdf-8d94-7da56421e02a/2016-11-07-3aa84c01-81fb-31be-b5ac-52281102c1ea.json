{"_id":"3aa84c01-81fb-31be-b5ac-52281102c1ea","authorName":"Nathan Phillip Brink","authorEmailEncrypted":"BcvHZfNr6aFZBBXLus2tA4OmkLsYibt4LsqPxQykwzdWPYBTzWMwuTmremUmW+LTFjaWa6SdkU5WGp1jOL9vGgwviWtitUbGjQjOzsyjZ8VanCHgK3AjhueCLsQLO2du68VanBZcPhKOCpJpK0ydUXTQqMvIvW7inEuSOYkUuyfdN63+U6sw8VOs/h7VpxwWocL02sDwa1WuWwufxbM/JQ9ft80L4HGlKztev8O8zu+dgIYed+PKGA1z5mbKn3CqQBmTpPJ2rz3NTsKiP7eMBElFrJtRDTHwA+/RBDP/PF4yFoExBcBCyR6R/a1ib30JLTP9bHFsvwKL9mmEEewqmNxcn30hjF4kT5grUdPsXHbGuKFQIy1fSoQnRQGZVJkE3uUyw/XxY8jxDovuT0IMBhKCtdfUO50H+a8IVwXqQsH0X6BvdASh3TMzgQxmAsrdAJMR9416sxauASR0nMvZkVaez/uvpNnKtMkK2EC2JI4kAlPrqhxyChNmMM+pUCu1zqe5WL9CsxJ5iX3ICTP1OMVcsnCDDj1c1ao/pfgI4wucPbflUTicJn4U6b4fOZwdIts0T86FovlDJI5vriOR6fNgB2JmmKn4ZGVAeWJCtJM2r9gLUZ4ktMot7AkLiz9Y4U3B1pDCQpK2PILOfkx19n7C+h/2aWoM2cXvBVjHrtM=","authorEmailMD5":"a8defe14b1c80bc2bd59a1fab3848cfb","message":"What about blocking things that have no async implementation? Like `File.OpenRead()`, `File.Open()`, `Process.Start()` (which I assume has an implicit blocking `PATH` search). I’ve heard that some of these functions don’t even have OS-level support for async and *require* sacrificing a thread if maintaining application responsiveness is a goal.\r\n\r\nI understand that just using a simple `Task.Run()` would be bad for these if one is really properly putting CPU-bound work on the threadpool because blocking calls would just sit there preventing CPU-bound work from running. But is there perhaps a way to create a custom threadpool just for such calls which have no async alternative to keep the main threadpool performant *and* keeping the main application responsive? And, is there a way to keep my code concise if I try to do things “more correctly” like this?","postId":"2013_11_taskrun-etiquette-examples-using-4eb201ec-e73d-3fdf-8d94-7da56421e02a","replyTo":"","date":"2016-11-07T19:27:55Z","timestamp":1478546875,"authorUserId":"disqus:ohnobinki"}