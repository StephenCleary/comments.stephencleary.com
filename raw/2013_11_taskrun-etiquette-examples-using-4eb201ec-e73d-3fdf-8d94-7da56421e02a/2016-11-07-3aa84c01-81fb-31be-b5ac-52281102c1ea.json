{"_id":"3aa84c01-81fb-31be-b5ac-52281102c1ea","authorName":"Nathan Phillip Brink","authorEmailEncrypted":"bPNbxMb3E3t+0zfnUBFNHgV/tNCPCpDthiNRoFuBuRpAX8GeSPwDMF5xGzhBN8+LvS4qPBIPM4jhi4gYo6rLrcj4qC1vajFNCOybLZK4m+94OMgLMM9LBCe/S7rfue5QzURofqb3nNuKeon04XMrGUX6+PbRY0oedokzr0lvRSE3jhrov/dEbMVQ+OYu4hAa/O4g2OoAvMiN4EoFr+eAIpGQ1SnlGmQLOIbFWToIpYuN52EJ1k7nt9OMhOwSYRO6nHwmA+FiwSVo7GZ9j+L2tAD/xGZb6gCPnTe/r2h1cC0BI57g2zlPLH87L26FbgOUokIstvZpRt7XBPdAe958C9w8vyGKdARYIf4lq2kEyTZ2cOWtLMbg8Fe5mZGlQ2IRviwxJjJzicyFCCptkBHht4ZhvTsw5iSqUlKCT+aLxEt62piH8lap1cDhXHKeWec9Bt9U+6lnIyx6uEzaQKChO5Aj0zsSxF6EEE8Psvb7u0kTj6KVBXMiUkUEOtT1ouw2joyBSNC4d/6DPoINWK54ElLnQ1o5hVlFDJe36BgWeLOw5n8aZOsrriRcdKh0V0yUmmzK3J9i8Tj23GEGwqXxw8beQ2TpzJAc7IbBB9ecx6pfRAdS4tN0b2DK4jUAU2q3RpnSJCMeAgCR5bbdqlaEZQhY2XXjCHnQTCFYu6goYDg=","authorEmailMD5":"a8defe14b1c80bc2bd59a1fab3848cfb","message":"What about blocking things that have no async implementation? Like `File.OpenRead()`, `File.Open()`, `Process.Start()` (which I assume has an implicit blocking `PATH` search). I’ve heard that some of these functions don’t even have OS-level support for async and *require* sacrificing a thread if maintaining application responsiveness is a goal.\r\n\r\nI understand that just using a simple `Task.Run()` would be bad for these if one is really properly putting CPU-bound work on the threadpool because blocking calls would just sit there preventing CPU-bound work from running. But is there perhaps a way to create a custom threadpool just for such calls which have no async alternative to keep the main threadpool performant *and* keeping the main application responsive? And, is there a way to keep my code concise if I try to do things “more correctly” like this?","postId":"2013_11_taskrun-etiquette-examples-using-4eb201ec-e73d-3fdf-8d94-7da56421e02a","replyTo":"","date":"2016-11-07T19:27:55Z","timestamp":1478546875,"authorUserId":"disqus:ohnobinki"}