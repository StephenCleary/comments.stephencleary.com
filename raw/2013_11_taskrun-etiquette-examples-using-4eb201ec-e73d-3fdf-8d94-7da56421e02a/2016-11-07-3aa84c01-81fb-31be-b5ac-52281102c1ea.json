{"_id":"3aa84c01-81fb-31be-b5ac-52281102c1ea","authorName":"Nathan Phillip Brink","authorEmailEncrypted":"axFQ0b/YAI0KwQYemgf4JUPvCZbLkexWyf0Iz8QK57gDiyTR+mp4WYaNMQUFaTp2zW3qxSrsQQd7fw8nn57K9rYrf2kojL3B4mHXRejLX2Yu1pGv6EEpepI9/uTr3gMpTVrVaBYmaqmgUcFkRZoSvQRLY2dGhGFIf0Oypz0CeZ0dP2xQ51yj4pXbhw62gvw/igLYS+rm42/NXSRvEsTNHuxSWzL5wUTOlsz2sQKCzmpmRgWVVl1A8vZ+tU89NmskSUgHK7I+mGCUqdFqhrafteAxr0UBynV/Cx80y4lv+qm5CjHQZt2f7ECQkaiv2ljZaLlWYjjVRcb29ljDDK136hrwXN94Znzs7lSBR8BpX4edyXzDBQjxuOH8P50bITytwioA2ZLJdiIve7EoGo8ruE7K9Y+k5+Sb9JTjycsFjDJ92/Ab3+nO3zj7FDz6tGI1nI26PTaQa8i3TNiGAGD1GUFC2FumeoIBSn3FX+ytabGhTFgPDtftx8YuFRCjmsXQgvMXHNPjaGprM1UbCx1ye/zmhrk0XfvTZS/xr193pmz36RKoFFP+6u4pPUleotWDVGeqq78vngB5JK2BS9FS8fymot6jFhhIlou5nGL2y0UChSK8RhLSXEW+U+HSwLcjp+m0VpQtuN4IHvEhzJiSiIeUPX/DRV2DJs8LzJ4xmnc=","authorEmailMD5":"a8defe14b1c80bc2bd59a1fab3848cfb","authorUri":"http://ohnopublishing.net/~ohnobinki/","authorUserId":"disqus:ohnobinki","authorFallbackAvatar":"https://disqus.com/api/users/avatars/ohnobinki.jpg","message":"What about blocking things that have no async implementation? Like `File.OpenRead()`, `File.Open()`, `Process.Start()` (which I assume has an implicit blocking `PATH` search). I’ve heard that some of these functions don’t even have OS-level support for async and *require* sacrificing a thread if maintaining application responsiveness is a goal.\r\n\r\nI understand that just using a simple `Task.Run()` would be bad for these if one is really properly putting CPU-bound work on the threadpool because blocking calls would just sit there preventing CPU-bound work from running. But is there perhaps a way to create a custom threadpool just for such calls which have no async alternative to keep the main threadpool performant *and* keeping the main application responsive? And, is there a way to keep my code concise if I try to do things “more correctly” like this?","postId":"2013_11_taskrun-etiquette-examples-using-4eb201ec-e73d-3fdf-8d94-7da56421e02a","replyTo":"","date":"2016-11-07T19:27:55Z","timestamp":1478546875}