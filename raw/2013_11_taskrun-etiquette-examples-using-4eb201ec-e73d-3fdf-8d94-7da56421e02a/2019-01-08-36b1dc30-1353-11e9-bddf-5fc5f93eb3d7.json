{"_id":"36b1dc30-1353-11e9-bddf-5fc5f93eb3d7","postId":"2013_11_taskrun-etiquette-examples-using-4eb201ec-e73d-3fdf-8d94-7da56421e02a","postUri":"https://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-using.html","replyTo":"8149f6d0-1207-11e9-a15f-f5dc9e0c5ef2","authorEmailEncrypted":"VRz7aGA053f0h0i+YDsqnJ0d5LHCQp35bjloa249Dc0hAlv13ecItcjoqxmf8U6UPX8ZjcigwC5WkAfYRCi7mUtNvHBg+HR22SD+CRrD4g+iVf/fo0SBQIFghXq5rqO3xbzDETKv1UVIz2Qlt8ADvkNalBWJR/ANqg5H9NhqL9bSjm/iXr/rTOrJG3Id7m0oB3XCiapcXzHGkI4I5Jb0Ku6A/w8i7Thq+vsogMcoXctfs9qZk6G8t3woq2fBUQkLL9z/ROlxhZ/aCroHIAjwNeVSGeLL/XSu4s6fDG8ZCZtNad2ofWL7Ik6haL6IBQ3/WUBYu8ApDYafuvtTfbtNqywGAfYfXKk2UEGW6CvFlpyKTu4Hq/qLe/IhGbu3eA76B93OtLskWPk0dyrZVEyApaOWGv3i8j2vKsTA/o8oje3c6VbQNGJlJgPP9OBZR1FMWQPy4u9PcUTWQnuhebutr0IOZURFY6tTcVNOqyX6JccjIKz2VoJ2L8af8RXd3MhxiR9OSX7Xjzyivnh+3014V2TjFuKe1XsPzOeQreJsMbdT6zsMWmS0MwtrsJ6/7ci9XwEDswA7W4KhGanf20VeKF0yBivQSN/OaZPHb4S08wL0T+/d6TXogMqMiEYJcHwsHh3Wa4Ca+Iv7wz6isX3S7PuB6NAHzm9atTFOAQxBX4E=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I have very little experience with C++/CLI. However, I have done unmanaged C++ exposing a C-like API that is consumed by C#.\r\n\r\n`Task::Run` (and `TaskFactory::StartNew`) create tasks that run on the thread pool; this is not what you want. Check out the `TaskCompletionSource<T>` type; it gives you a \"controlling API\" for a task. When your API is called, new up a `TaskCompletionSource<MyResult>`, start your own asynchronous operation (passing it a reference to that `TaskCompletionSource<MyResult>` instance as part of the asynchronous state/context), and then return `TaskCompletionSource<MyResult>::Task`. Later, when your own asynchronous operation completes, retrieve the `TaskCompletionSource<MyResult>` instance from its state/context, and complete it (`SetResult` / `SetException`).","date":"2019-01-08T14:39:33.750Z"}