{"_id":"2eb94a70-b108-11e8-8dc2-1511f82e59f7","postId":"2013_11_taskrun-etiquette-examples-using-4eb201ec-e73d-3fdf-8d94-7da56421e02a","postUri":"https://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-using.html","replyTo":"","authorEmailEncrypted":"U0pL4sQOShZDGvcnZ2NJyBwMs4k41eu1V+vs31DQPswGFWG4mzfdtMUjkeOHR1p9OhUfR+yUQX/v9Fa9WwKNXvqnAx25FNcQ5uODkraNRQahYEqj5OfjnpQXaApCawqSSb8ZDXVSI3jfoZYBy70uZ1nTQO/7iFCePixrZMkkQS/w29ZoVFpYllzhPGjDGj6wRaDTPZ8XBnFCrNZAwyq9oLlhfQeD5d4iPj4biaWi/9u67OOGSi8+FfNVReVZPlk5vmf7pzDokl/Bim+uB/uzYoM2XEqKtEYhXmxnSnyC/icnmetzy7jZYxe/zOoPw7MgzGFucu5XyH/WqEV1mPkPFf6oYUm/OkGxdh+JUHDvglEtC0Wmh0lx/Vx0KevErSBmPWbFEFVyPUj2r5YFVybXpEYjMcf8jEtjKrvVcyHbcdUGq/Q6pqC9OI6b7jQH3xslWcvHyLWtMQwrsRJp/6pWhSlkgTJ6asYaQeRFonD+XYI7eFJZM2jSLFDsU79RJ2RKNGm9bX2WCoY7x/E3Pcs72oK9JOhnL1HGp9h8RGYtOcd1I7bcO4M5WFZ6tq0bjs8UHs508dbLAtEXU/qWfYRLNB5hL0QIyQFXhEiCXPorRE3m3J1EcChff6dGA7ro32UAWjVOnZyNpN58LpI45xPLas7eXGf3P6y4pM9HjoZ54jo=","authorEmailMD5":"692dcf2b70c918f31e5c8884c92c60b2","authorName":"OReubens","authorUri":"","message":"What about the case where you have a native DB library that only provides a single blocking query function\r\nThis function is wrapped into a non-async C# query method.\r\n\r\nInternally that native function submits the query to the DB Server, then awaits the result via Windows API call WaitForSingleObject() or WaitForMultiple Object()), so the CPU is essentially going to be idle for most of the duration of the native call.\r\n\r\nWould this be a good case for wrapping the native call into a c# async QueryAsync(queryParams) { return await Task.Run(e=>CallNativeQueryFunc(queryParams)); } ?\r\n\r\nIf not, would task.run on any methods that launch multiple such queries be a good (in ASP.NET) idea or still not recommended ?","date":"2018-09-05T12:35:34.148Z"}