{"_id":"8702cb01-6ec3-38bb-a6b0-d4c43d7a6b41","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I can't say for sure, but I *believe* that a lot of Linux I/O is actually fake-asynchronous. That is, the underlying APIs are synchronous, and applications have to burn a thread to treat them asynchronously, thus creating a higher possibility of thread pool exhaustion. The core cause of this situation is the Linux driver stack, where drivers must support both synchronous and asynchronous operations (in contrast, on Windows, any I/O data transfer *must* be asynchronous; all synchronous APIs exist in the Win32 layer well above the device drivers). And asynchronous drivers are some of the hardest things in the world to write, so Linux is trailing Windows in that area.\r\n\r\nMy experience is from over a decade ago, though, so that belief may be out of date.","postId":"2017_03_aspnetcore-synchronization-context-ad62260e-a3f5-3648-b8e3-575b9b12f379","replyTo":"d24b6398-d50d-3099-98d2-2da41b5e1bf7","date":"2017-04-04T12:48:08Z","timestamp":1491310088}