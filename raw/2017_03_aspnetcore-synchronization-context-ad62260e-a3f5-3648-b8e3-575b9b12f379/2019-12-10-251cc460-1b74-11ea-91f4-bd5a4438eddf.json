{"_id":"251cc460-1b74-11ea-91f4-bd5a4438eddf","postId":"2017_03_aspnetcore-synchronization-context-ad62260e-a3f5-3648-b8e3-575b9b12f379","postUri":"https://blog.stephencleary.com/2017/03/aspnetcore-synchronization-context.html","replyTo":"2994c680-e593-11e9-924f-e758b2f23fed","authorEmailEncrypted":"AT03rb+F/ki60o0bXkcpbLY4TPh9oZ3PU6lbByACiqh2htOZy/BQIfq+brP3Y7Tf8LMo5EubycBNGYzWaMlGkHu8rIaMPKeRs4DVqxwm/fBL3kTRZ1DduZ2lmjxTJLZANxoSWyq6FpCIt5Yjr0+cWXxo4OLlKojurav7p8RSBIURRSMpve7Wg9Azcl8pZV9DtvDbKdPRqCiKHmoSnydrvPCGYgHHwOZR8HsZbziD49vtea0RMIR9Eh1mD0/dyItYGOJTnBjM5RqkfxuLMiHOUG/8qWppK+2rFwY++Or9Qm8xOyhJTNKjt1GITy0j0DC4m26gW0cQC0k6NX7PIfwucXAovV14PjrxvCE2uvk+FfV1DCuTs6TqCGIJW68DrzUSEONrOSDo/CKHSyWHKiq3rAooPvor8n7Qu6xfYXgx91rFChPgCy6/2rO2DPoSVHnDTJCAhXzqWwkN89x+1pK97sAVR8LZ2s7KjFH+Vh/Zrgm/v7cnwqIy4iylxW59UbD6KkdZzIbXWTHsnWlwav1GHBmC88/xY0cAQ/olqb0ZTAtuhD8ptamcRm+zKI3YNnjviuEA7X7BCJ+ZTfKwBf5+o8LiDgrAS4WBODIAJbdjsYicnrHVwhxFrf7jI62UJM8QciExKmd8kp7E89AVMTBKxg1uHz8pwo915syXw0iVFrw=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"ASP.NET Classic was certainly the biggest offender; due to limitations in the framework, blocking on asynchronous code was sometimes necessary for MVC child actions and MVC action filters. ASP.NET Core both removed the context *and* made the entire pipeline asynchronous, so there's nowhere where developers have to block on asynchronous code anymore.\r\n\r\nIn the broader .NET Core world, the only other common place where a context is found is in UI applications. And in that particular case, you almost never want to block the UI thread *anyway*. Also, in a UI app, if you *really do* need to block the UI thread, you can shove the work onto a background thread using `Task.Run` (you wouldn't want to do this in a server situation like ASP.NET because it would limit your scalability).\r\n\r\nSo, there aren't any scenarios remaining where `ConfigureAwait(false)` is necessary to avoid deadlocks. But on the other hand, that was not what it was actually intended for in the first place *anyway*. `ConfigureAwait(false)` should be used in general-purpose library code that doesn't need to resume on its context.\r\n\r\nThere's currently a movement to do away with `ConfigureAwait(false)` completely. For a specific application or private library, that may make sense. I'm not convinced that's the best approach for a general-purpose library; that would be a judgement call, depending on the library and its intended usage.","date":"2019-12-10T17:40:24.718Z"}