{"_id":"79a3e100-aa0d-11e8-88c0-ef9d7cca50b9","postId":"2017_03_aspnetcore-synchronization-context-ad62260e-a3f5-3648-b8e3-575b9b12f379","postUri":"https://blog.stephencleary.com/2017/03/aspnetcore-synchronization-context.html","replyTo":"37c86c70-a980-11e8-a35f-f529256716de","authorEmailEncrypted":"HwhJOmwclMofYB/eippvZL9TYMWooCeUcOnz6cBcXRO9V3k1i6H7T5qp5xuHwlXy4LRJblaH7D/qzzk1ga46UjXKKTv4RgI1tTVkrEx0ke8FTO4+mHUNm2AFu0o7asQvO/gzG9Y70PXKirw263MftDyb2NRuYsOVewQ7Ojccjrm9CZrYd8fWGRvBWoKovXgjAfopRuqaOB9YTQ78+CClCU+YqLHDVLNjSZPMkdcFkud1WyhtiMnUN9HxTrvz0cmLMFcTbmeZoU80nPNAVGlMCeFIx1tV1VFl7Clawry4nmf8DoQYw6PY7nT3rx8iOk5l3McL/H0f4372GZd8suNYPvZl1G+VovGX9CnQ6neiXGZRJ6+BbfkFsd8SiKcVV5Eh+OQx09zCfyJwb1kTHACdYZzYzjoUBYjqgzFRtGu+q/oF+rvzjg/ERyF6tR+as/idlWZrMycDBLyeLJvlbJ4d49oYHuS3VPtAEvY8o0qw3cr8h6ooezSmTeox4necmR/p1AxzHwmHGQzTm9w0exk02ki+QBkSafllcfqCapM8L9+cY6v0KG0wz+pHtba+cKSkufLmhYhUmk4AGCmfmyv7eaTlWxy5b8mYE1Hb5qvvGdL56kosExMA7VsGq22q7GXuk6E3d1wcXmhA7plsbtXrkZUBlzfx2oy7CBTe5mt9VQM=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"It means that any code after an `await` will run on a thread pool thread. This is the default behavior unless a `SynchronizationContext` or `TaskScheduler` is present.\r\n\r\nThese are the most common contexts:\r\n- UI context - used by UI apps to ensure that code after an `await` will resume on the UI thread.\r\n- ASP.NET Classic request context - used by ASP.NET Classic to ensure that code after an `await` will resume with the same request-specific global properties (e.g., `HttpContext.Current`).\r\n- Single-threaded context - used by some test frameworks (e.g., xUnit) to ensure that code after an `await` will resume on the same thread. This is intended to emulate the UI context behavior, but without a full UI thread.\r\n- Thread pool context - the default if no other context is present (e.g., ASP.NET Core and Console apps). Code after an `await` is run on a thread pool thread.","date":"2018-08-27T15:25:49.146Z"}