{"_id":"cd232a52-3b49-4d19-a015-615d0478ac9f","postId":"2017_03_aspnetcore-synchronization-context-ad62260e-a3f5-3648-b8e3-575b9b12f379","postUri":"https://blog.stephencleary.com/2017/03/aspnetcore-synchronization-context.html","replyTo":"03eb2a3f-2404-41e5-9e8c-af9f172d4cbd","authorEmailEncrypted":"hz4\u002BXjcz9ZHKYb3tohWmjyv9EQ5thDyggo9\u002BEZaAzPnBVbl1UvcfWUmREAshkajOfsmGW7zWMPC/2f\u002B6D92oLUkcGVx1y91n8Z2lCCgDxr61Gkx4SnGYpzMCidesDiHXmxzrDeKbhJc55LxEOMlBdXlKX95gESmmYmRulFfABS1j6PGWdknoXcrO2DrGVV7pFcjXZpjjv5Jpm83vtslprLZ/JuCaKNm0e163\u002BhwDmtwH4TAtmp8kbf2AGMzxI/i9YA9/irQO8rgAxTE9tBAW7\u002B7WJb/dg7D\u002BSqOjvd/VGvzB0F47ws35IHDnSwciYfLfu4bEc8RAav2nTcLNBQgcaAs1Tqkw7NtkmjMln9wuKP3W2PZ0bI\u002BfzQtbDgEVXFZSZI3IARIflf0fqKG1J//256js6WFYGPhmQGYfNvc9uqY\u002BMNdVEzC0kBntYvwJ6SigijkGU878dlPbP/oDvhbv03kTzRYcs0qix6H/Qj/Nc6bEo6I8Nh8JVQ9np74I/ZJdiVb5zwsPsY0MiL1TbQ3p5MJAf6suSVMBijLhIKU2xQWftFAm7ZnPv2Len\u002BdtxkYfkSRoveQcg4bUsGV/NVyVwo7KPcPgvVMeSqQHloS0eMGNYq7C01tImeuZNiC5JZVimEjFXbLyk3KwH43989w6cEOZ7TLW9OATE67jK5BWq4A=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I _expect_ that AWS lambdas do not have a context That said, I\u0027ve never used a .NET AWS lambda. If you want to be absolutely sure, you can log \u0060SynchronizationContext.Current == null\u0060 and \u0060TaskScheduler.Current == TaskScheduler.Default\u0060. If they\u0027re both \u0060true\u0060, then there\u0027s no context.\n\nIf it doesn\u0027t have a context, then your shared nuget packages are always used in a non-context situation, and you can remove \u0060ConfigureAwait(false)\u0060 from the shared package code. (This is assuming they\u0027d never be used in a UI application).\n\nI would always recommend the AWS lambda code to _not_ use \u0060ConfigureAwait(false)\u0060. It\u0027s at what I consider the \u0022application level\u0022, so it should resume on context if AWS provides one (or provides one in the future).","date":"2024-05-29T17:07:03.3010991Z"}