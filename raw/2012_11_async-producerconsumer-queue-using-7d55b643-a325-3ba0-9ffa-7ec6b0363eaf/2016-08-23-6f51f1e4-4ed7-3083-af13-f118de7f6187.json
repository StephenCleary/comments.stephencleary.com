{"_id":"6f51f1e4-4ed7-3083-af13-f118de7f6187","authorName":"Buggy Squashy","authorEmailEncrypted":"IPpawreaLYcJlo0GgzqwqdqR0K7/XXk/Gq8WC2adO64jjFHKICKBQgnJCgWIfFTuihoL/gU2IMOsMOB1J6DeOAylLrDsuGorjNB2LEpPfqerMUM0eD+QORxXATmLvKsisGfKWea0mLj/PVQC0XC7mh53MfYwr36YUWsYBHYSrVjOu6YrN54MwN4GoYi3EQgkTte0EeFRT/p3E23uYBNG2KTvMXh29mCLkLklOc4bYh+M59swtocNrkxLOQ9Wq1uynS3YwvvidfqWeSkqsJbb/Ua2NHuizWTsdziE/kBih+ewRRUZIRqC+61dKxiLRfl39Oo9ynE3nbnznVfPMDeuvdYzpH8MqAW3LqKEXqweUIRg5J2eWv99J9pNuJ6QPvUEg8ndZ1QgXLx8Gxl8Mdzd5z70rqNObey2KIT2kkafW+ROvTeNItLD11oadgjgKX5nFKdeANAeZr8lT+n3oW3/xNl4CO//Or1G9I3OkxWkzoC2TyrN5XKrykaHKwkPYglu7hTDfGkfTqouKLRtVAFrHW875EHbV3mbS7uD402FC81ZMYGuM+C0Bn3fm9H4InKGspOlSuIW4rG3JrarRQEfRxFGQgvb7jnc0nZ+bemcd1dHpVrRHLnCorJGJ8T+toXctTecOW7GnwgFcbfXFsovjx4XvIPNsQtfPQY2OSgnOpM=","authorEmailMD5":"b13725d59b683df333736b9a404801df","authorUri":"","authorUserId":"disqus:buggysquashy","authorFallbackAvatar":"","message":"Hi Stephen, me again. Thanks for your patience. I have a couple of more questions. (11) First the producer/consumer queue implementation appears to work OK for me, but I noticed after doing one pass on the items, then selecting the same cases and attempting to run them again does nothing at all, any idea why that might happen? From my limited understanding it appears to be happening because the buffer block is transitioned to Complete state. Can I reset the buffer block somehow in my method which is analog to your test? Or is this is a use case for multiple producers? Even that doesn't quite meet my requirement it seems. Can I just use your first example for single producer/consumer with throttling, and just drop the call to queue.Complete() in the Producer and likewise the queue.Completion argument in the Task.WaitAll(...) call in the method analogous to your test? (12) I noticed that using the producer consumer queue enables the cases selected to be run asynchronously from the main thread in non-blocking fashion, but sequentially one after another w.r.t each other, i.e., the first case runs first, then the next after the first completes, and so on... this appears counter-intuitive, I thought all the cases could run non-blocking and concurrently since once an item is received, it should be ready for processing right away? Perhaps it has something to do with the fact that I'm using one boolean variable (initialized outside the while loop to true) to await all the tasks resulting from processing each item. But declaring and initializing the Boolean variable inside the while scope still results in the same observation!","postId":"2012_11_async-producerconsumer-queue-using-7d55b643-a325-3ba0-9ffa-7ec6b0363eaf","replyTo":"24cf38aa-a9c6-383b-96f7-94de4197da9b","date":"2016-08-23T14:33:14Z","timestamp":1471962794}