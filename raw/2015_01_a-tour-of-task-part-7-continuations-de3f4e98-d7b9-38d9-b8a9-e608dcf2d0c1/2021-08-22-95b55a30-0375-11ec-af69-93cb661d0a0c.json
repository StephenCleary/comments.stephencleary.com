{"_id":"95b55a30-0375-11ec-af69-93cb661d0a0c","postId":"2015_01_a-tour-of-task-part-7-continuations-de3f4e98-d7b9-38d9-b8a9-e608dcf2d0c1","postUri":"https://blog.stephencleary.com/2015/01/a-tour-of-task-part-7-continuations.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Arty","authorUri":"","message":"You mentioned not to use TaskFactory.ContinueWhenAll and use Task.WhenAll instead. Generally I agree.\r\n\r\nHowever lets imagine the case when have multiple tasks lets say Task1, Task2, Task3 you want to await on all of them(probably go with using Task.WhenAll) and some of them may fail, others succeed and you want to have a control over it and add some post completion logic. Imagine that firstly Task1 is faulted, but Task2 and Task3 complete at some point in time in that case Task.WhenAll will throw the first exception from faulted Task1, but you wont be able to granually control Task2 and Task3(unless you will add some ugly await logic later on). However,  TaskFactory.ContinueWhenAll wont throw the exception of the Task1 instead when it completes, one can examine all the tasks process them accordingly.\r\n\r\nPlease let me know your thoughts,\r\n\r\nThanks for great articles.","date":"2021-08-22T18:20:10.052Z"}