{"_id":"a746a262-8748-3e92-92a3-bea5c9a9b05c","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I do not have a message delimiter example.  \r\n\r\nI'd start off by partial-reading a large amount off the socket (the maximum message size, if there's a maximum), splitting by the delimiter, and saving any leftovers for next time. If you don't have a maximum message size, then you'll also need to handle growing your buffer if necessary.  \r\n\r\nIn .NET, I find the string methods (Split, Substring) more useful than the binary methods (Array.Copy, etc), so if your protocol is something simple like ASCII (many delimiter-based protocols are), I'd start with a conversion to string and then do the message framing. But don't do this if your protocol is any kind of Unicode (e.g., UTF-8 or UTF-16) or binary.  \r\n\r\nIf you do have tight timing constraints (e.g., you're reading a continuous stream of messages), then you may find my ArraySegments library useful (it's on NuGet). This makes it easier to minimize the amount of copying done (and memory garbage created).","postId":"2009_04_message-framing-35559d4d-46b6-383d-ad38-3ed5391f3894","replyTo":"8b52750a-a1d6-3e32-8fe0-582584aaf804","date":"2013-05-13T22:12:30Z","timestamp":1368483150}