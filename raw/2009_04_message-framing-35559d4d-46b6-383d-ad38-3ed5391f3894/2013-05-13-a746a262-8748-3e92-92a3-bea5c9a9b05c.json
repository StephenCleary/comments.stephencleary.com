{"_id":"a746a262-8748-3e92-92a3-bea5c9a9b05c","authorName":"Stephen Cleary","authorEmailEncrypted":"lszWTL0g7EBZYhQXTCLqy5DeA3KVgep/fXgjhJQIjKDHTLvbOCLs7LmTB3aw1PhWJNKibSWUD9jVkQvFretPBfpKp2jneLfpLHohkgMVb2+NG+oSkkVB6BdAnX80y1p4teL6ZzpWuO7T7zP7zvp+wzbWpZdVy/MHTD/KJgLSxp0vJzW8u+ttNj8MSqsSo3Qpn8zPC4nrEDZziW4qEuB+LXKjLPlCRsIWFKwiHfQSlg9SMUhleK/uNQy9o0huhLr7TmgUmNcQxkF4O0sbAbsT9qz3gAaMmsDY22rd2vx7KFaLRLta4CfzKorprhEV1IIyOA/2APSqbXRPNcjlRSztduaIOauPkz61pzdtePT3f5TosfDSnsITnoN7W2B6MEBSDJGXmnGn2uz3bKsSLAweE2JXPQfq3ttK2wOFkZMMZsMC/UpIMPq3gT37gRdhdiU/bdsc/K7NCEM1voc85YWhWDy0rgqFyGDj1t5ad5DdaTBWH3shMej4KHaZbCIKGu4TIDcgWKtDwfXWUb2eB2gGidaFdho4n9uuEDxQKKFU/7oqGKRvk7abykD9HmvNRboKihklLufwHU6vWTchtKnUQx0gRjj+CRMMocwbB8EJzRuflmMPLuHdyoLCqhw7F8yBJS4M2z1oGSITzWb7s2VpYbsfrdsM7f286fRK3pnRpE4=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"I do not have a message delimiter example.  \r\n\r\nI'd start off by partial-reading a large amount off the socket (the maximum message size, if there's a maximum), splitting by the delimiter, and saving any leftovers for next time. If you don't have a maximum message size, then you'll also need to handle growing your buffer if necessary.  \r\n\r\nIn .NET, I find the string methods (Split, Substring) more useful than the binary methods (Array.Copy, etc), so if your protocol is something simple like ASCII (many delimiter-based protocols are), I'd start with a conversion to string and then do the message framing. But don't do this if your protocol is any kind of Unicode (e.g., UTF-8 or UTF-16) or binary.  \r\n\r\nIf you do have tight timing constraints (e.g., you're reading a continuous stream of messages), then you may find my ArraySegments library useful (it's on NuGet). This makes it easier to minimize the amount of copying done (and memory garbage created).","postId":"2009_04_message-framing-35559d4d-46b6-383d-ad38-3ed5391f3894","replyTo":"","date":"2013-05-13T22:12:30Z","timestamp":1368483150,"authorUserId":""}