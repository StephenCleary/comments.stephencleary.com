{"_id":"a746a262-8748-3e92-92a3-bea5c9a9b05c","authorName":"Stephen Cleary","authorEmailEncrypted":"kpuHitoxAMe6PI2/LbnUSZFq9SgcCbCfTparW9VSIPwB8EnpCA7dY6Vr5AGBVeJ8D+uVJPVd1Evccem8kYqXdA17RSFZpH64+ukd4cgIvziMkn8u+4ojd184uaYy867SkJpth8vsrxQIfrz0QzWlWCqCoSW1hMfmgXA1tu4LbATjuAjXs3Rc5gWjWYk0/+a7b0JBr1uXiS+gtEPgP/aeWEeuUghhGMQUv5pgxLvUo0esFnpRASQUAAK16TN+2KplNtFUaNnl/8A18GE1UaVcygOc8Fo6OFsIlgnFomxQMMBiWirSzPlfzx5xCJb61NE6QX1fW8QUTBrHJR//SiKbPtlfeQbiwil/1tV8cCXmYgwvQp0Ku9SSqvkuCAcLXL/rd0GhadsCSki0CSDE21UABp7TRGX3nXSWvBbk5OqZpjqI2y4VHXSaFAkzyTaqJ/R8EpjoDYOORsU8DdraVZVypDpftQ0Podw68Z1k3N4k9NymVOQvJK0InaeG53+rGFvpYRFJvG+VzE31kjeS2qBkgM3fj9EucBVcz1s3tREU5rA6u8g+cdg11MsTBMWtKkzZArWDtJqWK3mnoX8BQze+NIaoASxSnCSvNapDbhC6v+cmix/pUutxwmRe+liqF79olDX9vma4L8vYb1Z4sETkMIB8Mgh1ztLLIKTVFVwFEto=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"I do not have a message delimiter example.  \r\n\r\nI'd start off by partial-reading a large amount off the socket (the maximum message size, if there's a maximum), splitting by the delimiter, and saving any leftovers for next time. If you don't have a maximum message size, then you'll also need to handle growing your buffer if necessary.  \r\n\r\nIn .NET, I find the string methods (Split, Substring) more useful than the binary methods (Array.Copy, etc), so if your protocol is something simple like ASCII (many delimiter-based protocols are), I'd start with a conversion to string and then do the message framing. But don't do this if your protocol is any kind of Unicode (e.g., UTF-8 or UTF-16) or binary.  \r\n\r\nIf you do have tight timing constraints (e.g., you're reading a continuous stream of messages), then you may find my ArraySegments library useful (it's on NuGet). This makes it easier to minimize the amount of copying done (and memory garbage created).","postId":"2009_04_message-framing-35559d4d-46b6-383d-ad38-3ed5391f3894","replyTo":"","date":"2013-05-13T22:12:30Z","timestamp":1368483150,"authorUserId":""}