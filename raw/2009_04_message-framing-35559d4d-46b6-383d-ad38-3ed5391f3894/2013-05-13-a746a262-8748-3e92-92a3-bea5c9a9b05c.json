{"_id":"a746a262-8748-3e92-92a3-bea5c9a9b05c","authorName":"Stephen Cleary","authorEmailEncrypted":"a7dIY/+yaFoJbU9VQfXbNtZnBu51wwb5LKQJ6475gHRc7nBDn5FEeBzxS7vr/jp+s5XnfMLtOoPttscZSl+Srpg5H7bQgj/ZUSXz4oinIMU38n/Rk3Wcknura7oKWsNJM/0XUMg6F7FO/qvru9fC5ZqgZ3DXvl1nlGaBCS5gQyUUR6f0LSc3aspPdMh4v64VYtOnU9M0Rj6GGkJzpjkFFRacSaJdX/NBduqY4OGph13PJPBtm4CSJYYHb13BW8OMv/ETnSfmmYrh2GzX0VP4hRE94M0EixtzQhXYmmXIlpL6ti0W2UDD1+fvSGqx4C58hI8H3E6RlPZ/yWcheKAkhIjMVloo0OizrwWkbc5UgMjqCtjmEKP3pMBoCsk6EQUgxeFDUpHNw0fi0iOUM0oiaBWNL00Z9bHJU7Qkgu9olGSEAY3w2GvlLrGkSesbD0pZjyS4qiv+lLu2p4de1n5zdm5AK6wFmvKCwXctod1q1+yrl2O7aBaMzntGRkRTbxjli0pl9BVPR9tb6MFfpc+Z6ak6r9+JSdYo2/TPKoOF+OYLtnUMR69JV4f8AVTxYtzLYJiMEG1rIGK7l7HRx7no1scxSxtksn3tv8PAImbtpfAhRktl3be/5Yq8z+g98U/r5/i+1a9aQH283Wd4f3dbHIIIvzbQLaz9qIcegFFN3v0=","authorEmailMD5":"36e44ea0274d8207eb632c566e60ecc7","message":"I do not have a message delimiter example.  \r\n\r\nI'd start off by partial-reading a large amount off the socket (the maximum message size, if there's a maximum), splitting by the delimiter, and saving any leftovers for next time. If you don't have a maximum message size, then you'll also need to handle growing your buffer if necessary.  \r\n\r\nIn .NET, I find the string methods (Split, Substring) more useful than the binary methods (Array.Copy, etc), so if your protocol is something simple like ASCII (many delimiter-based protocols are), I'd start with a conversion to string and then do the message framing. But don't do this if your protocol is any kind of Unicode (e.g., UTF-8 or UTF-16) or binary.  \r\n\r\nIf you do have tight timing constraints (e.g., you're reading a continuous stream of messages), then you may find my ArraySegments library useful (it's on NuGet). This makes it easier to minimize the amount of copying done (and memory garbage created).","postId":"2009_04_message-framing-35559d4d-46b6-383d-ad38-3ed5391f3894","replyTo":"","date":"2013-05-13T22:12:30Z","timestamp":1368483150,"authorUserId":""}