{"_id":"6caa9a50-d8f1-11eb-b968-d76a3395ed13","postId":"2014_12_a-tour-of-task-part-6-results-b6e44095-ed73-3545-8772-598d69dec4ab","postUri":"https://blog.stephencleary.com/2014/12/a-tour-of-task-part-6-results.html","replyTo":"7ab4fb80-9040-11eb-bdc3-61a057cc069a","authorEmailEncrypted":"gOYzO7RU7cMTtk3GDgLRKbkAkx2hVSd89V59PmxVH+QESCkcWB8OzgKd3zg0zo1k/u8lRxnhvgEnEeCp3nAgXAMfqwfQDcTiBjMqiCcAwbg+dVC9vDueL7ZOnrH7I4S0NiE9XKfAtgNhNVyedGt8jqK5eJUnao1TSdOP2ixOYp1hqOZb4uEJu+7YvqvKMPNc4Q6IMARfNAq4by20RI9Ux3oTb7lbY+TFGVZSgkFH/0NH1Ol0XfdXi5DQzUaRquziIAHl9TOpPFpQHGYXyZNlF9LU49moO5VIJfDbC/9+SeEdDDJDYpzd/lOeNFV9mc9tjeXVKBs7iTiqlGYzQQDYfZVnpBsdj0u9k0UtmMz6LVC9sfLN0x0wVKd6AGc0Yy8Azz/bSvuAHp+6OQa4rlxotMy6tsFT8z24cacUDPcSjPrNTi0p6lDVoHF4RTTdXQhoeTv3gyfmSEjo0lwk3Mj5zDgqxYoYKM6Lb86E8ldnRavWeRhGzLOxyc6SeRa5XTuUfbs4tz0GmSqKbAzUVT89O1xQJ8MTAQn1dsth/0xkIDlTdkY155kvWFUwEW7w9NjI7Q7TvtSepFyU7u3POYWFu39jEFjV0eUr9Qaemzuq/i9mgRNaKJXfdWYjKHms0i1+M5RsoeQUJv3cbqCBXQsLujv1G5hP30+JTxfT5qfY61g=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"As I explain in the [deadlock post](https://blog.stephencleary.com/2012/07/dont-block-on-async-code.html), the two parts necessary for that kind of deadlock are 1) a single-threaded context, and 2) blocking on asynchronous code that attempts to resume in that context.\r\n\r\nIn the code example you've posted, `Task.Run` will run its delegate on a thread pool thread *without* the context present, so there's no context to capture, and no possibility of deadlock.\r\n\r\nThe `ConfigureAwait(false)` doesn't do anything since there's no `await` to configure (and since there's no context anyway, even if there was an `await`), so that can be removed:\r\n\r\n```\r\nTask.Run(() => AsyncRead().GetAwaiter().GetResult());\r\n```\r\n\r\nThe code is also odd in that it is explicitly blocking a thread pool thread for apparently no reason. The code can be made more efficient just by removing the blocking:\r\n\r\n```\r\nTask.Run(() => AsyncRead());\r\n```\r\n\r\nThe code is also doing \"fire and forget\", which is highly dangerous. Specifically, `AsyncRead` may fail to complete, and there's no way for your code to know this. There won't be any caught exceptions, logs, or any other indication that the work just disappeared. If the code must return early from an ASP.NET request, then I recommend using [asynchronous messaging](https://blog.stephencleary.com/2021/01/asynchronous-messaging-1-basic-distributed-architecture.html).","date":"2021-06-29T15:48:18.901Z"}