{"_id":"baca2c42-709e-4c3c-be11-62758ca281b3","postId":"2013_10_continuewith-is-dangerous-too-6366f031-8e25-3813-9497-1ee7cb9ab6a0","postUri":"https://blog.stephencleary.com/2013/10/continuewith-is-dangerous-too.html","replyTo":"","authorEmailEncrypted":"lNFSxmE0Hm95jpZDVfSt8jNFHxJlmCasZqcTlf7R22OZwfZ13GcxVeoffxOus2uVe2Xs7HDc6xZy4IxfgA6KzLPgo3AVKqI8LJlFIYbQNY3k8XsfSxKbwL02A0MnFB1EcOYQ9UDimu8eUFXsZ0H1A/W7nu33\u002BZBDBUvgivjuPwHDYaSPLckgBg7rKa5QvuyNJZaSun\u002BwzPmH2dG7bLwpCkYxNaTSwrx412OT88zboqjDC7lmZTedAynk2c\u002BLvnWHAqu/rKkrQtqaRjRgK6OBoXlm9OSGcDSFtoG7zgaauXkZgw6rJ0DlPhKW0DC5Y9zJ\u002BHfaDeWIZh3CYzZWZlgOXFm6LDmeAUJFxYC8k3YKxko8uuKOlJAIZnimWThww4TTT6TWuWn7FJe8kN\u002B32DQQDnW6Uunq/CNrlLFz7B5ym8SbTR2UKdjwhXdmBEV3oe3H51HkFbAySMS/Z61sxXDCmkyM/DtnjF2r56kc7kfDGC/BbtvcngUUqrDdR0cYuWo\u002BHALh8CkHIR9tk\u002BjpRhZ\u002B22YMI7HDuhphPjq/IuBs0Ek8VNj9\u002BNDYr01VVtwrrZO2c5cv\u002B9pXwL7boStKKFPPijKz6ilPVmjkTM/aR9/2HVya9dhVLdpF1YaC1\u002BtDV8qKCXoo0xJBlizlDfBMqdV\u002BVPYSit5P8PwNMTfGxND\u002BkdU=","authorEmailMD5":"13b7c89b1959c82b46e2b249b8358d63","authorName":"Yves","authorUri":"https://ygoe.de","message":"So you recommend using \u0060await task\u0060 instead of \u0060task.Continuewith()\u0060 for understandable reasons. But this changes the flow completely. The following code is now \u0022blocked\u0022 until the task is completed.\n\nIn my case, I need the method to continue (actually, return) and have something executed whenever (if ever) the task completes. How can I do this in a safe way? I don\u0027t want to use \u0060Task.Run\u0060 with an \u0060await\u0060 inside because it will be there forever if the task never completes. Keeping an additional cancellation token seems overkill.\n\nThe background is, I have a method that\u0027s called when my client connected to the server. Then it still needs to wait for the handshake to be completed before using the connection. If the handshake fails, the rest will never run.","date":"2024-01-02T22:29:39.5967467Z"}