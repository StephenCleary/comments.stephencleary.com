{"_id":"168f03fb-64ca-43a7-8249-460adcc5bafc","postId":"2013_10_continuewith-is-dangerous-too-6366f031-8e25-3813-9497-1ee7cb9ab6a0","postUri":"https://blog.stephencleary.com/2013/10/continuewith-is-dangerous-too.html","replyTo":"c10383f7-cc45-475a-8994-24aa40afa3bb","authorEmailEncrypted":"fg8d6fGOKaSAKj6o9xtnK2WuSrjGCH\u002BQzLzzu1r7SBJNlVD5BFGY7ETlHgwYb/NYkqAZDesvO8fJJGfHyjgdd6H9/wQKitq244OFIHWYxqaf5L0Nbw9LfE3l8WbORzxHlwPGhVtp\u002BL8SNoZRx6P7fAeDhDf1xOqyBtTvmNdoPzficIox\u002BuE9TEpVYs\u002BWRtfMCJOCL7r8/1WGnptJlf1XbSV1CY7Xtia9TkSaFSNiHtAjsY0FBY7R7ocVTMGocPOuCxR9uTZYpakSf3HVqYvob1ahtIoxDgKRIYmYEBbBoYdG/wowNMLeFxbFxG1EBZGVs2kogIKs2wR1mfScPMnVVBZOz3jSN/oS47Tk9WOgYQyf1WnZOeTa4I002OZ3ukz3\u002B3iOZXsuHzDor3FsBEW6PCY6DDGYDYVfhei1dkbGH8o2y/5llpc9FuwPGP/tsuNbgPxwl3aarDi/nIwPvlz2VELNPCgj2ABvIv2PJD82LDzE6O6yJ6vCvqkqiTd3BKz\u002Bths2W88oDXyJAu04EjbXhKEqy8OQGxnU83f2QcOmkM3epjyG/ftYsVOFmAdJfKzg6d/ObO8UpBlJVt1adwCazWu/UZk3nFVIW4O1qTp\u002BXL0vuQCdDBIn8SzrbQGMvcDflJphcUN0WQGiz5SlvLK5/B23GouA9wMVE6DrxeIhHx0=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"\u003E Task.Run will always use the default scheduler so following it up with a ContinueWith will also use the default scheduler.\n\nNo; this isn\u0027t correct. \u0060Task.Run\u0060 always runs on the thread pool (with the default scheduler). However, \u0060ContinueWith\u0060 is called immediately (likely before the \u0060Task.Run\u0060 delegate completes), and \u0060ContinueWith\u0060 uses the current scheduler of the currently executing code (i.e., the code calling \u0060Task.Run\u0060, not the code within \u0060Task.Run\u0060). So, code like this: \u0060Task.Run(...).ContinueWith(...)\u0060 may not use the default scheduler; it would use the current scheduler. It definitely doesn\u0027t inherit a scheduler in any way from \u0060Task.Run\u0060.\n\n\u003E If you were continuing on a task, wouldn\u0027t it be expected to use the same TaskScheduler you started the whole chain with? Imagine how more dangerous it could be if it defaulted\n\nIf you\u0027re writing old-school Task Parallel Library-style parallelism complete with \u0060TaskScheduler\u0060 usage, then \u0022the current \u0060TaskScheduler\u0060\u0022 is expected behavior. That\u0027s how this API was designed. If you\u0027re writing modern Task-based Asynchronous Pattern code, then \u0060TaskScheduler\u0060 as a whole have surprising behavior, and \u0022the current \u0060TaskScheduler\u0060\u0022 is part of that surprising behavior.","date":"2023-03-09T18:29:31.3636165Z"}