{"_id":"ebe89c90-9766-11ea-85f9-d963faf51bb2","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","postUri":"https://blog.stephencleary.com/2012/08/asynchronous-lazy-initialization.html","replyTo":"c5714070-9721-11ea-aaef-318665cfb908","authorEmailEncrypted":"B45bXJX49nXq9rFfb0xZQSQwNJQqTDe4eVr3cVYdeVojI9jf1gUPg7rNfGhu+HdQFwftjuY2UAhqw6Z3/LKxwcV+QPuFmhNzpZwk05/Ik71ZtZXQGKQ50UtOAFwQEa8wc8kAVy8VLZQY8CLgmdBhGRUtACw06lpd/5miqmsj/l8AkHL2dQ5GgYVe5yXxFgHMjE/FBqKuYgY+DMGKRvIoxSJ0MHCKGtFC1cclNszIfqTWVjWSOCTpAWdut+i6Hk9xYPIuzws9kTV6mCXuO2jw2YI9WNFhJc4L7LAvnS+RpwsDgiQOlAo84VxFSJ5lAYu7bVVhVeI5AA42StujdrOFasDPOphr3kP2p/7hRmAH0z6EqZqv+ov3MXfqTBEeiL/4gN3Uc6pTSd3WhbY8ne8sh+7oCOs9O8lcdPGlLcU2GjraF8r2iGRPMtsgEzFyTv4L5baSuDF7w+mdlM65oiEROlybRO04H1Pv8uhcH/jggnHyeJvOqZfVqNEfwiJOA4Pj+kdCayvTAnT0ImnNsa0P4t80yUp7a4+1LAINIcu7bkKRp+vQjOZCj2dnhsxDRlx62nWCH5eDfD5L8xdakyRrWUkrmxxj1fH4qXM1SySBvT0w6PMMb3pdI6IxA9n9160OCa0V51DkP7KCgTdABE6i+FlK9hQj/SQlER6seYwPDnU=","authorEmailMD5":"c315f0c5bd7b1dca88c9d6070d4f873d","authorName":"Dmytro Kontsevoy","authorUri":"","message":"Hi Stephen, thank you for such a quick answer. The blog post you mentioned is actually a reason why I am asking.<br/>\r\nI will try to extend the context... I am writing async memory cache class to cache expensive(on server-side) calls to server and of course those calls are async, so I want each caller(from multiple threads) to wait same task that was created by first caller and if value is already returned then get it from cache. The tricky part is that I need to pass arguments to factory function, assume that all other callers will pass same arguments or in any case all other will be ignored by cache nature if key is already exist (for now. it is possible that I will be asked to make a change to delete cached value and get new one if arguments are different).<br/><br/>\r\nMy simple implementation of AsyncLazy class looks like this:<br/>\r\n<pre>\r\n<code>\r\nclass AsyncLazy<T1, T2, TResult> : Lazy<Task<TResult>>\r\n{\r\n    public AsyncLazy(Func<T1, T2, TResult> valueFactory, T1 arg1, T2 arg2)\r\n       : base(() => Task.Factory.StartNew(() => valueFactory(arg1, arg2)))\r\n    { }\r\n\r\n    public AsyncLazy(Func<T1, T2, Task<TResult>> taskFactory, T1 arg1, T2 arg2)\r\n        : base(() => Task.Factory.StartNew(() => taskFactory(arg1, arg2)).Unwrap())\r\n    { }\r\n}\r\n</code>\r\n</pre>\r\nand this is a part of cache class:\r\n<pre>\r\n<code>\r\n...\r\npublic Task<TResult> AddOrGetExistingAsync<T1, T2, TResult>(string key, Func<T1, T2, TResult> valueFactory, T1 arg1, T2 arg2, CacheItemPolicy cacheItemPolicy = null)\r\n{\r\n    var lazyValue = new AsyncLazy<T1, T2, TResult>(valueFactory, arg1, arg2);\r\n    return AddOrGetExistingAsync(key, lazyValue, cacheItemPolicy ?? _defaultCacheItemPolicy);\r\n}\r\n\r\npublic Task<TResult> AddOrGetExistingAsync<T1, T2, TResult>(string key, Func<T1, T2, Task<TResult>> taskFactory, T1 arg1, T2 arg2, CacheItemPolicy cacheItemPolicy = null)\r\n{\r\n    var lazyValue = new AsyncLazy<T1, T2, TResult>(taskFactory, arg1, arg2);\r\n    return AddOrGetExistingAsync(key, lazyValue, cacheItemPolicy ?? _defaultCacheItemPolicy);\r\n}\r\n\r\nprivate async Task<TResult> AddOrGetExistingAsync<TResult>(string key, Lazy<Task<TResult>> lazyValue, CacheItemPolicy cacheItemPolicy)\r\n{\r\n    var cachedItem = _cache.AddOrGetExisting(key, lazyValue, cacheItemPolicy) as Lazy<Task<TResult>>;\r\n\r\n    try\r\n    {\r\n        return await (cachedItem ?? lazyValue).Value;\r\n    }\r\n    catch\r\n    {\r\n        _cache.Remove(key);\r\n        throw;\r\n    }\r\n}\r\n...\r\n</code>\r\n</pre>\r\nMaybe you have some thoughts that can help me. Maybe I do not need to make/use AsyncLazy at all?<br/>\r\nThanks in advance.","date":"2020-05-16T11:18:09.069Z"}