{"_id":"7646841b-dba3-3259-8efb-715bfbeef7a0","authorName":"Nathan Phillip Brink","authorEmailEncrypted":"ptrOeuF1g3ggJs1zY+XK0hepokss2OeMVFxW+5CXlUdaFwVQGwIV+0tLANfHywo7Q65X9Wo5QN32SRAIeC6kgiNDOwFG1Zlga8Z8eHuxK/AJJdw78XjKJUEfOATvxHE1ofgK5k8rsgEADnRNfMcMsiZz+gk0ooKUKUmU8ZeAhxHIuuPo8dqNEfpWHU1qt6h8eV7rvhQxvIHzt2HZ3SmA+gpACr9jFtLCoyVmbpHZXEfdysuwvAcZJNSOjHvrsqm69xoqFMmfR4zG/Ul47QAFQNyk35BHvV0zO9lE83NzY3g0YRZUZyE1+FGkEODsMR7ewuX2Bl23nB/KaTYOGRTaDG93S2f4lCZLMCXWuuR4F307qYE26QD5AyUKZE18YatRDa1jInV2rUq4fLWw10rNNgOgs40K1RLGGJ+ptnC3s3fVBFdc3ZJ38xc7ZBgl+lCw2mLGATCp7AAHDOscbTMEMTwLSFc0YKXnPsKKCIdriJHRQ0L+2wswl0yrFSkeUCZsS7Ugo3cZ2NCw4lqmnIJf7J5AfXTjbIITZqHFFCN8EM2NQeIhyXWQluwM+sKA5qtDCQRtFfvm7Cd4Nj+B9xryNenpn8GW8QgVC7kHIlkgkbYQ9Q/jYwdvsXYik86M/fv33SGK5ZMgaT/vVb0nHNS16f10JjY8WnbsCnRsCtL2Arc=","authorEmailMD5":"a8defe14b1c80bc2bd59a1fab3848cfb","message":"Could the necessary synchronization be achieved with something like `Interlocked.CompareExchange()` (only replacing if the _instance matches the value it had at invocation) instead? lock(){} is “alertable” and can cause issues when accessed from a GUI thread: [https://stackoverflow.com/q...](https://stackoverflow.com/q/8431221/429091 \"https://stackoverflow.com/q/8431221/429091\") (yes, I'm still using winforms, and I recently refactored something from using lock() to using Task+SynchronizationContext just to avoid the slowdown described by that SO question. Also, I’m still using an old enough version of AsyncEx that it doesn’t have that lock(){} in it yet—and I don’t need the feature it supports, so I guess I could just avoid updating too ;-)).","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"8480e4a3-c37b-3ce7-97d0-789d2e76359d","date":"2018-02-28T17:57:55Z","timestamp":1519840675,"authorUserId":"disqus:ohnobinki"}