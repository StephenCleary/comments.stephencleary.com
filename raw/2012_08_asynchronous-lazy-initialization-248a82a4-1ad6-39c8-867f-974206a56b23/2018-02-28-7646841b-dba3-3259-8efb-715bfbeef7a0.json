{"_id":"7646841b-dba3-3259-8efb-715bfbeef7a0","authorName":"Nathan Phillip Brink","authorEmailEncrypted":"Qs0yFduvt0xxDnsiDv5LjGVGG/xTo8edGrI12WEl/MqqH+0OTyHemAdxl4qQtTMDahqBgyhjLersF4TfX4OHkL8QMfN7viNLrNc9CeEWpHoa2jy1u3CWIzR6MBxrgJP5uTe+fXguzd/SWi9VrN2s8ntlolwSnlYNBVo9j1eHdUOZaqI5RMcMf3khDRvVIV5XNNcQ9aRR61nvoVmVqFys6ANqxFMoMTEOKUtM0nIQVF+XDGKE7j9/6IhS4Fm7QMPRJdvxSwZm1vagXn916kwm+JnaDOAy+7mhaD/4VkSHmJAWRQ/TW0HbcbajN3BX2XedkyVUjilI4NPJ60KEkHQajawyW5jgBbtd0XkMZt08oPsz7fD5hz1dB/x3sHVli+NBCv1UhbPQu4dwSvHift1OCQKrbMaiUXuU0x8H17PYXkC9rfPJtQchvW0z7FcL7Hl/A/CoshfOEaX8uKGqmmmX2tI3rccaHMbeq6GCkbh92Un3+hJ7Innu69oU4NEJU2o7mb32vcClhNVAGNOByDqF6Gb7xSoGM9byUwHvAHLUl86r5Vbc49CcTnQ7tAvKXcQ8fRVUhznX6glM2nRqdsVvC1qPsuOG5xoyDDT1mtb+69aX0tBbVb6OS7Ber24lEiwM+/s9xhXCG283MVQyHljHeEUeUuP4OeqdOR9hDTrAUMs=","authorEmailMD5":"a8defe14b1c80bc2bd59a1fab3848cfb","message":"Could the necessary synchronization be achieved with something like `Interlocked.CompareExchange()` (only replacing if the _instance matches the value it had at invocation) instead? lock(){} is “alertable” and can cause issues when accessed from a GUI thread: [https://stackoverflow.com/q/8431221/429091](https://stackoverflow.com/q/8431221/429091) (yes, I'm still using winforms, and I recently refactored something from using lock() to using Task+SynchronizationContext just to avoid the slowdown described by that SO question. Also, I’m still using an old enough version of AsyncEx that it doesn’t have that lock(){} in it yet—and I don’t need the feature it supports, so I guess I could just avoid updating too ;-)).","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"8480e4a3-c37b-3ce7-97d0-789d2e76359d","date":"2018-02-28T17:57:55Z","timestamp":1519840675,"authorUserId":"disqus:ohnobinki"}