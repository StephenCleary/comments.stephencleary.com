{"_id":"7646841b-dba3-3259-8efb-715bfbeef7a0","authorName":"Nathan Phillip Brink","authorEmailEncrypted":"eAtGp+UPwlCGxB9Fnq/ADKSHz2kU2FoYJkEO+G1TLG44FXKkPZxayk/RLCG3EbUBF5n3Y+Xf4gS9RnW8BqCRdpF0OY0kCM/gGmVEw2IndEhd4vrRGHZDM6z5U24iqjXdYS9WEfypwZcS4oYDH4sd2D2fq6y80HC0KImdgauk8/XIVs8bAe3eG+/mMoN8eEeqeDNght9OXsdvn63QmHiwuetPtGq6NDHBLZECt4VL1GNBnL5aeq6CoxSdqCPb7UAXm2dBfSPZOkhghmschZEV9rgFdSyYpzjljIpO4JgSJgge/hijGTGtS4v2idLVSn9DNUD10VAMWLsgexfohtBLJgnR09OIdFL3R9n1IZ510G4ZH5Okc2O2R3faqDOOK4Q6JNUcd9BaEORhpcz9ucQ+M+o0GFca65AmrYwfu9WbKPVyXMUh4kRJK9Avl88U2CHUORyYH9UN1ydkOYT0XG0g9f0s4yHUKxSXL+cBsBDsqOdAfHJxfJ/ET+141q/HDqPogvwFQk7xeGzrfE90OciIook/0El5wGQR++ML00scmQ0kuCMjAjP9lPGg07GKD9/vDZgWWElcl42ApJeUAXUo7ODVDbWTA6tExthrUOpQ3QnxJlUsU3VyjLpMKvdribYlFSSuw2MNoMvSsbLR/wDFqKQz4rgZB7l6xoEjbP4DuBE=","authorEmailMD5":"a8defe14b1c80bc2bd59a1fab3848cfb","message":"Could the necessary synchronization be achieved with something like `Interlocked.CompareExchange()` (only replacing if the _instance matches the value it had at invocation) instead? lock(){} is “alertable” and can cause issues when accessed from a GUI thread: [https://stackoverflow.com/q...](https://stackoverflow.com/q/8431221/429091 \"https://stackoverflow.com/q/8431221/429091\") (yes, I'm still using winforms, and I recently refactored something from using lock() to using Task+SynchronizationContext just to avoid the slowdown described by that SO question. Also, I’m still using an old enough version of AsyncEx that it doesn’t have that lock(){} in it yet—and I don’t need the feature it supports, so I guess I could just avoid updating too ;-)).","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"8480e4a3-c37b-3ce7-97d0-789d2e76359d","date":"2018-02-28T17:57:55Z","timestamp":1519840675,"authorUserId":"disqus:ohnobinki"}