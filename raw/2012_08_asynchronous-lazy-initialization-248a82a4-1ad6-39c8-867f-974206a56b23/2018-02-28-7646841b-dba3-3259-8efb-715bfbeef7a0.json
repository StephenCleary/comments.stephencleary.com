{"_id":"7646841b-dba3-3259-8efb-715bfbeef7a0","authorName":"Nathan Phillip Brink","authorEmailEncrypted":"N0KYSEsdoKSrLjjjJtv5/2ACjYk7ioL0qW3lM/oxOSQOG49TKMpa8d+J2v4kbu61MV9mLi2MzyQhoS1kr9kFVqo2wirDIdear9GHAhzihD6jvSqoULX88G69BOaYCA1BiXaOkIacSL9u84gsqvuJrrpiYFnrz7s3p1lDNKr/8oxvm+XpqB9iClg+r8Hn2tQIkjdVdpcYh/N/xuGSN/oggD/stSZpJDKqTlnlJjzF91HSxcsDMK5PVFPm4QbIgKk/Jm/NTtFg7Sw3KKDwT7nAAEQ9/gs9vh9aR3Dkvrhec3/RmMRlvo6diHKbxEeCp91QU6fWTcHbpqADPukV8+UNJ6zPlXeRLpRYtfTq5ChfHIUpqrG866IZSwPrN5p/U0LlTbUx4tfffcI+vc5szoh18QNEfU0kF7T6aZBXVsULtnVz+Py+mf7/VwncO5OnP7xE6RJPMq2IekCUWGOtqd3cT7YPrRT5o+CWd+UHqJEsEHwDyFOKuTPmDDJjg9GwNuffAgJFFlNbo2eOg5BkhbC0moKQUActTNv4HqWGdSDKLM65la1O2ydq4mQYUGSuSS3p5MjwBpfmLD8kMu7vKNM7ublCYnY9B8lRQ0Uhm9ZHU3lxPiY3OiB2JIZkvZgVu1wP5pKiFLL6PR6Obk568FoBdCKjsn2POeHHRKcIW8FswI8=","authorEmailMD5":"a8defe14b1c80bc2bd59a1fab3848cfb","authorUri":"http://ohnopublishing.net/~ohnobinki/","authorUserId":"disqus:ohnobinki","authorFallbackAvatar":"https://disqus.com/api/users/avatars/ohnobinki.jpg","message":"Could the necessary synchronization be achieved with something like `Interlocked.CompareExchange()` (only replacing if the _instance matches the value it had at invocation) instead? lock(){} is “alertable” and can cause issues when accessed from a GUI thread: [https://stackoverflow.com/q/8431221/429091](https://stackoverflow.com/q/8431221/429091) (yes, I'm still using winforms, and I recently refactored something from using lock() to using Task+SynchronizationContext just to avoid the slowdown described by that SO question. Also, I’m still using an old enough version of AsyncEx that it doesn’t have that lock(){} in it yet—and I don’t need the feature it supports, so I guess I could just avoid updating too ;-)).","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"8480e4a3-c37b-3ce7-97d0-789d2e76359d","date":"2018-02-28T17:57:55Z","timestamp":1519840675}