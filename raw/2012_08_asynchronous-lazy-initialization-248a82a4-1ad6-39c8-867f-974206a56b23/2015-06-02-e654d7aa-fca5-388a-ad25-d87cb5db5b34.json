{"_id":"e654d7aa-fca5-388a-ad25-d87cb5db5b34","authorName":"Stephen Cleary","authorEmailEncrypted":"lWCkMw44TfWl+vPKIq6jhDKXft7TKa6Q/a+X5t9PwcB3jK97h5OGgx/oConm/DSWY6Ok/yaHYmq0N0MIQeRACwUPUOoYlwLJXIAXgHJqISyR8KuJNqNJJA2vfCxZDrs24ymTV54MsxIWD2C+B8mqHGf9WQ7sKZpDlfbuk/euhVvU+nog0ay5rn4U7V6B40ggT2cPaRAHTVU27DGOMsg/OI4OKuDK5azWQye7cgiCjhwh1sG8qy4ih2PInPEgOR/qY7UdHC4caFI7yPW3jFQndTSSOJAegoc36/qvXHIbcJs3tDIczaqNY2CenjD6CBBICKNZEnRaCx15mhpdis9bLMPqDphdkCScAdyPn194y/j38Gh49dblLc6UXicJRsQBVuoqP/QqBNFxkn0Mo9UCHvRaz9XZRLy8yUhkywWsSsOy0YXiTpW4Bgr7E/68573cNsx2L5xjkfXs+eqPQq9YoHxFGAlya2z5z50eXIogiYdmTIDv4fVZ/AtPvJmBj6LMZNH0MeeOC+lijmD7hbrNvMS6s7BCQ7lD8MVZnm/+/ErVxiBLl972H0sCxAqMQtlhUX1DMnLiSi2KREnrha/4kbwVNk+VhedMqqUKaB1gDoLZLhQ+yMGtW18y2g6bw28utDS3V6KQfQ+iWKK4FcI+sV8GlZDav5ZiePSPvWNiQ0I=","authorEmailMD5":"28dde5772b48c92e08b8050411aa5ba8","message":"There's a few pitfalls.\r\n\r\nFirst, Result will wrap exceptions in an AggregateException. This is easily avoided by using GetAwaiter().GetResult() instead of Result.\r\n\r\nNext, the AsyncLazy<t> will complete the Lazy factory in a very short amount of time; it is only locked while creating the Task<t>. Then all awaiters that consume the AsyncLazy<t> share the same underlying Task<t>. A plain Lazy<t> will (synchronously) block all callers until FooCreate completes.\r\n\r\nFinally, you inherit all the downfalls of performing sync-over-async. For example, this can easily cause deadlocks if called from UI or ASP.NET request contexts.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"7a589abc-e0ca-3fd2-ae55-8f89434bfef4","date":"2015-06-02T18:33:02Z","timestamp":1433269982,"authorUserId":"disqus:stephen_cleary"}