{"_id":"e654d7aa-fca5-388a-ad25-d87cb5db5b34","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"There's a few pitfalls.\r\n\r\nFirst, Result will wrap exceptions in an AggregateException. This is easily avoided by using GetAwaiter().GetResult() instead of Result.\r\n\r\nNext, the AsyncLazy<t> will complete the Lazy factory in a very short amount of time; it is only locked while creating the Task<t>. Then all awaiters that consume the AsyncLazy<t> share the same underlying Task<t>. A plain Lazy<t> will (synchronously) block all callers until FooCreate completes.\r\n\r\nFinally, you inherit all the downfalls of performing sync-over-async. For example, this can easily cause deadlocks if called from UI or ASP.NET request contexts.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"7a589abc-e0ca-3fd2-ae55-8f89434bfef4","date":"2015-06-02T18:33:02Z","timestamp":1433269982}