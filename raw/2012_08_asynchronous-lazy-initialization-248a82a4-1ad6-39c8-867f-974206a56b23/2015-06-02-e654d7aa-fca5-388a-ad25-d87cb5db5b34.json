{"_id":"e654d7aa-fca5-388a-ad25-d87cb5db5b34","authorName":"Stephen Cleary","authorEmailEncrypted":"A5Ind+GGwn8W376BZ2e2D6UewmtcXf1+dUCj4j7pRBvLKph0qe1RkQ4Uowug1gXlMkD12CYlbtaUgnR6VPrOsnDYZFqSyxvqd0vqy8lH5R2+jU1sT8l7s1lIjlhju2MhxkJhp0L8T6Agwx1Xendeb4s5o4xRfLN/zJ2kJT8CdrFVaCdJseemO9W2cghnvi/o7EEqR5olT+ACemBJHB4T3uvwtlMA21N+k5T3VZhzbMOmBV7TeFON34rYFcxVGJwo7SdZV0aB3EuRuDZKuhcNF8ytBHM8d6hBSv3cUONm8rnpZt8kSNjZJrAWBbqfM+Q9oneLVdtmvQ5dTpaTfYsNF/6rKErR/iqmz4W6g8Jr9xYuQYbpYePptYRjpJmC5xYKyq42XaDHq0hcdB45Fc9Juge6vwLNFKQk4Oo5qw3HdFdeYBUOCxQTt8LNyg5+fFuic6Fgx3Hgh8KRVZJfb+ZWPP2KtqxxSkzqKuiwHlvV8B6j+gPKBAmbUFUfWPpQj511siWsmWsGTUiGJfMSQgFb6maRByygjfPy43NTTE0t0ISBHTetGYWG8/X3B1b+13gOYcRTantdRhuqV3VFLMla665E2N2wpVWfbfc5+3/D8uaJxrVxnvKJZW5Fx7viJs+vZ2WM2p51++mtZN2wciZlbth1veVBPnO8VpqbE/LJK6E=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"There's a few pitfalls.\r\n\r\nFirst, Result will wrap exceptions in an AggregateException. This is easily avoided by using GetAwaiter().GetResult() instead of Result.\r\n\r\nNext, the AsyncLazy<t> will complete the Lazy factory in a very short amount of time; it is only locked while creating the Task<t>. Then all awaiters that consume the AsyncLazy<t> share the same underlying Task<t>. A plain Lazy<t> will (synchronously) block all callers until FooCreate completes.\r\n\r\nFinally, you inherit all the downfalls of performing sync-over-async. For example, this can easily cause deadlocks if called from UI or ASP.NET request contexts.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"7a589abc-e0ca-3fd2-ae55-8f89434bfef4","date":"2015-06-02T18:33:02Z","timestamp":1433269982,"authorUserId":"disqus:stephen_cleary"}