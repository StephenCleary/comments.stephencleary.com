{"_id":"e654d7aa-fca5-388a-ad25-d87cb5db5b34","authorName":"Stephen Cleary","authorEmailEncrypted":"YVszKx4icqHUF77vb286B/pRx6o8bRo3/yzaBuueRxqrf2hMD+/1ORVM+LiaUq7WFynnPoKDsHZfSmfIj3D9ZwVjhMT2zL2nK17eCkzsrFXr9blO0FHqWCj01kewrtpDPVBfB0EwXjprWKOke/HQr4pyekObS9B5TQ0ADY3LnWSa3zZD/DOGIjY/PLdeRo4L0uHh42dHpS7bOZq7qcBSjsZDeXThp4RW2zmWAMsazY0Q/KRK2cjWmXCKmX5b6bwKLv76E/jPuXGM7EIukYIilPHYXCTvHbDvF6c/3BYy1TdxE/leiUDtGGICopxgw6u8fsIcrs98krvyDbfBcSDKYwW4itejQbGY/N4cgdXvlLl/qWfa7ab/Ela7u8YQKJ52qNe/qtUi2yYv2N9NHa8eWra21tS5ch6iOVtp0vBPyKZkOC8aIKutZN7rD4c2dV7rhriV5907i3ujI/l0mBQc699KK9ZjeVC3U7EBSQ6bPACTov8FHhOG4nb7p/a7vWoZbh7pyHSqYldmu9l2/QfG9bQixTdxhXslvaKqvnuTun4OE24ZwoUtVk48AqhtKYIkzw9Lxh4xEQVWl9AbcblliFP5QOkBAcBSWhv6Rd0AEoS0VTCY1DIKzclN742vbVrDMk8LUXjr/6EZQ8JkocOXlpqWcW4gnYF0mfjXRKlqruI=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"There's a few pitfalls.\r\n\r\nFirst, Result will wrap exceptions in an AggregateException. This is easily avoided by using GetAwaiter().GetResult() instead of Result.\r\n\r\nNext, the AsyncLazy<t> will complete the Lazy factory in a very short amount of time; it is only locked while creating the Task<t>. Then all awaiters that consume the AsyncLazy<t> share the same underlying Task<t>. A plain Lazy<t> will (synchronously) block all callers until FooCreate completes.\r\n\r\nFinally, you inherit all the downfalls of performing sync-over-async. For example, this can easily cause deadlocks if called from UI or ASP.NET request contexts.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"7a589abc-e0ca-3fd2-ae55-8f89434bfef4","date":"2015-06-02T18:33:02Z","timestamp":1433269982,"authorUserId":"disqus:stephen_cleary"}