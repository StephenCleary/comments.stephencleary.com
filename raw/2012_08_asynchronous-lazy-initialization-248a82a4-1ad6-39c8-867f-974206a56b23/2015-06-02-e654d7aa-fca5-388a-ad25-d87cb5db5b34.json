{"_id":"e654d7aa-fca5-388a-ad25-d87cb5db5b34","authorName":"Stephen Cleary","authorEmailEncrypted":"UH58KyVzwB17Tk+7Ngr99UbygMpocLwI5NoBv+QOWbdzW0Qi8irZusKNN6ApJ0AjnFew9Z7Oa3bOOWGpndFEWAOQJ52P8dcg+FNPZWwl16COf0EPwrgqtxMIrPfWu8TnKYBFxDVz3ZxothJ6Isbmaz4yWsS7LCpse0c6Sf5aSmP/epkRunHiW9B4lPZFbv7WbsANkiUbVhlLjO9NUrg4sB9UEGp4MAxKaVZgC5VMkuhrwcNXFaOx43d5/GqhbadarR51q+d5I8MnqjPBs1ZYFP1AkaTUMoeVJnWTjncn1Kce123JpQy135eUQkX2FHRStxeANnWzV31fgdKPm2ZT0ScXWiJAhycIDVyPPdoJsHcPzSB0O/NaXZn0sclS3QZNZ/O6AR2qEkV2XCldq1lE7YAuTzi3A+n92LNey3wjMVcGRJ+XMbsJ7dU3cl+MkMG/KUiPIjKh4aLX68GiDCEQkW8qXcBJScWUhQ506FLxDYFWLAcmsU1IUKZ6IGMZU1+NCZ1OEcJMqGjkx3HFV91n6030qZCpmY8ZnZriujb0ChZk11rcsHMNaLjhLo2tDHTMNTpeR8NGz0ep1L1vGfLRX7xKr2+z0DZgDRb5AgnoFjW4Bf1hdhlnLboLy/D9Uf8DtLMRivLe31z4f3aufWU5g9UGZgX7bc3+a0oZ/P9iwvI=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"There's a few pitfalls.\r\n\r\nFirst, Result will wrap exceptions in an AggregateException. This is easily avoided by using GetAwaiter().GetResult() instead of Result.\r\n\r\nNext, the AsyncLazy<t> will complete the Lazy factory in a very short amount of time; it is only locked while creating the Task<t>. Then all awaiters that consume the AsyncLazy<t> share the same underlying Task<t>. A plain Lazy<t> will (synchronously) block all callers until FooCreate completes.\r\n\r\nFinally, you inherit all the downfalls of performing sync-over-async. For example, this can easily cause deadlocks if called from UI or ASP.NET request contexts.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"7a589abc-e0ca-3fd2-ae55-8f89434bfef4","date":"2015-06-02T18:33:02Z","timestamp":1433269982,"authorUserId":"disqus:stephen_cleary"}