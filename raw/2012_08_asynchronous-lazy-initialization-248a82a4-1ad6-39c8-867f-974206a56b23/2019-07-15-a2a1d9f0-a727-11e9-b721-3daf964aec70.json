{"_id":"a2a1d9f0-a727-11e9-b721-3daf964aec70","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","postUri":"https://blog.stephencleary.com/2012/08/asynchronous-lazy-initialization.html","replyTo":"94bdde50-a70f-11e9-b721-3daf964aec70","authorEmailEncrypted":"HMlTgaC3+p69EKBx5fhlTMxNGj6TVjXV4bMluyBdVHLrrATOl6r3uEG3q8y2/KZU3UNdQDjukEOSza3UBjpA6X12FVWZm+b0/v1j8f/dGKollzMV0Wh5GPpInfbvADBpJyvCxGhCA5JG2tpNHzG/BZJb7k7YvvsEn+20lEf49bkWnE2Zjv4UdDXKZMXEaR8xKWrskcJm2DKBjhVjGDspxp3vOUGTTqnmclx7nbDe2CQObttglc66Wt2mnoqDbtTh1irU95sk751mP1tgidqHuzbb+Y4Ucgez+f332qalfQYjWuQSEhKHX1TLmFbFdirI6ykACHM23mct2l8wB3rMe7NDS/n2rEig/BCXf9nx1ZBvuHdIju/Tfz7AXJnkqUC+h5SqnM4zLZZ/F+zPGyR8FWStbpwjl663hsUGi2lOYRKmrMS0a7KP3MdYi/nnUS9zcZMxnWKM7+a548ipLYfgdnJbu7nOCcbvMkKjoJoqtDuzThPUyPwiMc3kNEiEw18coacIJhnLMU9x+aq0bU9EbdT7D9M8aUYq2LRZF+Jz5ICkiTlPqLDMdqGhWQw/XA8k0vSVwHPpB/TQZ/TqoUsd3Nf5By+xMXGRGEJ0zu6YxPUd/D5qL6u1oCfFt3HlKxXnEioYjZtQXFbjDzToTOqQTdSzzOEI1vIuRHl14QnHBl0=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I'm trying to imagine how you would want cancellation of an `AsyncLazy<T>` to work. Would each `await`er supply its own cancellation token? Or would there be a single external cancellation source?\r\n\r\nEither way, you can cancel the delegate passed to `AsyncLazy<T>` just like you could any other asynchronous code. If you do cancel an `AsyncLazy<T>`, you would probably want to use the [`RetryOnFailure` flag](https://github.com/StephenCleary/AsyncEx/blob/76b27a3ee531554c0c81e55ab8425ac7caefaccb/src/Nito.AsyncEx.Coordination/AsyncLazy.cs#L27).","date":"2019-07-15T17:40:29.247Z"}