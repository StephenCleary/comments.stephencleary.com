{"_id":"29d6d320-987d-11ea-81de-7f5f3317fff0","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","postUri":"https://blog.stephencleary.com/2012/08/asynchronous-lazy-initialization.html","replyTo":"ebe89c90-9766-11ea-85f9-d963faf51bb2","authorEmailEncrypted":"C2tV6ttUyYEocyhjAepyfDHrFYhwcIhuNj+CkJbsTNyOnmA7cFSIJaV1ok+BiEtw0tQBEWj0Jk+DehL3VpWjzI2t6kbml3cquwt6YAUhqyBX/tewCi8+WEOyBIW+D/yiFoE5hYyvNSOMoGucpXu86KvgcCiG4G1xjvGJiXa/McJR1IGTFWGmoBsGz93FkyqqbwNX9e27ig3W9LNhMJ+9HRfeMMMWByUtiTKmvVIifOG662tlh2XuZR9PYLQbyFt+zVkDGowQwmEvNYwKCRP0Nfij49jcfVq52GPWyzM6pslfHL8rskFmAihoRFcwZ1yvfwcB3E68cTNMCqiDOuTx6PG5wh8oEMX7rXtc9z6IEMXTtn0rqryz74+Fba+1dxdea8O7V9eqUsV6uILqX4BbIK1sBuWSa0zsaV9u+OGvMywZJevRsN9evUhR92i4r6nUvB2bf3FvQNX8FjSRYx/fYcrZW3wrTEjAXtU/DFDER79Mnx/ejl4qNEiBEZFeggxn6HRiVRq8ejGwcoaq1KW9sdGzej0SAso7XoCRmvAk/QJj01Z52SLOf53FPQQh15nmKaVgkeDfZviIEqR0p50AozcEwOQUvulLgREwMmQAWPRNMb4d9i2TemTHY/WmK+iuL9unGAn4AbNWgQzPm4TeX5IRZMp/9JGFNw/EIZujz7U=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Ah, yes. There isn't a really good implementation of an asynchronous cache that I'm aware of, at least right now.\r\n\r\nThat said, I don't see any benefit of using `AsyncLazy<T>` in a cache. By definition, if it isn't in the cache (and so your code creates a new instance), it would want to run it *immediately*, so it will never actually be *lazy*.\r\n\r\nOne approach for asynchronous caches is to cache the `Task<T>` itself. You do need to handle the scenario where the task fails; e.g., remove the cache entry if the fetch failed. But that's the general approach I would attempt.","date":"2020-05-17T20:29:53.164Z"}