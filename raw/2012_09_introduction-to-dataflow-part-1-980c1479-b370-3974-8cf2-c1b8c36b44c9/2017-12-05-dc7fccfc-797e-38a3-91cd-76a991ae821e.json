{"_id":"dc7fccfc-797e-38a3-91cd-76a991ae821e","authorName":"Stephen Cleary","authorEmailEncrypted":"LhXvkkq1MEPGzpDgmyt5qa3OSm6WWPT4i3k9uo+LJQM3OQN8ODOLL4SZTW26ruCVyIwJd7kJhn1Hk7rEblZcHDnAOYTxs4uHamcqLIiu+E2AFx324B/mX/pcv3UhHrekOjJ/KMbFwvQBJg0q+VElL8Iuc0QNxucr3w0YuxeLJH6WdU23xjjZBplKPrS9gR7HKxcQFBUvEYcoBgKi2Qix8pv4LEWmqGEl80q5OxBwho1vndyP/R+uVO4C1jAz2ikQIYHZtfKzAcl4q9lIobaTFZN73JmGANHnA+yCmumrK0eEawC9s3i2i4F49CL6X90if3hPoI/cBZeMqoSKKiYygwkNVlAuYWAnCgxcGk7Hf/Ylmpmc4mJFbTgI4DUI8cO7LoG9ya4y3rvH2qwzWLjD5acMGv5Lqypry+BdyeSRBrwH4b/1T4TsIKwBlBbT/XHfgQSiMcHiA9I57NARRwvxcWLFyszyavYFvSoCbe6jsGE0Im6U7A2sbADRFAvX0p+FfCGwtDtoO6n/8H7ChSJjA1ke/SuDApA0y6xYzU61kGHBN4gh0EXVFzhNygvWwrTyEcCfc+jRiWuRXymhMmFNrugFWrrZToJmcOhxuH0EO5l9SBup8ELICB7FRfYL+Ay4xREb/aJtJeM5ZId9Nskd7f2ogwr3zhgwuHTOvuQZqHU=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"You can wrap Parallel in Rx to get synchronous concurrency (parallelism). TPL Dataflow permits the same kind of parallelism, and also supports asynchronous concurrency. If your Do1/Do2 are synchronous, then doing it with Parallel or doing it with TPL Dataflow is pretty much the same thing.\r\n\r\nRegarding ObserveOn, this is a way for Rx data to \"jump\" thread contexts, usually used in the middle of a query so that the first part of it is executed on a thread pool thread (e.g., throttling), and then after the ObserveOn the rest of the query is executed on a UI thread (e.g., updating UI elements). TPL Dataflow also permits \"jumping\" contexts in that each block has its own scheduler. In the TPL Dataflow world, while the scheduler *can* be used on an ActionBlock for UI updates, it is more commonly used with a ConcurrentExclusiveSchedulerPair to coordinate one or more TransformBlocks/ActionBlocks with each other.","postId":"2012_09_introduction-to-dataflow-part-1-980c1479-b370-3974-8cf2-c1b8c36b44c9","replyTo":"b6414c54-ad6f-39e7-8c63-ee84e298ee1c","date":"2017-12-05T20:10:48Z","timestamp":1512504648,"authorUserId":"disqus:stephen_cleary"}