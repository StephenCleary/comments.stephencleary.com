{"_id":"b183e8f0-1657-11eb-b2ea-877e283118d8","postId":"2013_08_taskrun-vs-backgroundworker-round-3-396e3bc8-af1f-3ec8-9a2c-77219cef0993","postUri":"https://blog.stephencleary.com/2013/08/taskrun-vs-backgroundworker-round-3.html","replyTo":"5490cd10-1568-11eb-94f5-3b85f1c028fc","authorEmailEncrypted":"dkQ70yn8NNx5EZgnDWbDo6zC/iDbkTZzfBig1oHXyBlxc56unEUFZ+HbelQYigb377/TG+DPtp+ZMe6B4FJHnzq2yfKgM0aGNi4QqTOzPOcHnqxgjTuqMVBC0z/LNIqfE+miYyEiJEUcI5xnEolO87zxcq91joCget8CmCx0HXBUm90i/KmiLNVKjIx/SPpWZCjnvBNuOrIJYUfCQs6lLsdex8OsXYHvN2qI3HngK6fVCLzxtcy8/gh7YEZjXaMmyOASymZuiDkIrDIbwUhOlM6GIIl5nfOx4oz3lx2UEbDuGI1i2HDrVV9CTf32IEGzXjUws2pvBP+3kFa+7s4RScxdgfDht4m7rzfVsZT/DbXNwANdO1hKL0wnfKzxslsrZdt1ypMsTjJhlVutsZD77bUke37mDklp0bTKFmCdylUeL68OREvI3BReRgPejCjOR1ybnfbrgXyL6GhDidbc7UfkAnmYtNzb3N4sJ9tNjGD4KwfM8Vx7k/eR7nXuc8tlJIfrn8J1B3J0moleCPK3Vb9O6ov40r/n4VfFCp9x2GFy0zJWCpoyReFpq0ZC3s29bILe2UiCNCuxoHID1Sgpy+MMbqDeMPAQ7yMzBvkpwk1AcvTPgP04ku9iQYkPE1z2aBXnuD4hx7jbGcY2iSDBHbL2G/70r0x7QKuojGFQdgA=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I'm not sure how WPF would work with `BackgroundWorker.IsBusy`, because that property won't update any data bindings (`BackgroundWorker` doesn't implement `INotifyPropertyChanged`).\r\n\r\nFor `Task.Run`, you can manage your own `IsBusy` property, and you can implement `INotifyPropertyChanged` for it, too:\r\n\r\n```C#\r\npublic bool WorkerIsBusy { get { ... } set { ... } }\r\nprivate async void button2_Click(object sender, EventArgs e)\r\n{\r\n    WorkerIsBusy = true;\r\n    try\r\n    {\r\n        await Task.Run(() =>\r\n        {\r\n            Thread.Sleep(1000);\r\n        });\r\n    }\r\n    finally\r\n    {\r\n        WorkerIsBusy = false;\r\n    }\r\n}\r\n```","date":"2020-10-25T00:19:06.414Z"}