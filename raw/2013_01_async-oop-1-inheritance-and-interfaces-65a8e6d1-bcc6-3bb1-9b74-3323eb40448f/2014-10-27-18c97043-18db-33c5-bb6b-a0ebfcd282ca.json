{"_id":"18c97043-18db-33c5-bb6b-a0ebfcd282ca","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"That's a very valid argument.\r\n\r\nAs a counter-argument, I would state that there are other signs that can imply whether the return type is a Promise task or Delegate task. For one, Delegate tasks are usually not returned from methods; instead, the standard approach is to use tasks only as necessary when the work is being done; in fact, the Parallel class and Parallel LINQ remove almost all need for code using Delegate tasks (they are higher-level wrappers that use Delegate tasks internally). The small amount of use cases that actually need to use Delegate tasks directly are situations like doing CPU-bound work on a graph traversal, and in that case it should be pretty clear from the context (type and method name) that the returned task is a Delegate task. At the very least there should be some documentation regarding whether the method's task attaches to a parent task, how it's scheduled, etc.\r\n\r\nAlso, there should never be a reason to end a method with \"Async\" if it returns a Delegate task. The \"Async\" suffix is a pretty clear indication that the returned task is intended for use with await.\r\n\r\nSo, is it *possible* that different task types can get mixed up and cause problems? Certainly, but I've never actually seen it happen in practice. (That is, once developers learn the difference, and which type of task is appropriate for which scenario).","postId":"2013_01_async-oop-1-inheritance-and-interfaces-65a8e6d1-bcc6-3bb1-9b74-3323eb40448f","replyTo":"bf73d638-4709-33c2-81f1-3bc30adb89e1","date":"2014-10-27T01:14:36Z","timestamp":1414372476}