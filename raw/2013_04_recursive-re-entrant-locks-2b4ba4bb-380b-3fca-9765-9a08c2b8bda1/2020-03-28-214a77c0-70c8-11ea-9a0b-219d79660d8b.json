{"_id":"214a77c0-70c8-11ea-9a0b-219d79660d8b","postId":"2013_04_recursive-re-entrant-locks-2b4ba4bb-380b-3fca-9765-9a08c2b8bda1","postUri":"https://blog.stephencleary.com/2013/04/recursive-re-entrant-locks.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"xylent","authorUri":"","message":">> When method C needs to change, itâ€™s a simple matter to verify that all its callers are still correct. With recursive locking, whenever any method changes, you have to verify all methods it calls (and all the methods they call, etc), as well as all methods that call it (and all the methods that call them, etc).\r\n\r\nHow can you assume that the method ```C_UnderLock``` in this case is *always directly called from a method that acquires the lock*, though? It may very well be called from a method that does not itself acquire the lock but is called from another method that acquires the lock, i.e. ```A => B_UnderLock => C_UnderLock```. Now, when you need to change the implementation of ```C_UnderLock```, you not only need to review ```B_UnderLock```, but also ```A``` and anything that ```A``` or ```B_UnderLock``` calls before the call reaches ```C_UnderLock```, and anything they call, and so on. In addition, since now you are changing the implementation of ```C_UnderLock```, you will also need to review anything ```A``` or ```B_UnderLock``` does *after* calling ```C_UnderLock```, since the invariants may have changed. So the problem at hand is *hardly* any smaller.\r\n\r\nI get your point though and agree that the mentioned problems are in fact there (great article pointing to them clearly), but using non-reentrant locks is useful only in making the mentioned problems more visible (which is still a good gain), not in magically getting rid of them.","date":"2020-03-28T07:45:44.497Z"}