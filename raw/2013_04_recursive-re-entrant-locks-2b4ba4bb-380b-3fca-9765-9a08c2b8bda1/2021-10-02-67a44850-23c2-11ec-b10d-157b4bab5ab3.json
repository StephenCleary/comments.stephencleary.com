{"_id":"67a44850-23c2-11ec-b10d-157b4bab5ab3","postId":"2013_04_recursive-re-entrant-locks-2b4ba4bb-380b-3fca-9765-9a08c2b8bda1","postUri":"https://blog.stephencleary.com/2013/04/recursive-re-entrant-locks.html","replyTo":"7b983f10-234a-11ec-ab6d-053298adc8e9","authorEmailEncrypted":"dIWTGIv62QgeMzep1VKSrO4pJxXukceAT2nZZUwRa0YeI0Cz08TCp/NEJP6v5m/cANgV5oC6+/2AFmzcjCGAEYCTUUApCkBRPxKK1rG8OElDXNOPrQ68k8fYIJiuSPCX1xnTZgplWUPogOOR79dm8PSDeU2LvgJbJW80tHjGF3YvTKPNqXDt9LXwCQzO6A7jcE3swGPjfoG7DalJuh2swyeffRzq1yKDNwJqOudVVbj/Xo1ouNcV5RArPIRfpSxesJQ7XRtkQYnxoewx/TJkjZnoIk6y+Qcw/j7nYqKS2NDuPkefcQ0kHRmgOhBJy9dsZSNJtq1mc+BGSjVg/pU/YtIaiONioDmAvqTijyWU6yn6NFwUB6cLlmVkdre94sZQR6SzCRIYipl+H4MZRGvzQNEdvIgKMl+6BxUUlfxQyLCtvctLHV1+LrDnObfA3Qjhn1HDx/v/2AjFVlwBwQStNHrUNNiXC0Qwkjog9Lz5UqBWTqCcY/jG5ZPRYE8dczrh6D2BsfxIXg3lHpOMePMmwcsWPNGONamAlLENiaXQU3oubm9gsRFs9qkToKZxyIMCTQUiLxmzEUzST46eN9yP4Wo4Q5zymIJGLWCg2vETB7wszUCbUzcm4mO9tIyLJhESf9VIBkZxRVOourwr0TFMtMQzdq3GYFNZkv/Wgm4Al/A=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I do not have a blog post about asynchronous recursive locks, but I did write an implementation, untested and unsupported: https://github.com/StephenCleary/AsyncEx/blob/v4/Source/Unit%20Tests/AdvancedExamples/RecursiveAsyncLockExample.cs\r\n\r\nIt uses `AsyncLocal` to keep a set of locks that the current code scope \"owns\" (i.e., has locked) along with their lock counts. I can't recommend it's usage, but if you have a broken existing asynchronous recursive lock implementation, you may not have a choice.","date":"2021-10-02T20:50:41.315Z"}