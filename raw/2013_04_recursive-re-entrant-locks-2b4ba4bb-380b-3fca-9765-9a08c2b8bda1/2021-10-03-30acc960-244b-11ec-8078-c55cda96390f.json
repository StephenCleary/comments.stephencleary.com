{"_id":"30acc960-244b-11ec-8078-c55cda96390f","postId":"2013_04_recursive-re-entrant-locks-2b4ba4bb-380b-3fca-9765-9a08c2b8bda1","postUri":"https://blog.stephencleary.com/2013/04/recursive-re-entrant-locks.html","replyTo":"8d221580-2444-11ec-8078-c55cda96390f","authorEmailEncrypted":"Ucr1LwbCsXwyY0WesVLIehPFhSEcajySAL/IZPB3N0QGuevxM+fh9NsMwOP5hiCSoMYcBTc1YCUtgwt5r+zw5/STVGkcpG11tQd+d7hUaSGM3+/24mgOuAmXGJzdDIQIhoRvDtu036viEJcUTgW19na2vbr91hISP+VQ5zxTq/878xspfL4wIScqJy8Ujl7wGwYqVzJ3tgk83bD0HTsh9YE8NaVd5PpsHh7bPgrhdaHjSw10P/P8ZfowbyHSkg5oigJAdTmuZ8Ys3jvNd6i0jgmc/nLFq5E775cJL8J9KrsBefg66OoWSlJCLlBYc2Q/hd6yzDdX381AXnZAzXpZEdDOIFH+pG2pYefCHENtfLmWfyj1uZ8DHFrRN43D6tlHqLO6RLKxh2jfE8YNIkC9G0PkvVDOdE6N6A0hyafThwu5nEo6VUqQzIpYfwSZLbdrbCSx5ZCAzhBSg7NYTt9w4RDMth5jo5PCF4CnZ3MQuZeYZP7kS0M86LTcRnwm/YDri/FYxhJzPAwtSVTQqodYd1iyh/qRCG6HlVLyu+wY6Vrg/4jlrl/L7axUaEspOTWStkoHbXOecj836RjIeJozamEyk6z+W2Ciezv2oFtpYidOHAvON0mSSnk0C578lHXHJBhSEM9LFRXW6HE9Cm466JGudUvZOAlhrMXI0doYiEw=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I see what you're saying. The problem is that AsyncLocal is establishing a scope, which is inherited by child threads. If you create *two* threads and lock from one of them and then try to acquire from the other, then you'll see it block. Your examples are establishing a scope at the level of the test method itself, and the child threads inherit that scope, and thus already \"own\" the lock. The key takeaway is that the child threads are not independent from the parent thread.\r\n\r\nIf you want to prevent the child threads from inheriting the scope that owns the lock, you can suppress it by wrapping that code with `using (ExecutionContext.SuppressFlow())`. I haven't tried this, but it should work.","date":"2021-10-03T13:09:50.129Z"}