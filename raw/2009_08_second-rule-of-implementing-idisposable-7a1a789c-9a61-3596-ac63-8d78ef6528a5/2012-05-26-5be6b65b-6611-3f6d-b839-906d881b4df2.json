{"_id":"5be6b65b-6611-3f6d-b839-906d881b4df2","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"You're overlooking a possible scenario with your advice to avoid null checks in Dispose().  \r\n\r\nYes, *if* the IDisposable resource is created in the constructor of the class and is never released until the class is ready to be disposed, your approach is fine, because the IDisposable resource is guaranteed to exist when Dispose() is called.  \r\n\r\nHowever, there are cases when that is *not* true, even though the class is still responsible for owning the resource.  \r\n\r\nFor example, if I have a class that can be configured to do something at regular intervals, it may create and own an IDisposable System.Threading.Timer. However, if that functionality is not called into service, the Timer may never be created. Or, maybe it was used at some point in the life of my class but turned off later. In either case, the Timer object is not guaranteed to exist when Dispose() is called; therefore a null check is required in Dispose().  \r\n\r\nAnother scenario might be when an exception is thrown while attempting to instantiate an IDisposable resource. The resource was not created successfully, so it will be null when Dispose() is called on the owning class. There may be other IDisposable resources besides that one that need to be cleaned up, though.  \r\n\r\nIn short, it is possible (and in my experience, somewhat common) that even though a class may own an IDisposable resource if it exists, it is not guaranteed to exist when Dispose() is called. Therefore, a null check is required in Dispose() to avoid an exception in Dispose().","postId":"2009_08_second-rule-of-implementing-idisposable-7a1a789c-9a61-3596-ac63-8d78ef6528a5","replyTo":"","date":"2012-05-26T02:27:26Z","timestamp":1337999246}