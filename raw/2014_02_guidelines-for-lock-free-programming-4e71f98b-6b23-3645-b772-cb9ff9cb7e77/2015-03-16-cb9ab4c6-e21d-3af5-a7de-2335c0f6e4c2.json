{"_id":"cb9ab4c6-e21d-3af5-a7de-2335c0f6e4c2","authorName":"Bengie25","authorEmailEncrypted":"Ff9Dy3JMCzf2P/yIT2hz5dz0bDAw+9wQH2Qpi9m9JM8/8RUrD9kUt1XoypGbgHJhxAnOVAkXdIdt6LWjjd22/McxlZwFYVHbolTbSXoGNYhMoEado1pb6lCSsK92hFR6VtDLeDhEuLh8vO9B8rjudjMUkbWlylypiBwmRO4Qq9MrPXC+pC5/bwnWG5VkPsQKhVRA53i47Dzirqehg3scajnTY1x/GADUvMYBrPzuu1eF1x6rO/shuCQ7UbrlsCOIJ7hGTpWTQyZtRzwurcrWafMAbRkHfXLMPSWU24EyWhty8XYzmd7u0AuyXqfDxI/oN51aYvHYz9UFMyx9DcPisbjx6RMDQYzHe/+UQxXw7PgMce0AjN5tx3vugjxEmbABj+yM3/kTbbcS84Atg7W07ukRkKUTjRmiymq/DbsjUuBthOqYWIpiQGGkKKd3bKyLyCxrkpYw+DYmOwiTG+fhNACKaEVlQbVwLmRQVuv2ZSzV1Ks5i9hvxra6sijV4nZkIqhQYJrzOOGta4qAoXsG6XFjSxmIV846f6cwiH6Kmo6vnxmVKgv7k5y9mc7/Kiki67cxocBOIpcl8v6XYK7JKG/KJ8OQpxGplYWQ7JNDTnZvyv8bEGv2+nPV2geX+SdousljXTAWXppbvRoVRdIDJrBHXB3nsoAwmyocHhSqITM=","authorEmailMD5":"dadde6abc68d13f78c8170d42540967f","authorUri":"","authorUserId":"disqus:Bengie25","authorFallbackAvatar":"","message":"Now if only System.Collections.Concurrent has a high performance lock free queue that wasn't plagued by massive memory allocations. There doesn't seem to be a single-reader-single-writer lock-free queue. I had to write one myself. Went from gigabytes of allocations per second to nothing. I will admit that the worse case of a single-writer-single-reader lock free is the queue falsely thinks there is nothing to work on or it is full, but it is an example of lock-free that doesn't fall under \"don't\". Unless you're using non-x86, then don't use my implementation :-)\r\n\r\nGC pressure can negatively affect thread scaling since it causes a stop-world.\r\n\r\nMy single greatest example was some high performance C# program where a code-path that occurred about 10% of the time had a \".foreach\" coupled with a very simple lambda. This single line, which 95% of the time operated on a list count of 1, accounted for over 98% of my memory allocations. My program couldn't consume more than about 50% CPU on a 32 core server, constantly stalling on GC. I changed that one line into a FOR statement, and my CPU usage jumped up to 99.5%+ and a text label that updated once per second to indicate estimated time remaining now accounted for 60% of my memory allocations.\r\n\r\nDo not underestimate the cost of allocating objects.","postId":"2014_02_guidelines-for-lock-free-programming-4e71f98b-6b23-3645-b772-cb9ff9cb7e77","replyTo":"","date":"2015-03-16T17:51:18Z","timestamp":1426528278}