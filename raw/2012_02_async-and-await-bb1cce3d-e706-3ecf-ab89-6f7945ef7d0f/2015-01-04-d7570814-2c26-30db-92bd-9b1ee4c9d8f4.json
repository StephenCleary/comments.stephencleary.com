{"_id":"d7570814-2c26-30db-92bd-9b1ee4c9d8f4","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Task.Run should be a last resort; what you're actually doing is just moving the blocking call to a thread pool thread.\r\n\r\nIf this is a WCF service, you should be able to have Visual Studio auto-generate a proxy for you that has Task-returning methods.\r\n\r\nIf that isn't possible, then if the API you're using has any asynchronous capability (e.g., Begin/End methods, or an Async method with a Completed event, or even just custom callbacks), then you can wrap it into a Task-returning API (e.g., TaskFactory.FromAsync or TaskCompletionSource<t>).\r\n\r\nIf all you have is a synchronous API, then async/await isn't going to magically make it asynchronous for you. You can implement a workaround like Task.Run, but the ideal solution would be to augment the API so it supports asynchrony natively.\r\n\r\nRegarding return types, both await and Task.Run will work just fine with return values. E.g., if Execute() returns an int, then you can do \"int result = await Task.Run(() => objSlowOperation.Execute());\"\r\n\r\nIf any of this isn't clear, feel free to post a question on Stack Overflow. Source code examples in particular are formatted much nicer on that site than in my blog comments. :)","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"fac3e235-8c1d-3abc-af64-0e271c3d5d61","date":"2015-01-04T20:32:39Z","timestamp":1420403559}