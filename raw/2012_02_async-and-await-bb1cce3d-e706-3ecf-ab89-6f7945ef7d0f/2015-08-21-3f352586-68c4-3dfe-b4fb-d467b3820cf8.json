{"_id":"3f352586-68c4-3dfe-b4fb-d467b3820cf8","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Re Avoiding Context: Those aren't two examples; it's two methods in one example. The second method shows how to call the first method, and illustrates the fact that context capture is per-method. In other words, the button click handler resumes on the UI thread even though the method it calls leaves the context. This is in contrast to the example in Context, in which neither method ever leaves the context.\r\n\r\nRe Async Composition: I prefer to await the tasks, for a couple of reasons. 1) Result will wrap exceptions in an AggregateException, which means catch blocks become much more convoluted; you can avoid this by calling task.GetAwaiter().GetResult() instead of task.Result. 2) if the code is refactored later in a way that the task is no longer (indirectly) awaited earlier in the method, then the await will still properly behave asynchronously, while a Result (or GetAwaiter().GetResult()) call would now block.\r\n\r\nThere's no additional method rewriting necessary for multiple awaits. The method is only rewritten once, triggered by the async keyword.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"2527cc42-78c1-350b-ac24-6cb3a00c785e","date":"2015-08-21T14:20:50Z","timestamp":1440166850}