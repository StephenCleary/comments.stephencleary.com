{"_id":"f1318270-4681-11e9-8eaa-bf9870a70db5","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","postUri":"http://blog.stephencleary.com/2012/02/async-and-await.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Sanjeev","authorUri":"","message":"Hi Stephen,\r\n\r\nIn UWP/Rich Client Application: The way an async method resumes on the UI thread is through synchronizationcontext. \r\nFor ex:\r\n\r\nasync Task DoWorkAsync()\r\n{\r\n    await asyncOp(); // this method may be making a network call\r\n    continuation\r\n}\r\n\r\nSo it means when the Task(represented by asyncOp()) gets completed, then a thread in thread pool thread typically an iocompletion thread uses the synchronizationcontext's post method to send the continuation/callback to message queue so that the UI thread can pick it up using the message loop and hence the continuation runs back on the UI thread.\r\n\r\nPlease correct my understanding if I am wrong.\r\n\r\nAlso in case of await Task.Delay(1000); how do we resume back on UI thread? Since in network async call we have iocompletion port but in Task.Delay which uses underlying Timer class, which is the thread which makes a synchronization.post() call?","date":"2019-03-14T17:52:32.907Z"}