{"_id":"9a9bec5d-4987-3e23-8552-ee0ccdc0d0c5","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"In the general case, ConfigureAwait(false) will force continuations onto a thread pool thread. In the case of an I/O operation, when the operation completes, it briefly \"borrows\" threads as that completion signal works its way up the stack. When this completion signal reaches the IOCP, it borrows one of the IOCP threads to complete the operation's task (and schedule its continuations). Depending on which operation this is, the BCL may switch to a regular thread pool thread before the task is completed and the continuations are run.\r\n\r\nSo, if an I/O operation uses the IOCP (as most of them do), its completion will come in on either an IOCP thread or a regular thread pool thread. (The .NET thread pool manages both IOCP threads and regular threads). So ConfigureAwait(false) will just continue using the notifying thread in that case. Actually, if the notification comes in on an IOCP thread, ConfigureAwait(false) *might* switch from an IOCP thread to a regular thread pool thread, I don't know off the top of my head.\r\n\r\nWhile it's true that an application may only be concerned with a single UI thread, the thread pool is always there and is utilized by I/O and other parts of the BCL.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"6e0a3be3-54ea-3ccd-880b-b3f1b1ea431f","date":"2015-02-26T19:50:15Z","timestamp":1424980215}