{"_id":"48152830-b308-3a4a-9c40-337e4f809cf7","authorName":"Stefan Forster","authorEmailEncrypted":"","authorEmailMD5":"","message":"Hi Stephen,  \r\nThanks for your answer!  \r\nTo stress my point I made a small console application.  \r\nOne run generates about 5-15 race conditions on my laptop.  \r\nMy recommendation is to always use a SychronizationContext unless you really have to optimize the performance.  \r\n/ Stefan.  \r\n\r\n static void Main( string [] args ){  \r\n for( int i=0; i < 100000; i++ ){  \r\n TestThreadSafety();  \r\n }  \r\n Console.WriteLine( \"done.\" );  \r\n Console.Read();  \r\n }  \r\n\r\n static int m_counter;  \r\n\r\n static async void TestThreadSafety(){  \r\n await Task.Delay( 10 );  \r\n\r\n int n = m_counter + 1;  \r\n m_counter++;  \r\n if( n != m_counter ){  \r\n Console.WriteLine( \"Error: counter=\" + m_counter + \", n=\" + n );  \r\n }  \r\n }","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2012-04-27T01:40:01Z","timestamp":1335490801,"authorUserId":""}