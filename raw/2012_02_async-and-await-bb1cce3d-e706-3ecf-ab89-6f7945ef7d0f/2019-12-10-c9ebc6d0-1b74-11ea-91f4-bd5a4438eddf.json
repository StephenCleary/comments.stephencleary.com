{"_id":"c9ebc6d0-1b74-11ea-91f4-bd5a4438eddf","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","postUri":"https://blog.stephencleary.com/2012/02/async-and-await.html","replyTo":"10cff160-ef0c-11e9-9ee1-a1a740761680","authorEmailEncrypted":"wqpER3bcXfL8nnEzqNeqRcrkWNb5MZrxs+mPfgIlPYp6ho4zK8F+uz7PNQVMcuUupTy8Sf9+f/pHEjQN/6JR3Wwv1yDVLTDjThc4TEL9j8Z9LIAN5xJQrIVZUHQkG5cSgNySb3IXplgVv0Loj0o3nQPa9TuGCirQjYofX8Rox39U254/8HxQU9We9ca7OvXvLcbhe7XpcJQPTtyInd+0V/YzvbbG5uw1ivl0OeXybLKOUeidV8BAOqshY3sn9JZd+CxRAGBF5Ctj3Pu5hFfkW/DHFH8Z5IkMj4judxqvzL94GLFOvtgGPorQJ773vus8oo+qnk73Y+rnq5TybO9SXaRxupUDaC+nhViyVj7qfpJsEUHLgWz5f+4mBKqztxf7OFOXuUfuYEwmWsQNMc5K0ilskjFRWpScpKOd+Ei6nWb3pgHzVjdl/QOPyuCO4bF79K6nxZMLAwB7I86ZSGnvCLgQVm8bklZakOIE8ENU2WxKSbBQhaUgtG/d1rBWScWwdQ8qMk2TJyUNELmLh08GL4Q3CJdpdspwTRAqMOUEpX3LJNWwPpp8beDCix9hu0/GHoTvSCfLFQLWc9sXb54h0XU4b1jsA0J5aSJmDezO/7Z2pGlaLtBmUT84pGDrGN/y09V9o91Ms5TLZdj0vSy93lM7jRucWxHMG4Hyu9VqIcc=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"This is due to the ASP.NET request context. When a request arrives at ASP.NET, it creates a request context (including `HttpContext.Current` as well as a few other things) and then calls `GetValue1`.\r\n\r\nWhen your action does its `await`, it captures its current context (in this case, `SynchronizationContext.Current`, which is an instance of `AspNetSynchronizationContext`) and then returns to its caller. ASP.NET then allows this thread to return to the thread pool.\r\n\r\nLater, when `ReadToEndAsync` completes, a thread is taken from the thread pool and the action is resumed *within that context* - the `AspNetSynchronizationContext` sets `HttpContext.Current` (and a few other things) before it resumes executing `GetValue1`.\r\n\r\nSo it can change threads, but it's the same request context.","date":"2019-12-10T17:45:01.010Z"}