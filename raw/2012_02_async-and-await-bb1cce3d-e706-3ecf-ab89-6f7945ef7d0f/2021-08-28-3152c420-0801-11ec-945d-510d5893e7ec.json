{"_id":"3152c420-0801-11ec-945d-510d5893e7ec","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","postUri":"https://blog.stephencleary.com/2012/02/async-and-await.html","replyTo":"ea342420-0770-11ec-8455-9dd7f49c6deb","authorEmailEncrypted":"KpeMOw1DC9UEx1CrCB6zc7MoJiLVEwve2Wai1lyVG+J57iT/btPMsHX83tFqCngtbUp2RMF3qSXofRMQJXkRdfYkxowQAM/YreePlFFIrsDTojMnv8i+P/0xrySe2Q3iikboGeXX9Sgh6xSxuaP3pkyX6xBXGi8GpI6/SDsSDHQb6GO/DrZoJyBgGFtuLpPX550iiKd0nfW7b2WSBQXjeriijinqJ1jX/RULWQwdmzfe7K08t0Aqq7ghhQGzuZMWMqWltQ4mRxhw+RdIZ8d/Qwlh4ev0HH3TvFJPtlxLT1eKtTcdhx3hXRoAAXnpJZTt5HMjcywUv7ROrrQNon5Tss8iKG4fRrr9XGfxVry7iJvkDtCeUh0Eq3yyrnnlG1KHJlUzVKn5ahZRsEGn4O+VbeRCQeujI5WASJt98J93KlIy3GsbzJZ/CffIdITCte04Wh2C+NH8ugbZInIilzOpym0YMZnfs+/ee2ZB5Ym2nYlkklicpuyOMR57fuBEXJJAlm+yxEv2iof1EAZGSZNkcFD6U6Mf2nQ+4F6rribn7iDG94Yac3Hg2gsRytJ4ZSozLomHW7pldPBMR8/ggU24tcb26JdLmQ6ouY5CbZdkTy851IKgW70RM1zPXH9L2xPajoFwxFsAF2MYLg5Lj3EGT3ukrbAcYar6Rar6axfP53I=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"> Is this also thread?\r\n\r\nNo, [it's not that simple](https://docs.microsoft.com/en-us/archive/msdn-magazine/2011/february/msdn-magazine-parallel-computing-it-s-all-about-the-synchronizationcontext).\r\n\r\nASP.NET pre-Core has a request context, and this is a collection of a few things. It's never been documented *exactly* what the request context is, but it's at least:\r\n\r\n- `HttpContext.Current`\r\n- The page culture\r\n- The page identity (i.e., user identity)\r\n\r\nSo, consider this part of the code:\r\n\r\n```C#\r\nvar jsonTask = await GetJsonAsync(new Uri(\"https://jsonplaceholder.typicode.com/todos\"));\r\n```\r\n\r\nIt's run like this:\r\n\r\n```C#\r\nvar task = GetJsonAsync(new Uri(\"https://jsonplaceholder.typicode.com/todos\"));\r\nvar jsonTask = await task;\r\n```\r\n\r\nWhen the initial request is made, this is what happens in `Get`:\r\n\r\n1. ASP.NET takes a thread from the thread pool and creates a request context. The thread enters the request context (i.e., setting `HttpContext.Current` and the current page culture and identity).\r\n1. That thread starts running your action, calls `GetJsonAsync`, and gets back an incomplete task.\r\n1. At the `await`, the task is not completed, so the current context is captured and the action method returns an incomplete task. This causes ASP.NET to return the thread to the thread pool.\r\n\r\nWe'll come back to what happens after the `await` in a minute.\r\n\r\n```C#\r\nvar jsonString = await client.GetStringAsync(uri).ConfigureAwait(false);\r\n```\r\n\r\nIt's run like this:\r\n\r\n```C#\r\nvar task = client.GetStringAsync(uri);\r\nvar configuredTask = task.ConfigureAwait(false);\r\nvar jsonString = await configuredTask;\r\n```\r\n\r\nThis is what happens in `GetJsonAsync`:\r\n\r\n1. The current thread (which is still in the ASP.NET request context) calls `GetStringAsync` and gets back an incomplete task.\r\n1. This task is configured. What `ConfigureAwait` actually does is return a configured task wrapper around that task. In this case, the wrapper is saying it doesn't want to continue on the captured ASP.NET request context.\r\n1. At the `await`, the task is not completed, so this method returns an incomplete task to `Get` (which then does its own `await`, returning from the action, and causing ASP.NET to return the thread to the thread pool, as we saw above).\r\n\r\nSome time later, `GetStringAsync` will complete. It actually completes on a thread pool thread, because there's some copying into the string and whatnot that had to happen once the data arrived. So `HttpClient`'s code does a little bit of work on a thread pool thread to create the string instance to pass to your code. Then that same code completes the task.\r\n\r\nWhen the `GetStringAsync` task completes, this is what happens in your code:\r\n\r\n1. The code continues running `GetJsonAsync`. Note that the current thread is a thread pool thread that has not entered any ASP.NET context.\r\n1. The `await` checks for exceptions on the task; there aren't any so it doesn't throw, and instead it assigns the string instance to `jsonString`.\r\n1. The method continues executing. Since it is a thread pool thread without an ASP.NET context, `HttpContext.Current` will be `null`.\r\n1. Eventually, `GetJsonAsync` completes. When this happens, the current thread completes the task that was earlier returned from `GetJsonAsync`. At this point, the code is still running on that thread pool thread without an ASP.NET context.\r\n\r\nWhen the `GetJsonAsync` task completes, this is what happens in the original `Get` method:\r\n\r\n1. Since the `await` in `Get` was used without `ConfigureAwait(false)`, it will resume on the captured context. This is the original ASP.NET request context.\r\n1. At this point, the current thread enters the ASP.NET request context, getting `HttpContext.Current` set as well as the culture and identity.\r\n1. The code in `Get` continues running. The `return` statement completes the task that `Get` returned earlier to the ASP.NET runtime, which lets ASP.NET know that the request is complete.\r\n\r\nSo, the main takeaways are:\r\n\r\n1. `ConfigureAwait(false)` can only affect its own method.\r\n1. There is only one thread pool. There's not \"ASP.NET threads\" that are separate from \"raw threads\" or anything like that.\r\n1. Thread pool threads may enter a request context when necessary.\r\n\r\nSide note: ASP.NET Core no longer has a context, so on that platform this is a lot simpler. `ConfigureAwait(false)` has no effect on ASP.NET Core.","date":"2021-08-28T13:09:35.909Z"}