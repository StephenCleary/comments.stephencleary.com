{"_id":"01d91132-8da1-3b5f-8fcc-33e19277f2a8","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes, a single task can be await'ed by any number of async methods. \"Await\" will first check the task to see if it has completed; if it is already completed, then there is no continuation at all. If the task is not already completed, then it will *add* a continuation to the task. Each task can have any number of continuations.  \r\n\r\nOne common use case for this is (shared) resources that require asynchronous initialization. You can declare the resource as such:  \r\n\r\n class MyClass  \r\n {  \r\n private readonly Task resource;  \r\n public MyClass()  \r\n {  \r\n resource = LoadMyResourceAsync(); // Note: no \"await\"  \r\n }  \r\n }  \r\n\r\nand then multiple methods can await that resource:  \r\n\r\n public async Task MethodA()  \r\n {  \r\n var res = await resource;  \r\n ...  \r\n }  \r\n\r\n public async Task MethodB()  \r\n {  \r\n var res = await resource;  \r\n ...  \r\n }  \r\n\r\nKeep in mind that when the resource is done loading, it will continue all async methods that have already await'ed it, and any new async methods that await it will continue running synchronously (since it is already loaded, there's nothing to wait for).  \r\n\r\nIf you want to *lazy*-load an asynchronous resource (very similar to this but delaying the loading of the resource until it's actually needed), I have another blog post for that: [http://blog.stephencleary.com/2012/08/asynchronous-lazy-initialization.html](http://blog.stephencleary.com/2012/08/asynchronous-lazy-initialization.html)","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2013-05-07T01:31:34Z","timestamp":1367890294}