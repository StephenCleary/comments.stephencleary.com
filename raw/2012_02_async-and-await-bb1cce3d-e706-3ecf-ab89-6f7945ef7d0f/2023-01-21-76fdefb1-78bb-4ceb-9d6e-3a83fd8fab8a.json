{"_id":"76fdefb1-78bb-4ceb-9d6e-3a83fd8fab8a","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","postUri":"https://blog.stephencleary.com/2012/02/async-and-await.html","replyTo":"d62dda13-58c6-47ac-ad42-e85f22edde28","authorEmailEncrypted":"bK9KtCChNNWT06hMgEQ9u05CRsZbOnKeSDcn1mC39zxOPaK7zdcWPcdea15muHPfdJzKSlsc5xJ7ZsKB9bbTSVJc4UBx/uHmLK1RmVV29OtW\u002BazXZak4npMnyig9ZYCqiB8NS8BzJ5TF52tPzmtLtTkqglxpa1QdAGrWxRMzHJ65pRPGywa0gbYQsJ6M8Fu4KocAEYdoqo569SqLv35S4K2fpHsCMJFFhB29KOcWqqaNMtPbUZUqLoPwCtoSzWVBL/zPYAOgehHEkqTDJbG/h7clJJyhnFveIrQIEJx7EGKtLfmbA2z0MA7sTfvQd226LYd6KTxwVyq0LdrZd8W0C2QpX0gIiSenF4lHic3Zq1x1o1Lj5tS5L7lv0Fi1/b/OpGAd4XBMiva8jZJwHWHeGqAAyxq\u002BdZndt3Ftmd5kP9eX2v3Tpf9tjqTkisv4pF7RT53vsMCYeOC9WdCDQK3rUeHd/gsqQM\u002Bev00rT6Eynk9KXa7mIXNHDAyHrPdzjuNgHgofPfUiPb3TafnzItG/9ppLkZD4sRN4XGYGddHYfwkB35cPwNTT2czZ5ePgw\u002BTTk5NHlH6xJYpIHLREmGAk3JdRypd5IlebMb9/ZBEv6/XiFpGnAFpcctMqfThqxsKbcmTkH59EF4dcAWmFMWebtG/RoEkrXlTy166wmrZgThY=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Each \u0060await\u0060 captures the context that is current at the time the \u0060await\u0060 is evaluated. So, if the first \u0060await\u0060 resumes executing on the thread pool, then the second \u0060await\u0060 will capture the thread pool context anyway, with or without \u0060ConfigureAwait(false)\u0060.\n\nHowever, I really should update this article, because these days I more strongly recommend using \u0060ConfigureAwait(false)\u0060 throughout the method, and the reason is the \u0022if\u0022 in that sentence: ***if*** the first \u0060await\u0060 resumes executing on the thread pool... In the case of already-completed tasks, the \u0060await\u0060 doesn\u0027t \u0022yield\u0022 and therefore doesn\u0027t \u0022resume\u0022. In that case, the \u0060async\u0060 method continues executing (synchronously, on the same thread). That\u0027s why \u0060await Task.CompletedTask.ConfigureAwait(false)\u0060 does nothing: the task is already complete, so there\u0027s no resuming, so the method doesn\u0027t resume executing on a thread pool thread; it just continues executing on whatever thread it\u0027s already on.\n\nThis is less of a problem with true asynchronous code (i.e., file downloads), but it *can* still happen (mobile devices in particular cache web requests heavily, and can complete file downloads immediately and synchronously). For this reason, these days I do recommend using \u0060ConfigureAwait(false)\u0060 everywhere in a method if it\u0027s used anywhere in that method.","date":"2023-01-21T13:40:55.2982889Z"}