{"_id":"fac3e235-8c1d-3abc-af64-0e271c3d5d61","authorName":"Grateful","authorEmailEncrypted":"KnYUJoNB669za2jIjtxdvBEFlDue5pLtbVRyyMv3/yi9bLDj3RN20oJZ+yR0X9l0dZhINVjjf92rmUiM02Vw49iw7LBPkUVs/jZ8JmWB64SgEGsedrJ4pzk8IYc87sCdHAI59q+TBRVhrMnP76kaWfID3nfnxHyK8eHIgw55kdQ9xnHFayOGcrWHYY1F1OSzJr3AtMjMuATTfYdXxyBSdKtRw+OhMaUOCn296jWhrRSiwaGasaAeydcZeCvo1Bkvq1jXcuYVPyhIhwpjSViKgzdpYq0GFvSt6ekeqJ4xFsRiOsooS8cBQQyTZ7uF266d1jlgRNBNADW5DjXKQSh2bj+0cl9374iy5PV+xGQmBkX294mK5tDuRsW4QKtkqJPQiaa00533IcgO+Bv0EX7wx7LI93Hlwlh+ceoMbEB+OSsshAGFTIsk52Os4VnVGpcBIHHEU8MldYD8s7onugiNlCtK5tsDsaht5CtlT4Et6/hyC7527cGn+3xrvzDDOkn38usupK0ofRNNUiLuYb6KFM7K2YW5qfclmz2o2BG5jQn6KXJx0AW9C39kFoE07E5N6+43Qvpidt4REkmpAAQ8E2lKi8BS6lWl8ZcQ+rerETpeXxRQwOtcfZEn6By+7CSg890b8L5UA6UIZJgc6hQDzy61nYWTN0swTzKPW8D4CUc=","authorEmailMD5":"0c2887c19932ba204e4abe9336971ade","message":"I think I figured it out (mostly). I simplified the console app code, and I made the method to be executed be of void return type. This is because I initially had it returning an int, but it turns out that if you try to refer to the Task.Result int variable value even in the next line of code after invoking the task, the task will execute synchronously. Simply by not referring to the Task.Result int variable value, the task executes asynchronously. It seems to make sense that it would work that way, but at the same time it would seem to make the usefulness of async/await/task stuff limited to executing operations that have void return type. In other research I have just done, it seems like there are more beneficial use cases of async/await/task within the context of ASP.NET MVC apps and other scenarios in which UIs are involved. But here is the code that I came up with to (kinda) do what I was wanting to do within a simple console app:\r\n\r\nusing System;  \r\nusing System.Collections.Generic;  \r\nusing System.Linq;  \r\nusing System.Text;  \r\nusing System.Threading.Tasks;  \r\nnamespace ConsoleApplication8  \r\n{  \r\n public class Program  \r\n {  \r\n static void Main(string[] args)  \r\n {  \r\n Console.WriteLine(\"In Main, right before calling clsSlowOperationInvoker.InvokeOperationAsync()...\");  \r\n clsSlowOperationInvoker objSlowOperationInvoker = new clsSlowOperationInvoker();  \r\n Task aTask = objSlowOperationInvoker.InvokeOperationAsync();  \r\n Console.WriteLine(\"Code to execute after the clsSlowOperationInvoker.InvokeOperationAsync() invocation...\");  \r\n Console.ReadLine(); // This is just here so the console window doesn't vanish!  \r\n }\r\n\r\n public class clsSlowOperationInvoker  \r\n {  \r\n public async Task InvokeOperationAsync()  \r\n {  \r\n Console.WriteLine(\"In clsSlowOperationInvoker, at beginning of InvokeOperationAsync() method...\");  \r\n clsSlowOperation objSlowOperation = new clsSlowOperation();  \r\n await Task.Run(() => objSlowOperation.Execute());  \r\n }  \r\n }\r\n\r\n public class clsSlowOperation  \r\n {  \r\n public void Execute()  \r\n {  \r\n Console.WriteLine(\"In clsSlowOperation, at beginning of Execute() method...\");  \r\n System.Threading.Thread.Sleep(10000); // say this executes a database stored procedure that takes 10 secs  \r\n Console.WriteLine(\"In clsSlowOperation, at end of Execute() method...\");  \r\n }  \r\n }  \r\n }  \r\n}\r\n\r\n// Output of program:  \r\n//  \r\n// In Main, right before calling clsSlowOperationInvoker.InvokeOperationAsync()...  \r\n// In clsSlowOperationInvoker, at beginning of InvokeOperationAsync() method...  \r\n// Code to execute after the clsSlowOperationInvoker.InvokeOperationAsync() invocation...  \r\n// In clsSlowOperation, at beginning of Execute() method...  \r\n// < not part of output - a 10-second delay occurs here >  \r\n// In clsSlowOperation, at end of Execute() method...","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"2f24ce7d-b8ac-34a7-afbc-60c1467b0f61","date":"2015-01-04T08:55:40Z","timestamp":1420361740,"authorUserId":""}