{"_id":"222b99a3-1dff-4a09-ad66-0fbfc4beb74d","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","postUri":"https://blog.stephencleary.com/2012/02/async-and-await.html","replyTo":"08dd5086-1a7c-45f5-82e5-c1b32f7a9d9a","authorEmailEncrypted":"f5UVPnJRoTI0bgLYUa9CK1\u002B4OaGabMFVPooMJkKCBMcL55ie/ZlEc0q95y4zIa\u002B4uWJGbMs/k/1KN3wPVGQPFyNSdDv2ZvK9sGIl1ZEiXYS7BqTm6cdyXH\u002BJ0Z9FuNueuUESpVPipfQOeKkz3VCKy6mGSr\u002BRroKkJuxp1oFWnFLNyjKfEvjyf5fxGslmp4JDsXnTc4e959WZ94PChf45nocywSGNMziqTM\u002BIcUGeXb8cdaIWJ2IRH4MNuWzC2U3JNVvpw8O9b65Jo7tg27HFhocG46iQ2OwPrbGXSnjfy1CjC7c1SDxj8JissfIs28R8vuk17IesjJFIan4GHpjdiehqiZnRirduzeelpB8tCtI5VzzcolQ4xQehm5r4j8\u002BpofRuahApcyysv4wkR8n/XFMA9A3RP0k0ASUt0Mqzp5l7IEpVVn6\u002BE7oi53HtSX/CbUTXJdBFjKYkRNzW6ZWvkLu04NBM\u002BnzelwKeG8zTsa/xie4VQ8ehPKLtk8f8x9OIKRMk6aRaOSNTZokA8XK\u002BNclESgbrkrFXoVmWHLWZjG9Hmr4gJ2faj33RHJa3oBwoUEqsM\u002Bgj076wAR05hKZN9BFdIJCxcmW0J8ZSg4dJV/bu\u002B03xj4cv9XyWohyeDvaVPwXtAvfSoOytRegjIi8bztYA3u0EPthom8HZHO7dOno=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"The point of async is to free up threads. It uses _fewer_ threads to accomplish the same thing.\n\nOn the client side, the focus is usually on freeing up the UI thread. E.g., doing a DB query so that the UI doesn\u0027t freeze. For background code in UI apps synchronous code is fine; it does end up using more threads than necessary, but that usually isn\u0027t a big deal. In the UI layer, though, async is a more natural way to write code even if the \u0022asynchronous\u0022 background operation itself is synchronous code running on another thread.\n\nIn contrast, server-side code is more sensitive to thread usage, due to aspects like the limited thread pool injection rate. Server apps get scalability benefits when using async instead of sync code, often on the order of 30x. And async servers can also scale more quickly during a spike in demand.","date":"2024-08-31T16:52:39.1454474Z"}