{"_id":"ba3895d2-138b-3e56-94d5-a1a2b3decc56","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"As you discovered, mutexes have \"thread affinity\", meaning they must be released from the same thread that owns them.\r\n\r\nIt should work to have this code in a special thread; you can use AsyncContextThread ([http://dotnetapis.com/pkg/Nito.AsyncEx.Context](http://dotnetapis.com/pkg/Nito.AsyncEx.Context)) which will set up a separate thread with a SyncCtx that schedules work back onto that thread. So any awaits will resume on that special thread.\r\n\r\nAlternatively, you can use AsyncContext (from the same library) to *temporarily* set up a SyncCtx on that thread. An example with AsyncContext:\r\n\r\nAsyncContext.Run(() =>  \r\n{  \r\nusing (Mutex m = ...)  \r\n{  \r\nawait...  \r\n}  \r\n});\r\n\r\nAsyncContext is a \"nested loop\" approach to the sync-over-async problem, in contrast to the \"blocking\" approach. Both approaches are not ideal, but they both should work.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"5ca49c8c-57b8-3ce8-a122-a20b7bc1852b","date":"2016-06-07T12:26:46Z","timestamp":1465302406}