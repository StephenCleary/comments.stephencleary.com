{"_id":"ba3895d2-138b-3e56-94d5-a1a2b3decc56","authorName":"Stephen Cleary","authorEmailEncrypted":"LRXwPRsJS7E/aCHjWTzS4djEkN5FBYy8pKxrsPZd9SRZL9R1SaR6s4CH0resvZt9S7RK9p4TpuurbnxlNScyCSdbR00eYlDGsiEf/XHdL79eKnCjp7WfLxjMaTN2lPrzVElmZ8/vPOiL24QE4QUMMp3QFyYpCDo9ND2+d/Qrgq6dx7OrneUMbCYGMXXY/Qu8AeWFY8HPq+DL8KgaVcStJX7Y5RwUIjyCdUMgmr/CDyAZbfAQcLYlXA22+zCvKSmZU1caq8bW5zsBRRL9/KP93Kn5WLxvo3Mhcs4yw1WaIM9c49CXJ457Oh+SCch/bBqeEkjP7UN0FD/kQqF4yrTJ/0SQ0PVJh5/ca9bDupCmrJHXo+cYCDN0/eUgW5DAWtON8w/DVKk87wDlefLFK+l3Vang0WhyaZ/7qh+90tB+7mI6B9Jezfm/4eVduT0JCq6faS0YhqFCQbidFLXbS1zfJUh59u+eZBDu4WFnY/1hvnO4godnupDhMW6cze6IRboHnVmOVg/eabb3AbPFDLukECk8JhYE+V/4nMGl2r9EZo1/eTPna7s6j+EsXT7WhlJewIc1ngCRqTkH7gnMIJsI67c+wg0fpLk45gWdnq7fpjeuRyikRTMjs8iASKOATyXhvqsorodAuxLND1Emz4x4hULiOiO/icSmSK6UZi8Hagw=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"As you discovered, mutexes have \"thread affinity\", meaning they must be released from the same thread that owns them.\r\n\r\nIt should work to have this code in a special thread; you can use AsyncContextThread ([http://dotnetapis.com/pkg/N...](http://dotnetapis.com/pkg/Nito.AsyncEx.Context) \"http://dotnetapis.com/pkg/Nito.AsyncEx.Context)\") which will set up a separate thread with a SyncCtx that schedules work back onto that thread. So any awaits will resume on that special thread.\r\n\r\nAlternatively, you can use AsyncContext (from the same library) to *temporarily* set up a SyncCtx on that thread. An example with AsyncContext:\r\n\r\nAsyncContext.Run(() =>  \r\n{  \r\nusing (Mutex m = ...)  \r\n{  \r\nawait...  \r\n}  \r\n});\r\n\r\nAsyncContext is a \"nested loop\" approach to the sync-over-async problem, in contrast to the \"blocking\" approach. Both approaches are not ideal, but they both should work.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"5ca49c8c-57b8-3ce8-a122-a20b7bc1852b","date":"2016-06-07T12:26:46Z","timestamp":1465302406,"authorUserId":"disqus:stephen_cleary"}