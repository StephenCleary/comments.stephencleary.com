{"_id":"ba3895d2-138b-3e56-94d5-a1a2b3decc56","authorName":"Stephen Cleary","authorEmailEncrypted":"ePRxjYRzhgFXD7+mrm+ApWseNI+On3iSmtF9dflbC369KiZmWpLbeKDG1GHbCGAB7SU6F1TxdI2tWFbwIvEPeDa0fQM9XWhcRoOVQxddpCeC3MKMnl1k47A6SyjtuMACjLk9xT0MyJ8ZJA/JGyhczvL+5uWbHVbJ+LkEZ8XdZCV2ep7djCZHKtdQHCQsQjybtXm6nPup/wcsy0I+WZp1YjY5JPBS2Qgm4JkyR1vGswYbMd2t+K3P50c8FNFANfhAnoRCkaUkqLsOUgsp0emQayMzRngZ2lfTYbiMArh/BQuG2LzfS1m2urYc6qd3slsufZs5BQGH5qVixsbOt3WVFPYLisNKUWpyaynpitvq2+oOMPFeVotieFnNiQIRNjzmydYcgW3QY3qArarCwERJy22WbVCt/9A/2IEHt5qEV0Pae4yk2gDof3oyfga7wT/8g6/4rSJMiALVnyuksGbwOgtPicjP76Ro0rBlobDjaHPoV50oruGhqDQVxdhoYQ5VIY2ogW0neyBf6bukW3wIMrzvj4ix0dm7UVFOYxhDScG0U4kULXwjnylMjC9DRTAbxpE8uVnVQIMv3nuoeQQgfYc8oYSV99DvrVEKcMKjcGdfO9tPdWlD41kjYdJFf7eyfAGyHurO5PMRZEe7/CCBZNR+G6psSTyhBUFwWIekVaY=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"As you discovered, mutexes have \"thread affinity\", meaning they must be released from the same thread that owns them.\r\n\r\nIt should work to have this code in a special thread; you can use AsyncContextThread ([http://dotnetapis.com/pkg/Nito.AsyncEx.Context](http://dotnetapis.com/pkg/Nito.AsyncEx.Context)) which will set up a separate thread with a SyncCtx that schedules work back onto that thread. So any awaits will resume on that special thread.\r\n\r\nAlternatively, you can use AsyncContext (from the same library) to *temporarily* set up a SyncCtx on that thread. An example with AsyncContext:\r\n\r\nAsyncContext.Run(() =>  \r\n{  \r\nusing (Mutex m = ...)  \r\n{  \r\nawait...  \r\n}  \r\n});\r\n\r\nAsyncContext is a \"nested loop\" approach to the sync-over-async problem, in contrast to the \"blocking\" approach. Both approaches are not ideal, but they both should work.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"5ca49c8c-57b8-3ce8-a122-a20b7bc1852b","date":"2016-06-07T12:26:46Z","timestamp":1465302406,"authorUserId":"disqus:stephen_cleary"}