{"_id":"ba3895d2-138b-3e56-94d5-a1a2b3decc56","authorName":"Stephen Cleary","authorEmailEncrypted":"Av2ElHNvU2LjxZ1IjRBIVCMLwBFitoBni/I6WflMWG+e+qODIB8Z8vkHMNvikcU1TTqf+ZBfkYtgKAAJT0wgDjL65I82ykIp6/TzHs+Y3/YU/kjxQ7f8JbBcMPRFfD3KXTAvRMWPpKDcvalRX6GmcWzUMlKENsd8GxdInMfeMXkieKyPQOcwSc91ndIwH2lwxbfO3yCKVm6UGjJ9FqvZCwCtPpPhEERWEovvIMZ/F9cBpAaUxDV5bBwtC62oxvjzLy5oMZfiHvCHyk4HPNP7dbl68tl6VwrFQLM69cLT4WVLCmNTCGE05fKwcJ1GufPOJHIEqrnKOTHH5b6WnJk9vY6NRqFtTZic4s0W77mYP5UpUvGdD2/UJ+89gLSXKLY7YRQI2s0u732kysnFcjbLL9Y8pnBm66W2ppgggXkB5+9tSaBr5QYqgF2iXI/L66sHVO/s1RbsUrJxlywJtMtYwkTOWliAK3e4+/SvER1xK68pMBJzC/BQAFZyapTXxSM2mTu03J2/mgKE6D1tl4yg5zYR8IC6z/BTPi6Qyn67D3EAmfjBmgOsuYfMRsOEfghDvX69gDuLYlWlHh/FZHX07s8wFsp8LQXmtYWUzXXrp+gPTkUNZNYJ7DuciwpEkRMksSlYz6gzo6NB37FEOp8FVyohDqQRsoGXIsHvlc4OGXQ=","authorEmailMD5":"28dde5772b48c92e08b8050411aa5ba8","message":"As you discovered, mutexes have \"thread affinity\", meaning they must be released from the same thread that owns them.\r\n\r\nIt should work to have this code in a special thread; you can use AsyncContextThread ([http://dotnetapis.com/pkg/N...](http://dotnetapis.com/pkg/Nito.AsyncEx.Context) \"http://dotnetapis.com/pkg/Nito.AsyncEx.Context)\") which will set up a separate thread with a SyncCtx that schedules work back onto that thread. So any awaits will resume on that special thread.\r\n\r\nAlternatively, you can use AsyncContext (from the same library) to *temporarily* set up a SyncCtx on that thread. An example with AsyncContext:\r\n\r\nAsyncContext.Run(() =>  \r\n{  \r\nusing (Mutex m = ...)  \r\n{  \r\nawait...  \r\n}  \r\n});\r\n\r\nAsyncContext is a \"nested loop\" approach to the sync-over-async problem, in contrast to the \"blocking\" approach. Both approaches are not ideal, but they both should work.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"5ca49c8c-57b8-3ce8-a122-a20b7bc1852b","date":"2016-06-07T12:26:46Z","timestamp":1465302406,"authorUserId":"disqus:stephen_cleary"}