{"_id":"ba3895d2-138b-3e56-94d5-a1a2b3decc56","authorName":"Stephen Cleary","authorEmailEncrypted":"uLroNK50riIaXIHhN1RFnjnjpwNhIAf2wbTBe2AY9sfuNkT64PKHdpJkF+LqgCU/UWFjOVGgGy3eB/+yJWV/uRHEcO2EcPAgfS979ZoVEThbI0frnVoORp23/Ovo3o8FjzrQ8euKLkcU2m0oUtLpoRwTJolztaoqvE2BI0mUwBnGMObkq/Hmy7l4kEK0ReCfHy8e/rVvXq5fnD5K4ZY1frM3A0xmUxQ85hL6i3I9EyGPp6GPu+V7DbB5szBgWhzn/ZWTWCtnLH8afCYZMUtHSuut3fc8xT7yivYMa6g8iRHNgt6LP7bmo/BBLJKC6ImL0ui3o0vBype/dXKWbWFEnS5IOzx8+Td3+mtKB4j6UnOzSy4sN9G1q0UYBmlcRxVIkvfXCT8/D/+hmG4OUFbpiwqrblU5a4g2cE6W0K9PEkxp7/IAFvxsnLWPINvKyTLxt/0bRwIwyVEcYEz6m/t1uRvpSabUEL12irIuaEIASdQM/k4nR/F4hgaGdRxmQzV4B8x9HfHsW+PYf8w5/fKXzUQ2ir3+Z00ACJXJtuosWegxMK83f5Ypzmz12AseM8NEo2ak+MzmRgvLlZamR2URekMAo1WrFLU4zkRAFXw1X8AP67L0HZAgmYOiyElv4qlcn9P2oJ+lXRv9H1RWprJEtJ5CIg+oQ5IHyRBcY8sI8Ds=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"As you discovered, mutexes have \"thread affinity\", meaning they must be released from the same thread that owns them.\r\n\r\nIt should work to have this code in a special thread; you can use AsyncContextThread ([http://dotnetapis.com/pkg/Nito.AsyncEx.Context)](http://dotnetapis.com/pkg/Nito.AsyncEx.Context)) which will set up a separate thread with a SyncCtx that schedules work back onto that thread. So any awaits will resume on that special thread.\r\n\r\nAlternatively, you can use AsyncContext (from the same library) to *temporarily* set up a SyncCtx on that thread. An example with AsyncContext:\r\n\r\nAsyncContext.Run(() =>  \r\n{  \r\nusing (Mutex m = ...)  \r\n{  \r\nawait...  \r\n}  \r\n});\r\n\r\nAsyncContext is a \"nested loop\" approach to the sync-over-async problem, in contrast to the \"blocking\" approach. Both approaches are not ideal, but they both should work.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"5ca49c8c-57b8-3ce8-a122-a20b7bc1852b","date":"2016-06-07T12:26:46Z","timestamp":1465302406,"authorUserId":"disqus:stephen_cleary"}