{"_id":"6f5d1b60-b7c3-11ea-ac04-03fc0593d314","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","postUri":"https://blog.stephencleary.com/2012/02/async-and-await.html","replyTo":"1007b500-b762-11ea-9711-437599e9bffd","authorEmailEncrypted":"c25MPBs45i/MKWLpWb5Pd6RE7POQmeO+WSBHt9b6+PlRfsTyy+QnZLBhgzdiWeWkdXG4z2mi1MLIYkx0hjWoRqCDU/Qy7AS7HFhCPBblRm8YjBnoYrWHFYThBTGyYEIifAx+RSjkQ3IXOzQxTYDyl7Ub27wkdiGkHBigmoAfhFxwnMKnoQ+jxrm1+GSMyB1kD+D4iEJOQJJEyXstEzFN5Yh2qd3FdBJFNLxOT4RNJNymq2+p0/IkQNdanULSgAGodcllbZfVPqSWRbFM3eo820zK34fEP/O6ZTvOher5RR83xZwQIbL3slahMvtYU5j+8DE/vClecpydg6D7GYexxXuKmuU4bNc2ulxb5FjeKKQMKP+Q/pNfg5FFZnMO/3jPkdheFujS9NrQitLMvdex4eRuhcjTSCzrm10jWyv+lruP4x+82nvHUek/wLeSp1K/d0l1n+C3eXK244NSsERAz3Gz0yNPGtLxIIz8kDEFRS7vgS21SgwxZuXSxtavquqr+5lxFdfRkYywy1deyJp8ZzMPBIxYyNsHVK/n/MCwPBqOwdvNX6UvIZlXX06G4PAM/cgdwa5pirShls0sHVsh8xs73bz28b/bMwBwdCQV96H/VD4qA6D2XWt4Ri94H0lOZfTpQdOFJa3sIsOMciry9+OVVkKu+EYUEgxWTEncD14=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"The short answer is that [there is no thread \"running\" the task](https://blog.stephencleary.com/2013/11/there-is-no-thread.html).\r\n\r\nAs an example, consider an asynchronous REST request to an API (this example is I/O-based like most asynchronous operations). You can think of it this way: the request is sent immediately (starting the asynchronous operation), but it wouldn't make sense for a thread to just sit there waiting for the server to respond. There's just no point in using a thread that's just blocked on reading I/O anyway. It makes sense to just have a `Task` that represents an *event* (\"the response from the server has arrived\"), and only resume executing when that event occurs (i.e., the task is completed).\r\n\r\nThe long answer is a bit more complex, but that's the general gist. :)","date":"2020-06-26T15:41:00.639Z"}