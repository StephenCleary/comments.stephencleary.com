{"_id":"2f24ce7d-b8ac-34a7-afbc-60c1467b0f61","authorName":"Grateful","authorEmailEncrypted":"JHQuBD+jBj1Pre/VxFRA9fNyk0b0UfO9jI/f2KnvG+oWQBDTzo82lSUVv/AY8M8X1r2mO0bwd2Df4dLajaY/b5J8GqT79KXJb9+VAOAJrAPTj0Xjy24MdwJtdvkof0G/cVYFSLLrFNY4Sd3Ze56l4+JA2hkKkTCE8yzNGi5pdepjPCeAWxKHDrz4XSL2qSSDtf7+tJsQdB4iN+thQhPrggTmInk+k58CcCGxasZJCUil3EJjVY/gFNkSKHe0bDdPH8tB/6naXAlPZUd+yrPAEN0jXGf/VEIduM3Hr0ciAsCqz21oLRTUTscLCIrw8UsUvnhf0jN+dmuSIEdOEaNKVUfSsl2zk8tw81zWm/U5rWBdQec3KhrPQfbppiVVUccfm7HEA/jtGolgx2VEUiG4Se6meDddDcWxTK69K20+bQszd2CPgpayoaogudVZA9Wkb3s5A8KYLUWvmERjST1oUwLf5cjPIjpJATVyFw7XdDmkud00InH1tZ626dr2FxnF1p3B5JYqjjbjcuv4eLxKAGNeZ+IG7R+B6jnHgCO+Y2VNW/8XEnNmnGF/61TzTlkJUGR2e85jDNPlOqUP2MhZ6ERX22iVt+O3cFBrRI6Zu3K6jsLUTSraun+Gvc48GchugTJdcDSAft6VbAOSnPywpARFHYk+j4izIwn0CNF2JNk=","authorEmailMD5":"0c2887c19932ba204e4abe9336971ade","message":"Trying to wrap my head around this stuff. I hope you get what I'm driving at with the following example. So I start with one regular (no async stuff involved in it) method A which calls another method B. Inside method B there is an instantiation of a web service which returns an int returnCode value. The web service takes a long time (up to 30 seconds) to execute. So hearing about this spiffy new async stuff in C# I thought, great. I can leave the web service completely alone (i.e., not touch its implementation), and just \"wrap\" the call to method B inside a method C, where method C is an async method. Only, this is evidently not possible because WHATEVER operation you put the \"await\" keyword in front of (in this example the call to the web service's method), HAS TO ALREADY HAVE AN ASYNC IMPLEMENTATION. So, for existing codebases where you have some long-running operations whose implementations you have to or want to leave alone (instead of changing them to async implementations or adding an async implementation of it), you can't just easily \"wrap\" async around them. Or am I missing something? Here is the actual code of my console app:\r\n\r\nnamespace AsyncWrapperMethodTest  \r\n{  \r\n public class Program  \r\n {  \r\n static void Main(string[] args)  \r\n {  \r\n clsMainlineStuff objMainLineStuff = new clsMainlineStuff();  \r\n objMainLineStuff.Operations();  \r\n }\r\n\r\n public class clsMainLineStuff  \r\n {  \r\n public void Operations()  \r\n {  \r\n clsLongRunningServiceAsync objLongRunningServiceAsync = new clsLongRunningServiceAsync();  \r\n var task = objLongRunningServiceAsync.RunAsync();\r\n\r\n // more code in Operations() that I don't want blocked...   \r\n }  \r\n }\r\n\r\n public class clsLongRunningServiceAsync  \r\n {  \r\n // This is the new method I added as a wrapper around pre-existing class clsLongRunningService.  \r\n public async Task<int> RunAsync()  \r\n {  \r\n clsLongRunningService objLongRunningService = new clsLongRunningService();  \r\n await objLongRunningService.DoLongRunningStuff(); // build error - Cannot await 'int'  \r\n return 0;  \r\n }  \r\n }\r\n\r\n public class clsLongRunningService  \r\n {  \r\n public int DoLongRunningStuff()  \r\n {  \r\n System.Threading.Thread.Sleep(30000); // here is where the web service call was being made  \r\n return 0; // say we got an int return code value back from the web service call, and are returning that value here  \r\n }  \r\n }\r\n\r\n }  \r\n}\r\n\r\nThe clsLongRunningService was the pre-existing class that inside its DoLongRunningStuff() method, a call to a pre-existing web service was being made, whose execution took a long time. Originally, the clsLongRunningService.DoLongRunningStuff() method was being called right from inside the clsMainLineStuff.Operations() method. So I just thought I could write a new class, clsLongRunningServiceAsync, \"wrapped\" around the clsLongRunningService.DoLongRunningStuff() invocation to prevent the blocking in clsMainLineStuff.Operations() from occurring. But as you can see, since the pre-existing clsLongRunningService.DoLongRunning() method returns an int, I get a \"Cannot await int\" build error on the l.o.c. in the clsLongRunningServiceAsync.RunAsync() method where I say \"await objLongRunningService.DoLongRunningStuff();\"\r\n\r\nIs there a way to get around this snafu that I'm not seeing, or is there just no way to accomplish what I am trying to accomplish? (And that, in other words, the new async/await/task stuff is great and all, but ultimately whatever operation you want to put an await keyword in front of, HAS to already return an object of type Task or you need to write a new implementation of it that does.)\r\n\r\nThanks for indulging me in my long-ish example :)","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"","date":"2015-01-04T04:39:51Z","timestamp":1420346391,"authorUserId":""}