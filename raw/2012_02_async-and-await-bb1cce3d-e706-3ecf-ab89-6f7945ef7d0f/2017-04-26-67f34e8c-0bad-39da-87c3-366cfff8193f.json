{"_id":"67f34e8c-0bad-39da-87c3-366cfff8193f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The \"thread that performs the completion of the task\" is a temporarily borrowed thread. E.g., I/O operations do not need to block a thread during their operation, but they do need to \"borrow\" threads for very brief work like copying data and completing tasks. Most I/O requests on .NET are based on OVERLAPPED, which will call back a completion method (on a thread pool thread) when the operation completes; that callback then needs to complete the task. It's the final step here: [http://blog.stephencleary.com/2013/11/there-is-no-thread.html](http://blog.stephencleary.com/2013/11/there-is-no-thread.html)\r\n\r\nSo, the optimization is where that temporarily-borrowed thread (which just completed the task and has not yet returned to the thread pool) is used to continue executing the request, instead of switching to *another* thread pool thread.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"a151155e-8218-3fe0-b240-490bbb1ca724","date":"2017-04-26T13:53:44Z","timestamp":1493214824}