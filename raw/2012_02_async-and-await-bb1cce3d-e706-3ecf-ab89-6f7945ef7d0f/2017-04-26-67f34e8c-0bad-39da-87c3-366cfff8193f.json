{"_id":"67f34e8c-0bad-39da-87c3-366cfff8193f","authorName":"Stephen Cleary","authorEmailEncrypted":"Kofkfr87FmDUAeqnfI4x3xlzne7raVugCX9sHYswjiTgmaob7re8H2PBVo7aTNyFk9S2S3uN+D3v0Dy7BXDG8/mleB2eOgwxv6dTFlzUrUWbm7Whn39b7tYOlrxkqrpm/cELGJLlouHsVLtbnuPigJ2B8hY/TLmMyTsOPtmCiuVxlVuCUg/q3673WoQwKwDvOXsn0o5ggaYyMLGbccGI41I1NoVsGWaBHKfGvAaN3IwFljSDO2/FVq6Z61KdaRpdCdIqajmuQ6P50dEXSdaxlE5CUD2LC5bOkLsdaleXTTEYNlODIVI5pVfjrdKbDDyNjyjtfM6WZ0kc+D2EANEHxcxhcfFn5pjoNJwmlppIo29rd7mOw0w7aJ2dFfU/FJt/y9jAMFdQbb/hbiLF9LX+HphOlMf+krGaZuPVc1Se4+0ohqSmxjd7OYe/nCEpYOgU5/jkSfDpvkfLRhzSI88NhMTEK9tZOeM0llcCgywIMdNaC0ryA5Eu/ojkHcEZFuMqr5LY1/AfzRSfSr6vH6USaUz9U7HFsI+EKJ2mk/DW6tIHeDctZQXaGkYu3Y3yE+L/YxK6yC7XTpQ06yHvpiWW1RRelgTpvhOwc57vgmzDvkBMjza3kYFkJvKFQI/NtT63JDWXyjWnyaMpp9QSHKGx/AjhEpX2yhu80ekwkEdDBZE=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","authorUri":"","authorUserId":"disqus:stephen_cleary","message":"The \"thread that performs the completion of the task\" is a temporarily borrowed thread. E.g., I/O operations do not need to block a thread during their operation, but they do need to \"borrow\" threads for very brief work like copying data and completing tasks. Most I/O requests on .NET are based on OVERLAPPED, which will call back a completion method (on a thread pool thread) when the operation completes; that callback then needs to complete the task. It's the final step here: [http://blog.stephencleary.com/2013/11/there-is-no-thread.html](http://blog.stephencleary.com/2013/11/there-is-no-thread.html)\r\n\r\nSo, the optimization is where that temporarily-borrowed thread (which just completed the task and has not yet returned to the thread pool) is used to continue executing the request, instead of switching to *another* thread pool thread.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"a151155e-8218-3fe0-b240-490bbb1ca724","date":"2017-04-26T13:53:44Z","timestamp":1493214824}