{"_id":"67f34e8c-0bad-39da-87c3-366cfff8193f","authorName":"Stephen Cleary","authorEmailEncrypted":"vApAgak1dRrDFCU8UzKTSqgpUIr0cHiTZkJUJ75+8D84wx+7JVfTHxtmbvRU+O3+wDgyUZ4T6b/Eed2lqrP9lGz7H/LfDf4qk5aGFfUpfuq3gDZhvuWj8CTqOVFkg7tE52+X+95tK3krBJwPsE8v/yQDNsIw287XfXXedTflkuava06GhRcCAJi2MNmjbZB9T+vnMbZM9vTmUVe5HMS0W6/GOnhQrAm17lXQVN+u0r73t6naRu+ufHVMZmbETQnbmgHSP+WKkgUIudKOKJZril7WQD8ZCDWL8a7zqDa8whSRV9+xQ02jRays/CWa069Ctd5BvMQn+oNAC04YG3NPpGdURkUxj14vtoicf2RZBlE6VG2R8VPPVCs8YkKWEDJ2Cegj95bGwzT1quH6mLBCoH2tlMi4XzQmByXxGu0dNd/AZZyl0PkFdoXpWEt/Y4H86Bl6f+ukvxgzJwnw5H9jMDd5uEhXE3nQAk0OiI9jy4EQa55J6iHUsiDYYZBOttAJuoxDecYY3iP/LMsvGcf194jGKrrTJuQfj/fd3nvFDNWeRuP2cdtGeUXCatMDg7BrfvxiPex+x//EZg6w1ht4fozrCa6YxAg/TZTLrl84wK5ZnlwtF0blHMDzhjDiLExLZ0Oe/jlWiqexfCQSkTvm9UYQ9inje7mTOCgENYTQpuQ=","authorEmailMD5":"28dde5772b48c92e08b8050411aa5ba8","message":"The \"thread that performs the completion of the task\" is a temporarily borrowed thread. E.g., I/O operations do not need to block a thread during their operation, but they do need to \"borrow\" threads for very brief work like copying data and completing tasks. Most I/O requests on .NET are based on OVERLAPPED, which will call back a completion method (on a thread pool thread) when the operation completes; that callback then needs to complete the task. It's the final step here: [http://blog.stephencleary.c...](http://blog.stephencleary.com/2013/11/there-is-no-thread.html \"http://blog.stephencleary.com/2013/11/there-is-no-thread.html\")\r\n\r\nSo, the optimization is where that temporarily-borrowed thread (which just completed the task and has not yet returned to the thread pool) is used to continue executing the request, instead of switching to *another* thread pool thread.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"a151155e-8218-3fe0-b240-490bbb1ca724","date":"2017-04-26T13:53:44Z","timestamp":1493214824,"authorUserId":"disqus:stephen_cleary"}