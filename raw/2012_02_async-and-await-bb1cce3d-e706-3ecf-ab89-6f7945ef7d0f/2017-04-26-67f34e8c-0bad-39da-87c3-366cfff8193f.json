{"_id":"67f34e8c-0bad-39da-87c3-366cfff8193f","authorName":"Stephen Cleary","authorEmailEncrypted":"XruU3X5+BdBfGhVjJdEczTzVz5ja6Aa1Rvs1h1KHEHhElUd+pLNLRocoyy2kwCPPhKlg3jBjtTRLi59ALuaNA5rdPygq8IRilucuikYVeOuD0KrwLwNMoOAzqTUoCmzt4b2hBz0bOgskgR+yif1/JH16W2gqe6XsyDXkaGqxz+dkyBQihjzHVKKe/fkFWXbX32yl+J46qOZlTYJL7aGgCggxzZPCdRpDTssMJ0tZHivm8qFKKpHsp8fAqDhnGYGnQF28Uk00s1Z5NE4Bncm48eQpKRmnEfPelF9TTxtOwZKq0i4X0LEqfDiohg2y9YqG552iGAjH7CyXDKu5oRYj2WAONFmSpMZoAwAOrozkXC+uALHPJnq3NfLUHxVSXzXt4f91BMIMoGN+W0ew6aRtCOJBvhbF+t/3dMrx56OhCGX5xWmmLEZDlaqaVJU+j4wTZnZV9BKC0Rp2asmBxD6k7DfFo/hI1f8biC3H5VehSA5akc7jbWiRjRBoUEwbRAj4CaJSCkmi9NmRPDhTx3Ndl9bq+ty+yFrhkRal99HBfUJ2A3h+nO11gID7wGmj/ruBuOgzdm2mE5daxdfkuyM/lkxiAnufra80Tk08QlgLS7eV4YauHDuv2bXqgy1jif22EAln7zD2mIwYFDhLKNQocSv5nmB02EI4OjoCdba2Q24=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"The \"thread that performs the completion of the task\" is a temporarily borrowed thread. E.g., I/O operations do not need to block a thread during their operation, but they do need to \"borrow\" threads for very brief work like copying data and completing tasks. Most I/O requests on .NET are based on OVERLAPPED, which will call back a completion method (on a thread pool thread) when the operation completes; that callback then needs to complete the task. It's the final step here: [http://blog.stephencleary.c...](http://blog.stephencleary.com/2013/11/there-is-no-thread.html \"http://blog.stephencleary.com/2013/11/there-is-no-thread.html\")\r\n\r\nSo, the optimization is where that temporarily-borrowed thread (which just completed the task and has not yet returned to the thread pool) is used to continue executing the request, instead of switching to *another* thread pool thread.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"a151155e-8218-3fe0-b240-490bbb1ca724","date":"2017-04-26T13:53:44Z","timestamp":1493214824,"authorUserId":"disqus:stephen_cleary"}