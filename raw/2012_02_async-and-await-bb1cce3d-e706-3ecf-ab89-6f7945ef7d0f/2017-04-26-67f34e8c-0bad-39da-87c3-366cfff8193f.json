{"_id":"67f34e8c-0bad-39da-87c3-366cfff8193f","authorName":"Stephen Cleary","authorEmailEncrypted":"gdJWEZ9hPIlVEjJ+UxiLWZSuEtaGaZ+JY8Sh1gxhsHw3s1vspYw6/FmCsbNq9GH0KNrR8q+5aD3yGnF1hdOcnECgAeIzlfEv3+6XRaBgcAiZbq+SxFlYNl1le2vHq/rxMJllEOK9sPUmLktS8dPP2XVqtBZ2vfnk0wVgXtQdiLvrcUu39+TVpwXOTmjKm3RaY9ZcT9XQSJfdU56W6xIy6HhZcfUkVDKDAhniKGROxk2T2vv3NPafAeDCOp616pi/PrG8kLmHfgD8+CVKTk2xfV3QDAm4Pkvpr9CF3hRq1yulV+k5Wa4ie5lrOBm6qKFYOjjxQ6oCd8Jycz3q8vGQnsEvkgvvirFJQL36dJg/AwoFzWPO4snenqAQYaot5ysSMYdom7/0Ck5HKNO5Kh+GniCaQveUWSTD7TPPMN67ShyVeByIHx5uBPtnwKpp8sk9WevuHw9VrYew1HlJnzj3uw4oveXQQ4YYeOMQGAbmsT+pDxWe+3sgOecZMIt24q0yL19U0bWiAqpea8WyzCP3FXZpA/rpMo1w2kiTHU7t+tpgbUneESLtpcnq/2uQbs1uP8tIAyEyGwlq19G/1zKEHbXi+W/Ok1hxf7J4WKsrHupPd+QhHbG+aghHxDyzk37W760QAc+ivTljQtcWLRZLyH6TeeneuelD6rG0jnvRD64=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"The \"thread that performs the completion of the task\" is a temporarily borrowed thread. E.g., I/O operations do not need to block a thread during their operation, but they do need to \"borrow\" threads for very brief work like copying data and completing tasks. Most I/O requests on .NET are based on OVERLAPPED, which will call back a completion method (on a thread pool thread) when the operation completes; that callback then needs to complete the task. It's the final step here: [http://blog.stephencleary.com/2013/11/there-is-no-thread.html](http://blog.stephencleary.com/2013/11/there-is-no-thread.html)\r\n\r\nSo, the optimization is where that temporarily-borrowed thread (which just completed the task and has not yet returned to the thread pool) is used to continue executing the request, instead of switching to *another* thread pool thread.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"a151155e-8218-3fe0-b240-490bbb1ca724","date":"2017-04-26T13:53:44Z","timestamp":1493214824,"authorUserId":"disqus:stephen_cleary"}