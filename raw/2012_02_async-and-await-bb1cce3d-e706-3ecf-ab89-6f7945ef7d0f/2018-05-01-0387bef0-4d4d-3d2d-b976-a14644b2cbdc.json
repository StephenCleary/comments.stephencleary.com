{"_id":"0387bef0-4d4d-3d2d-b976-a14644b2cbdc","authorName":"Stephen Cleary","authorEmailEncrypted":"RsaaV/2BCOEzWRtwq8BW8WzaMsxeXQkddBe6m3H2Ic1Kcu1W5g/cafCPFVGnh5rEn2nrAHOmcE1dKIr499QkDh4T4HQUjsBr3QOF6rDyX3EQitH0SXde1uSxOcRplM3P/WV2cbYJ2MpGjPHq6z9oH5BuzBGKJuY2rO/04KbiXmWdiAVq2CpqszayBuCNx4zDdi45gLcghZAQvvdUD7BNJDIx5pBmrtg2UeRpQgfOoLoVGmdtqEpZE4bsmwX3Pvn77ugvuEYlyfE/2mfPSNv67n3go6p5TWiUs3+nMLCPZB6hfpEP2J4nIc9zJCj6QkkSnuVdp6BCD4QFnk2OssM7YDHtQu9ER51zWaBzVorLjbTZFFZHDP1BKbcZ7K+C2/PPNLlYBRX+P3qr+cU4m/B5mzmU8Spa8Ksutsz6VDlyT0Uhm9M/PL3lPRaE3MsLMnj205Ljc7FDTnKnlW7E9PR1QQGX6a2Yk0sUsQwivUOa70QWhl9bqGgvonVWRxjigqRdtPGnXUJWeXZ6Jy6dED0vNXZLGdm6iJF22vIrynHvTAB67DCh0XQHXYrcu2mDoSn24sx3LuQUSbh2Nf7eXdri3Wmf4DRb9hFZgFJJOuMhgtEVhTP4e7NZJKUgQSWWc5Hn/xt3HXBmv+nlha6Itm17Y/DMlbfKoTUPo8A53t9CnXg=","authorEmailMD5":"28dde5772b48c92e08b8050411aa5ba8","message":"What eventually happens to the thread depends on what the code does upstream. When the async method hits an await, it returns an incompleted Task. The thread can do whatever it wants.\r\n\r\nFor example, a thread *may* choose to block on the Task (e.g., by calling GetAwaiter().GetResult(), Wait(), or Result on the Task). In that case, yes, the thread is blocked until the async method completes. Please note that this is **not** recommended usage! One of the key async principles is \"don't block on async code\" - not only does it prevent the code from actually being asynchronous (obviously), it also can easily cause deadlocks. Instead, you should use \"async all the way\". More info here: [https://msdn.microsoft.com/...](https://msdn.microsoft.com/en-us/magazine/jj991977.aspx \"https://msdn.microsoft.com/en-us/magazine/jj991977.aspx\")\r\n\r\nSo, how about a more realistic example of how threads behave in an \"async all the way\" scenario?  \r\nWith \"async all the way\", each Task is consumed by an await, which means that method returns an incompleted Task, which is awaited, so it's caller returns an incompleted Task, etc., all they way back to some kind of entry point.\r\n\r\nMost threading scenarios fall into one of two styles, depending on how the entry point works:\r\n\r\n1) Message loop. UI threads that use \"async all the way\" will eventually end up at an async void event handler (or what is logically an event handler, such as ICommand.Execute). In this case, when the await is hit in that method, it will return back to the message loop. The UI thread then continues processing its message loop normally. It is not blocked on any Tasks. It does block on whatever GetNextWin32Message API that it executes in its message loop.  \r\nEventually (when the operation completes), the continuation of the async method is queued to the message loop, where it is picked up and processed by the UI thread like any other message.\r\n\r\n2) Thread pool. The most common example here is ASP.NET. ASP.NET threads that use \"async all the way\" will eventually end up at an async Task controller method. In this case, when the await is hit in that method, it returns an incompleted Task to the ASP.NET runtime. The runtime then sets up a callback on that Task and frees that thread back to the thread pool. In this case, there's no blocking at all; the thread is completely free to be reused by other requests.  \r\nEventually (when the operation completes), the ASP.NET runtime grabs any available thread pool thread and executes the continuation of the async method.\r\n\r\nThread pool threads without ASP.NET (e.g., via Task.Run) behave similarly: when their await is hit, the thread is returned to the thread pool, and when the Task completes, any available thread pool thread executes the continuation of the async method.\r\n\r\nThere are some more rare scenarios as well. Sometimes it's useful to have a single thread that maintains a queue of work (similar to the message loop), but without any UI dependencies. This is more rare but certainly doable.\r\n\r\n---\r\n\r\nIf it helps, you can think of async/await/Task as just a nicer syntax for setting up a chain of callbacks. Each await registers a callback with the Task it's awaiting and then returns. So when you have a chain of async methods all calling and await'ing each other (which is the common case), then you end up with a chain of callbacks, starting at the innermost Task and pointing to its caller's method. This is how they actually exist in memory - as a chain of callback delegates.","postId":"2012_02_async-and-await-bb1cce3d-e706-3ecf-ab89-6f7945ef7d0f","replyTo":"2bd586f0-f2e8-3c7b-a28d-37b58589fe8f","date":"2018-05-01T14:47:32Z","timestamp":1525186052,"authorUserId":"disqus:stephen_cleary"}