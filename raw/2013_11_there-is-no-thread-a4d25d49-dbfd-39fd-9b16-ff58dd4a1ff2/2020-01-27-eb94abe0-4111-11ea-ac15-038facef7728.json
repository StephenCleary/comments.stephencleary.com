{"_id":"eb94abe0-4111-11ea-ac15-038facef7728","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"d6183a70-4107-11ea-ac15-038facef7728","authorEmailEncrypted":"OszHh5rBVryXfGaoSMQPtvzzS+7lxWMUfl5akViWVEBjVXeDA4bR8rtRfWaYAM4S+6sg20iGmMMYXbzJTA0Awo08bxOSnzap+tENe/1s1w8YDN2J+r6wmZVCOsNkxsN519Dt5J+aPCjbgtJ8ZIcN6wVS92Jrlf/Lq0A17YFVo9W4MdsBLd13KNX8jiYRs7N8z56cfda7ZrxWiRKfG3knL9OO3m/6imciMQVyEkXACHNxe2o7TkNkzh49yMyLuQKV2zCeUcpwTRuDgOKePkUu24U6J6KSvLcr3GOxNsLIto7zMORv94Ad1wef9mNeVcuVgD50LmKJ89vlEW/FT/AsoGV5CtUbwyFdzn+8FGuKFZlV7u/fCuY4jNYQLIzwLvvPBYNpTB47xwb1rTVzl4nyl5woJV+Bznb+SAXFjPXa/FGo+dYDHSiq578irGegWoPG914sMQfAXXpT+gjbRwaQMS0btnDTLPEElXMLdQmnHiheTnjeGSngqzlNU+WhBLvHOTtHS4XqvUHwu4Ic5VTs+wdQsGs8OOoLCSwBcjNNp10Yhc0pvILmo46N1ezRG9x/pH6Krhu+akrZdMWbGQI/5b+vEBz0Jl0Tn5sG2Xb9yFYUGyzRObzA00BInd3NuilRvwwavsFzdAZ+B6XFRAeZ3zZtZXBi/LOj2UUcKhvP1fI=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"1. Sorry for the confusion; I meant there is no thread \"doing the `await`\" or \"executing the I/O operation\". There is of course a thread that *starts* the I/O operation, which can be a UI thread. And there is at least one thread used to *complete* the I/O operation.\r\n2. All asynchronous code [starts executing synchronously](https://blog.stephencleary.com/2012/02/async-and-await.html). So the UI thread executes that code synchronously. I would *not* say that it is \"unresponsive\", however. Probably 2-3ms, which is not enough to qualify as \"unresponsive\", which as a general rule [is >50ms](https://blog.stephencleary.com/2013/04/ui-guidelines-for-async.html). In my experience, starting an I/O operation is actually faster than, say, creating and inserting a tree list node.\r\n3. The IOCP itself is created during the .NET runtime startup. In the particular example explored in this article (where the asynchronous operation is a file operation), the registering of the handle happens [as a part of opening the file](https://github.com/dotnet/runtime/blob/059b57ae1074b1e06e6afad17cd4d1c22eefb731/src/libraries/System.Private.CoreLib/src/System/IO/FileStream.Windows.cs#L92), and the handle being registered is the file handle itself.","date":"2020-01-27T14:33:01.604Z"}