{"_id":"71f02c10-e3e6-11ea-adda-79bb21134a81","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"09e491f0-e3e2-11ea-adda-79bb21134a81","authorEmailEncrypted":"waS4uZL0fYpYS+5I4shwPyQsfHhfqrU9cSn8TosFpGtQJYLkaH0zZHZ0Lc7DQMUUvUKC+H3Z7Pw7uf3uoj2cGOnJbAHPdtqjwYDvhafZ+E/Rpl8xjI7U6u7kCRhrLYbCFS1j1F2AWMf6o/CY8WRjL0Q3kupNmaX6ydIYzYuIJwD0cAKIjQo4PVG2l7MB+DIzahZoHFoX1VKqEOnv9RSaVZAa5yeaQw3GgnjXfTEI7LVRDLI3LLMO0nO5M1EQ4JGnkLN0wZ8AajQfOsUHHBHyl7USakZEmK2isGu1IKWkXSE9tDXfUqoJd8G/A+3Fn2o6GzTrAdHAL3WIZtYoXB7C5WADahQ/l4MSUPbKYhw0gzmTPsYUvYMPdnDNyWJOkvVqU4tb+ikaZo15EycaNUD92qVVGqsbwxTF/Y8mYaCXFPtS39nGV6tJlL1/HVoMXo+SeTALl6xZ6Duf+27qW8nal6l7JuyofDevyKzfFYRzjbU4MJRXYvM3zmIVbmcprRTZfFRzl6j6T4aJ9I5hnM6PCRgU1Hm0f/v/X8dGyFsv9aNo1ggxi4IJplgdTIXkEBcXI7GA85yaSTyZE6ojaZvZZXIBtfbpyqA98Kh9VZ+giG5IVL30jxYA0fDkc2fHz/n666uKSgQu68tnnK8YxsuXwOJQlGWRdwgDlgKrl5i15jU=","authorEmailMD5":"38f94e31ac62e70238db3f90b034896d","authorName":"Moon Fisher","authorUri":"","message":"My point is very simple, and it is not a question so I don't need to post it on SO.\r\n\r\nIn a streaming scenario, where you have to consume an <code>IEnumerable<T></code> from an Http streaming response.  After the initial <code>await</code> when the thread starts enumerating, it has to wait every time when the buffer runs out and there is no more bytes available to fully instantiate next instance of <code>T</code>.\r\n\r\nTherefore the notion 'there is no thread that waits' is fundamentally wrong for this simple scenario.  By the way, this is a very common scenario.\r\n\r\nOne possible solution is to use <code>IAsyncEnumerable</code> to address this scenario, but that's something that came in C# 8, so your point was wrong until C#8.\r\n\r\nAlso even if you use <code>IAsyncEnumerable</code> there are only handful of deserializers currently available that return <code>IAsyncEnumerable</code> from a <code>Stream</code>.  Most of the deserializers return <code>IEnumerable<T></code>.  So you are left with the choice to implement your own and get into lower layer to read bytes, parse raw data (json, csv, xml, binary etc) and hydrate your instance of <code>T</code>.\r\n\r\nAt a high level your point makes sense and it may be true for the scenario when all the data arrives fully before <code>IEnumerable<T></code> is returned.  But this does not work for the streaming cases, which is a very common case. \r\n\r\nSo the thread has to wait for a very common streaming scenario that I explained above.","date":"2020-08-21T19:42:28.411Z"}