{"_id":"0a3d8640-d1ed-11ea-ad58-79193f5c10fc","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"f3a68040-d1e6-11ea-ad58-79193f5c10fc","authorEmailEncrypted":"QKb4It2Hl1Bl5KFxNPOhHyZYuBW+5z2rIoiFmO4PVjkFngm6YYSzCyWx6S0s0AjmvIMfqU1YKUJXNrh/n1J+4mbtxNA4bLmoLp6BQFmGng9snaCfiWH8Zein4BGf6HgH8BzGbEKdLJRqCOhMvGArC6Ee5yvrlTqtL7w4IDyuClTpLpCyLKI+OwW+Sw5h9PHc6D0ZhHONrkY6JO9DIQFnw9S4ZsjD2DEKbhrfELvwU4rePLne3iNQQlBPbTcqrGUHKYoomAy2eSOddYNL5UvnO3TRiKmh1sFMFYC7/skZfUpC/ofMVBnpYXPzhB4yM7GpJfIZkR0kd+OCoAnl5PM8itWIZIux0yMnO5Wq513v6jx8Cn3VcGraDvGCtP9Rj2E5yowj91gfYmwyl4GAcmF/7fm8+Wpm2vq4dKKyTg17ziAdjtaIl1bN+ubSrGbBs+8Fu+RWM0Mcg3eCaw3AVKwcop9L2eO1TjNF4B5sj0+jAXE8Ym/TDDIZ+tvkRlH/588IyxQIaTXhZyhgtszZYFpMxLW32ZqVrYanwOflRJCzLHjzd1loFYfAK3pcQBJHLVBhzUsmHPnY0VHPsDcVoSP4yBBSeQUfiSSk8CaJTxvn0wZV7nm0andqoaoaPC6SK1KGQVcLFV6EFIUT6+yJp6gMbhIRQX/FTM6dinfO2aGqor4=","authorEmailMD5":"38f94e31ac62e70238db3f90b034896d","authorName":"Moon Fisher","authorUri":"","message":"\"there is no thread waiting for the next chunk\"\r\n\r\nTrue.  But \"next chunk\" != \"the object I am deserializing\".\r\n\r\nSo the thread will have to wait to fully deserialize the model.  \r\n\r\nThe default behavior of HttpClient is good only when all needed bytes arrive in the first and only chunk.\r\n\r\nIf the result is large, I don't want to consume it until it arrives fully, I want to consume it as it arrives (streaming).\r\n\r\nConsider the case when I want to consume IEnumerable<T> from the response of HttpClient.\r\n\r\nI cannot hydrate an instance of T until all the bytes required to fully instantiate one instance of T have arrived.\r\nif number of bytes required to hydrate single instance of T are more than the chunk then the thread has to wait.","date":"2020-07-29T22:44:20.006Z"}