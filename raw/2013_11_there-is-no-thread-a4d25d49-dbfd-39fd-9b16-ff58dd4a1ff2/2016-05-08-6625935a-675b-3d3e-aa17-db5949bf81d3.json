{"_id":"6625935a-675b-3d3e-aa17-db5949bf81d3","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"CPU-based operations are not asynchronous, by definition. It's true that both kinds of tasks (what I call Delegate Tasks and Promise Tasks) are both represented by the Task type in .NET, but they act completely differently. Delegate Tasks have code and have to run on a thread.\r\n\r\nNow, it's possible to, e.g., have the UI thread *treat* something else as asynchronous, like \"await Task.Run(() => ...);\" But that's not fully asynchronous code, so this article wouldn't apply.\r\n\r\nRegarding Mono, I haven't taken the time to research their implementation. They have recently absorbed large parts of the .NET framework regarding thread pooling and tasks, and are currently in the process of moving to .NET Core. The real question as regards this article is whether or not they use asynchronous I/O *and* whether or not the device driver(s) in question support asynchronous I/O. (On Linux, the device driver is aware of whether I/O is asynchronous or not; on Windows, all I/O is asynchronous).","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"f5f7916e-aaf8-3ea3-8f4e-f04d7352e160","date":"2016-05-08T19:48:37Z","timestamp":1462736917}