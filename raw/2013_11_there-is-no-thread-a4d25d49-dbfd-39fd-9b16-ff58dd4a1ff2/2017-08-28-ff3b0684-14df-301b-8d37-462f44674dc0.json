{"_id":"ff3b0684-14df-301b-8d37-462f44674dc0","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"He's speaking from a language perspective. At the language level, async/await has nothing to do with OVERLAPPED or anything like that. It's just a code transformation. So, sure, you can use async/await to consume a lot of things: asynchronous I/O, CPU-bound thread pool work (Task.Run), timers (Task.Delay), combinations (Task.WhenAll), button clicks ([https://blogs.msdn.microsoft.com/lucian/2012/11/28/how-to-await-a-button-click/](https://blogs.msdn.microsoft.com/lucian/2012/11/28/how-to-await-a-button-click/)), ...\r\n\r\nSimilarly, you can achieve the \"there is no thread\" scenario with any kind of fully-asynchronous I/O. Whether it's async/await or OVERLAPPED or IAsyncResult or event-based asynchrony doesn't matter. I've written a fully asynchronous I/O model in C on an embedded system without an OS.\r\n\r\nIt's the combination of async/await with the truly-asynchronous I/O implementations that make the modern paradign so powerfully performant. All the other asynchronous code patterns are much more difficult to maintain than async/await.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"66589d6e-3555-37d0-8097-af3823ded819","date":"2017-08-28T14:16:50Z","timestamp":1503929810}