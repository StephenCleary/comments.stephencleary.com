{"_id":"d059f9c3-04f8-3224-8b49-5289000e88ac","authorName":"Paul","authorEmailEncrypted":"","authorEmailMD5":"","message":"Great article, though I am compelled to Well Actually you on one point:  \r\n\r\n\"DPCs also execute at a level so low that to speak of \"threads\" is not quite right; like ISRs, DPCs execute directly on the CPU, \"beneath\" the threading system.\"  \r\n\r\nThis isn't strictly true. While ISRs don't particularly have a concept of thread (a kernel developer would call it \"Arbitrary context\"), DPCs specifically *do* execute in the context of a thread. Now, *which* thread, is the question! They are run before the next scheduled thread has a chance to do anything - they are part of the scheduler. Since kernel memory is mapped into every process, what they need is always available.   \r\n\r\nThat word up there, \"context\" is super important - a thread is, at its simplest, a context in which to run code. Async operations *jump contexts* as they are being processed, they're not tied to a specific context (i.e. a thread).  \r\n\r\nIt's better to think of an async operation as a 'message' that gets passed around, and that message changes forms several times (i.e. from a system call => IRP => APC => UI Dispatcher Queue item). Every time this message is processed, it ends up changing forms","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2014-01-26T09:42:39Z","timestamp":1390729359,"authorUserId":""}