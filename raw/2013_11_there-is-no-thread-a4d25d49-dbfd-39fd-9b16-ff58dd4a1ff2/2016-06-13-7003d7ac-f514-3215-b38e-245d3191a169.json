{"_id":"7003d7ac-f514-3215-b38e-245d3191a169","authorName":"Stephen Cleary","authorEmailEncrypted":"sSS2+JNa3yno1oUhIeHkfMYQVlNWKMDeqgDTfUIivDyZJbxSyZqVeo84oXfb1+F5lZzWz/LhNOH87asMSABiNjHa5HTa2hDzwjHA30GUMbDr7hf6B1JBJHEXMsOTIb2L2l/Fexkn4l/8WckfOdgDveRtXgTF9nTB6QycJ90Fit03JvMKetCu0th9fo+VNS8DPCN94z3WHR0H+n+WYDEWwbkmtYJflvg2NK842dhKF0///JKgqe5WoppsBXtG2h47fPKLwmVxoiBkTS55ua/VEtr3ziWMahcJwtbhz1CwSwhEdU5FS2qXKk+/50lprQOntD+ftCUHBVrbbIqtT+tZQdoA33j8f4rdfiTI1k7psITwWb0yr/moPdVsTU13OrUqB0TTk36P0CvVz9Kke7byzetfGO3ZU1q++9b+UrLHJVArwrBlX1rbWw5MKSTeEHobx+OleCBPWLmBhI7aKU5Rg3VdmfDBrxncPSqixSq3re4+MtRWvezKXFQqE1hDFEKG27G7rAYPaGUGbp2q922J2RugfVH/TUJO9+oCZgSPLBkOU/sKuF05wOsYJEJyKwxNed98U5x5FADrsAI93zcMfNIIk40M5ua1GBmvQV0OSQ70R/fqbm2Yd5GBvuRa/NX2Z+PsYvXIBVTeyCDuOJLutHLLTkGfTfTHt3aU9mOSKh8=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"Oh, yes, this article is quite incomplete. Among other things, I completely skipped over how caches influence this flow.\r\n\r\nBut I think we can agree that the idea [that there is a thread blocked \"doing\" the I/O] is incorrect. In my experience, this is an *incredibly* common assumption. When I talk about async to .NET developers at conferences (so these are not even the dark matter developers), it's always >50%; I'd estimate around 80% (or more) just believe that programmed I/O is still how it's done. :)\r\n\r\nI was not even aware of IoIsOperationSynchronous! I knew that Linux drivers know the asynchrony of their ops, but I wasn't aware that was true on Windows, too. I'm having a hard time thinking of a real-world use case, though; any driver would *have* to support async (the hard part), and it *can* support async-only (and most do AFAIK), so why have a second path? Seems like it would severely complicate the code for no real benefit.\r\n\r\nI also didn't remember the details around APCs and threads. Since .NET-based I/O generally uses a single process-wide IOCP, that's the only case I covered in this article. In particular, I did not remember that it had to return to the *same* thread outside of an IOCP; I had actually assumed that *any* thread in the process (sharing the same address space) would work.\r\n\r\nAnd finally, yes, as you (and others below) have pointed out, the IOCP itself does have (a) dedicated thread(s). But this would be true even if the end-user code never called any I/O methods. In other words, asynchronous I/O doesn't take up *additional* threads that are dedicated to a specific operation.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"9572473e-4ff7-3551-92be-614b308d6ca3","date":"2016-06-13T18:42:13Z","timestamp":1465843333,"authorUserId":"disqus:stephen_cleary"}