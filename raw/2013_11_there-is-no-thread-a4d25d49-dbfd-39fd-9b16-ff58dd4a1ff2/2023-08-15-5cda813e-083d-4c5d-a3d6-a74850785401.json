{"_id":"5cda813e-083d-4c5d-a3d6-a74850785401","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"ff385fbe-41d3-4ded-8119-7ec9ec2e02ba","authorEmailEncrypted":"f9yefh9HWiTiFUN8QMo1tHGmAKtiE5WjCzMfb\u002B5VYKpsyiN8RofBLDqhWKhP4yDFW\u002B7bflTMzJqsxOuRBVO\u002BqmNgTeuZZpkt0e3WEmz\u002BdrU2HBD9GDp1fnR/6bWBMKxoEgwW3hFQMNv7RaUZaBOJZ847J\u002BEFjYaFB1WvM4hs/PTamZDTbLhbfya9kvG874pkcizRrRzfnh0cOHRPVKGJJmt9vovkXIntoifWIh8bskvMwjVL4oTK5BHyTpE/lIiffpd\u002BSxVeOtkdwfAZAjeJ7BW0JvZscQ6zJSoptrS1J\u002BozysX9jQY5TjrOh2n2WEbmTohkM7owsV82\u002BgBzQwzm33za4X54dDjqwGgTVeR8f9YSkNS9SHnuJajQOTPfii48Bzzabd8p15Cwbpuyte6wfFlKzMzIuiJzV2vm\u002B6rAPliEhFMfi5Cmta9dwLL6RoMTYUAL5oqLtmASJBh02CDFyooIP\u002BviH7h2iaKw7HbQIkCm2Kkh3RKl0KwArM5vNrfMTfCsNGwUSKnZmYb4Jr\u002BDvuJbXfxv8CHwNyE/zEfOKXdWf4/a/INgeLwwQlELsSxzdXr/PZScQK1kqqZDXWnhokPVBdO0lC/l0F5tYaFjUuHd6YTFiIZgTJpgqdHesB3dVXbsQsD\u002BGJGKlPd954WmvTGeYhjSymJnVNpAya/UA4o=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"\u003E to me a Threadpool is just a collection of OS threads.\n\nYes. A thread pool is an application-level collection of threads. The OS has its own threads, too, which are not owned by any application. What I meant by that was that there is no thread *at all* blocked waiting for that operation to complete.\n\n\u003E this means there IS A blocked thread, some threadpool thread / OS thread is blocked and waiting to execute the APC and to set the Task to complete, and to pass the Continuations of the Task to the UI context. So there is actually a thread or possibly multiple threads (depends on TaskScheduler) being blocked, just the calling thread doesn\u0027t get blocked. It could be one Threadpool thread / OS thread that gets blocked by 1000 tasks due to the optimizations of TaskScheduler but even then we still have a blocked thread waiting for the task to finish executing\n\nTechnically, you could say that, yes. The thread pool (which exists in every .NET process) contains thread which are blocked, waiting for work to do. As I point out in the article, various threads are borrowed to *complete* the operation, and that is what happens here: one of the free (i.e., blocked) thread pool threads is what actually completes the task.\n\nBut those thread pool threads exist - and are blocked - in every .NET process. \u0060async\u0060 avoids adding a thread blocked *on just that one operation* rather than using the existing thread pool which contains threads blocked on \u0022any work to do in the entire application\u0022.","date":"2023-08-15T01:38:47.3536915Z"}