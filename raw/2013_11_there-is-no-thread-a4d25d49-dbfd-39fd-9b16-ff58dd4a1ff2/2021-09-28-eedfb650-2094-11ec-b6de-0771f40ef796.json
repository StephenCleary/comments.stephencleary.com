{"_id":"eedfb650-2094-11ec-b6de-0771f40ef796","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"8a5ebfa0-18e7-11ec-88d7-435a48a028e8","authorEmailEncrypted":"FMLC2OYNPr1OszrdYpHe07SjPT9IAA+OWC+naezfSfpcEOsK4go7C7CUtMkSgZ3cZao2G9Umb+62S+5tbHgKopbwQFQTIM9JyZG6my8OsRgD1DRVrtJLMV0TqDBx6CTkYxCZDqNVOYISClBbN6khvGdKWZh2QaOCV+dIgw92g6ZuA30NzhvL2JQmnL2pq3S62+qVU8dy7ZXK3FWUAggXnrajUSAMywHGC5gfzdd+IMxHwTjLqF6QOhD7tOpVl2gngUHYeBpjvzpp+r+qX/by3f1okdnCVrWh5Wb0llOkKcwJ8k/s+xJojNtdVWqtHqR9wLbhH5vfyExSXijXBLUJeB8r8Jf0AEUNkS/0AT3tRly2Z+7AbGysdKwA65N9RLLYZwcbGekrmfH/On/xIOqj1ft3PBZq5pkJ1E5ZvuX2xE1M6zhZNp8wDwSLg3UnYGoXkMAM8pdnO+DCszDk+yojH6r3m/POgmuA2/xgd5i3IY6q1vL+FGqTfPS904LTpmR28BIHIn2QVBEgLwpONgCb8dNcPHIxKSBdKUSfGn2je0Ehq/OwGJ/haxABDOvLbpDZ/uXjSxiSS9yzv/NI9IrhaynYTdMCFFJYla45BDTclkg2ecSQVQytzbiUfUMUN1MoB2glNO2pg24GVLpeSyyyjPZcfCA8Z7w9uX8N8Dqw3cI=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Your questions are still difficult to understand.\r\n\r\nIf you mean \"can I write an unmanaged dll that uses `OVERLAPPED`\", then *can* do that, but it would be very difficult. Alternatively, you can write a software device driver and communicate with that using file read/write and `DeviceIoControl` methods. You would then consume that in .NET using the IOCP built into the thread pool.\r\n\r\nIf you mean \"can I write an unmanaged dll that is truly async without `OVERLAPPED`\", then the answer is yes. You would normally implement the asynchrony using callbacks, and then consume that in .NET using `TaskCompletionSource<T>` .","date":"2021-09-28T19:47:37.852Z"}