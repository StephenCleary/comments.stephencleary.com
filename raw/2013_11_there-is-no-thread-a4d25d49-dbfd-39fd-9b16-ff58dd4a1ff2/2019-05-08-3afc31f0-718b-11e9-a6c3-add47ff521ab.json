{"_id":"3afc31f0-718b-11e9-a6c3-add47ff521ab","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"http://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"67aae750-0ab6-11e9-9bb1-17a44b157a7e","authorEmailEncrypted":"YWv9B+iOruWgm08tkWZJBFDBN8bChAPMzZNdWyU14HJVf0EMFNbdQiRMpdH5a+EGQlOI3F4R2+Kw0itadRL1nr4Bw5EaPy7qsifSUiBUWdkgKiP+d1l3/TGrTXtXiTCX8HTVZoEnr7/NjNTsM0VdLkMEkr09AcNIog1FU967R5/qk2m4bJH3+HbZ4Ok3nGOQKfhKam3BtAh4ejt/8JPzDGomEs7GHF8UIpvunhsuSyAejO8iMbT91In8oeb9rYcMmU7md0sA3MfouHNKiAe8hfcVmdKqEzB36aNp5zUKjA2kr1yzhj4Ep2sVHWcvWugUhw5S+qrkuxkLE+S+eIVzPyqxZeXIDOIefnpPJWRXeGvje7nPHmFyfj/Iw6lkf4DqK31tF5uCDu0/wvGKDh7o1H7vN84sbg6zGuYguJ9lTsRo+t2QQRKQKXqDvJvbB8Y4+1kXfgJ8QD/ORNULXDy4OpG+n82AJ+G6PJXwy5PGv1WAauZ3ZJ5jsHnSbk17NR6p+FL78kkKaIY6TTAAEFIhR20RaS+xv/4NXKaTm7Th99hzWlj6gEIWtSylKMalZuJY6KVTJTvVbdINQKaiYMRfMIHFMt1xE/Q/BejKJvlSVkaW+ZqPmJhfVmBgVr/dikeztq/TCcdxnHkLWyYqFWb6eHmEyCBjCE3UMWuY6iJAHW8=","authorEmailMD5":"5441945c65e3a98df2e7a91dc7e9118c","authorName":"Alice Bevan-McGregor","authorUri":"https://github.com/amcgregor/","message":"Python support for async methodologies has seen some interesting improvements in the last few years. Core language support for \"async\" declaration of most control flow (\"async def\", \"async for\", etc.), \"await\" as a built-in statement, polished up \"asyncio\" (\"aio\") libraries (https://docs.python.org/3/library/asyncio.html) and a growing ecosystem of protocol implementations, servers, middleware, and bridges/threading interop, such as: https://github.com/agronholm/anyio â€” the future is bright, and lacking in threads unless absolutely required.  (See also the concurrent.futures implementation of that pattern, too.)","date":"2019-05-08T12:17:22.091Z"}