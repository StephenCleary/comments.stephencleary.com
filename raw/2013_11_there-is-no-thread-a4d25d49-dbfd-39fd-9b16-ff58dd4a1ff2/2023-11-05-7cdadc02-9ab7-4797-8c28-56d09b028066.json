{"_id":"7cdadc02-9ab7-4797-8c28-56d09b028066","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"2f309c8f-c1b5-364a-862c-980332c3d6a7","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"George","authorUri":"","message":"\u003E The key behind truly asynchronous methods is that there is no \u0022work\u0022 to do. Thus, no need for a thread. If you, e.g., asynchronously read from a socket, then there is no thread that has to periodically say \u0022is there data yet?\u0022 Instead, the task acts like an event callback; the networking layer will tell your app when there\u0027s data.\n\nNo matter how many articles I read I still can\u0027t wrap my head around this. Especially the part: \n\u003E there is no thread that has to periodically say \u0022is there data yet?\u0022  ...  the networking layer will tell your app when there\u0027s data.\n\nHow is this happening? If no thread is used to \u0022listen\u0022 to that notification from the networking layer, where is that happening and how? I get that such an operation does not need to block a thread in order to be performed (because it is happening in the tiny CPU of the network driver, if I understand correctly from what you said in another reply) but what is \u0022listening\u0022 for the notification that the operation has completed so that the result can be picked up by some thread? Something has to be checking whether an operation has completed or not, right? Otherwise how can something get the notification that the operation completed? ","date":"2023-11-05T13:09:50.0696592Z"}