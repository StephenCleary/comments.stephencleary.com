{"_id":"a8dd8eac-88e2-3dde-b645-4a475a8dfb1f","authorName":"Stephen Cleary","authorEmailEncrypted":"YBH3YtXzrG/gwL77fKgzpy6IK9avXCEuQmAGd9JbSfRQeAshMOy1TPRMbhzMzGJ4thLfIQUG+0J7SiskOlLpYt5v7KXbJmgrE2lo2NldRw/svEaOKaITMewmoNzgTBYHFVLT8uUuzFsmC5VTK+6nGulN3Y02NUzsx93oraXl7bxPbWSkxTJNDI2m1Oy8za828XLYf3VwO7ck+UVKrjBXB1ADLCukV7WYoSS6Prsa0SeQLXSAI0DkxpNJQwFZJl8pK2bQcZvsUDde1A7UjwUMCHPp4b3KvsMBAOiiZq2M1ZjP9H9VOiZgQRyGXcPyJxo2x/kjjafciPozQlRzopk+ivzkBGRqAWUjgyviy4tfAO2PrZqI30I4fzX++Hu2gat3N1hUj4GQhzRDM9HT+svBIxBdLjV7vxKbns1FT6oBzoQ+p/GEy2fLB1rnco3pGrEsd0ehLZ0eIgXSS0ylm6jvN3SS4zYUtXU4ZY3nv1I0ypxR/WMq/mCMw84v4aCjgBR6/zl560gVhEd+7HAbqaV9gU0xB970Z3F7t9wta0drdoG8Nocpe4De15wrmxZo0/+kC1k1ycne3HUw5x2ePDtUyLrTP02VSf+2xYgfuEg1nMBAc5crJe2jC4WtlLLB2xrMuRUIb7Ju/jk15Oo+FpE8LzJwlUK/ucC+0nLHjAIUMS4=","authorEmailMD5":"28dde5772b48c92e08b8050411aa5ba8","message":"(Copying from my answer two years ago; the blog migration messed up the comment threads, sorry!)\r\n\r\nThanks for your comment; I love the \"message\" description!\r\n\r\nBut I'm not sure I agree with you re DPCs (not that it really matters; the details of semantics aren't that important in this case). My reasoning is:  \r\n- A thread does not have a DPC queue, but CPUs do. A DPC can be scheduled to a specific CPU, but not a specific thread.  \r\n- DPCs are executed (at IRQL DISPATCH_LEVEL) when the CPU IRQL is transitioning from a higher level to DISPATCH_LEVEL or lower (e.g., PASSIVE_LEVEL). So they execute before normal thread code can resume.  \r\n- While a DPC does execute with a thread context in the narrowest sense (CONTEXT), it does not execute with a valid thread context in the broader sense (able to use the security context of the current thread). So, they may execute in a thread context, they must be written to run in an arbitrary thread context.  \r\n- A DPC is still very constrained in the code it can run as compared to code running as a part of a thread. In particular, no page faults are allowed.  \r\n- Interrupts are masked while a DPC is running.\r\n\r\nAlso, these quotes from MS:  \r\n- \"The system schedules all threads to run at IRQLs below DISPATCH_LEVEL.\" (\"Scheduling, Thread Context, and IRQL\", [http://msdn.microsoft.com/e...](http://msdn.microsoft.com/en-us/windows/hardware/gg487402.aspx \"http://msdn.microsoft.com/en-us/windows/hardware/gg487402.aspx\") )  \r\n- \"IRQLs at or above DISPATCH_LEVEL are processor specific... IRQLs below DISPATCH_LEVEL are thread specific.\" (ibid)  \r\n- \"Code that is running at PASSIVE_LEVEL is considered to be working on behalf of the current thread.\" (ibid)  \r\n- \"DPCs ... are always called ... in an arbitrary thread context.\" (ibid)  \r\n- \"Before a processor returns to processing threads, it executes all of the DPCs in its queue.\" (\"CPU Analysis\", [http://msdn.microsoft.com/e...](http://msdn.microsoft.com/en-us/library/windows/hardware/jj679884.aspx \"http://msdn.microsoft.com/en-us/library/windows/hardware/jj679884.aspx\") )\r\n\r\nI came across these quotes while trying to find out whether a DPC actually counts against the current thread's quantum. I was unable to find a definitive answer. :(","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"d059f9c3-04f8-3224-8b49-5289000e88ac","date":"2015-07-27T16:36:25Z","timestamp":1438014985,"authorUserId":"disqus:stephen_cleary"}