{"_id":"2f309c8f-c1b5-364a-862c-980332c3d6a7","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I think the disconnect is here: \"I create an async task to do some background work.\"\r\n\r\nTasks that do background work (e.g., Task.Run) are not asynchronous. The UI can consume them asynchronously (just like truly asynchronous tasks), but they represent synchronous work to be done on a thread pool thread.\r\n\r\nRegarding thread switching, there's nothing special going on. Threads and CPU scheduling are handled at the OS level by the preemptive scheduler just like always.\r\n\r\nThe key behind truly asynchronous methods is that there is no \"work\" to do. Thus, no need for a thread. If you, e.g., asynchronously read from a socket, then there is no thread that has to periodically say \"is there data yet?\" Instead, the task acts like an event callback; the networking layer will tell *your* app when there's data.\r\n\r\nSo there's actually no switch away from the UI thread at all; the UI starts reading from the socket and then awaits (returning to its event loop). When the data is read, the networking layer calls back into your app, (eventually) posting a message to your UI thread, which then resumes executing that async method as a result of that message.\r\n\r\n(the details are a bit more complex - there are some threadpool threads used for extremely brief periods during the \"notification\" phase - but this is the general gist)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"38b7b886-2a53-3900-bd7b-6a2588f633b6","date":"2018-02-08T18:47:40Z","timestamp":1518115660}