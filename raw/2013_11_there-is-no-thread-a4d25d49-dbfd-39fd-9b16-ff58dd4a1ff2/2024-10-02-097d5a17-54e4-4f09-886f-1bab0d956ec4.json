{"_id":"097d5a17-54e4-4f09-886f-1bab0d956ec4","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"UrXHqvn/Li8hJMCJbI66YWnkGHmOBJzsNuh82fg8i3AcLKGn7RjAql5n6hwBoZB287LM8S0eyb2IzOhCe82swzFoFhEVLoEKL72gx6gjJtD5IuaOT6g6nFrINHWLCJz7RJUH5ju111OWWi/6GPb8cHS1lD3BHzuxEMaNpgFVsXK1Ztb2a\u002BZfB4H38Vh5GlT7GP/tOWllIDOXNxg0pWGbl/RcRNzatzXgxjjtI9NKdImjoEHzsHKPDzLlctGQ1Tpc\u002BiAqyyZDPrG/ptfELX/fQF\u002BUEZX1l/47uTFCjklH4IRiqGlE8vHM6UK9USH0Jj6R2UlJpRVLlxxVJ0kgV\u002B5DgjqMLmuLbGkk\u002B/s4141DwlC4/mQ0IX2IIE5aY4kK85IWat4j43rCKDQedrLNkM1JV\u002BAzEuda6vX5GEdOXr8kP5EDQ4ctMAW41jgtF0XNNshaKZrqwMtXHLnSQVzF1EbW0gUlSOZrRrlg1yOaNqmR9p0IZ3TraIdTzlQBK0Iz\u002B6C9BSfdIZ3DtFrwGeZx4znkywg6MT8gV\u002B4oyuAZtuCGeRlWwLnN5bgr1dZlrH/KnjR156MtD7M6U3FAQGvBSypK9qtq12ew\u002BMJlGbdpOm\u002ByUExn2lSVuwqJ8tNo6XP3TENHYfmYD4thX6Aa4LyrlGWMwLHPM3X0ClE\u002BoIrkp6trEs8=","authorEmailMD5":"a0bf0e3b85927b20b5c03efb74612051","authorName":"Ken","authorUri":"","message":"**Thanks a lot for sharing!** \n\nIt took me quite a long time to understand one thing: The blocking behavior of \u0060read()\u0060/\u0060write()\u0060 system calls is just a illusion that OS provides. The **\u0022REAL\u0022** I/O operations, just like you mentioned, are always not blocking.\n\nI think these questions also help with understanding:\n- If I have a thread currently being blocked/sleeping at \u0060read()\u0060, what would happen next?  \n*The OS would wake it up when the IO completes.*\n\n- Then how does the OS know when the IO completes?   \n*CPU receives interrupt from device controller and the OS code handles it.*\n\nSo my conclusion is even if you have created unlimited number of threads, the OS still relies on the **async IO interrupt** to schedule them. i.e. When to wake up who.","date":"2024-10-02T09:21:11.0724777Z"}