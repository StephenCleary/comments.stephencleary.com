{"_id":"9572473e-4ff7-3551-92be-614b308d6ca3","authorName":"Foo","authorEmailEncrypted":"amR/nQJg11zIFAOqgqbjN2xJQ4GUrjdaXwHX9Eb3FtIV2uFt4rdueZj/4W2l+bllH95JXGjaGEgm0OKALetH8JW5lL+rjkPWY3qcdY4+clxGaZsyD2D2wKcFZm+GVaYhUp5j1tQ8kRShcIUvTsS2bwkkgSKC41guixfyfBBFvs9tzSzMqnkTlGK3IoqPVHd6b23sYWeTrtCrwOcuafYsomQsYdqXCjykjto8hynvY5l1obFW9kZ8m+UlIF016Q8HP4peDMd/JkqjoYJRYpIDupNs+BUaiG4DQ896GEzV0sb2RQZZdaVYEbGyUTx3nj1rx+nKCZJHV/ioFoIULcji1Ktr89ZCAx5p0lI9rTiKQwa0WS2HPf5BDQjSmHflocUIFX1xQ+A0vw2UPDUyMOrSyhe97ijeZHGsiFoBVoAXLUW00BqJQM07th6WsEsXlXS3iuq+UFg+mQ/w+e3uviRy6EbHUY3+7gNnJLnDMDUbx+f91sN2s3RdwV5ZDTdX+O+E9LdlDKwQXOKu0z+ZwP7mJC9EKKXSAjIR1C22dbRY5J2o1qgr32ASeWBLuMtzK/XWtYTdQxW3LTt9IVdshd244Cd222UMXSRF/waejUstaKE7b4Uo5eoK2D2JiJnjOrIU6Wxr8rsN49C35zKPYxY2b//xnagdFU4tu0L4Hx5zRjE=","authorEmailMD5":"2b225b0dd03bd728a5d1e51c031a34a6","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"There is a thread. There has to be a thread.\r\n\r\nThis was an interesting read, but I think there a few inaccuracies in it.\r\n\r\nFirst, the quote from Windows Internals. It's wrong. The driver chooses how it handles requests. It can ask IoIsOperationSynchronous(Irp) and if it is a synchronous request handle it synchronously. What is true is that when Windows passes the request the the driver it has to be prepared to receive STATUS_PENDING (even for synchronous requests).\r\n\r\nSecond, a thread is needed to perform the special kernel APC which copies data back to the user memory (assuming METHOD_BUFFERED). This is either the thread that performed the request (if you don't use IOCP), or any of the threads associated with the IOCP if the request is associated with an IOCP. Note that if the request isn't associated with an IOCP, the completion must happen in the originating thread, and if that thread is terminated before completion the I/O is canceled.\r\n\r\nI'm willing to stipulate that in .NET IOCPs are used, but that's just lucky. If it weren't for that, you wouldn't be able to terminate a thread that made an asynchronous I/O request before it completes and still have it completed successfully. So threads matter.\r\n\r\nI get that your point is that there needn't be an EXTRA thread for every asynchronous I/O operation, but some thread is needed - those thread that you say were borrowed had to exist so they could be borrowed...\r\n\r\nAdditionally, there certainly was a \"thread that was blocked, just waiting for that request to complete.\" If there' was nothing to do the IOCP threads were blocked. They weren't waiting ONLY for this specific I/O, but they were waiting ALSO for the completion of this I/O operation.\r\n\r\nIoIsOperationSynchronous: [https://msdn.microsoft.com/en-us/library/windows/hardware/ff548443(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/hardware/ff548443(v=vs.85).aspx)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-06-09T23:27:11Z","timestamp":1465514831}