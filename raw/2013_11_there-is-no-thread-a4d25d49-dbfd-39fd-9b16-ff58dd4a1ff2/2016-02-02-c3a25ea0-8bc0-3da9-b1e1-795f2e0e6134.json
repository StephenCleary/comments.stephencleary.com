{"_id":"c3a25ea0-8bc0-3da9-b1e1-795f2e0e6134","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"It is possible (though rare) to write an inherently asynchronous operation in C# alone (using TaskCompletionSource<t>). I use this to write things like asynchronous locks in my Nito.AsyncEx library.\r\n\r\nHowever, when you're consuming an API, the situation is a bit different. An API method is either asynchronous or synchronous, and there's nothing you can do as a consumer to change the nature of the API. So if you have a blocking API, you can't consume it asynchronously - that doesn't make sense. If you're writing a UI app, you have the option of pushing the blocking to a background thread, but since it's the actual API implementation that does the blocking, you can't entirely avoid the blocking.\r\n\r\nIf you would like an asynchronous API, the best thing to do is let the library author know.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"923aafa7-8632-33b7-8034-5667f92234b8","date":"2016-02-02T15:04:30Z","timestamp":1454425470}