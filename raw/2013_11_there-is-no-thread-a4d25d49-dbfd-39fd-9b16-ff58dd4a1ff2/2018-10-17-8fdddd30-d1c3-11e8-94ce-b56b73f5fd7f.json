{"_id":"8fdddd30-d1c3-11e8-94ce-b56b73f5fd7f","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","postUri":"https://blog.stephencleary.com/2013/11/there-is-no-thread.html","replyTo":"","authorEmailEncrypted":"gcmtIkmlbLU0gjPo3kUU8tEG6hHYdKpdlxZ4tuvclHfzpMIk2P37GNOXgf5x3QboJoOuvrjLRwXnxK+64RB4DaogtuL4+gzOBqDkeB8BiFsglcdZG8YMK6x7JZCxcQXabtXOwjDGIZ32TZJq5WjcVXzEgKQ3MrLzPnDiLiiFM2Tpvtd8iZBLP/tyT9xiISM4gfLNdxsJYRXJTPmtI6tMCT2Bfe/AF1dELEQOmylIZ4R1hZunUK8gIzeZxqbCOm2uDP5/+wjz6oAmMR5nQZHGwVeEpPPDdo7iFkncNGPwPOjDHeUHt9agKBEt/x2zgAVgo/eV5b8Ep4Wa4UlpRfX33Zp1PmgtMmv35np3U8BfNoBT2K5o4cA0N/wXVujuInfFpDSvDrQzv+zql3KTL8rNgkOKlAGB6rxWxSbp5uTBgp84ACM51keqhOS1YEVRixznr52VLXGe+3bMPrPcrx426cGY5R4WUcyIurk2WuEF5p0U4WW7Q3sM/BSgKnxc7rxUldXbh86N5EqB0N2Grf2dyFvzoQLEF06JTXylNbSmsdpKNXlFlMPmRR188SUTeQ9xtxn3kAjkPJRkJA1rcC31SnTt2ChfusnmiMC3fgfob/un+DUFNjfLfllihMqDkin9SjHf7YWrqAS2fGUAblMumPSLk10OfEpC4ljXifC+hKA=","authorEmailMD5":"fbd0de6ca98b9ab6d316ee57c4239058","authorName":"Mark","authorUri":"","message":"Could you help me understand the limitations of the \"There is No Thread\" scenario with regards to this this Microsoft support article (https://support.microsoft.com/en-us/help/156932/asynchronous-disk-i-o-appears-as-synchronous-on-windows), which says:\r\n\r\n\"On Windows NT, any write operation to a file that extends its length will be synchronous.\"\r\n\r\nas well as:\r\n\r\n\"The memory manager in Windows NT does not provide an asynchronous page fault mechanism to manage the file mappings used by the cache manager...so if you issue an asynchronous cached read, and the pages are not in memory, the file system driver assumes that you do not want your thread blocked and the request will be handled by a limited pool of worker threads...Because the pool of worker threads is limited...If you issue a lot of I/O operations for data that is not in the cache, the cache manager and memory manager become saturated and your requests are made synchronous.\"\r\n\r\nIn the first quote, it sounds like that the user thread will block until the write operation completes, and in the second quote it sounds like either some kernel thread or the user thread will be blocked waiting for the page fault to complete, depending on load.\r\n\r\nSince, in my own work, it would seem to be harmful to performance to use FILE_FLAG_NO_BUFFERING for reads, and pretty much all of my writes are appending to the end of a file (and even though I may know what the final length of the file may be, I can't use SetFileValidData() because my application does not run with admin privileges), does this mean that I would derive no benefit from using async IO? At least, no benefit that I couldn't achieve with just Task.Run() on a sync IO API call?","date":"2018-10-17T04:17:30.237Z"}