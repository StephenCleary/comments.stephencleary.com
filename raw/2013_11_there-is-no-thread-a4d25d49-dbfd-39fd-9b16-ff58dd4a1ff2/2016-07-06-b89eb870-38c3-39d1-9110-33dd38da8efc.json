{"_id":"b89eb870-38c3-39d1-9110-33dd38da8efc","authorName":"Andy JW","authorEmailEncrypted":"WOA4GE2XMXSYRbbJrdp+Np1dRT67BrNIzGDHRqpkp1udOjCEtIVvLJ3bfVRl91M7/z8cwAetUS5k4oBPE7nLzZ85ZqP1yZ5HUbqFEplNzuJ/mpAr271ggdkAbBOSrz6ySg7Xbi2nDpKu9998c2gGvWjoC2GDUXPWB1FGsyvf2fgS+dhqRuAzVwFmBYmq74nKb49f53k67PkCoJWGwdiEFwxsnC0dD/Na+97l3j9nw/oBjVl0z2z2r7Dq6ZVzXUoRIPJODDpHoNh6adTUTYWNbN+oKIUDnByB07136tNThH2OGa9pQI+HlYW2eR1gKL1bXEnMIMH+cAW857cHRmSXw9kHdUlxLaVIefZwNTI8QfCNMe1WzXE9npukiZ2BGu7nha+onbruuaZ2qa1tzRExjZUhLbp36obzqTOXlz8crpszUdntJcUu2NfO6rPlPdqwnucde6M5sonHacKB0TOUb7bdrlkp2/k90MTragw2Qs1dEAU0B4o8Xw6BQGb4fL7/aggYmUYNTRFHXkyM+5G3a4xlqmPo+hyFuW3zeTNyvRXuVjc7zi55t5i19wLhsfuN22wxhAF8V1BOg6g4bPvU7YflWT9sxMHLpDX/w0P3V6PsmVRvDyDmTTc+uRCQRZhMKLR2cOxRDP3rL+UcS7a9EOjpNU6rejfC44YWokeJNx4=","authorEmailMD5":"7a2c32431708704ac32f2e2637ef6b48","message":"Great article. IOCP's are a kernel-supported concept in win32. I am (or was) among this 80% naive you speak of because my conceptual education in EE/CS was the traditional model wherein the thread (or at least a fork/clone somewhere down the line) is blocked and put into the non-runnable state by the scheduler until the ISR is ready to toggle this. And we're taught that it's perfectly acceptable to use a small stack size for these blocking threads, with the only price at the end of the day being the context switches. I would make an argument there is nothing really wrong with this, since even with APCs you need to have one of those I/O pool threads get around to you anyway. Now, supposedly, the only equivalent to IOCP in linux is the epoll. The critical difference is that you implement this yourself at the application level. So it sounds like the exact model taken in win32 is the same pattern as what I would do if writing my own app-layer in posix. I might spin up my own pool and loop over epoll, and I might use the results to feed into a compute work queue, essentially achieving something very similar to .net async TAP.\r\n\r\nNow given that posix epoll is a user-level concept and IOPCs are a kernel-level concept, I do wonder what the port of .NET to linux is going to do. Will they basically implement the I/O completion pool as their own layer on which they will build their .Net I/O primitives? hmmm","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"","date":"2016-07-06T22:14:30Z","timestamp":1467843270,"authorUserId":"disqus:andy_jw"}