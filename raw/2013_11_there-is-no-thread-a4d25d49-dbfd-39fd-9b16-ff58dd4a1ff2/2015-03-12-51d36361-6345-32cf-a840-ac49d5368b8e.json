{"_id":"51d36361-6345-32cf-a840-ac49d5368b8e","authorName":"Stephen Cleary","authorEmailEncrypted":"ucnpC4yEx2JLKM2+pFkuT/3maiPvtjZVfJEHUYHpgxSjgYyCelWmsRCEJZyGXjEfBaBIGOs7XOdyjsvxe/qSJSnuJrI4+Hj+UqyjZN1GSH9dShFQPSMjB7aKMpHPnbE13Wz30gk0xElJpnbSjeo4GWEDEkGqQ3NHZLfn+yVheEzRFF9vLrP6oMKx2kDz0bqTIXMQfPrOwfBeDVH9J7teRAlAYiTbP39PNxjEwnwcd0aFsZ3So0iFypwve+EzAQzolYT2F4c7PkT8UZ4JnI7/dx1E6rJ9SpZ+XOkOCssrxcwZK/eliM7KNCbG3BPQeUKQQy1dqIQk/ReUmFpb/09lUD7iZLz3iJ8fvbqVN17e0RFdDYWMJ5o9yPxGv6p3QyhLHVNJRnMrH02lezUER9EgUCKic3p9KRYhY9Dw13IGdoQF5j5kVSoBQS/ZwrQY48VkPAVIDb4vQM7qw36F1F5SFiHJMdu7giKjmvdta0bHg7Xq6ijj7aAR1XTlL804Pt2DQ42uHgzxRb3KuJoh6MI4z+OlE10dM8+R6yee4eici02R5CfUO6/HOylqiCfZrgu4PoOkBboHYHcDocrIjEuvvrDeqN/yYGsPWbLHqhvTG1fHC8yFLl2aUKyd4MU39FZkKKtyu7QEHJcYUMBNe27mXpIRaBUBIROTROKulcH+AYU=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","authorUri":"","authorUserId":"disqus:stephen_cleary","message":"Yes; a method marked as \"async\" may only become asynchronous when it performs an \"await\". I assume at the end of your call chain, you'd have an async method without an await - and the compiler will warn you that it will execute synchronously.\r\n\r\nThe core idea to keep in mind is that a method should only be marked \"async\" if it has asynchronous work to do. If the method only has synchronous work to do, then it should have a synchronous API, not an asynchronous (Task-returning) one. So, in your example, the entire call chain should be synchronous, not asynchronous.\r\n\r\nNow, if you're in a UI context and you want to avoid blocking your UI thread, then you can *call* synchronous code asynchronously by using Task.Run. Task.Run will synchronously block a thread pool thread, allowing the UI thread to treat the work asynchronously. Note that I recommend using Task.Run from the UI layer rather than in the method implementations; this approach has two advantages:\r\n\r\n1) The method APIs don't lie. They have only synchronous work to do, so they expose a synchronous API.\r\n\r\n2) The methods are more reusable. They won't force work onto background threads unnecessarily, i.e., they can be called directly (synchronously) by code that is already on a background thread or from an ASP.NET context.\r\n\r\nI have more info in my \"Task.Run Etiquette\" series: [http://blog.stephencleary.com/2013/10/taskrun-etiquette-and-proper-usage.html](http://blog.stephencleary.com/2013/10/taskrun-etiquette-and-proper-usage.html)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"f6883af5-6da0-3dd0-9cba-ac5148b6758c","date":"2015-03-12T13:36:05Z","timestamp":1426167365}