{"_id":"51d36361-6345-32cf-a840-ac49d5368b8e","authorName":"Stephen Cleary","authorEmailEncrypted":"rwxQyQYbCoGg2ub4UwBXusdRhfBfJrTDkuLo3Rfe4OUbilqOREbcqO0tF4H1XY4KNwSQfYKiWeVDfn+g9CmsRhrqwgm5JxWzoHjWbG/SdpQVlWolGXEKsxMPhKYRhIKwyDPkKC6c+Bl9OM4f6+DPZlyJzC+mUH0XSYB+fbzoxS+R5khlmpC03WKhYy9lKjtnwWVnvmYlVLJlSeVcC6NSBDBur2qZcu/FZ+XWmHuWmxLcTfeestqpmjSJ1ed9Cj41q4f49w+wWJI/rpFr4kQ5/em7/jqgROmGofgain6pK5eobeVVspZk9zAy6xh0dl5ApBen+5Rd50RAIRu8uN1ZUDUEdHQot43xZBZBUBwlPe5fiKM/Qm5lpiiWO4fF7BIIOsY9VlQGk7CFMho2u0SWHBl03Tt9hY+zhUkiBrWzePrhYlLuUsi/aoAHYcMKOEoMnooDOo4s++4sPcFNU99drf/bHFExZ9lxNJ04aDaY1KfnN2WSdkTs7JI41Y+/FOQSa+/E9ZyRsj+mHaiXINuOXIZwEYK1cNbj/tBa5ftZrrqYJaxw5wgB0it3OV9gW6WeWj1p9Q66z7FqcY8X3FRJIvfa5NhR3e+9LNmxT2rSMXpotoExGebmyaWIv//9YTn1WwKu/+ierDp9cQ2OjhecEeJ+4eGIOzAYFyNlbK2BSlY=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"Yes; a method marked as \"async\" may only become asynchronous when it performs an \"await\". I assume at the end of your call chain, you'd have an async method without an await - and the compiler will warn you that it will execute synchronously.\r\n\r\nThe core idea to keep in mind is that a method should only be marked \"async\" if it has asynchronous work to do. If the method only has synchronous work to do, then it should have a synchronous API, not an asynchronous (Task-returning) one. So, in your example, the entire call chain should be synchronous, not asynchronous.\r\n\r\nNow, if you're in a UI context and you want to avoid blocking your UI thread, then you can *call* synchronous code asynchronously by using Task.Run. Task.Run will synchronously block a thread pool thread, allowing the UI thread to treat the work asynchronously. Note that I recommend using Task.Run from the UI layer rather than in the method implementations; this approach has two advantages:\r\n\r\n1) The method APIs don't lie. They have only synchronous work to do, so they expose a synchronous API.\r\n\r\n2) The methods are more reusable. They won't force work onto background threads unnecessarily, i.e., they can be called directly (synchronously) by code that is already on a background thread or from an ASP.NET context.\r\n\r\nI have more info in my \"Task.Run Etiquette\" series: [http://blog.stephencleary.com/2013/10/taskrun-etiquette-and-proper-usage.html](http://blog.stephencleary.com/2013/10/taskrun-etiquette-and-proper-usage.html)","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"f6883af5-6da0-3dd0-9cba-ac5148b6758c","date":"2015-03-12T13:36:05Z","timestamp":1426167365,"authorUserId":"disqus:stephen_cleary"}