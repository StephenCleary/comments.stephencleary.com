{"_id":"51d36361-6345-32cf-a840-ac49d5368b8e","authorName":"Stephen Cleary","authorEmailEncrypted":"R8vXNxIAxfX+yPAPde9OxUTGEBup+LBS53/vcx7eIIfP8LGS4WFLMK2PxbQDW94Gvgc2B88pUnUt1elUt6sc+UL9ZJGcSbOUpmwpq8nyDlSfuMItGee/8tzXF/DDBMomf8Gwa5MsEBU/QNcN0DUdwO6lHIQVrwFN+qkt9jERu23J6JLqMOw4cgwXrnpdBC50l15j97JgvA9YQ/pEU/MPg16wKGUjXq5A8fIGOurchBvmJEYXrEad/wyMxvUItNkk2aC8JldKVCtWEZJxU3x/XuRuO0LdTM1bX0TGyzHj66yyMtgHeDUBuK4kCfUxzjqE4w6PFJ1oZCT6vco+r1Dbrq0LY9P9IP4yCc079Bwuohhl11HwrxL/MWGb67neHFxPYMLiz6mBfTsi41WZY39IEqRc7vrt2D+so9DUCo1AIzJ3u5Hy6WoqAk5N365LYoV6g1XLtsmZOQQO63AACI3mdh+Ys5FOYylY1OGUOytsBegQi8Gbg9APVjYsDGkxp8TYo82Hcym6ZlOMFp3jyWuUN8llIwbt5ksSf/OT9HHcP0CnCCbJ/Fb2waZnA9WU3UO/Rlpc9lukY52+j7cS7Ukoz7koP8awMJ+VYc3zIWSHsbbfSNh/2mhRQLfCHjAA+uzAffSKQjNYjFntikQaZ66q28IgK/IRrZrLvIHAcz1dMw4=","authorEmailMD5":"28dde5772b48c92e08b8050411aa5ba8","message":"Yes; a method marked as \"async\" may only become asynchronous when it performs an \"await\". I assume at the end of your call chain, you'd have an async method without an await - and the compiler will warn you that it will execute synchronously.\r\n\r\nThe core idea to keep in mind is that a method should only be marked \"async\" if it has asynchronous work to do. If the method only has synchronous work to do, then it should have a synchronous API, not an asynchronous (Task-returning) one. So, in your example, the entire call chain should be synchronous, not asynchronous.\r\n\r\nNow, if you're in a UI context and you want to avoid blocking your UI thread, then you can *call* synchronous code asynchronously by using Task.Run. Task.Run will synchronously block a thread pool thread, allowing the UI thread to treat the work asynchronously. Note that I recommend using Task.Run from the UI layer rather than in the method implementations; this approach has two advantages:\r\n\r\n1) The method APIs don't lie. They have only synchronous work to do, so they expose a synchronous API.\r\n\r\n2) The methods are more reusable. They won't force work onto background threads unnecessarily, i.e., they can be called directly (synchronously) by code that is already on a background thread or from an ASP.NET context.\r\n\r\nI have more info in my \"Task.Run Etiquette\" series: [http://blog.stephencleary.c...](http://blog.stephencleary.com/2013/10/taskrun-etiquette-and-proper-usage.html \"http://blog.stephencleary.com/2013/10/taskrun-etiquette-and-proper-usage.html\")","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"f6883af5-6da0-3dd0-9cba-ac5148b6758c","date":"2015-03-12T13:36:05Z","timestamp":1426167365,"authorUserId":"disqus:stephen_cleary"}