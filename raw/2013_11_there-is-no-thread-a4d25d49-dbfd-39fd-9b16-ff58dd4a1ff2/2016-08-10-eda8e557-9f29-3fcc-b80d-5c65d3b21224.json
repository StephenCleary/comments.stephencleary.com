{"_id":"eda8e557-9f29-3fcc-b80d-5c65d3b21224","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"It's going to be awkward due to the unmanaged/managed transition. OVERLAPPED is an unmanaged structure that must be pinned in memory for the duration of the operation. It also only has one callback pointer with a single data pointer (though you can extend the structure to include additional data, such as more callbacks).\r\n\r\nFrom a high level, they are similar. You can see a lot of OVERLAPPED influence in the IAsyncResult interface, which is implemented by Task. However, OVERLAPPED is pinned unmanaged memory, whereas Task is a regular managed type.\r\n\r\nIt may be possible to create an awaitable extended OVERLAPPED structure, but I'm not sure if you'd get any real benefits. You'd still need a managed type that you can return from your asynchronous APIs.","postId":"2013_11_there-is-no-thread-a4d25d49-dbfd-39fd-9b16-ff58dd4a1ff2","replyTo":"579cb753-63b9-3665-8f9b-5ccbdcc96f58","date":"2016-08-10T13:58:01Z","timestamp":1470837481}