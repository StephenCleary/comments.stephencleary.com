{"_id":"f4596360-f1df-11e8-b68c-e5773aea49b1","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","postUri":"https://blog.stephencleary.com/2013/08/startnew-is-dangerous.html","replyTo":"ad149ae0-ed77-11e8-b1dd-337f40a65949","authorEmailEncrypted":"ktaTbI7LW/CvftNK7jdwtjQKAMLCYpVZlBAdExTEmCnjA3owd/1e1yIPVTuG1t9t1L1UjwLcGkDYnoGgu05fZ3a0owribVnywyW/6AcSYDyZ9g5KkrUsKB65SINiVoV5OTsQyPNsuAQhKwqYm6mhTmXH5FNLictXbgejfFhVdMRcVxERYigB38D/C3ijNIzr/OEtpCMqO/kO1f9hmRtv/a6Mp1iUiLKxJ63TWkEdp+Nzly2vNWsugz5lrrgudHVafbEcqyCf6Fc0Ps6cpAsEmLkxg36ckvLfQt2OmG1O1ZvAjIyAk1DGWEDOYlGkRBTf8KdTfJyOaqO2GZixVdAET1yAGCi5o7ZzCnmU8vZ31iStM8QXnhRQ7trG5c4g/FJ/sbRt/g7b/cV14pfBNRp6KkdO2L1aNvweb7FbPamXC6yqVGEe0SjjIHr35YR5dcw7+PAzfUrEYG/90vHiYS0Qm6TfPbhp/exQNS6++s5A94wYVY06O2lV9wglDxEcQEsTBO3QGOOK54xuByPWjexCWWkkaHbZqb4xd7xjzyKwoZOkVh9Tmbl3PgdD9aUxHZL+yRDyDxcDsklihqPawlTq6d82AAdOj6Ui7ugIORQ4Q+Gdi2J8HXCkec1G+h5rvaxpzT+iNFwqxZMRtu18P6xkBPUikhjL7201rJUryCPGyAI=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Hello Aron,\r\n\r\nI would think that this situation would be best served by asynchronous concurrency. Especially since you're reading from a db and can easily filter which records have not been sent. Asynchronous concurrency can be done using `Task.WhenAll`, and in many cases, LINQ's `Select` can be used to kick off all the operations.\r\n\r\nSo if your code currently looks like this:\r\n\r\n```\r\nforeach (var record in records)\r\n  await RetryAsync(record);\r\n```\r\n\r\nthen the new code could look like this:\r\n\r\n```\r\nvar tasks = records.Select(record => RetryAsync(record));\r\nawait Task.WhenAll(tasks);\r\n```","date":"2018-11-27T01:01:21.958Z"}