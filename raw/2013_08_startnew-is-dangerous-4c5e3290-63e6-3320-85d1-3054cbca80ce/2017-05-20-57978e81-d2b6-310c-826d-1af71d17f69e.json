{"_id":"57978e81-d2b6-310c-826d-1af71d17f69e","authorName":"David Wright","authorEmailEncrypted":"DyEksCNyG6gAu0PUGRCCf7QDBNDm2k7ATAdTW/URaTnQMAH5cSuHoULuQqiogoFqrMbpqt0RjR4JZg13+R1Mse+DaqpzvzIF1AFxGS9I73w8J7KKFGvQ0lF8nWSMKz1elNdWdrvDRJAjnH4YHL9YoeeE4wgG564UYpyIZcckjK4cIFAPbJf6Ohzsf58TJJAoyyUSpVudtmuLe8+D9Lp2xT+vD3a7sKSHoTI6ZKjTBf7b6VbT6tGbU6hc1RVlHVg4qgLvrZJbsIem4MHWo2bdyI5AClssfBMkNkDDaFGxkcB7ztDwkuT07euxusmtkdnTKpBiMXU8GexB0JKNfN8RID5CrqZlVOFdT6B56BcXz4YTpVI+QzMrymi030okvfQXPmAzdM3OtoncQ4gg9pHSt9FO+TVW1gLF3roLatJNQf0ibsDq3jca8aNDImFXzk0N6wyETsqn7umfzM4q0GIU+JG/5gzM5LynFzg5xJngzPyQd1Knt+vYRRE+E0WALZLyI7rMGqpbiKKkHzdLgx81mTKN6+r4/VZHtfMDUQO+HupQ3RSVQJMZaP9Ix8E2n9mvqD4DDhPXAtgRZFFF4z5qsIfoRxI/JLSYXkmRM3JF8/94zhueFc0+G4RzLXTzXPWSKw4XQNEh/VaHTGr5h3tkWriSA/bxKHn1FMOPpCP1gtA=","authorEmailMD5":"493e9873244c4ee952e775e7f5dd072b","authorUri":"","authorUserId":"disqus:disqus_gFHel0qnPC","authorFallbackAvatar":"","message":"Does the use of TaskScheduler.Default below constitute adequately specifying a TaskScheduler? Also, in this scenario, I really really want to guarantee that the thing being started is on a separate thread, hence the LongRunning. I'm under the impression that this is the only way to satisfy that guarantee, i.e. I can't rely on the ThreadPool for my use case? Is that correct?\r\n\r\n this.cts = new CancellationTokenSource();  \r\n Task<bool> commandRunnerTask = Task.Factory.StartNew<bool>(  \r\n () => commandRunner.InitiateRunOnNewThread(),  \r\n cts.Token, TaskCreationOptions.LongRunning, TaskScheduler.Default  \r\n );","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"","date":"2017-05-20T19:33:54Z","timestamp":1495308834}