{"_id":"d588b275-2448-3402-b9a7-ba0234100d6f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"It's not just UI schedulers that cause this; it's any usage of StartNew/ContinueWith when there could be an unexpected ambient scheduler. I did run into this with a UI scheduler many years ago, and I've answered a few SO questions where others did the exact same thing with a UI scheduler (so it's not just me :)\r\n\r\nBut even without UI schedulers, I've seen smart programmers run into problems with the ambient scheduler. I've seen it happen in code using the ConcurrentExclusiveSchedulerPair, as well as the old StaScheduler from TPL Extras. The ambient-scheduler semantics are so tricky that I'm aware of multiple code shops that wrote their own code analysis rules so developers *have* to pass an explicit scheduler. Which I think is a great idea.\r\n\r\nSorry, but I've seen enough people bit by this that my opinion is still that the StartNew/ContinueWith overloads without a TaskScheduler cause developers to fall into the pit of failure, rather than the pit of success.\r\n\r\nNow, if you're using StartNew/ContinueWith for dynamic task-based parallelism, then sure, go right ahead. I haven't written anything against that usage (I still always recommend an explicit TaskScheduler, though). I guess you could say that StartNew is dangerous like a chainsaw is dangerous. But if you need a chainsaw, then you just have to learn how to use one safely.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"2acd6063-f7fb-3482-89c5-63b0a87628bd","date":"2016-07-09T01:58:35Z","timestamp":1468029515}