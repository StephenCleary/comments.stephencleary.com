{"_id":"da6594c0-8b69-11ec-acf1-c908b2ed19dc","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","postUri":"https://blog.stephencleary.com/2013/08/startnew-is-dangerous.html","replyTo":"f6664620-8b13-11ec-9463-0bd7f48c85b0","authorEmailEncrypted":"gclA4ICZGIp04yKw9/b/Gaj1iDfVRC4zDLjKNTQbSMbKg1A+A3qzMz7qxOO6hpiYet9IDc2+feHCaesFoTHrvwW25dcqLRNkLSHTwa+YspDlUx1RkFDK4mkVemrFYbMToLZl51mtzkGg8qAhMh2eVWj5bjjjLANInOzKBIzeuom21CuMykjShqAAvZboBPWjRtqZy/aZpylF/84mTIE9wovZIDDwbPRX9tfF9cblUuYeLFVnUeDT/EdvSR05ne85KNsR4FX5zHOuDFw5kAIKPKf4dEAjDXvxhIfJr1/NIR2wOAJud+sEVgiOSjfONlBqw4ctNn6uy+J7tQiBVnZ7kpd6e5sYxAFAPHt4yfxmJS0HxHkI6QtA1fWdJozXX6Re/bD1dil6jH//fwxBYHcNObj0pNx6im2HdSfWBw0W3C5nxvAZt3AShLDic+9ts6u6vlpAnY3ZzM/Xmzmd5aCPZ22jcl7Y72xBAZ5dwOxejeDBaISgEY89bmbnyiUDB5x77ZRYCJNv1TAnJ707Aap8YrYN/QDjYb/f3F68G5PoCiwA393kHrSHlkXGKW1LZr1gr1LRUTTSpJ3gMMr0nRaEiJi7D1kQXvOhRs5+3j456PLCOR9CbmLGucbO8lVb4wz2YM+4c7lgsPCIz9oHjjPOUPr+T5IR92OeY1UmTnDe9eg=","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"It's true that - ideally - `Task.Run` is only used for CPU-bound methods. It's also true that - ideally - I/O bound methods provide an asynchronous API.\r\n\r\nIf you have an I/O-based method that only provides a *synchronous* API, then you can't have an ideal solution. Your options are to either call it directly (blocking), or call it using `Task.Run`. The proper solution depends on your environment: anything server-based like ASP.NET should just call it directly and block the current thread; but if you're writing a GUI app and need to unblock the UI thread, then use `Task.Run`.\r\n\r\nUnder no case should you use `StartNew` or `Thread` in this situation.","date":"2022-02-11T18:38:49.544Z"}