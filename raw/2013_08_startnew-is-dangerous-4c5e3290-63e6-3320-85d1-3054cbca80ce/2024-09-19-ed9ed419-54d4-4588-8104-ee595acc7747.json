{"_id":"ed9ed419-54d4-4588-8104-ee595acc7747","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","postUri":"https://blog.stephencleary.com/2013/08/startnew-is-dangerous.html","replyTo":"6624ea34-dc5d-4535-bb1a-7559a96e5bf6","authorEmailEncrypted":"RZZHLMYU4lIiCHVkp8Spjdsa3DuPnALIK1Cc6KxNYLxOBhm\u002B9N3\u002B9W8vWhRHkCkJb7VTcHQ/en9YRX2pnF\u002BfPD6W0L55IsrCAgD8rapQB3o/VnrIW22He3\u002BBFmuibOz2E32YIS1nuRGEy5nI87thdBkKQTosMQoQRA7egzAPgt5F0pAYFcyThUGSxT9s7AZTM984ACq1tYfyap05zEVy\u002BkW7QKNBoa\u002B2Ds7Z1lsLusaY6k2yo0FJc6bSMBb4eBq7FtpgNmiN5mDsVgNcZxrMPrdw3bUQdkqBPEYUrP\u002BZWML2amoY3/gCLBXXap7mTV979fz2BJL7Vb6Iktnd35izBwTKsbl0LnLbGUfOP\u002B6VLZXlHZdRFJ0uY5i1NDky8icbvXLYr8ZtifszAZsiRYmsAxqai68BqqrYdQ/s44Pp0O3w090igBYMOd42uILleXO61YUZCo0s4gjbeiwH8eIPr/xKsgztMKgCTIVXbc7uT7DwmJi\u002B4RC4GEarJ5\u002BmlrqxaH\u002B3P9OZsL4sySHjfTom2x/DuRcTHirzIqlWp\u002B4nli1fTPt20I887ZeQm2u1wnyM50FV/pBgy28RkTWtI/0Ayb2u3tIhO3RnGDX0bH2F8s6iKWV50Ccbs1cwed\u002BHDYNDv3e7jdLns3r4S/0vKldl3U7vDysLzaqz659pN60DB8Q=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"No, that would not be a valid usage. \u0060LongRunning\u0060 is supposed to be an optimization hint that the task will run for a long time synchronously. But the delegate passed to \u0060StartNew\u0060 is asynchronous and spends a very short amount of time running synchronously.\n\nThe way that \u0060LongRunning\u0060 is currently implemented in the .NET BCL is that it starts a new thread. This new thread then checks the cancellation token and then checks to see if there\u0027s anything already in the channel. There is probably nothing in the channel on startup, so then that thread would exit and be destroyed. When an item is added to the channel (satisfying the first \u0060await\u0060), a thread pool thread would be used to resume executing.\n\nThe point of \u0060LongRunning\u0060 is to avoid thread churn by using a dedicated thread. But since the delegate is asynchronous, it\u0027s actually _causing_ thread churn: a whole separate thread is spun up to do essentially a handful of boolean checks and then that thread is destroyed. It\u0027s a performance pessimization rather than an optimization. My conclusion is that \u0060LongRunning\u0060 should definitely not be used in this case.","date":"2024-09-19T01:15:02.7467988Z"}