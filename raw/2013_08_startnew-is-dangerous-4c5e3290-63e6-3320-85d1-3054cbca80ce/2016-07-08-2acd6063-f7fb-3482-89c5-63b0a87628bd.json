{"_id":"2acd6063-f7fb-3482-89c5-63b0a87628bd","authorName":"Craig Brunetti","authorEmailEncrypted":"s4hs52R3KrBjW5i/eHyxCVFSS5P4lIVXS9C6311IdSYFuiAgophPbp2MZXickX6g3COpgj+3UOWU/OyjjXEwXyAjoV7MNWv96vvyVXIzMKOspHrI/dBhZfFm4Dw12jCjXKv14Z5AnB8w//eeBuDRlhxPl2YocMEGsmGmIrGwBDnmVWdUWCf1dNQZIiixBA0cXKfkyHeEgE4Bi4f+O0E6YmP2PVz1p46BgQQ3a2KmN5q+Rwgv29TMbg9lkJZ3vbhM4DNdZyckYWdQDGHc0G2FRnC+DcbXHjATYlSzRg3H2YqTXQQ8pyhJgaVnA4r4FWJ3hsmtnyBNioPjbbn+QvdfpRfhr6oFC2gKSWi8XevaZ4gFztMq/3SzKL68ILixaZLrPE7sq3EvJOpjskfrMTnBKEcAERMO6cgRui4JDzgS3N+fNlS1hvumVMeINgJNoNP9E2eYmrudainOUuwpiEEqor6zVSSxZbvbNUvK+ave6tADnlk36AZh2ttqMJ4kpC9QhJrW97mJfK8zRkHKrU3cbUre9jmpxrhNOaVhXKw1Lsc8Z5Y1o/ztUyLWLSLQJyIhOjpo+cqDLiAF0nbmhIF0NjeXupgtLLv1tj4sqPm+6IP2trODgJqh/g6jJdw6tKvCD4bjiPNRJf1w5P84/DnasAugqkQMb7rs6cbL08BK+YM=","authorEmailMD5":"a0c658c500db456bbd691d6ed64b6d4f","message":"I've just run across this blog, and I couldn't believe it with my own eyes, so I tried it out... and, well, wow. But, it still smelled funny... H9uest's objections may not have gotten specific enough to defend his position, but perhaps I can add to the mix...\r\n\r\nStartNew respects TaskSchedulers, one of the reasons it's more complex than a simple Run(). So, fine Run is more simple, but it's not \"better\", because StartNew isn't dangerous. What's dangerous is a code example that pretends that a Forms UI thread should be considered participant in TaskScheduler (which is the assumption leading people to use .FromCurrentSynchronizationContext as a Continuation's scheduler).\r\n\r\nWhen that method is called, it makes a brand new TaskScheduler, from scratch, that represents little but a synchronization back to the current Thread:\r\n\r\n[http://referencesource.microsoft.com/#mscorlib/system/threading/synchronizationcontext.cs,826929a6f7e9421f,references](http://referencesource.microsoft.com/#mscorlib/system/threading/synchronizationcontext.cs,826929a6f7e9421f,references)\r\n\r\nSo, in essence, in order to appease a desire to hand something TaskScheduler-like to a continuation in order to get back to the UI thread, we find one and pass it. But you're tricking out the Task system, by simply asking/passing that new TaskScheduler (called a SynchronizationContextTaskScheduler), you're now setting up StartNew to fail, telling it to use favor your scheduler over its own simply because you want code to go back to *a particular thread*.\r\n\r\nThis is what smells funny to me. StartNew is being considered dangerous on the grounds of code that tries to return to the UI thread is an off way. That seems entirely unfair... because the call to update .Text should have been specifically dispatched back to the UI thread directly, not done through the Task system (and then the next call to Compute should not have... though that's another problem entirely, a .Run should have been invoked from the Click event handler for something supposedly so expensive).\r\n\r\nI believe this will happen with any thread that's not being managed by the default TaskScheduler (of which the UI thread is one). So sure, be careful, but it's better to understand that the UI thread is a different beast entirely.\r\n\r\nSo, all in all, though I agree that Task.Run is easier, its simplicity removes possibilities and depends on instantiating these SynchronizationContextTaskScheduler objects for no good reason... it's waste in comparison to a Dispatch. When every tool has its purpose, one should realize that bad information can cause bad results.","postId":"2013_08_startnew-is-dangerous-4c5e3290-63e6-3320-85d1-3054cbca80ce","replyTo":"c7a8aa0b-ac89-35ef-adaf-21f8bdf83573","date":"2016-07-08T19:35:08Z","timestamp":1468006508,"authorUserId":"disqus:craigbrunetti"}