{"_id":"ba48f75f-1e9c-3f59-88a0-d1020226051f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Not exactly. The term \"asynchronous\" implies a freeing up of the current thread.\r\n\r\nSo, you *can* call BGW \"asynchronous\" from the perspective of another thread (i.e., the UI thread). It's this definition of \"asynchronous\" that MSDN uses in its older \"Asynchronous Programming Using Delegates\" documentation. However, this usage of the term \"asynchronous\" is actually for executing *synchronous* work on another thread.\r\n\r\nThere's also another type of work, what I call \"truly asynchronous\" (and on my blog, whenever you see the term \"asynchronous\", I'm referring to *true* asynchronous work). This definition of \"asynchronous\" also frees up the current thread, but it does so *without blocking another thread* ([http://blog.stephencleary.com/2013/11/there-is-no-thread.html](http://blog.stephencleary.com/2013/11/there-is-no-thread.html)). It's this definition of \"asynchronous\" that MSDN uses in its newer \"Asynchronous Programming Patterns\" documentation.\r\n\r\nBGW cannot handle truly asynchronous work.","postId":"2013_05_taskrun-vs-backgroundworker-round-1-b69afd34-80d1-3c0f-9885-0555b3d7c797","replyTo":"644763fe-2607-38f1-9868-cf75a3e5d7e0","date":"2015-03-03T13:35:52Z","timestamp":1425389752}