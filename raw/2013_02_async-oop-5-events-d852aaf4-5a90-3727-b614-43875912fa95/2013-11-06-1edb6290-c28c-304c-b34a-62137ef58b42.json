{"_id":"1edb6290-c28c-304c-b34a-62137ef58b42","authorName":"Thomas Levesque","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","message":"There is just one problem with your deferral implementation: if a misbehaved handler gets a deferral and doesn't dispose it (e.g. it wasn't in a using block and an exception occurred), the event producer remains stuck forever, waiting for a deferral completion that will never occur.  \r\n\r\nI used a different approach for my implementation. The deferral has an associated Task (created with a TaskCompletionSource), which is awaited by the event producer. When Dispose is called, the task is marked as complete. If the deferral is finalized before it was properly disposed, the task is marked as faulted, with a DeferralNotCompletedException. This way, the event producer will be notified of faulty handlers (well, of course it will have to wait for the next GC pass, but it's better than nothing)  \r\n\r\nHere's my Deferral class if you're interested: [https://gist.github.com/thomaslevesque/7325901](https://gist.github.com/thomaslevesque/7325901)","postId":"2013_02_async-oop-5-events-d852aaf4-5a90-3727-b614-43875912fa95","replyTo":"","date":"2013-11-06T01:55:16Z","timestamp":1383702916}