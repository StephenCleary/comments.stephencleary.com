{"_id":"2470c566-e828-3348-96e4-406039c84440","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"It only violates encapsulation if you consider the event handler as private. This is often not the case, e.g., ICommand.Execute is not private. So exposing an ExecuteAsync is not problematic. If the event handler *is* private, then it's probably better to adopt a more async-compatible approach (I prefer deferrals; others go for Task-returning delegates), which allows the triggering code to detect when the handler has completed.\r\n\r\nUsing a SynchronizationContext for detecting completion of async void methods would be acceptable for unit tests (note that the async method still runs asynchronously; the SyncCtx just gives you the capability to detect when it has completed or raised an exception). I have a type called AsyncContext that can provide a SyncCtx for you: [https://github.com/StephenCleary/AsyncEx.Context](https://github.com/StephenCleary/AsyncEx.Context)","postId":"2013_02_async-oop-5-events-d852aaf4-5a90-3727-b614-43875912fa95","replyTo":"27a97a50-11fa-3da3-9f1b-27798ed7f05f","date":"2016-07-22T14:34:38Z","timestamp":1469198078}