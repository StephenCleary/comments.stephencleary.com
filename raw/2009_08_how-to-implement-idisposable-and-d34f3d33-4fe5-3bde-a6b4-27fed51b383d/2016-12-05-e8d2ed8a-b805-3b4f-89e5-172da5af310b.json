{"_id":"e8d2ed8a-b805-3b4f-89e5-172da5af310b","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"It depends on your background. For example, with my background in C++, I see one major problem with the whole disposable system: it puts the burden on the client to dispose of the resource. C++ destructors do not; they are always called automatically when the object goes out of scope (RAII).\r\n\r\nI have nothing against using IDisposable for \"cleanup\" tasks - e.g., I use IDisposable to unlock async-compatible locks; this series is just looking at IDisposable with its original purpose in mind: disposing allocated resources.","postId":"2009_08_how-to-implement-idisposable-and-d34f3d33-4fe5-3bde-a6b4-27fed51b383d","replyTo":"8500c14e-1853-3795-b2da-02362700a4ae","date":"2016-12-05T14:20:46Z","timestamp":1480947646}