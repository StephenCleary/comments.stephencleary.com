{"_id":"362db132-1b02-412e-82e9-3e72e5220565","postId":"2021_01_asynchronous-messaging-2-durable-queues-17eca5a8-3cf1-33a3-bab9-fdb074569ebe","postUri":"https://blog.stephencleary.com/2021/01/asynchronous-messaging-2-durable-queues.html","replyTo":"","authorEmailEncrypted":"Bgeb5/QsPYzU/MeVfmfnLNu0hDoqz6tWO8cSmXX9t4hrgSy4SRL7J74yZPl8HKRCAQACjHw1KBKrAZDFFqpY60Z4KpITriItp9RruxCA7J1Ok7TP4KLaAt8iBgcLEwHlky/kocLCIyYyJK/EHP1\u002BF3XLuVn0HVQ9Eahl9TC6Lbg821sNcT33U\u002BYIheG8oHaw2qdc3VIoVR9NXPvmj6uL8lH/UCvA6WgRdMEztkdxATFnTmGMs7DMnkg8CLETs7kFGJS850dh5mf3N1pkGIpJtPJ4EmrSZF0ROVq9w/AkoK5W9gaibZ8b/5fbGqABJTpyAMZiaQiCPbWk\u002B1PgH97Ii\u002BkC9AFZI3KDnCjOKUbOMu3NNQ7MQ8UE3ZJmGoeilV51VMayAtmmWGtjjJsKvpb4BvpU1ddEWVb6ZO46xWVOOTDrLTe5i3IXKT8r6kU4T\u002BUs2P/noLyyH/RdxHLK2rjYWmweOkePGmcW1JiUYnD4pr7kPuX7bwban\u002B0LjTmmDX2t3zaSAyMRkEhFe5bYKKzEcjrYxKctlfDm2cmvarOYJORnE5ykU2sF6/1ooZcicGRoja4OFk6P/R10bYI2Q\u002B4HAi\u002BXPpdJ1vsH4ID\u002ByjHcYQBA/HEBVu6mH69wrUAPhWsebfTUvNHCcV7DboHP0xddwLI6suteNGdbA\u002BTshWClj2k=","authorEmailMD5":"8ac9108503e4e5cbe152b8ff2d13665b","authorName":"jescs","authorUri":"","message":"\u0022Shutdowns Are Normal\u0022\nUhm I don\u0027t agree with this. I\u0027d say that \u0022Managed Shutdowns are normal\u0022.\n\n\u0022All software that assumes it will never shut down is inherently buggy.\u0022\nI don\u0027t agree with this definition, for me it\u0027s slightly out-of-focus. \nWhy would do you only focus on shutdowns instead of focusing on any generic crash which could happen? \nA software must be able to survive an unexpected crash (including unmanaged shutdowns) without problems for its data consistency.\nI\u0027d say it makes sense to have a robust code and \u0022acid transactions\u0022, intended in a more generic way and not only at the database layer.\n\n\u0022For example, Apache\u2019s MaxConnectionsPerChild or IIS\u2019s periodicRestart can recycle child processes periodically. This is primarily useful for managing memory leaks in applications, frameworks, and/or libraries.\u0022\nYou said it. You\u0027re describing something to absolutely avoid. You\u0027re referring to buggy software, a software/library/framework with memory leaks. And a periodic recycle isn\u0027t a good solution at all. That\u0027s what we must teach people.\nDoing a good diagnostic check, code check and profiling is the solution. And the memory leak must disappear. That\u0027s how you do it.\nA periodic recycle is an absolute no, why should I lose all data on the running instance for the sake managing \u0022managing memory leaks in applications, frameworks, and/or libraries\u0022. It makes no sense, really. \nIt\u0027s like saying \u0022ok, we restart Windows server once a week to avoid problems\u0022, what?! And there\u0027s so many admins who really do that.\n\nI\u0027m not sure Stephan of the focus you have in your articles. I really do appreciate you because you have a brilliant mind, but my impression is that you\u0027re describing bad architectural habits, using unsafe operations and how to complicate code and infrastructure management (patches, updates, etc). Instead, it would make sense to explain how not to complicate your life.\nI think the solution is to design robust software architectures avoiding the pitfalls you\u0027re describing, avoiding potentially dangerous mechanisms in the code which could lead to data inconsistencies. \nLets talk about robust code, unexpected conditions (like an unmanaged shutdown) resilience. But we cannot suggest that \u0022recycling to fix memory leaks\u0022 is anything good, lets talk about the solutions for memory leaks. \n\n\u0022The proper solution for request-extrinsic code is asynchronous messaging, which is accomplished by adding a durable queue coupled with a backend service\u0022\nThe idea of designing a system with complex solutions to handle stuff which can be done without all of this complexity is bad. It\u0027s no rocket science to handle a \u0022post-request\u0022 code, it\u0027s something people do. Why do you call \u0022durable\u0022 a persistent operation? Writing data to storage exists since before we\u0027re born, no need to invent new terms, it\u0027s a useless complication. So you\u0027re talking about a \u0022delayed response\u0022, a queue and the code to handle it. Please, Stephan, keep it simple!\n\nYou know what I think, it\u0027s what I always teach my collegues (and in return I learn from them): \u0022A good code for me is the one you can read on one monitor and convert in real-time to another language without having to decode weird/super-modern mechanisms\u0022.\n\nJust my 2c. \n","date":"2024-06-19T00:00:58.9391091Z"}