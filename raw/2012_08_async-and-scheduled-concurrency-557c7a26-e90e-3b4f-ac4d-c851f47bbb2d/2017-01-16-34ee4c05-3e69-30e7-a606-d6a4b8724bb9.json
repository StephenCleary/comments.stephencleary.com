{"_id":"34ee4c05-3e69-30e7-a606-d6a4b8724bb9","authorName":"Dan Gershony","authorEmailEncrypted":"OlNTiXazxpVbVmhJN1Xh68nqltHm52cK3hl9QIJHMZ6LwUlJ+FsyeBE6kktoJO7Sp9fp2KLyPFnxsM2b9ZPpSGwvRX238sj+GB4itDBKEDVzdEHYw1WxJZLS2Y2/mgVLS6+GGu4CYE/ahkL70C0bfevV/bA5rauLxs7j9MnbRksXJs5h0mtVYfUb8LaZNv2btJB7axD09F4YNHZs2/ykqyXzkIW9FwjDmpZaLTWs4kJx3h7JpzFtjGFZ4gCBWK3TwIaUvpbLMBrj8u/L4Jg3YeO7GHyUWmprEKbY6MiAYHPC76poO+cRr4irmM6GANvxCT9guNE1KmNhCpEVy23AnmnH8Rl9mFubjjyXKC2IvH5knWj/JObuCTC4AD2vFpvgf0Z35DRU1kk71LQ42AtxZH1QwF/OPjBo5Gn9TA5r0mEN3Nf2wc7ar9k9J1Pom0LayUdSP6eceOHJ0wNxiXuIWpQjYD39zTh9Uc002iAT7KUqZchI6gH8XWx/imLuMK3zVs1JzvIQznlLZRA9bvHpSs0b55lDyZ3QxB0I6TnwooPdagyMqENQ/ojuDgZGqN6wVX2+cI14xPuwHgWaokA2Uqf0Z3YTsp03SnLTHL1rKUGa2fiYvCcr5G4Yxf1VbZ3ncBDJBVnAvOXQqNNtAGAHa5ujq4aE3HbLOYExDK+Qzh0=","authorEmailMD5":"71adc1449fa9b5644d69a5d25db9ecd8","message":"Thanks for getting back to me. it is indeed complex but writing none locking code is truly useful.   \r\nMy team is doing something really interesting in the Blockchain space, we are porting the Bitcoin c++ core node to C#. [https://github.com/stratisproject/StratisBitcoinFullNode](https://github.com/stratisproject/StratisBitcoinFullNode)  \r\nI do consider using the scheduled concurrency approach to avoid thread locks when doing read/write operation on a Dictionary (instead of using ConcurrentDictionary or Reader/Writer lock).   \r\nThis raises some questions, in some cases we have a limitation where a db operation can only happen on the same thread it was created, does the ConcurrentExclusiveScheculerPair.ExclusiveScheduler reuse the thread or discards when no more work is waiting (is it configurable).","postId":"2012_08_async-and-scheduled-concurrency-557c7a26-e90e-3b4f-ac4d-c851f47bbb2d","replyTo":"152e5833-cc7d-336e-b070-3fe9360f9f5f","date":"2017-01-16T16:30:41Z","timestamp":1484584241,"authorUserId":"disqus:disqus_Mq904YACXH"}