{"_id":"800e4bcd-ab2d-34b7-b8ec-4fdfdaaa820f","authorName":"Ohad Schneider","authorEmailEncrypted":"t5fGZEuoEKhJb+AQ+mFAtt6yOohEW92tJq/pBRzYQzFKqGeUUggVn0QbZCzhxPdB4hJn+ouG8ctWYcch+vF40C0FVsnbmS5gGQSEmy3+L8jhzpshmM1+XxOxnb3IczBZF24ekMH7MGnGSS99p/t60S2JSMZifiu16TEzAlz0SRjdVIM/6zVhPfVosSShthm2XD2yeHClVyaTu6cUB3Nnry0rgg6KRyzarwWnooFZf7gubLqZf1Hn5nk3qlY2T0s2PsKUDzzt1oBjfsXHhdLPzaaDoIUwXceE6Zb993cg9Kd3tG7aScLSRzOR6NwxScVpZR8ztR7mQVSLD3K6AoW2E/+CqyvyeDFTMGWGeXpIqLODbKyr7aqoWmSOY4Zk6p4+3jXeHW7MT6SLr22duTYTHKaHJdPiqSABKzFzyNQkldbduJSqhZ6kfqtTYl8b7ovWVN8b+GRagLvPWnCnJtLxJtJNcej4ZghQIc+AfOpUXjKZDn9HnODk0gCsIqfcM3baID53Z355U3Rd3b+DaqV0FDQezGFPdU/lkEdECGcAgVu+01NHogc9Y1Df/oCNsn1aKYU6TWduj5UFQY8DOm3kCDpec86P9v9bWWnkXl1fGbpzKJ4qopSkWfZhmWhdgu+ZrTTt9FmwQo5atP3zUOsldri+U758ovEBSeZ5s1Q4D1U=","authorEmailMD5":"cacacd08cdb74729cd4a964ced03f62a","message":"\"If the method later resumes on the same thread (e.g., a UI context), and the “other code” attempts to take the lock, then you have a deadlock\" I don't think this is a good example, because vanilla locks (Monitor.Enter) are re-entrant. So the other code (running on the same thread) will succeed in taking the lock. A better example might be the UI thread launching and waiting on a threadpool thread that is trying to take the same lock.","postId":"2012_08_async-and-scheduled-concurrency-557c7a26-e90e-3b4f-ac4d-c851f47bbb2d","replyTo":"","date":"2017-09-30T12:26:25Z","timestamp":1506774385,"authorUserId":"disqus:ohadschneider"}