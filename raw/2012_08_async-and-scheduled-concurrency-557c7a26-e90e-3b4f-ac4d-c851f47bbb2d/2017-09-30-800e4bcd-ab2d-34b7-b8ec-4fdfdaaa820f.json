{"_id":"800e4bcd-ab2d-34b7-b8ec-4fdfdaaa820f","authorName":"Ohad Schneider","authorEmailEncrypted":"bF76Vs3ZkU9aShiQkgrfl6Q6S7mwEGprNP0bCO2plZ+bE0XzpHAzp4cYFImuQYfsIVdmWN8/7XX6aGXb8vXub8xyzRuU8Bkgu8PAJgPcZEKlb7ImaYpPbFMsqjXpD6gUmLh16TJr9HDmi9fe861/dU7YjFHquL/nbRi/y030JDIA55FWMDhpgv15JdNv0Q9caMk/IpiFLpidMhZ6mKix0/mRHGY9hiqvW/cHZq5rdC2bFtnuIsO4MefCR1r/aXDuF76N51oxTY8bxVGgmPJj/DAEF9Wat+AhrVqajYkQ/rAlWQW0JLBgAYLmZPCiYj7tS57VX7dx6hFDGeWDj6T7a2PIAUIdrL1HmdqNUk7f+nw8Yw5JvMLNTGWnH0GV1ieopeiwViPcE0/KkVRLVLZHdVbKcNnF5ZG8gjcBTXIz/398N70YqkPPQNy2xoOUBSvYp5OhDZPMxXEA7+Z1HPg5yx6+0qvqkL2+/4MGa6a6X7jEsrEtGoXZYCz2mXm+miXVcZxBNq4k5GPyiEs9eFcTFKAoXj8XpxqgCCFoMGgGWNjlOzHBuo7c4TBHeEuSnzBhekxk5WXyh0yaj4R+8Y0KHS2Od6AaFWjUHcoGLmnKyqcZjNfr3Z1MnqcFFyiExTL+u8MJ1WlXiNNvQ0K3TNTkWfabY9BX762qeWtDOzuzAjA=","authorEmailMD5":"cacacd08cdb74729cd4a964ced03f62a","message":"\"If the method later resumes on the same thread (e.g., a UI context), and the “other code” attempts to take the lock, then you have a deadlock\" I don't think this is a good example, because vanilla locks (Monitor.Enter) are re-entrant. So the other code (running on the same thread) will succeed in taking the lock. A better example might be the UI thread launching and waiting on a threadpool thread that is trying to take the same lock.","postId":"2012_08_async-and-scheduled-concurrency-557c7a26-e90e-3b4f-ac4d-c851f47bbb2d","replyTo":"","date":"2017-09-30T12:26:25Z","timestamp":1506774385,"authorUserId":"disqus:ohadschneider"}