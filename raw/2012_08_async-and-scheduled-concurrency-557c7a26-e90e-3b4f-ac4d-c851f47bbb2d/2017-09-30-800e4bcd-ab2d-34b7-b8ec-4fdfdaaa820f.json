{"_id":"800e4bcd-ab2d-34b7-b8ec-4fdfdaaa820f","authorName":"Ohad Schneider","authorEmailEncrypted":"tR8JfE2atH8LbtYgKaPSShRIlJUzHT44fMTaVFhIqXYPdGFo9cEAJ/dXifNHtv+8dC4ME2Iu1Az0BpDli5FB3jMYwH2vm5SbXDAuyNYvYwI1BIIw0dhNw9eafWHIwoyzau/Q3odbObKehZ7OsCgeRkVEgmIoA1bn3wcvHIAD8lAUDhOH0lPFaqkTvgHwfN3l+w9S1mncy+7VqqaTPGz8458cisNKM91Eq0icVvwh1uVod7xu3UiLPVow0IMGGH66/vw41GWzN6jbvilbZblYdzhIMy4EKyhRNrDdLgeFEdIudfvsrjFiOkRTsjFs+yhVXDnYTvz8J1KEft5nkqKNC63WBapLg8fmP5dM37lg79h34gUIKc0iKd5zeo5wiR4p84gBampfIx9UVMj4Bx/23lP9Vf/fHhd5rhV9OQGOuwVmcz1UfDjNEmTsR2VhXDZbSE/Yju4KHDYnTjXZV7XrSj4T+gfwKYTN3oa7i9IkBGaE+tTPt6EjdYwSqbrhiHcX0vTmeZhExa4MIOJPrFvK0sdYXAIElG1dykY930ur/ipTp0Ttlb+4W/KysJo4qNTY36rUdXuxCya0e+7H/HXCFwL55UyJIGhWcKoS0qxHg66ihyk0VjMwC9tACbMz5WzLhnc3SdTp2kmW8ioT4+OVrVsQ1rFBwFjX3z5EWinoLvk=","authorEmailMD5":"cacacd08cdb74729cd4a964ced03f62a","authorUri":"https://www.ohadsoft.com/","authorUserId":"disqus:ohadschneider","authorFallbackAvatar":"https://disqus.com/api/users/avatars/ohadschneider.jpg","message":"\"If the method later resumes on the same thread (e.g., a UI context), and the “other code” attempts to take the lock, then you have a deadlock\" I don't think this is a good example, because vanilla locks (Monitor.Enter) are re-entrant. So the other code (running on the same thread) will succeed in taking the lock. A better example might be the UI thread launching and waiting on a threadpool thread that is trying to take the same lock.","postId":"2012_08_async-and-scheduled-concurrency-557c7a26-e90e-3b4f-ac4d-c851f47bbb2d","replyTo":"","date":"2017-09-30T12:26:25Z","timestamp":1506774385}