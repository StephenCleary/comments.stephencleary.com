{"_id":"800e4bcd-ab2d-34b7-b8ec-4fdfdaaa820f","authorName":"Ohad Schneider","authorEmailEncrypted":"n7EXCfRSMUduDkSgzcNqiis7iaxpD6uMdXq0kM6Wk+W0wp8j5WiHeOr5Z7zx/GKNh+zX2vFiKKu/3UicLr4r68oMAeI/YzleS9J7fQh9XrpPuR8B4B//sFaxzROinXACiAAcPBPJqXz1pY3DSK4gOWN4uDqb+mGSG2FvC4mwF5lNWPISn1dk8k5fTr3gGDYsx+8QwmcwX0YOFiucCcFksjW4sT2H6o3H9iHTkiFOJm1MnhSalH9zohkLCkzcW3Kh9XU8zieh8OysQIu33XCoEy9ej3xg7twri9PTSvscGTOdxEuPliewpMvau1FH01NflIH/8DrKTJGkcjmcOUbpcuTLocpb58UJKQlYOo1eIVB/PxPjGkyI9IwXsxVDjQo9WzwrjyRqEguHhI2TWziTQNylAWg21PCHrdWyF5OV3u5LvvGdOdMXNP3m4EHTI/pGL5+q89GSq0mQxm+bMEovOFpUKEwlPEBBolqlERDznrKzuo1Q977AcwnkXn1EzS3rFvJZBMM9oojK87XNZ7nYSoHhUzdMAwXyNHn/W/5Gm6Vgc9EDJ7McnHva7N4JAD5T7n/b6RfZlau9/DbmCbO5tjAZxl6b8mIQlnpZg6l0D486yN3B0lLDsDdjDqgzqiZkxfiNIvBTzYhD257HmPT96k/3WN/PvZw/DNVdIJbgZIw=","authorEmailMD5":"cacacd08cdb74729cd4a964ced03f62a","message":"\"If the method later resumes on the same thread (e.g., a UI context), and the “other code” attempts to take the lock, then you have a deadlock\" I don't think this is a good example, because vanilla locks (Monitor.Enter) are re-entrant. So the other code (running on the same thread) will succeed in taking the lock. A better example might be the UI thread launching and waiting on a threadpool thread that is trying to take the same lock.","postId":"2012_08_async-and-scheduled-concurrency-557c7a26-e90e-3b4f-ac4d-c851f47bbb2d","replyTo":"","date":"2017-09-30T12:26:25Z","timestamp":1506774385,"authorUserId":"disqus:ohadschneider"}