{"_id":"3070325c-a41c-3896-ad6e-4eb1858c6da5","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Technically, it's the same SynchronizationContext unless there isn't one, in which case it's the same TaskScheduler. The vast majority of the time, the TaskScheduler rule doesn't come into play, but it can catch you.\r\n\r\nIt's not necessarily the same thread - that's only true for UI threads.\r\n\r\nIn particular, ASP.NET (currently) has a SynchronizationContext that has all the \"current request\" data like HttpContext.Current, the currently-logged-in user, the requested page culture, etc. When an async method resumes, it will resume with all of that same \"current request\" data, but it can resume on a different thread.\r\n\r\nFor another more common example, the thread pool context comes into play when there isn't a SynchronizationContext *or* TaskScheduler. This is the normal case if you use async/await within a Task.Run (or any other code running on a thread pool thread). In this case, there is no context, so it works just as if you had specified ConfigureAwait(false) - that is, it will resume on any thread pool thread, which may or may not be the same one it was running on.","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"c283aa43-841f-3c84-89a9-6814d2eee83b","date":"2016-02-05T13:59:12Z","timestamp":1454680752}