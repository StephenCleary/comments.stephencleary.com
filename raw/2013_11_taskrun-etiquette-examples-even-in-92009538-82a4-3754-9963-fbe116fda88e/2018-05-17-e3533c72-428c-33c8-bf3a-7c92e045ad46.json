{"_id":"e3533c72-428c-33c8-bf3a-7c92e045ad46","authorName":"Dave Dansey","authorEmailEncrypted":"qKVKNJN/qyUIDX0MAu03rGFOBOhVuMilS1rKn1GF9RypCb7z1gIVzkIChVU5ySGQ4LLAjVAFM3Iv3WOR3azE9p1t35OzDmSYkNMHBpBSVNYn3iRvZdtr3A2BkyZpw01K29Lvc/ywwunqp9qDO+HGp6+0LAY86Ney3QbNH6pmMrj8OGx2vcvEb/2Yzx4Ii82x0227DUDKVeQ2h/78/aiiJYwulRhuyVH3JunRe+V7DuNSlxgxdNZnIhqWJqZAMx02o3Ddi9aryyhSpXSEe2BIpLdqFdOOU/IMJZtOgS+7IpQ8ZVWZSPInMjI88AIXqoUKl7f8BECnrGXuw2jo9vPCeDGSzkma9N1FTYXlcjdM+B5ujruK531m1SVw3H0BR+ZDQcESqC2BsE/BGFF6QBn45HpZQOhLVlrL7n+YHeLYw18of9IKylc/yiMbi0mYqDNXgAeQNuKJyUm9vGVwgMPaxN36K6U1oL2D5Y7aBquWoRWrCKU+1u53Ks1a+TiYTI5cH1y59LNUTXtUfLB94Z7N2cDPYWLpEH5qVfgTXJtV0H8hrq4s1mZKhDnNPPaLLHgrhjiHmCwC6HZDpCoPxCiLArbTqZ1ameL61BoHUDg3YJGZ1v+4mPekgAN7BPdO6Am+Dk9vsHOxsIkfBJ6oCYILTngeXOZxNaLfAjRwx29oTtk=","authorEmailMD5":"8a98b0e3035b36a6128a7025cd8a0b65","message":"Sure, that makes complete sense.\r\n\r\nIn our case I'm looking at our client-side service layer for our WPF desktop app (we do have a web app but that has its own service). We have a large n-tier framework, started over 9 years ago, which has a very flexible\\generic architecture (before EntityFramework took off, so uses our own equivalent). We have our own Query object and EntityModel, which get serialised and sent to the server - allowing us to define any data to return.\r\n\r\nOur ServiceBroker on the client has just a few public methods \"ExecuteGets\", \"ExecuteProcedures\", \"ExecuteQueries\" and \"SaveEntities\". I was attempting to see if I can make an \"ExecuteQueriesAsync\", as under the hood, the \"ExecuteQueries\" calls HttpClient.PostAsync - but wraps this in an AsyncContext.Run (from a Nito.AsyncEx library which I've just looked up - and found out you wrote! - p.s. I didn't write any of our service layer).\r\n\r\nI did make a proof-of-concept for the above Async method (putting Async calls through all classes from our MvcProxy to the QueryExecutor, which the UI calls). I found myself calling it from the UI using Task.Run anyway, as our ExecuteQueries method does a good mix of CPU and I/O. It takes a payload of a list of Queries, then for each one, validates it, works out whether to route it to the local database (cache) or the server. It then sends all server queries remotely and all others locally. When the results come back it checks the response for errors, unpacks and de-serialises the response. Just de-serialising a large response can take some time, which I found locked the UI thread, before I called it using Task.Run. This feels like a complex case - I guess it's quite rare too!\r\n\r\nI think I've concluded for now at least, I'm just as well calling the synchronous methods from the UI using Task.Run. Our whole ServiceBroker is designed to be synchronous, it uses a lock, it's static - it's just not geared up to serving up responses in a properly Async way (where you could send multiple requests concurrently and have them return when they each complete, without blocking each other).\r\n\r\nI'll switch my focus to replacing BackgroundWorker for Task.Run in the UI (something your related series has convinced me is a no-brainer). It would be fantastic to have an \"async\" service layer but as a beginner, it's not easy to work out how to \"do async properly\" in a large pre-existing application!\r\n\r\nMany thanks for getting back to me :-)","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"07e07ff8-6f51-3969-bac2-03b60727010a","date":"2018-05-17T10:11:16Z","timestamp":1526551876,"authorUserId":"disqus:davedansey"}