{"_id":"c6a453c0-2e8c-11ec-8ef3-b56fbdcf4c19","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","postUri":"https://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-even-in.html","replyTo":"d195cc20-2e1c-11ec-ba7f-0bab595a093b","authorEmailEncrypted":"bpSEyYVh5/EcHZwcSFdVr1R+xHrqFguUzjjUY0L11d0b4kC6LhcpmpqWHC4rP9vCQPrHDmObv5AxDHfaMh0jI5oeUI3UG907MWYG9LWqMzL9034JejOJileDzdG9OtwlQysLXCWbluE1FzcHIyK4h7ACdVE1sSKgtzQM2hU0xZS8RSuunNEWkkxrw8QEY7endmtPhQ+J7WyWBp3tFoXeDM/rvQeRwNsq/f4HydwEcOlH/J7cjMVWqgAEgSK2875GF6GtxX905hu1gITyO8Kru9aCQbWxM9HuZ2adrHMaY1Ysw1oMpD8mI3G+kZ1QMieQIOLzA8rPWLuUOMCsi7mDkXVAulM8oHxAKvCFIid1P84ahO6dMI+UjSbZs7ABVn35S2M4c+V1c3zvnaA9JJyGZBPFwt6kUZ96Q5kA+OJd1xjZ/+x6BPelWFKL7SMjrXQgvgEw6V12lfm5iEXd/1iSNKDHJyIKJuAD0hBVZLxCAy6Y3VhUDBmNlYijCucesaIsteCxpRP7YvrmSRh6hFIu1SpSIBZwyLAKlmW2aISb0jbhjqp4Y+ogNBi3RujTexJyphOslArIAaA4Tefam5uSzSijlxyAsOsB488NeQinT3wmirWPmkZydQD09IpvsMJcdUiGzHthzCWTDt38m9C163Ve+WXwrUUT4koykRUSImE=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I prefer `Task.Run` for three reasons:\r\n1. It's really clear what it means. `Task.Run` means \"run this on a thread pool thread\". `ConfigureAwait(false)` means \"don't resume on a captured context\". If someone is using `ConfigureAwait(false)` to mean \"run the following code on a thread pool thread\", then that's an additional mental hurdle when reading the code.\r\n2. I find the code easier to understand and maintain if each code block (method and delegate) runs in the same context throughout. `Task.Run` runs a code block on the thread pool; `ConfigureAwait(false)` can jump threads in the same code block.\r\n3. `ConfigureAwait(false)` isn't guaranteed. There are a couple situations where the resuming code will *not* run on a thread pool thread. The more common one is when the task is already completed; in that case, the code will continue running synchronously on its current thread (the UI thread in this case). Even things you would think would *always* be asynchronous (like sending an HTTP request) can complete synchronously due to caching, and there are some environments (like mobile) where caching is more aggressive by default.","date":"2021-10-16T14:24:30.633Z"}