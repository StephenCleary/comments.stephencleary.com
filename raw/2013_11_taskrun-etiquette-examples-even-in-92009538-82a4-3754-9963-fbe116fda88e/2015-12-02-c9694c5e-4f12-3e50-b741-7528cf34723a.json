{"_id":"c9694c5e-4f12-3e50-b741-7528cf34723a","authorName":"Stephen Cleary","authorEmailEncrypted":"L803aaXd3U3l9H7YevjrpX9v3o1EtVMvoNGXauuusRUqxG1q6ycd1+KRSRanNiQiVhAh2fKe6wPPrhfAb4ckD7wYVQL6O9T7AmOpsNFAkAMarBMtewjJbUxJ8lZV0YOnuPphZEd1h2IXK1fC/OynVUn+BqeQT2JcnAwUl1xxQgZNorh3nqKl65QG1ailz/9jf2ZnlQQb76+NatX4CvsuNCjPCcx39+ZlTinArRaNPcUvjCERANe2wlYrR2hbBddz/cs96DA0XYMvQ3KMCJrqygQQQgfIKjEbaKeAE21nEM5fw3OpPX5fq+nGNJ+IlP4MHWlKZRqh51X6jGxXZnLBxlXdJ97hJXoX+rB8wgn5NHZRqLne9us4yZ4LAjV4rzqYGgk/BmfucOvTlnT7tOC25bFqHM1Ciift2LOz2eGY0RPk6ncvDf4lQQsZIAWKLQWFWSHT7czKw1/7YmCW78MRNcvBFF0AH0ZFhn9bcXeWvnfhjDAyY+S+LBFGhNRU94vN/xDCgu5GO4ylBRgvrshINjtFrlc0KHVB48Xrcjd4Wgj0fieqCRqNbv2JWZqzKqzZJHrhf+5H3TlDWMMBMkaGXRlPH0HWCz2ZLhT3bEiaPf4DrcsfrpIZcNTSeMVHCs84FwC0CY7KNuPIqQztFD92l4FivgTAItqkVT5dyGcf1sY=","authorEmailMD5":"28dde5772b48c92e08b8050411aa5ba8","message":"Your two questions are very related.\r\n\r\nFirst, the difference between \"CPU bound\" and \"I/O bound\". The difference is that I/O-bound methods are naturally asynchronous; that is, there is a way to implement them that does not block *any threads at all*. For more information about this, see my \"There Is No Thread\" post: [http://blog.stephencleary.c...](http://blog.stephencleary.com/2013/11/there-is-no-thread.html \"http://blog.stephencleary.com/2013/11/there-is-no-thread.html\") . In contrast, CPU-bound methods *must* use up a thread by their very nature (i.e., they execute CPU code).\r\n\r\nFor I/O-bound methods, it's best to have an asynchronous signature (with a truly asynchronous implementation), and for CPU-bound methods, it's best to have a synchronous signature. This post (\"The Complex Case\") deals with a situation where the method is *both* I/O-bound and CPU-bound. In this case, it's best to have an asynchronous signature but with a note that the method is also CPU-bound.\r\n\r\nThe reason that MyButton_Click uses Task.Run is because the method is CPU-bound as well as I/O-bound. If it just awaited the method directly, the CPU-bound portions would block the UI thread.\r\n\r\nAlso note that the ASP.NET controller does *not* use Task.Run; for efficiency reasons, it *does* want to block the request thread on the CPU-bound portions rather than switching to another thread pool thread.","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"5402f356-1fd9-3942-94ef-9169c1d29cf4","date":"2015-12-02T13:20:48Z","timestamp":1449062448,"authorUserId":"disqus:stephen_cleary"}