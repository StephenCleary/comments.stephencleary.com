{"_id":"c9694c5e-4f12-3e50-b741-7528cf34723a","authorName":"Stephen Cleary","authorEmailEncrypted":"hTpxdjJFxBU0yPwbVAnY4dlx81GRT5aSfMjsmzzTXPP8LuG0KjFiWSWEd/qiM7znvenZeoDRGYBpaZRTEuRe1V+eglbS0jjSlIlcpwFA7jj7KA/YZecuXWfgpkIMTvD1lexckWKlP6Nhj9KNdjhD9CB5SOgOIBa9HLdF+IqhGxPAIRtEnD8SyrZvAvVI5TUUcilR3dh9wbYiVSmoZYBPIUoU9t6WmNjtcaAOWnVzAsGnEtHtsHzZPf+uNJG5UWbYgtWgxR5pr1hRi+am3oJjDiQ4BIpewsibjjoSfFW/jZitZwFaoFR4rLcw1ZoQVotKdsu/b8Vlq4Y1XbP9TJbtl0fp3kZsihKHgFARpF1L2avF2WbKbkvBxCz/inWtSSkzNf0WNzDGQFX5cqCtFXqZTjSoTUdgWqSTIBe0YL037XBfH1OXYWMf15jKzrzza5TI6NKBEQHbft0gy5CYA2WWi/fpmEpNNJ/p5ycJlKpXdcmbJmVEvwdPOQDPJ/ddNfswTfMFh/LTHAc7ffbgtpiVdZXacNzx71xwKNCgLj5MK4Unj10Mh9fd9SA7Ui7DCDb0LEk9A9lOsvijWY151Aa057ad0M5u/eszorP5g+lvy9fZ/5a7sKnZqny7qlJvGU6fpn15OBgrKW3zSuhdW29bCRHgLXREn8tUF16Te9gJgXI=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"Your two questions are very related.\r\n\r\nFirst, the difference between \"CPU bound\" and \"I/O bound\". The difference is that I/O-bound methods are naturally asynchronous; that is, there is a way to implement them that does not block *any threads at all*. For more information about this, see my \"There Is No Thread\" post: [http://blog.stephencleary.c...](http://blog.stephencleary.com/2013/11/there-is-no-thread.html \"http://blog.stephencleary.com/2013/11/there-is-no-thread.html\") . In contrast, CPU-bound methods *must* use up a thread by their very nature (i.e., they execute CPU code).\r\n\r\nFor I/O-bound methods, it's best to have an asynchronous signature (with a truly asynchronous implementation), and for CPU-bound methods, it's best to have a synchronous signature. This post (\"The Complex Case\") deals with a situation where the method is *both* I/O-bound and CPU-bound. In this case, it's best to have an asynchronous signature but with a note that the method is also CPU-bound.\r\n\r\nThe reason that MyButton_Click uses Task.Run is because the method is CPU-bound as well as I/O-bound. If it just awaited the method directly, the CPU-bound portions would block the UI thread.\r\n\r\nAlso note that the ASP.NET controller does *not* use Task.Run; for efficiency reasons, it *does* want to block the request thread on the CPU-bound portions rather than switching to another thread pool thread.","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"5402f356-1fd9-3942-94ef-9169c1d29cf4","date":"2015-12-02T13:20:48Z","timestamp":1449062448,"authorUserId":"disqus:stephen_cleary"}