{"_id":"c9694c5e-4f12-3e50-b741-7528cf34723a","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Your two questions are very related.\r\n\r\nFirst, the difference between \"CPU bound\" and \"I/O bound\". The difference is that I/O-bound methods are naturally asynchronous; that is, there is a way to implement them that does not block *any threads at all*. For more information about this, see my \"There Is No Thread\" post: [http://blog.stephencleary.com/2013/11/there-is-no-thread.html](http://blog.stephencleary.com/2013/11/there-is-no-thread.html) . In contrast, CPU-bound methods *must* use up a thread by their very nature (i.e., they execute CPU code).\r\n\r\nFor I/O-bound methods, it's best to have an asynchronous signature (with a truly asynchronous implementation), and for CPU-bound methods, it's best to have a synchronous signature. This post (\"The Complex Case\") deals with a situation where the method is *both* I/O-bound and CPU-bound. In this case, it's best to have an asynchronous signature but with a note that the method is also CPU-bound.\r\n\r\nThe reason that MyButton_Click uses Task.Run is because the method is CPU-bound as well as I/O-bound. If it just awaited the method directly, the CPU-bound portions would block the UI thread.\r\n\r\nAlso note that the ASP.NET controller does *not* use Task.Run; for efficiency reasons, it *does* want to block the request thread on the CPU-bound portions rather than switching to another thread pool thread.","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"5402f356-1fd9-3942-94ef-9169c1d29cf4","date":"2015-12-02T13:20:48Z","timestamp":1449062448}