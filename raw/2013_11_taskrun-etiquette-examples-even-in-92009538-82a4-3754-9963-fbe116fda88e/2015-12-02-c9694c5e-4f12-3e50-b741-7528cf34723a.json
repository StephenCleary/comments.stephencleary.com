{"_id":"c9694c5e-4f12-3e50-b741-7528cf34723a","authorName":"Stephen Cleary","authorEmailEncrypted":"NR4iZAAyIDw2q0ZklunvnN2NeGkzQRr2DWvhJYk6amb2n1IEUKidKTPs3g5gYjIsAZb6nZ8ouCpUDmfn9JOjVZcLhQe8D+3RRFbbIVIvof/bpOD4740n5hB5LsJiklaMlvrqpRPR+CtxXdqheU7pEBHmMaFuSnZaq1xb93MitrRHo/SmicdVWDkf/V+9xRp02oafCgRopOBMBnqChwRV5MIMAloeFph6LNK9FJwyH7Vl8ukeYj0icC2iBr5AOTPw/j6dRs5nzRhUzj0X6fmX24v+tf1eHaQqtcG+ehn2txcImZwHruZ73fhFypoGr9Tnyx7qY2yK7bbpd3E/BkSTPL1zOGKIdi1vb5KDI2GM+xnFau6MLmvsAxsSF79OqtLjE2Coy10FslslWcq9eN5fPEAgdY6XNPQpdYdplcOPJRrgX0zQEjfoMvoXzTldLpm9zKZWyC0nMzj0HVU3ixyDMlGM3Trj04vepWSu0WWnNtq4H+bMsxm6zCOYwC/XflbMbQe+9KJGYV87j7wW3q1Ys67ryCnadlne9uFlA90Z3KorQWqPgaqFhCOkTR+7F1VpDghcTWv26e75TdE8JEokSj8m13VRWcfqjAXXWJ4fZcz41aRukrIRaDa0TyzI0KQE+HcdhAZt9idX5WZPF9BRwNicSfmP8mAPHM5GZkZQxdM=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"Your two questions are very related.\r\n\r\nFirst, the difference between \"CPU bound\" and \"I/O bound\". The difference is that I/O-bound methods are naturally asynchronous; that is, there is a way to implement them that does not block *any threads at all*. For more information about this, see my \"There Is No Thread\" post: [http://blog.stephencleary.com/2013/11/there-is-no-thread.html](http://blog.stephencleary.com/2013/11/there-is-no-thread.html) . In contrast, CPU-bound methods *must* use up a thread by their very nature (i.e., they execute CPU code).\r\n\r\nFor I/O-bound methods, it's best to have an asynchronous signature (with a truly asynchronous implementation), and for CPU-bound methods, it's best to have a synchronous signature. This post (\"The Complex Case\") deals with a situation where the method is *both* I/O-bound and CPU-bound. In this case, it's best to have an asynchronous signature but with a note that the method is also CPU-bound.\r\n\r\nThe reason that MyButton_Click uses Task.Run is because the method is CPU-bound as well as I/O-bound. If it just awaited the method directly, the CPU-bound portions would block the UI thread.\r\n\r\nAlso note that the ASP.NET controller does *not* use Task.Run; for efficiency reasons, it *does* want to block the request thread on the CPU-bound portions rather than switching to another thread pool thread.","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"5402f356-1fd9-3942-94ef-9169c1d29cf4","date":"2015-12-02T13:20:48Z","timestamp":1449062448,"authorUserId":"disqus:stephen_cleary"}