{"_id":"c9694c5e-4f12-3e50-b741-7528cf34723a","authorName":"Stephen Cleary","authorEmailEncrypted":"G4UAVr114iiZ47PSAykjg5Es8txLKTsA33exFGnW6uLL4aAVZyOOgrFwudPOPwEcNK8/Dd1m2THiYwv2lRc+TtQQqZ2b2h3qQGhNHtB6VCwhq3FVrhMvB41oSRaMEzxL3Vn0zpUvQESYO+IL0JPSqn/iEv9frtkNd4v177oSWMhZONAi6iANqrhR/WClBkaGIu+95lzj/lr0Fe5sSb24GCFltkl9ZLokw71g4jdmttuF5DEJFz/dZRMzF65ee8/tz006mTM7TYsOXlWR8L0SWDsb5o5HlS+i0Ad5EgmQOVzls3wvInn7630y3ow4d5KVHqPaEU4nDEEWunX2Q2Daam8LBzzCwpwJDRSN1vDaqQl/dfbcoojpwXqTw0bEQl1pyP/G81XoXYpBRxm6TFJbqusKF3LMHI7nvCL6Q1ke4ndq0Zqg6pb3n3Y81T+k9F69jUQGwlWkYbd8anmncVa7Mmwm1PKPqVL4jXSY2QcD9gh6HUS8s/x76oiruErFdnDB3hh0WEAXegaIwdxHnYg8SWzHqn8yNCSozVdgTacT1axkR2JyAYmTu8UaYq4clWks5/Hb0hBVokwVREe57U+0YR7aLkYKXPavXxBWmffoxu2KcWC5QUeXTV/f+M/VhE0Q+XU5FEysp1j0+Ic4GfDXmClFPslapbb25OyTYsAGC+A=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","authorUri":"http://stephencleary.com/","authorUserId":"disqus:stephen_cleary","authorFallbackAvatar":"https://disqus.com/api/users/avatars/stephen_cleary.jpg","message":"Your two questions are very related.\r\n\r\nFirst, the difference between \"CPU bound\" and \"I/O bound\". The difference is that I/O-bound methods are naturally asynchronous; that is, there is a way to implement them that does not block *any threads at all*. For more information about this, see my \"There Is No Thread\" post: [http://blog.stephencleary.com/2013/11/there-is-no-thread.html](http://blog.stephencleary.com/2013/11/there-is-no-thread.html) . In contrast, CPU-bound methods *must* use up a thread by their very nature (i.e., they execute CPU code).\r\n\r\nFor I/O-bound methods, it's best to have an asynchronous signature (with a truly asynchronous implementation), and for CPU-bound methods, it's best to have a synchronous signature. This post (\"The Complex Case\") deals with a situation where the method is *both* I/O-bound and CPU-bound. In this case, it's best to have an asynchronous signature but with a note that the method is also CPU-bound.\r\n\r\nThe reason that MyButton_Click uses Task.Run is because the method is CPU-bound as well as I/O-bound. If it just awaited the method directly, the CPU-bound portions would block the UI thread.\r\n\r\nAlso note that the ASP.NET controller does *not* use Task.Run; for efficiency reasons, it *does* want to block the request thread on the CPU-bound portions rather than switching to another thread pool thread.","postId":"2013_11_taskrun-etiquette-examples-even-in-92009538-82a4-3754-9963-fbe116fda88e","replyTo":"5402f356-1fd9-3942-94ef-9169c1d29cf4","date":"2015-12-02T13:20:48Z","timestamp":1449062448}