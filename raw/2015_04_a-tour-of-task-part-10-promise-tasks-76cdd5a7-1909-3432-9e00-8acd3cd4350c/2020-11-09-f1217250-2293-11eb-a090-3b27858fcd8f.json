{"_id":"f1217250-2293-11eb-a090-3b27858fcd8f","postId":"2015_04_a-tour-of-task-part-10-promise-tasks-76cdd5a7-1909-3432-9e00-8acd3cd4350c","postUri":"https://blog.stephencleary.com/2015/04/a-tour-of-task-part-10-promise-tasks.html","replyTo":"d97def50-21d2-11eb-9735-ed4e5d99591c","authorEmailEncrypted":"UzYkFvgHpVYpxFqUlHjhYuG9+tY7qwdMv620S9MKi1VWAGv8OaLNqATLGKl3o3yan58BXaj8mAilYtyBqjXacshmtdyVBjtkKHjUGCd//A8k7WycBN4SIC7KlweScAAi8IvzO5DbEfEc/6tP+QrbkmNAOFZYLsWLSvakFFZaNYgM7H80HRStMc/LYXz6mEk0G1M3jZ+SLa4EFTdnIuAmfIwJ1vKei2qOnDh8RsDXTbUgmfvVY1dDMXCajDvHzSNyb+QWcc087TQjX4a3Zau5KJRXlCh7Kf7RZfM2hKvqzZZTHf5GcdH4NOIMAXI6NHeAviMRyzm08u2BgWx0Rex1okm0dSsqv+IVx4KZYZrAQTNaME+whZ1E7h7m5Uy9G+p9KmGwDr1ikjK/LDIpKssec13Y7lpXrGkvHGsv3fb8laqBIATKlylYDfqti2e4YFN9mTWv10cTDZYCzyZt4Yb/63WrduPuBJ/7kfBiy45SN67jJXuLWYRqxouk5fRTrp964rrc6TjQ8+S/G6yMabFYZVNeyrueyywlstMGTQMX0swhCG2rCW5WDiRrfKmazVPoTD5L6H7mVtHNVZ97xeSjv+/+Ugu+spEBcTzcUz7a+yydWnKaPfWqiDaEaX2BHzkotYkSyh8dwNe+PmShLf4DA3W9bVrEg38qWEpM6ex7sG0=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I do not recommend that approach, because the continuation of the task is not related to a request, and ASP.NET (Core or otherwise) isn't aware of tasks that aren't related to requests.\r\n\r\nThe proper solution for this scenario is to have a separate background process that does the long-running work, and the ASP.NET process communicates with the background process through a reliable queue (Amazon SQS, Azure Queue, RabbitMQ, etc).\r\n\r\nThere are some simplifications that can be done (e.g., the background process can be in the same OS process as the ASP.NET server by using ASP.NET Core Hosted Services), but they each have drawbacks, too (e.g., the background process fanout is now the same as the frontend fanout; and anytime the frontend scales to 0, no messages are being processed).","date":"2020-11-09T14:00:36.841Z"}