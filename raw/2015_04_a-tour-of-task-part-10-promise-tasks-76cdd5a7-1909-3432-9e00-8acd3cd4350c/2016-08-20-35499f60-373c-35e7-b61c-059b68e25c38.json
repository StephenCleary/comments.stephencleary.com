{"_id":"35499f60-373c-35e7-b61c-059b68e25c38","authorName":"Stephen Cleary","authorEmailEncrypted":"U8KXPzrhibAuFwjDq8D1OPKvC6aixS4cRxUs1l++9YhtSMKCrwS6LM+c8P/Lx6gpMJezqRKLe+x48MTGoWDgYU+pTSdaiajg4M3spvOvpx93zDJcHDliIkmHDmP9EK5h+1h94P3M3gautn59wf7ohCBk+O9IOwJV1UaG5k2jFrOWynT56LbTYenCFeyqoysCdFUBvV37noWp9BmYl7qNtA5kjHXVE7TYVI9pVHVI/3Rc9as2Dw28ToWdO9JKhNZBnZnfXzsybNKGm3/XCMhgZyDICPVsJy0UuTSc8Fq6dlBI+HOl22vnv6Y0RfheGl5n4uyqtb50yQGpJae5g/h/c/pNO9NqwB3THSGQV5fn7NQKKi4AR2n1Kug58uw9GLe2/lZSXW3csWp/HJQDlNMnJsH30KcW7XDJETRSKNz4vQgQpPNfC+nSg9D+dutFqBRbBWcGl1muqKobMSCijt5m8gjQRVP6M6IMysh6McmV8pZX/pRl2hzrhJTbPs4wyhVkmMv+6BNdk4L03TxN13DY+u/iAK1KuoHUx6jTnlN5RJ8qxId9Dm45rW5UFcAgp6b2MV2UpZT+c/g70Jlbpz/CYTaNUXqvMYm40EHBYjaIn5A8flAbDkM1WabvSvWDTy6SABKh9zVZsYmRwdEttqb3cmhSCkF2aaypcZxY+4IuWvs=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"There was already a way to create a canceled task that did *not* take a CancellationToken (via TaskCompletionSource<t>.SetCanceled). The new methods *do* take a CancellationToken because technically, that's the right way to do it.\r\n\r\nThe CancellationToken is observable if that task is await'ed - it will throw an OperationCanceledException whose CancellationToken identifies which token caused the cancellation. The use case for this is rare but real: when calling an API that can be canceled different ways (e.g., a timeout or a user-requested cancellation), and if it's important to determine which one canceled it, then the caller can examine OperationCanceledException.CancellationToken. In most cases, just checking CT.IsCancellationRequested on both CTs would be sufficient, but sometimes it's necessary to know which one *actually cancelled* the operation and just using IsCancellationRequested would cause race conditions (e.g., if the user caused the cancellation but then the timeout expired before the CT checks).\r\n\r\nIt's also just cleaner and nicer to pass a CancellationToken because that's the standard cancellation semantics.\r\n\r\nI think the article you referenced is a bit confusing:  \r\n- The ArgumentOutOfRange exception is thrown directly. That is, if you pass an uncanceled CT into Task.FromCanceled, the exception is *not* placed on the task. It's a usage error - a boneheaded exception, as Eric Lippert calls it - and is thrown immediately and directly from Task.FromCanceled. Code should never call Task.FromCanceled with an uncanceled CT. That exception indicates a bug in the calling code.  \r\n- You would (almost) always pass in a local CancellationToken. You'd (almost) never want to pass in \"new CancellationToken(true)\". If you find yourself in this situation, it means you're writing an asynchronous API that can produce canceled tasks but does not provide a way to cancel them. That goes against the common semantics - a more appropriate exception would almost certainly be better than OperationCanceledException in that case.\r\n\r\nI'm hesitating using \"always\" and \"never\" in that last point, but honestly, I can't think of a single situation where you would ever *want* to pass \"new CancellationToken(true)\".","postId":"2015_04_a-tour-of-task-part-10-promise-tasks-76cdd5a7-1909-3432-9e00-8acd3cd4350c","replyTo":"4bbc17a8-d527-3b60-8856-f32f0cdece00","date":"2016-08-20T01:05:47Z","timestamp":1471655147,"authorUserId":"disqus:stephen_cleary"}