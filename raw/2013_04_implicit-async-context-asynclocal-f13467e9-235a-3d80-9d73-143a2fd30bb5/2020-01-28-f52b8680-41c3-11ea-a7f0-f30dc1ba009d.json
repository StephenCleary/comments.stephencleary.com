{"_id":"f52b8680-41c3-11ea-a7f0-f30dc1ba009d","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"29e9c040-3985-11ea-9fb7-dd74b7d427f2","authorEmailEncrypted":"SBiGPbOWuGYBdbiyG9ma1wwjekrExjJGtE/KwspSBGmKs+7xK5rG2g/i92tO2Oa6s6GY2R10LU6m1rjttGJCcJamR97z357wzJabL1V9s6jUc7kHToC5wtfWGuTP74688datxHfl0Pa4ky3SatMKMp/kkmmIgiFu+kzum+XSq80xy4iAA3eUEf1VESY9hLc69Gktztxw4vSKyMNJWiB8tLFl2uwA0f6IRGH2mMkKIOZUTKWVrLPnlyN+zLrz8VT3aG+YHcUMG4WvbKcVbupt70+wIQrpuvHoL4znC+bmpHKKQ91uPV8wyQRtqwAv1njU42MPFY5wXV0UJ21S1SUw8OxLsN2cHh+KIfYlIxEOsJGLJO0U3dOJnxktS6E6bilFg01/jIQvKETQO2DlQ2aSFwb1/O3E30Uvk1ynyDqFEFAQitwLPeGu+oFpDYgRKixaerdB8N3XiAFsuNtAEpNe0ONc/3PGiGiKb4fyTJ4xq1wNLR2ZAOZ6hVsOzZmNRy/fqZE4RFRInHpWw7wwbstNGRx5sT5OwxXTKmH55xUXeMCGnvB5GPkhIZnGVhWnoaVSdDv3Otappcb+8C40GgIadxJA507lMXjlNP7Q/gFX+ERJMm1zzE9BYhjikYl/KFBNTPMB26st1JXWpJrUGfz4ElGeBgESIhitDTtqAxLpTuA=","authorEmailMD5":"08f7976637ff7b2937883996406aab2d","authorName":"Ohad Tsamir","authorUri":"","message":"Thanks for your reply.\r\n\r\nPrior to .Net Framework 4.6.2, `OperationContext.Current` was thread static and would never flow between threads, so any `async` operation that caused a thread switch would nullify the reference.\r\n\r\n4.6.2 added [execution context improvements](https://devblogs.microsoft.com/dotnet/announcing-net-framework-4-6-2/), which were turned on by default. However, that caused other potential issues with services marked as `ConcurrencyMode.Reentrant`, and was [turned off again by default](https://github.com/Microsoft/dotnet/issues/403#issuecomment-303778619) in 4.7, with the possibility to turn it back on via an appSetting `<add key=\"wcf:disableOperationContextAsyncFlow\" value=\"false\" />` (notice the double negative, this is essentially turning the async flow _on_).\r\n\r\nSince we have no reentrant services, we are now looking to implement this config change, so we can \"trust\" `OperationContext.Current` again. Unfortunately, we still have many legacy services that were programmed prior to 4.6.2, which cannot all be upgraded together, and are still using the `CallContext.Logical[Set|Get]Data()` approach to retain request-specific state, hence my worry.\r\n\r\nAs for your suggested reason, I'm not clear on how _not_ having an `async` method up the stack could cause this? Isn't a single-threaded, non-async execution the simplest for maintaining context? In my own code there is no `async` indeed (nor any explicit threading). It is running inside a `MessageInspector.AfterReceiveRequest()`, and I don't know what WCF is doing with the call before it gets to my code, but from the top of my head I'd assume no asynchrony is taking place there either. Reminder: `MessageInspector` is registered in WCF pipeline as a singleton. Could this be related?\r\n\r\nAs for your proposed solution, I've been searching but can't seem to find how does one \"set the logical call context\". Could you either post a code snippet or refer me to an online resource? Still, I'm curious if it can indeed apply to the issue I'm witnessing, considering I have no `async` operations (at least in my own codebase) around the problematic area.\r\n\r\nI'm aware this is somewhat invasive, so I appreciate your effort in answering. I do suspect however this may be important to non-negligible portions of the WCF-using community.","date":"2020-01-28T11:47:27.953Z"}