{"_id":"17b9cea0-4fb5-11eb-b0d7-7f4815f9c976","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"30cee410-4fa7-11eb-a867-5507102e4024","authorEmailEncrypted":"GAEwiS7RD+1LVRwzrwmdIklU6t6UK7yxzBUUpDzKCyH46A+am5cSedcKFZ6qXAqgQH/8KmevhMGQHgRuR07OSIJHybPbI9Gx5YtzX8XgzKoW6IqZ2YQAMq2gX34MaCK4pdQed0FpCuAVzMDiRcK7uuda4rZ7bEEDgduh75VtGaGoFqCgxKFw5WYO6MXn2SgkgNmnuLY6ZX/0pFsHK1eg6qMg1CWhxOGpkPMiALbWqBWiBy37/azCVXC+omsQeIda5glYNOcRvRk185dNX2j16V3+Y7VjNToVwKwxqWHIDoCG66nxhssmNrUwA9OTf2KRh5qIADvrNjtvY0pFrk6p6aVWF2Jeyt868VeeD6beXT7bp87UVSGN8LLsE+SBzUQ7UDybH3TO4M70GcYuUAbCLq2M7MggC6GqJWp+VR3DBo7SFyCPEj3N16SmI2vLw2smVOz11K7ZoIRWwjhkqVb7h4hBVUtXBxxChLt0Om1gZJZ7kpaL8s0D85v91QWKc3QMRBvjdl802SENlLzye2tu5o2Bz+kREVudHOiUAG0/oHsmzsxpUdxxQg9XjK47HSOTJWQB5DXuCikcPHoY1y4hL4bBq3WS5AdGkScBbYcUjrpmnONImZMTGFZsp+7yVma4+w5d8sTqumjoGIGpdXQns7qPMr0/8XA33gilsSdHDOE=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"The `LogicalContext` is marked copy-on-write at the beginning of an `async` method. If it is modified within that method, it will be copied.\r\n\r\nThe tricky part comes in if the method *doesn't* use `async`. E.g., if the code calls `Task OneAsync()` and then `Task TwoAsync()`, and if `OneAsync` does not use the `async` keyword, then `OneAsync` will not have a copy-on-write context (or more correctly, it will share its context with its caller). So then if `OneAsync` modifies the context, then it will be modifying it's parent context, and that could be observed by `TwoAsync`. This is an extremely rare situation, but is important enough that I called it out in my [eliding `async` post](https://blog.stephencleary.com/2016/12/eliding-async-await.html).","date":"2021-01-06T00:21:17.608Z"}