{"_id":"ee7fc027-87a4-30cc-b1f9-41b910a7c72b","authorName":"Paul Rogero","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/18276298439153144212","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen,  \r\n\r\nFirst of all, thanks for your posts on the LogicalCallContext. They were very helpful in explaining the concepts. I had an idea very similar to yours above regarding logging flow throughout a tree of async operations. A key point in my idea was to be able to apply the logging code via PostSharp.   \r\n\r\nI copied your code above and it worked perfectly, just like you described. However, I then attempted to replace your using(){ } blocks with a PostSharp method aspect. It did not work unfortunately. The code for the aspect is below:  \r\n\r\n [Serializable]  \r\n public class ClearyMethodAspectAttribute : OnMethodBoundaryAspect  \r\n {  \r\n public override void OnEntry(MethodExecutionArgs args)  \r\n {  \r\n var disposable = MyStack.Push(args.Method.Name);  \r\n args.MethodExecutionTag = disposable;  \r\n }  \r\n\r\n public override void OnExit(MethodExecutionArgs args)  \r\n {  \r\n var disposable = args.MethodExecutionTag as IDisposable;  \r\n if(disposable != null) disposable.Dispose();  \r\n }  \r\n }  \r\nThis is the output:  \r\n*** ConsoleOutput ***  \r\n\r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\nMain:   \r\n\r\nIt seems that it would be functionally equivalent to your code but there must be something I am missing since I can't get it to work properly. Do you have any thoughts on what the difference between the using(){} approach and the MethodAspect approach?  \r\n\r\nThanks,  \r\nPaul","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2014-03-18T06:27:22Z","timestamp":1395124042}