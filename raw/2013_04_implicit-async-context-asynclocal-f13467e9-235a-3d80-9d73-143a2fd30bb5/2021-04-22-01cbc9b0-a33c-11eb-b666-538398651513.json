{"_id":"01cbc9b0-a33c-11eb-b666-538398651513","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"","authorEmailEncrypted":"RGOvq4tTqLOtJ1gYeHyqtBAmpRrc8Ic3EGs+yntknJKK2IlWvRaowS37bVdOFRSO2oeJuDyAuyexE/ASmMGrUjkdxQVxmxbyJFwqd6v7yytpdmEj0A3emX/peoMz1zvOt3usDObg2MRCG2MAL3OemSgCZTQOFX4peGor3+MFNAdQrw3I+/0IxIeknMbmyw6M8N37xM3+rRHiJs9xxAt2VOlxLbuRFWSdBCY6Ohg6t5SWRxSivyj+oaOvvw1MZdHXVsd7/1hkBeWIHoMi+xTDALuhou9AWlAUQN38LOcsCbEojyf5pzk9qO1AHlGBjhlzTihDlrbEDxz+jye0eDhykBHqWcFfiDPUlg19mLCfYHnG8tELaLCVAMXaQKNZckaBWyvelfvITXTNW42Alkc9J+mXzY6jhxVuGeZYjgXIQpRWyL5A/fGhnyKXWJNG8Ppq65X5S4aD4cwimYLpuoz5HST2ZqrMPKMs08pWq9xllKbupIBb+2iMnc2cI3sguZxD4yUDUC86rsWSwLMiNpLuK58qOChV1JbXzjlymXLWvyFfO0g3gxbWv40PBOwh9GPYchUrG+MbTYDT+mAVFm794/S1YU3nikYUJBQZOxn8Rro3lOLLMNvLPAHTxPuVOaVBmIZv72dodC/my39MjkdXMDf0l+Qq+jXq8j6y6a5ZBtM=","authorEmailMD5":"0be2d175837eede271b5a02849330850","authorName":"Melissa Wittstock","authorUri":"","message":"Hi Stephen\r\n\r\nGreat post!\r\n\r\nI'm investigating an issue where a user ended up with another user's cookie. \r\n\r\nThe following is in play:\r\n<ul>\r\n<li>Target The .NET Framework 4.8</li>\r\n<li>async/await</li>\r\n<li>.ConfigureAwait(false)</li>\r\n<li>static </li>\r\n<li>HttpContext.Current.Response.Cookies.Set(httpCookie);</li>\r\n</ul>\r\n\r\nOn digging into the code I found the following helper method. Try your best not to cry :-P\r\n\r\n<pre>\r\n  <code>\r\nprivate static void AddOrUpdateCookie(HttpCookie httpCookie)\r\n    {\r\n      // TODO: At time of writing this comment there were 102 live NullReferenceExceptions on this method in production.\r\n      if (HttpContext.Current.Response.Cookies.Get(httpCookie.Name) != null)\r\n      {\r\n        HttpContext.Current.Response.Cookies.Set(httpCookie);\r\n      }\r\n      else\r\n      {\r\n        HttpContext.Current.Response.Cookies.Add(httpCookie);\r\n      }\r\n    }\r\n</code>\r\n</pre>\r\n\r\nTo my knowledge the code-behind of HttpContext.Current looks like this. \r\n<pre>\r\n  <code>\r\npublic static HttpContext get_Current()\r\n{\r\n    return (CallContext.GetData(\"HtCt\") as HttpContext);\r\n}\r\n</code>\r\n</pre>\r\nAnd in your post you mention. \r\n<blockquote>The regular call context (CallContext.GetData and CallContext.SetData) acts just like thread-local storage, which of course doesnâ€™t work for async methods.</blockquote>\r\n\r\nBesides using HttpContext.Current with async/await being an obvious disaster. I was hoping you could elaborate on the inner workings of why CallContext.GetData and CallContext.SetData doesn't work well with async methods. Could this be a plausible explanation for the cookies being polluted across users?\r\n\r\nThanks \r\nM","date":"2021-04-22T07:26:09.118Z"}