{"_id":"654ec420-394c-11ea-a228-db01b2ef7800","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"","authorEmailEncrypted":"hUCqaPpjp+ZwL4NKvOI1Wfj9adUYrQFBfyTHgjgDjDOsHYPduNmkm1Lwp89J9WTCMHp6ErUFtegwVrIGjEXxN3ye7C5ah32I2VPRhgNKoQD+vr3XZOoHMI82xgT+0jYVYzfuASCEd3qN0BdPWSSDZVx7soo91tCVBqhYfeE5WY60um2k1YuBECRFHxIjYMd6ZJzEGrSweTo+suB7GwRloREB0hTStoNX98fcZJnM7WfT5UaXx4GoTQ4115APfvfMfenchnRNQxXw8P6OSlHenQhGCy17ItXk7M/+y/AdOhnijUFtnj+lg45pISo5YS52GPFzwwiDunj0IiPIqR1NQDBZIsW1Z4GIZ23WbeC/KOt+bk6WZDWyXhSUBsrfWhKJLNjNpehqq28pVlbVO4u/3ItZwVDBPFWDtY6FGYNVltUNlq11APQ85gnOWMclkTxUBJRA1ni2FZrrpgCc0qYPupo+lr7M5/P2UVzssPKYASzb6sNEHe5pxcjZaEY7gK5DwKDF0KvZ9yyiKY1a40ZSwxN4/xlFhHYbZ6sMHf8djlDBtd6gv9PYkmBR+Gi60dg1FPwqo3cfWNUJBTihX8mhYvjtD2r+wNW9OqOcDRkFiK6rd0nBzcIMtbZ0sxXJdq50mN/ry3gPo+nUnmzq/0X8i0zq/XEa+w+57DdY4JxKYGA=","authorEmailMD5":"08f7976637ff7b2937883996406aab2d","authorName":"Ohad Tsamir","authorUri":"","message":"In my company, we've been using CallContext within WCF as a replacement for OperationContext.Current, which could become null after async operations. I've recently stumbled upon a behaviour that alarms me: Sporadically (more often with high concurrency), a request calling `LogicalGetData` will gain access to data stored via a **different** request's call to `LogicalSetData`. Would you have any explanation to this? Could execution context be shared between different requests to a WCF service hosted in IIS?\r\n\r\nIf relevant, the calls to both methods are performed via a `MessageInspector`.\r\n\r\nAdditionally: The original data I stored was not immutable (because I only read your post now :) ), so I created a new test case where I only store the string `OperationContext.Current.IncomingMessageHeaders.Action`, which in WCF holds the operation name, and indeed I could still (sporadically) access another operation's action. But I'm wondering if this is of any relevance? If I understand your post correctly, the importance of immutability is to ensure that the data is in the correct state, but I'm assuming that even mutable objects shouldn't be able to cross the boundaries of a single execution context, correct?\r\n\r\n[Here](https://stackoverflow.com/a/59787566/198797)'s an answer I recently posted on SO (feel free to correct / address me either here or there).","date":"2020-01-17T17:11:27.128Z"}