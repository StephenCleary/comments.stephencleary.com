{"_id":"fc18e7df-8fca-3e6f-8231-21357ac66ca5","authorName":"Stephen Cleary","authorEmailEncrypted":"KWIZI9Fge7a3efTV52AsDlWev7W1/tyZd+o7KmTflFGSWjvZhhhghWs4zHNbFE9BRwrJv/15Ae1LSJ7LGYRMINejNn4K50jbJ7nJZRazYk0n/6k1ydv3L6qlLEWBIDjc6F2cspfXEo/WN2uCEWaQshIuEBLIALvFUCWZuLpzAGKA3bok+9DcZkHQ77ENCEb+JY2TqXTxJkdT8KCE2rFRUTN//H1swlJgzLT+SIkgGyE7wUXTw+ufwzDf6BQkx0EW5py3ITrma7n5gIiN7VyNAiZ7MF2ecrDQDDVxJjBPPPQKT5NGQnxIefQ/F+Lcx47JmYfeY2EyxPedD84hbTy4I+JL+O1MrRIYDdoKyKm5QT8O57Z7HV9+spAzMeLyxjZxDOgfaXyE+YglyPrH1k5z5aZqck5GOWjG5RfXb0Px5QHWaefG/csVYRDHdCVZqardFpd1dntkyflBL0V/bYTafbIgPmut4gHqtdbHAHVk4h3dQcuvJLz1Ajv1bhiS1x95SyZWROpPX4JRwLRqZWOIIRi1numGigY1dn3xD8d/D0S28lYrskiXB47XrTD2cSBKbExxHt0A6zbuhp5b12evh7X4VIdt520IPpGwrLjehryD5nJIj12Mn5XDi/3bSFnHjXMo1Xq1G+IOlB2hfMDx22WIkyqcsm98yAX2rB5+ss0=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"Yes. There's a difference between inheritance and copy-on-write.\r\n\r\nThe logical call context is always inherited across threads (this is what makes it the *logical* call context; the regular \"illogical\" call context does not cross threads). Technically, the data is shallow-copied. This happens every time the flow crosses threads.\r\n\r\nThis is different than copy-on-write behavior. With copy-on-write, every time the thread enters a method that cares about the call context (right now, this is just async methods), the copy-on-write flag is set. Then, *if* the call context is written to, then the data is shallow-copied. This is important for asynchronous fork/join scenarios, where it's quite possible that a single thread will handle every step of the process, but there are multiple asynchronous operations making progress concurrently.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"85cf54bc-ed72-3df2-8e64-187b258d2c29","date":"2015-11-03T18:00:55Z","timestamp":1446573655,"authorUserId":"disqus:stephen_cleary"}