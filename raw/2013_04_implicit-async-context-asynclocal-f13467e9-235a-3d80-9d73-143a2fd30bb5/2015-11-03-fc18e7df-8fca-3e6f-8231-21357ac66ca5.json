{"_id":"fc18e7df-8fca-3e6f-8231-21357ac66ca5","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes. There's a difference between inheritance and copy-on-write.\r\n\r\nThe logical call context is always inherited across threads (this is what makes it the *logical* call context; the regular \"illogical\" call context does not cross threads). Technically, the data is shallow-copied. This happens every time the flow crosses threads.\r\n\r\nThis is different than copy-on-write behavior. With copy-on-write, every time the thread enters a method that cares about the call context (right now, this is just async methods), the copy-on-write flag is set. Then, *if* the call context is written to, then the data is shallow-copied. This is important for asynchronous fork/join scenarios, where it's quite possible that a single thread will handle every step of the process, but there are multiple asynchronous operations making progress concurrently.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"85cf54bc-ed72-3df2-8e64-187b258d2c29","date":"2015-11-03T18:00:55Z","timestamp":1446573655}