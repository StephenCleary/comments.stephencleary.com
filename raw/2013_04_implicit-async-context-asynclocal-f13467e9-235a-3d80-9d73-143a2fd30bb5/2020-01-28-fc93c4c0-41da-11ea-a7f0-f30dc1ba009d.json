{"_id":"fc93c4c0-41da-11ea-a7f0-f30dc1ba009d","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","postUri":"https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html","replyTo":"f52b8680-41c3-11ea-a7f0-f30dc1ba009d","authorEmailEncrypted":"Hk0l+CL5AFUk4w64+RD6T/sFwsHVM4bdyPGbRRBoi7BKnaWYXdauDlBvc0iE6tfQOXAqYTuCxCekKnUEIFai7dIW4S7omkAXuEcs+/+NNU+N6AO80uKxhPG6ifDDzOQ9ROdSFUrlN+RrRE5DuHO/gEgdTbT1w+WHjLHZs/iARrHAQPp/fjhVZQ9AYRMgZvneJUaEl7TXgovs6MmaGd2cYq23xse1mG5zBSrBabPbYo+49Evjq2X1KQ8LF2xrtQBpBVChI5ulRIo+sN0vujORscrCaYsAXTkQUOlM1Ek8QbMbcWzTS39MYMMmSFRFtMhyZz4lcS3UZ/Rhd7rPDARQOmCBvSyMygUxoBAJusHfEzW3rDtQhtraOGmCE9AWY1tBaLy0mfLA1eWp71a857cpN/QszUpJvHo2OzOHpjYDI5BSt39tCpglxLXd774wPHoSLcrFUENh/pkRfvx3jk+FmRpzjUYl/HH3YLXFb1kh4hadsAQNUr/wrrUnEvUrnPj2KfpHvhOMNtCZWXTh5LPlJZXXT5nv7gjKiWN5oaJCk4WNIRZSG57TuTvYVJtzcmxtsR8/f1mhA7M7DD54Sv7+czMRS1xlud969BA8iTvxnR9H5QLH5EgaQnFwLg+e7qEcy8KURXIa4nS1Rzg6FEYQzom2NSlG99fjNhZNAunjLTo=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Ah, that context is helpful! It has been many years since I've worked with asynchronous WCF services, but let's see...\r\n\r\n`CallContext.Logical*Data` should work fine, especially if you need to use code across legacy and modern.\r\n\r\n> I'm not clear on how *not* having an `async` method up the stack could cause this?\r\n\r\nIt's because an `async` method triggers the \"copy on write\" behavior for the logical call context.\r\n\r\n> In my own code there is no `async` indeed\r\n\r\nAh, in that case the fix may be much simpler: ensure your code always calls `CallContext.FreeNamedDataSlot` to *delete* the data when it is done with it.\r\n\r\nThis step is redundant for `async` methods because when `CallContext.LogicalSetData` is called in an `async` method[1], the current logical call context is copied (if it hasn't been already), and when that `async` method completes, the previous logical call context is restored. So any adds/updates in the `async` method are removed/reverted automatically.\r\n\r\n[1] - Technically, this refers to the closest `async` method going up the call stack. So if an `async` method calls a synchronous method that modifies the logical call context, the copied logical call context is considered the \"current\" one until the *parent* `async` method completes. Synchronous methods allow the logical call context values to flow back up the call stack, and since your code is synchronous, that may explain the behavior you're seeing.\r\n\r\n> `MessageInspector` is registered in WCF pipeline as a singleton\r\n\r\nI don't think that would be related. The \"illogical\" call contexts are tied to threads, and the logical call contexts are related to call stacks; neither of them have anything to do with object lifetimes.\r\n\r\n> how does one \"set the logical call context\"\r\n\r\nSorry for the confusion, I meant just modifying the logical call context in any way, e.g., calling `CallContext.LogicalSetData`.","date":"2020-01-28T14:32:18.752Z"}