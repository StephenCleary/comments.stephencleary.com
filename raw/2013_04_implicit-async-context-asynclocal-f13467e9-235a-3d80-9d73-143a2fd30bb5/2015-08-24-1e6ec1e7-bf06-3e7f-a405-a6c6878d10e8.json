{"_id":"1e6ec1e7-bf06-3e7f-a405-a6c6878d10e8","authorName":"Brent Arias","authorEmailEncrypted":"A8LaOJGkM0mQXo9UnqYO+kKCJyxhFrU4aEixEsjPW2o3G6NbWjLEMVi6sx45vZ59Z+YACAM9KTdTN7lM31o4xuE7xsXbMW2LMG08c6rTYTi7OvAP+QA65BfscQUqmCZuV2agbKvWixSaPC+ey9yHQRZ8tP8LwOFT4kQeg/t7fa/HfaAo3lLE0YIlXqeSWkD7hkxX/ofJkor6nU2+4XGYJ0v93Ax1dozUAtRdzV+Eqe7GhgBqqqlqp6zvyXdiS+sHOlNB7GERzQu+WcNJ7nRmoM/fRzaHTmKZ6Ksr0J+mN2zA+eifR7thslNYZ2IbKgYotsY/je0MKD7K8M7jS7TgUKeEc22h0qC5j2BZ5XWvLavDXPgCnMtrAOi6WtPf1NCblGf4YBFC+t+vuo87EuzIVSDYEngEOw/QYoamGWSt7YNqDH+gAk21Yo9lxJXSRx7I19S4vzHs0yV1T4DtXxqvwCqSmH0tHW0ZjmtpMVFwyex867a+RTNnoODlYr3deHgASb39dZuzEi8MOk1pvDxC2gLNf1DGwf/IRdNGFDNtYwNFD1syzxDBS711ifprmwqha8y2gXiBTvjNILsqmVyMDrzkY7Id2PUt3qbaOK0jUVxk4XYakhuFPIBxUAUPKohGihyejJPv/PcN+N8fOsF/T2tVWlNC5XDV50+43NtLtaQ=","authorEmailMD5":"0c0a1f54ab0a0911fd931ae5e19a5903","message":"Three problems. First you said \"you can end up sharing data two different ways: .NET before 4.5 did not have the copy-on-write behavior, and the copies are shallow.\" There is something missing or contradictory in that sentence. I think what you meant to say was \"you can end up sharing data two different ways: without copy-on-write before .NET 4.5 and with a shallow copy-on-write after .NET 4.0.\" Am I correct?  \r\nAnother problem is that your article seems to insist that .NET 4.5 copy-on-write is only active when using async/await keywords. In fact it appears to work with any form of multi-threading. For example, I built a .NET 4.0 test app (run on .NET 4.5) that merely uses Thread.QueueUserWorkItem in combination with CallContext and it achieves the same copy-on-write behavior.  \r\nA final problem is that your sample code makes no attempt to call CallContext.FreeNamedDataSlot(). As a consequence you obviously ran into the \"...not marked serializeable...\" exception when a thread was returned to the thread pool - which is presumably why you created the MarshalByRefObject \"Wrapper\". Unfortunately this means there are threads subsequently being dispatched from the ThreadPool with a dirty CallContext. I suspect it would be better to revise the design of the sample code so that (1) explicitly freeing the CallContext is an option and (2) the final Pop() which produces an empty stack will in fact free the CallContext slot entirely.  \r\nI'm interested in your feedback on all three of these suggestions.","postId":"2013_04_implicit-async-context-asynclocal-f13467e9-235a-3d80-9d73-143a2fd30bb5","replyTo":"","date":"2015-08-24T20:56:15Z","timestamp":1440449775,"authorUserId":"disqus:Mystagogue"}