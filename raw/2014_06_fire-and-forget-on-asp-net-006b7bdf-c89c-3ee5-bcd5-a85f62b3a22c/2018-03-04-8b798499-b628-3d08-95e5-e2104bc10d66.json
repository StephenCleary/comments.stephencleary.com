{"_id":"8b798499-b628-3d08-95e5-e2104bc10d66","authorName":"Stephen Cleary","authorEmailEncrypted":"X6ICf15z6ty6LAoV554CI4RnqGlIPE0PnwvOiFQWc5UCJF4y99V94/j1w+fmBYJ2ZvCBJWDD+4Alzm5mcMoC7xr9CGjRsNtDFKUZSs0H9Sjy6zfiQ1t48nIJpk6VbPIKrV6n9K3w8sPFRff905Pg2zdbOzGvViAx6+Ht9f+UrsIzRafwcm2J55pIOXvTY3QmkuquAFetPuUVQ5X6C4vp2RSf6wZyMNwhjsEGeodXGmjRRi4By50Yii7RvQRp1tE84pBO6ekAFSDDgRd0apGRHXBxvAiO3F6rHYwStSdmoGb3OVlNFvX1LNJU4XBQzoag9dq/T3ahvRYelHIH/IhRyUeU3xeXOBkCKS5bzQIFAs0a7d0s7DrWdtemHvdG1+CTVcRTazJECT7LuR+rH65mWrTZrUutA7NIaCyVW31ottF0JrJtKD8YLSG+sOSo5U5fG/hCsguLuL9/xpExIR/x48xZdKW9UHuNLyMW5uxSijRHyr/A5Ke8mlEQJsKIswMbbvvCP3XoOUonLIAYLVUsTg/L0p/gZ83TOl5iu0BGMGb1mqRgLLGhbyDxU7crwuWr0FjI1VVJlfBYj+hVIcaiynAUz93FrFp36UdRVFaZQ3l4hDIMc+WZGo7N11sOVgL3koBfE41KtYNU0mAIGWhkmVBW/zLip9Nv0N1Nbqj18sA=","authorEmailMD5":"28dde5772b48c92e08b8050411aa5ba8","message":"Since this is a library, then if at all possible, I would push the \"fire and forget\" part on your users. If you have a synchronous API, then your API should likewise be synchronous. Async-over-sync is generally an antipattern: [https://blogs.msdn.microsof...](https://blogs.msdn.microsoft.com/pfxteam/2012/03/24/should-i-expose-asynchronous-wrappers-for-synchronous-methods/ \"https://blogs.msdn.microsoft.com/pfxteam/2012/03/24/should-i-expose-asynchronous-wrappers-for-synchronous-methods/\")\r\n\r\nThat said, if you are sure you want to provide an async API for a sync operation (and in a fire-and-forget manner, no less!), then I would say:\r\n\r\nStrongly consider providing a \"done\" signal for your consumers. This blog post of mine covers problems with fire-and-forget on ASP.NET, but the same problems exist for any other host. If a Console app uses fire-and-forget, then it can't know when that work is done, so it doesn't know when to exit. If a UI app uses fire-and-forget, then it can't know when that work is done, so it doesn't know whether to prompt the user to wait. If a Win32 service uses fire-and-forget, then it can't know..., so it doesn't know if it should delay a Windows shutdown. Etc.\r\n\r\nRegarding your options, I would say that it depends on what kind of \"kill/cancel the task if it is hung\" behavior you need. Thread.Abort is dangerous (can easily corrupt application state); AppDomains are a bit cleaner (more difficult - but not impossible - to corrupt application state); but the best all-purpose \"kill\" solution is a separate process (impossible to corrupt application state). I once had to encapsulate a database driver into a separate process because it was so unstable it would crash our main app on a regular basis - not fun, but doable.\r\n\r\nBTW, Task.Run doesn't provide a way to timeout a task, at least not in the way you're thinking.","postId":"2014_06_fire-and-forget-on-asp-net-006b7bdf-c89c-3ee5-bcd5-a85f62b3a22c","replyTo":"977dba87-4cbf-3c86-a939-e3ba5d2c2ce3","date":"2018-03-04T03:15:24Z","timestamp":1520133324,"authorUserId":"disqus:stephen_cleary"}