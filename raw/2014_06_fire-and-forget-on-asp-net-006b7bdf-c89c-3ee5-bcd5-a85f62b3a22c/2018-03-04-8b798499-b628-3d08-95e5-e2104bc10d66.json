{"_id":"8b798499-b628-3d08-95e5-e2104bc10d66","authorName":"Stephen Cleary","authorEmailEncrypted":"CYN7MI27zLvW5OjEob0tCPSregYR+MnT04Bh7Q2SSmabSgc4qhpz+CwH4Bi6Cd9Ge8Ol+5Dy3fG1v4Le4LPQktzLNrqeqZG4raR2wpfpQSIvCsDklLoxwuNZcRpMwssNJljZngCy3tYJ2zsjeUPbpDJAt3CEcDlDT439ICftzHQaLT5kO1MfRMfPXGOoGpfyQsEcD1KGHQ+AOrokiY2AxySASSEqF00kTJkP/i8mb1CbufFqzIssh9/eZAexmYeqfU9jkSCrMOElmcZgLaKXZCd1I+tKui93Cr3KpqVvjRndkBsNLBevRSPGyum/5BNYCpWbfH6F6OaKOsh08qcENFwZfFLVTdEGYgfh5BkhohAwnzsFcvF59zr4IISpCVlH7C5jEUWf1V1er1WM1lhSXU9+mMjlYuBJe6zJtKG6J9NScNrp6bV1MSCqfA3CiL0GysU3PnCy63r4dCCpuSCfAHstaxd5GYuugDLAcZNGz5sDzvW5a8kVRwselHtHH7cxcqxtImhc2J1LP9/kjASZDeab9g3Jl25nD685adCY/X2tsI5H148viEPk3noa90xhJfsN9xrbe+oDdTMfbCunPc606BVMs77rFGXNDAuMGP6mWzh4F4jzWLACyqrP+UxdaxjQDKftAhyCBUh+/ugB6RdLb/eR5jZf4gUiyqPnMsY=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"Since this is a library, then if at all possible, I would push the \"fire and forget\" part on your users. If you have a synchronous API, then your API should likewise be synchronous. Async-over-sync is generally an antipattern: [https://blogs.msdn.microsof...](https://blogs.msdn.microsoft.com/pfxteam/2012/03/24/should-i-expose-asynchronous-wrappers-for-synchronous-methods/ \"https://blogs.msdn.microsoft.com/pfxteam/2012/03/24/should-i-expose-asynchronous-wrappers-for-synchronous-methods/\")\r\n\r\nThat said, if you are sure you want to provide an async API for a sync operation (and in a fire-and-forget manner, no less!), then I would say:\r\n\r\nStrongly consider providing a \"done\" signal for your consumers. This blog post of mine covers problems with fire-and-forget on ASP.NET, but the same problems exist for any other host. If a Console app uses fire-and-forget, then it can't know when that work is done, so it doesn't know when to exit. If a UI app uses fire-and-forget, then it can't know when that work is done, so it doesn't know whether to prompt the user to wait. If a Win32 service uses fire-and-forget, then it can't know..., so it doesn't know if it should delay a Windows shutdown. Etc.\r\n\r\nRegarding your options, I would say that it depends on what kind of \"kill/cancel the task if it is hung\" behavior you need. Thread.Abort is dangerous (can easily corrupt application state); AppDomains are a bit cleaner (more difficult - but not impossible - to corrupt application state); but the best all-purpose \"kill\" solution is a separate process (impossible to corrupt application state). I once had to encapsulate a database driver into a separate process because it was so unstable it would crash our main app on a regular basis - not fun, but doable.\r\n\r\nBTW, Task.Run doesn't provide a way to timeout a task, at least not in the way you're thinking.","postId":"2014_06_fire-and-forget-on-asp-net-006b7bdf-c89c-3ee5-bcd5-a85f62b3a22c","replyTo":"977dba87-4cbf-3c86-a939-e3ba5d2c2ce3","date":"2018-03-04T03:15:24Z","timestamp":1520133324,"authorUserId":"disqus:stephen_cleary"}