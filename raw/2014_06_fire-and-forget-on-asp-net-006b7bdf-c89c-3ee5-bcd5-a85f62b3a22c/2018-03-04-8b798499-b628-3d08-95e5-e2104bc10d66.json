{"_id":"8b798499-b628-3d08-95e5-e2104bc10d66","authorName":"Stephen Cleary","authorEmailEncrypted":"rCCgz7dn7qeGNCf/CFZCTIIGMkX5vbCMaPXyvrig8xCgcyvSMhBG7hkebE50PSIFfz7/XlWEt4r60ReQJizqfkAmy5EEHjxFxaftQarzbR4K9xAtMRh51zSHiarL0D3Ti4ZIEWpjerfXhX5uH1TSqEnoSSIaB6P0Xxfyx/KxMgUcIeJ8Nh7q1IayMgGjtfQkYxzQ2DpK+1wAVmktGF6k4SNyf8mG8k8niNmTKoi7mv3+wiTSvKad6KjmojgYK7Var5bIcaspmDlA/Oag/ndcdM8cYHntdBbYPumk7CzvvrjOdjsCUy7jQK0KTAU0qOvjP1icIlO6r2duR2LDOqi7zNeLZB6kjKZxIsESsvq3lSHbPysgVXPenhdeIZTkKbLzDsCVt3eg9uhsp7yEvqoH8D1aRPcoOJsMwAUkKAPH9b9AJ2hTS0aIrlSoy0Cvp+akNbbpGIaJkmPkUUr9tUtVpizJC1tFJLrtoWNUqsFL/ZhG9dJHK2cLY7cDt5PX7YZbyj4M6yxZxiXSxdRBYOkViJ9vp995f5cw750VZ2xbrzAFI8xWfsVpOevQCakPRyxBbzh+277cbFDVEDVWvg3WrXn7qA/u8p9z2e9byr1FE1S8XSvE2omYuoBO99FTwtWT4O9x3fErYC6XYlX7ApLFm+hvpsR0vwn/W7l9wpLbbbI=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","authorUri":"http://stephencleary.com/","authorUserId":"disqus:stephen_cleary","authorFallbackAvatar":"https://disqus.com/api/users/avatars/stephen_cleary.jpg","message":"Since this is a library, then if at all possible, I would push the \"fire and forget\" part on your users. If you have a synchronous API, then your API should likewise be synchronous. Async-over-sync is generally an antipattern: [https://blogs.msdn.microsoft.com/pfxteam/2012/03/24/should-i-expose-asynchronous-wrappers-for-synchronous-methods/](https://blogs.msdn.microsoft.com/pfxteam/2012/03/24/should-i-expose-asynchronous-wrappers-for-synchronous-methods/)\r\n\r\nThat said, if you are sure you want to provide an async API for a sync operation (and in a fire-and-forget manner, no less!), then I would say:\r\n\r\nStrongly consider providing a \"done\" signal for your consumers. This blog post of mine covers problems with fire-and-forget on ASP.NET, but the same problems exist for any other host. If a Console app uses fire-and-forget, then it can't know when that work is done, so it doesn't know when to exit. If a UI app uses fire-and-forget, then it can't know when that work is done, so it doesn't know whether to prompt the user to wait. If a Win32 service uses fire-and-forget, then it can't know..., so it doesn't know if it should delay a Windows shutdown. Etc.\r\n\r\nRegarding your options, I would say that it depends on what kind of \"kill/cancel the task if it is hung\" behavior you need. Thread.Abort is dangerous (can easily corrupt application state); AppDomains are a bit cleaner (more difficult - but not impossible - to corrupt application state); but the best all-purpose \"kill\" solution is a separate process (impossible to corrupt application state). I once had to encapsulate a database driver into a separate process because it was so unstable it would crash our main app on a regular basis - not fun, but doable.\r\n\r\nBTW, Task.Run doesn't provide a way to timeout a task, at least not in the way you're thinking.","postId":"2014_06_fire-and-forget-on-asp-net-006b7bdf-c89c-3ee5-bcd5-a85f62b3a22c","replyTo":"977dba87-4cbf-3c86-a939-e3ba5d2c2ce3","date":"2018-03-04T03:15:24Z","timestamp":1520133324}