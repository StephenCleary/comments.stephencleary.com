{"_id":"8b798499-b628-3d08-95e5-e2104bc10d66","authorName":"Stephen Cleary","authorEmailEncrypted":"DD+im42CSGbPMzB/3Ht6tZ2DWaePwh1DLAPx/j3ySRLg3W6K9Mo3wxDLdIr1NEWVpP4HKcv22T8W1nTdyTUiQluB5ccnnYHzo/zjSNfia1pwgdtci7UzzBgQdKV8VgqWaucb9Dda5KrY2f0R3zVwG1dm+W4rtLpqKiI1AnwbrKTLfXMQ+AfsfGArxEOCpSUQ4OEXbgPu755Ca70QDgXVXlIl7o46dbWULarlzclcp3UVypCbfmPOLY4gGyP+dKVYGzBmbE/oleO5d194H2XqkdmtPK6sjtSWNCMTLhQ29fCvDAFyHsWZ8/GWvXBu8WRdlm+1dlMLxS16N72yI0gG4h9jhUGrshxgU4GG0w4JXD5wf2mf3wQJ/C9IErbxDszYQ36xXCNkzNpgbZfjS27Z7y08RkIVGgni06aX+FOshGRB5tBJBwFNtq8OTzm9MtSxZGI9F+Tw8hsgUMqbUGTsAzsb1V8Z+7z4xHxFQxne4CNHVDMBPoS8GnjXZ7SF643OPIa3b9JVXMUELrnn6iRqesq9FAdCQmBbSOtENm0bHJpbzNJ6KkAs+61clMPntRVFEHIOnTMRHbnkvRBXMeFelTDYrYZFGjgQGzqwdMYgVa2N78MDn9JxCMuZgKCxv2DFp7Dt49BVpUdFeWlRuRToz2mpubfecpQ/w7v5SNAg2MI=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"Since this is a library, then if at all possible, I would push the \"fire and forget\" part on your users. If you have a synchronous API, then your API should likewise be synchronous. Async-over-sync is generally an antipattern: [https://blogs.msdn.microsoft.com/pfxteam/2012/03/24/should-i-expose-asynchronous-wrappers-for-synchronous-methods/](https://blogs.msdn.microsoft.com/pfxteam/2012/03/24/should-i-expose-asynchronous-wrappers-for-synchronous-methods/)\r\n\r\nThat said, if you are sure you want to provide an async API for a sync operation (and in a fire-and-forget manner, no less!), then I would say:\r\n\r\nStrongly consider providing a \"done\" signal for your consumers. This blog post of mine covers problems with fire-and-forget on ASP.NET, but the same problems exist for any other host. If a Console app uses fire-and-forget, then it can't know when that work is done, so it doesn't know when to exit. If a UI app uses fire-and-forget, then it can't know when that work is done, so it doesn't know whether to prompt the user to wait. If a Win32 service uses fire-and-forget, then it can't know..., so it doesn't know if it should delay a Windows shutdown. Etc.\r\n\r\nRegarding your options, I would say that it depends on what kind of \"kill/cancel the task if it is hung\" behavior you need. Thread.Abort is dangerous (can easily corrupt application state); AppDomains are a bit cleaner (more difficult - but not impossible - to corrupt application state); but the best all-purpose \"kill\" solution is a separate process (impossible to corrupt application state). I once had to encapsulate a database driver into a separate process because it was so unstable it would crash our main app on a regular basis - not fun, but doable.\r\n\r\nBTW, Task.Run doesn't provide a way to timeout a task, at least not in the way you're thinking.","postId":"2014_06_fire-and-forget-on-asp-net-006b7bdf-c89c-3ee5-bcd5-a85f62b3a22c","replyTo":"977dba87-4cbf-3c86-a939-e3ba5d2c2ce3","date":"2018-03-04T03:15:24Z","timestamp":1520133324,"authorUserId":"disqus:stephen_cleary"}