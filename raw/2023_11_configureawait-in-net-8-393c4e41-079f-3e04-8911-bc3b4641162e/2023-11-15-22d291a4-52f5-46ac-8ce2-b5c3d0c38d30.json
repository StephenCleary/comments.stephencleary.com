{"_id":"22d291a4-52f5-46ac-8ce2-b5c3d0c38d30","postId":"2023_11_configureawait-in-net-8-393c4e41-079f-3e04-8911-bc3b4641162e","postUri":"https://blog.stephencleary.com/2023/11/configureawait-in-net-8.html","replyTo":"7008d2b8-5c5e-4ec4-9ea5-deb61dabad2b","authorEmailEncrypted":"ZOtJej3tLUor4\u002BPuepoFFIgwV\u002BexZHXgzZiQDqgXMtNfI6psOBOHH/SW1OqfGUU\u002BLpht\u002BuIV3PTRkSTKcZLa5ZziHhExmkyYvcNss1WIzGNC6vfKEy6sb3POUq7ffGFNSJimsKqlrrp5CyzyiZ0KkUXGnBwiqYvu2SUI3nXWBrDYxublmZw4lmmPhjw1DczvD5aABDYhBfqSTAbeGoRjTCh1catPuTnqmDNw4J8H7UmKKwx5Y5Xxe1nT2COmxSOYkyqDkgu4343ZAJEpbL/hgxpPEocnLivSieEMJIgY4NOPTVbIymEJFvTFqKnzu//ij/TxBnR2ThEQHLvwXIZctNsQCL/S4kOd4mussEMjug7zAdVfwAnaBFU/aBIczHYlDYxkgAAAd4tU1Vz6O74Aj//M7LvxVQm1TtEkCuL6xMo4XaaHxGSJsTYN4d9QxMk3l3Xo2HOnppSMOh74K8Vpc8Y2Kz3su4QAH/2qlIz/tgu7P1dlJtlWS\u002BApaB7MoL2a3DxD7SKC3bSPcV1sD8bIzsJTCDwL78NpyaXnRkT3hT3TNMUAJ2oWGpZEelVfMn9H85\u002BzGiEP33BVJIPcY1gT7urbAVPFQIBpzv\u002B5q2DMCpUe/ba8F\u002BGfWGFZ4UxO40hiQivtOe/skjNSKkyTuQOuLWYlso4t2I/amBi8k90cE8c=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Sure!\n\nFor the unit testing situation, it\u0027s sometimes useful (or necessary) to check how the behavior differs when the system under test receives a synchronously-completed task vs an asynchronously-completed task. E.g., if \u0060A\u0060 calls \u0060B\u0060, you\u0027re testing \u0060A\u0060, and \u0060B\u0060 returns a task. Most unit testing just has \u0060B\u0060 return an already-completed task, which is fine but does cause \u0060A\u0060 to behave synchronously. If you need to test the asynchronous case of \u0060A\u0060 then you need \u0060B\u0060 to return an incomplete task (but one that ideally completes quickly so your unit tests aren\u0027t delayed). In that case, I currently use \u0060Task.Yield\u0060 to force asynchronous behavior during the unit test.\n\nRegarding stack dives, this is a much more rare situation. It usually shows up with recursive algorithms that deal with cached asynchronous data. When the cache is empty, the data is asynchronously retrieved, and the algorithm gets back an incomplete task which it awaits. However, when the cache is populated (i.e., contains already-completed tasks), then the algorithm gets back a completed task and continues synchronously with its recursive calls on the same stack.\n\nI\u0027ve never seen this kind of stack dive in my own code, but I have tracked it down for other people, so it does happen - just very rarely.","date":"2023-11-15T15:59:43.6262008Z"}