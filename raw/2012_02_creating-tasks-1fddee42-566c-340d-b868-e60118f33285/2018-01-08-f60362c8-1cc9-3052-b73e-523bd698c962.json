{"_id":"f60362c8-1cc9-3052-b73e-523bd698c962","authorName":"PassingBy","authorEmailEncrypted":"sC2Gc8PlZ4U5H8pZv11d+V9/7XUPvq8L/G4oQ+IJCVYuPL2YcjAlSfMSEk2oHNBuQbylurbnMsZKmLCDa/qhFqr/3PLO0uoUFeceHa8uiT7TZJlgX61kgbAcWiyTE59bIX7S8v718bYDohByAJm8Puyap9hnt7ZIcEgLercPsQaPuSC14fdPcsoXwqg2DwJp1xdsRabjgxCpd3EA+amt5w3yaDuKjC/QBaUGkUIprJ36X3v6ceunaJW5dDCWZeKjt8lF5G6P13YzgYt7YX662wnxteZ6jr+Df5jwla+MJrvB5RxdsUvEJhbp4OBC1RDhnd2dNfETDSotYDTk4Z0rPuQ3rjdGM0NaszQwwR29duKMw6+ozmxqV4/8uBr/cPsj0nNW9XaFc/MNyqSbK3fOoQuFZ/RhdUD/Q1Fo4OitwiPB8q9gfYhBL/KvF2yW8aazuB4RpMc+mYnNzLggAWODQ44X0igCcb+k/uLwvQi8n8a1pzxzlDcZSG2b5/ga0rm6M8FVThFcI0/XUiMaFi1d45MtMGbes259rXwEGBBjfa+vohhzeaAPzPomoiWHa1FpSxAeW/Qj+yhv09BufcXGCMP1PniMGmHgeKY2zxFquIz/xaqLbJol7cXksYMiSQh0CJDMmvalOmzVQRfJAqabDHbWHS5jfBPWr96PvTMobl0=","authorEmailMD5":"7303b498db923f32f44778477daadb2b","message":"Thanks for the fast reply. I appreciate it.  \r\nAnd you said that GetAwaiter and OnCompleted are extremely fast operation. Can I consider this that it is free from your old statement\r\n\r\n-------------Quote 1------------  \r\n'Conclusion: do not use Task.Run in the implementation of the method; instead, use Task.Run to call the method.'?   \r\n-----------------------------------\r\n\r\nFrom your article again.  \r\n-------------Quote 2------------  \r\nThe request starts processing on an ASP.NET thread.  \r\nTask.Run starts a task on the thread pool to do the calculations. The ASP.NET thread pool has to deal with (unexpectedly) losing one of its threads for the duration of this request.  \r\nThe original request thread is returned to the ASP.NET thread pool.  \r\nWhen the calculation is complete, that thread completes the request and is returned to the ASP.NET thread pool. The ASP.NET thread pool has to deal with (unexpectedly) getting another thread.  \r\n-----------------------------------\r\n\r\nThat is, because I still see that for the second example, Task.Run is running in a static method which is called from main thread. And one more time, you said that GetAwaiter in main thread is extremely fast.\r\n\r\nIf not, I would just let the method be 'synchronous' for the computing-bound algorihm and implement the aync in a main thread with a Task.Run as you said in the other article.\r\n\r\nBy the way, thanks to your concise post, I got a new insight to concurrency. Thanks again and have a nice day.\r\n\r\nPS. Sorry if you got a multiple set of notification because of my edit.","postId":"2012_02_creating-tasks-1fddee42-566c-340d-b868-e60118f33285","replyTo":"e3298318-0f99-35f7-8caf-e7303fda18e2","date":"2018-01-08T00:46:12Z","timestamp":1515372372,"authorUserId":"disqus:disqus_dyYQnhsWs6"}