{"_id":"e3298318-0f99-35f7-8caf-e7303fda18e2","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"In real world code, you shouldn't call GetAwaiter or OnCompleted; you should just use await instead (which calls these under the hood). That said, calling GetAwaiter (or OnCompleted) is an extremely fast operation, and it doesn't matter which thread they run on.\r\n\r\nThe question of \"which one should I use\" comes down to what kind of operation you're dealing with.\r\n\r\nIn your first example, you have an event firing off a Timer. This is similar to the way I/O works, or other events (including timers). This is a very natural fit for using tasks as events, so wrapping these events into a TaskCompletionSource is a natural approach.\r\n\r\nIn your second example, you have a Thread.Sleep. This is a synchronous operation (blocking its thread). So it is similar to the way CPU-bound algorithms work, or any kind of a blocking call. If you don't want to block the calling thread (e.g., the main UI thread), then a natural approach is to wrap it in Task.Run. Once they're wrapped into a task, they can be await'ed just like any other task.","postId":"2012_02_creating-tasks-1fddee42-566c-340d-b868-e60118f33285","replyTo":"38ffb00b-cd4e-34d9-8493-dfaead61e012","date":"2018-01-07T21:12:48Z","timestamp":1515359568}