{"_id":"38ffb00b-cd4e-34d9-8493-dfaead61e012","authorName":"PassingBy","authorEmailEncrypted":"eOIPETS2ahUklW+HloAz4StdwIR+eIXmNuJGkw8fn6hnhfQFNW2KcrXgETBbm1xFhf3pr8/N7TGKhaTyVqPkglxwDPpoWTuKUX7oRBIu/3YQElvX1pWJmfnGRLEVkJGWlnpwGPeY8fF9GjLRcZj3xjCapd1wms3WgzDE4sgFzdbaKGdsD6J+ntfGRkJGXgpTFF13eIeS7SW1YRPJuc9p1/DRAmoB3PVcuR5mFBgYHAlUTr6/e9F5LSol81KcJluesr5khPl3agC1+++0aGW9kFsaGYvzSn0vMlaK2oUbXGftA/sBGRGI9ufCWjzvVJROrL1otWYxKuoy5c4MglYaPRlhFubs7AwcNHK143roCcEcgre52S5SUESwCzj+RV26IR3dPiZW0CY7fj8aYTE1Bb+nClOd/emhqtZjsC9ss+nh+A6rWkLz309EvIiBLkHtZmsSwBh13NoIpLmyfINW277t8J3BTjeBSeeFkoJOWl9+mZNwH0NadLPu7SXi3gTKQd05AQeIF3eR6vWN48grmkttIMc5sm+TW0OapEti3JbyUJlCZSEvDxHvzn8HJXOBwdc/LnjJKh75VP1nQ4q9LeXNCMPeUfxsNERhfngt5Cbw6oar66zMWQVtQn30hupQuyiHYWB2PQOMEPro5EFlPWeNeYqDDwdkIhdL4LuItHY=","authorEmailMD5":"7303b498db923f32f44778477daadb2b","message":"Hello, thanks for the great article!  \r\nNow, I'm reading below article together and getting a glimpse of the difference between event-based & computing-based async operation.  \r\n[https://blog.stephencleary....](https://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-dont-use.html \"https://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-dont-use.html\")\r\n\r\nFor the 1st event-driven TCS example, I would consume the TCS.Task with TaskAwaiter<t> in a main thread which is from method calling DoStuffAsync().\r\n\r\nSo, from this, may I ask you a question?\r\n\r\nIn the other article, you said that Task.Run should be fired in a main thread for a better efficiency. When you call 'DoStuffAsync()' and get an TaskAwaiter in a main thread, on which thread does this happen? Does it still fall into a category 'Conclusion: do not use Task.Run in the implementation of the method; instead, use Task.Run to call the method.'?\r\n\r\nI'm considering below two scenarios.\r\n\r\n// Below is an event-based approach  \r\nclass Program  \r\n{  \r\n static void Main(string[] args)  \r\n {  \r\n Console.WriteLine(\"Hello\");\r\n\r\n TaskAwaiter<int> awaiter = GetInt32().GetAwaiter();  \r\n awaiter.OnCompleted(() =>  \r\n {  \r\n Console.WriteLine(string.Format(\"The result is {0}\", awaiter.GetResult()));  \r\n });\r\n\r\n Console.WriteLine(\"Start Non-blocking-calculation with TaskCompletionSource\");  \r\n Console.ReadLine();  \r\n }\r\n\r\n static Task<int> GetInt32()  \r\n {  \r\n TaskCompletionSource<int> completionSource = new TaskCompletionSource<int>();  \r\n System.Timers.Timer timer = new System.Timers.Timer(5000);  \r\n timer.Elapsed += delegate  \r\n {  \r\n timer.Dispose();  \r\n completionSource.SetResult(42);  \r\n };  \r\n timer.Start();  \r\n return completionSource.Task;  \r\n }  \r\n}\r\n\r\n// Below is computing-based approach\r\n\r\nclass Program  \r\n{  \r\n static void Main(string[] args)  \r\n {  \r\n Console.WriteLine(\"Hello\");\r\n\r\n TaskAwaiter<int> awaiter = GetInt32().GetAwaiter();  \r\n awaiter.OnCompleted(() =>  \r\n {  \r\n Console.WriteLine(string.Format(\"Result is {0}\", awaiter.GetResult()));  \r\n });  \r\n Console.WriteLine(\"Start Unblocking calculating\");\r\n\r\n Console.ReadLine();  \r\n }\r\n\r\n static Task<int> GetInt32()  \r\n {  \r\n Task<int> my_task = Task.Run(() =>  \r\n {  \r\n Thread.Sleep(5000);  \r\n return 42;  \r\n });  \r\n return my_task;  \r\n }  \r\n}","postId":"2012_02_creating-tasks-1fddee42-566c-340d-b868-e60118f33285","replyTo":"","date":"2018-01-07T09:31:48Z","timestamp":1515317508,"authorUserId":"disqus:disqus_dyYQnhsWs6"}