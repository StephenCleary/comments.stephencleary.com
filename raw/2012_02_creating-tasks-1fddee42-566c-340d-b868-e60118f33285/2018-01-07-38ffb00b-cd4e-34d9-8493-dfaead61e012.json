{"_id":"38ffb00b-cd4e-34d9-8493-dfaead61e012","authorName":"PassingBy","authorEmailEncrypted":"vKI+BfrTJMT9whJ3LBfAe2UMH4l/pfl9ryMpHNj+0K2MjvyWIUwCmnPg3da+5tEtTbRIodLOuFhGXrJljIJxBrGGYi7FMQS/2z/JcS92M0odHsb5zzLVMU4Kn9TwRyP7i2eulQprxtpyxwyHTDVXyBGKZo0OQrf3UGiDZ4s51K4RhVPJI4EDpxXSs0WMbdE98ZIwnZ80Ho/4YOlgOFvt/wy8voW+pctxkwRGPQoQ+kNTfv9rUQOPeCC/vAQuHHQqCmQXRwdd1ut1V3anKDaNiTfjxqkZyTFEyL+OmwTQhoyAE9oqMOIgyeA/5tqddoTBrnUlQhibZFaF6h4K9Gt6+zVo0Ukvv7XBPg1EdbXb/y9aEUBQb4Yy1cSG9KQA3PKhFWByWCFOr14qW8LPvbJeQY/y25aNU4RSopnxGalraChtCNf/r54U88xP+/g5zvv4y1iKQ6KxiJvtXDg7v7o9CFbhPU7ClKeI7nlQ3E1mcfCHgmrCOq5owJF2HqcINVRLub8CmXdZr+Mas7sM66xQGqFgy6UcT5fKVHz1XGMmnWPezCCAkhC/UqWXTpUwcd2HsUguRRZFnsvrjL3HywN1IGEqEggPB2QUR+5omr60HqVsK/xFpvcrMRLdWcdtDvIdLoZcJYdCUep+AedR0zYhGuuMs/wQ9AOGfAX6hBnpfyE=","authorEmailMD5":"7303b498db923f32f44778477daadb2b","message":"Hello, thanks for the great article!  \r\nNow, I'm reading below article together and getting a glimpse of the difference between event-based & computing-based async operation.  \r\n[https://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-dont-use.html](https://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-dont-use.html)\r\n\r\nFor the 1st event-driven TCS example, I would consume the TCS.Task with TaskAwaiter<t> in a main thread which is from method calling DoStuffAsync().\r\n\r\nSo, from this, may I ask you a question?\r\n\r\nIn the other article, you said that Task.Run should be fired in a main thread for a better efficiency. When you call 'DoStuffAsync()' and get an TaskAwaiter in a main thread, on which thread does this happen? Does it still fall into a category 'Conclusion: do not use Task.Run in the implementation of the method; instead, use Task.Run to call the method.'?\r\n\r\nI'm considering below two scenarios.\r\n\r\n// Below is an event-based approach  \r\nclass Program  \r\n{  \r\n static void Main(string[] args)  \r\n {  \r\n Console.WriteLine(\"Hello\");\r\n\r\n TaskAwaiter<int> awaiter = GetInt32().GetAwaiter();  \r\n awaiter.OnCompleted(() =>  \r\n {  \r\n Console.WriteLine(string.Format(\"The result is {0}\", awaiter.GetResult()));  \r\n });\r\n\r\n Console.WriteLine(\"Start Non-blocking-calculation with TaskCompletionSource\");  \r\n Console.ReadLine();  \r\n }\r\n\r\n static Task<int> GetInt32()  \r\n {  \r\n TaskCompletionSource<int> completionSource = new TaskCompletionSource<int>();  \r\n System.Timers.Timer timer = new System.Timers.Timer(5000);  \r\n timer.Elapsed += delegate  \r\n {  \r\n timer.Dispose();  \r\n completionSource.SetResult(42);  \r\n };  \r\n timer.Start();  \r\n return completionSource.Task;  \r\n }  \r\n}\r\n\r\n// Below is computing-based approach\r\n\r\nclass Program  \r\n{  \r\n static void Main(string[] args)  \r\n {  \r\n Console.WriteLine(\"Hello\");\r\n\r\n TaskAwaiter<int> awaiter = GetInt32().GetAwaiter();  \r\n awaiter.OnCompleted(() =>  \r\n {  \r\n Console.WriteLine(string.Format(\"Result is {0}\", awaiter.GetResult()));  \r\n });  \r\n Console.WriteLine(\"Start Unblocking calculating\");\r\n\r\n Console.ReadLine();  \r\n }\r\n\r\n static Task<int> GetInt32()  \r\n {  \r\n Task<int> my_task = Task.Run(() =>  \r\n {  \r\n Thread.Sleep(5000);  \r\n return 42;  \r\n });  \r\n return my_task;  \r\n }  \r\n}","postId":"2012_02_creating-tasks-1fddee42-566c-340d-b868-e60118f33285","replyTo":"","date":"2018-01-07T09:31:48Z","timestamp":1515317508,"authorUserId":"disqus:disqus_dyYQnhsWs6"}