{"_id":"38ffb00b-cd4e-34d9-8493-dfaead61e012","authorName":"PassingBy","authorEmailEncrypted":"kaiFeGi8svElhZpUAFCY+h3twqcuSVJfWO5RB2uCsEK5pz5VffHY2/k8BAmcsYmq56M2t5myQH1KMKLRZPg4EdvPN5a3hGM3nxp6X2quldGwK2Imebb8LxMnSJH9F13fjp+X+Z/ln5oupbmqdILs5ydrjq5CT0SIKgbRtiRiztGPU0EODFAQhD6HbtT/V0ZoCEWObEeCm9c5YeP16s2VnPRQ/L5ZroXxobTnkm3DcUu+6EuESAoZjw4AZBHzr02KPSMYLy/xtS2WR+9btJbyBCtjyagv1xmwfvJhx3/QIIwtTIb2tZhsvvw6Lmoc3TA1clPF4j4kDc82w6lLC7g1n7m9Vqxla1XzPvb9IQaQKEfSx0xwvxepclXgTeqQ9KqLbxGR+ygrpfZjZoaw34w12vVxw60ICeIq5GAiv3fp1xG6RWl/6SPYDEHGKu+Dixw1aflqcjfGohSmtX/gFG0TzdpUoKuP2HHcS/3PM/ycZspAaCsb+Bo0cXGBw42iAZzxZ2yLrVYqhoURpMGRmoNpolsiS0+xFWs3eCD+gTZisVPrdSL8XAUxSjf4s9Ve3rf/ut5dC0Mswiw8Pf2CECaAoDaN91Lzl79c/fav9ykHddQy6+khzSipXxMIanUmOV7AomiuXbra8ROJoqI9MuEMCSp7VX5kjz8ELOaiixozcKQ=","authorEmailMD5":"7303b498db923f32f44778477daadb2b","message":"Hello, thanks for the great article!  \r\nNow, I'm reading below article together and getting a glimpse of the difference between event-based & computing-based async operation.  \r\n[https://blog.stephencleary....](https://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-dont-use.html \"https://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-dont-use.html\")\r\n\r\nFor the 1st event-driven TCS example, I would consume the TCS.Task with TaskAwaiter<t> in a main thread which is from method calling DoStuffAsync().\r\n\r\nSo, from this, may I ask you a question?\r\n\r\nIn the other article, you said that Task.Run should be fired in a main thread for a better efficiency. When you call 'DoStuffAsync()' and get an TaskAwaiter in a main thread, on which thread does this happen? Does it still fall into a category 'Conclusion: do not use Task.Run in the implementation of the method; instead, use Task.Run to call the method.'?\r\n\r\nI'm considering below two scenarios.\r\n\r\n// Below is an event-based approach  \r\nclass Program  \r\n{  \r\n static void Main(string[] args)  \r\n {  \r\n Console.WriteLine(\"Hello\");\r\n\r\n TaskAwaiter<int> awaiter = GetInt32().GetAwaiter();  \r\n awaiter.OnCompleted(() =>  \r\n {  \r\n Console.WriteLine(string.Format(\"The result is {0}\", awaiter.GetResult()));  \r\n });\r\n\r\n Console.WriteLine(\"Start Non-blocking-calculation with TaskCompletionSource\");  \r\n Console.ReadLine();  \r\n }\r\n\r\n static Task<int> GetInt32()  \r\n {  \r\n TaskCompletionSource<int> completionSource = new TaskCompletionSource<int>();  \r\n System.Timers.Timer timer = new System.Timers.Timer(5000);  \r\n timer.Elapsed += delegate  \r\n {  \r\n timer.Dispose();  \r\n completionSource.SetResult(42);  \r\n };  \r\n timer.Start();  \r\n return completionSource.Task;  \r\n }  \r\n}\r\n\r\n// Below is computing-based approach\r\n\r\nclass Program  \r\n{  \r\n static void Main(string[] args)  \r\n {  \r\n Console.WriteLine(\"Hello\");\r\n\r\n TaskAwaiter<int> awaiter = GetInt32().GetAwaiter();  \r\n awaiter.OnCompleted(() =>  \r\n {  \r\n Console.WriteLine(string.Format(\"Result is {0}\", awaiter.GetResult()));  \r\n });  \r\n Console.WriteLine(\"Start Unblocking calculating\");\r\n\r\n Console.ReadLine();  \r\n }\r\n\r\n static Task<int> GetInt32()  \r\n {  \r\n Task<int> my_task = Task.Run(() =>  \r\n {  \r\n Thread.Sleep(5000);  \r\n return 42;  \r\n });  \r\n return my_task;  \r\n }  \r\n}","postId":"2012_02_creating-tasks-1fddee42-566c-340d-b868-e60118f33285","replyTo":"","date":"2018-01-07T09:31:48Z","timestamp":1515317508,"authorUserId":"disqus:disqus_dyYQnhsWs6"}