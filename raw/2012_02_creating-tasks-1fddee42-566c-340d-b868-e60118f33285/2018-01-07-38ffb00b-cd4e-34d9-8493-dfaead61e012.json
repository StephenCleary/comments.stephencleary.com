{"_id":"38ffb00b-cd4e-34d9-8493-dfaead61e012","authorName":"PassingBy","authorEmailEncrypted":"P9N/+G0wcrQH/kkqnlgHOUZl52aOjupTn9GyRrV7xCVJyMGWccAZHPtla6QBT/4B7VHys5OZl4rBtDsQulbuZdwJnyWNe5h1vtVFPXGuUzbVHiGQofOf/eR/hI3FVv1ALQ98t/ycZTG0DRvlciIJVH3FU8yFt3HI6xYskA64UTfUmhBx4651q7A6yuel1qdEf/c1bfbgQLGyUeGp3qf4i97zG+63Gaf4ne6kxomM+OZnutEaRzIB9dMYkX/2AJrTNTG42NtW5Doco2euv646iMTngqM14nL1aUGjlMIux9oEgJCeKqw6navIUB+IK5uaqKrt27QXJx3uAu+avnRJ+Q0RV/4l6lFIHM52L2MkOd4kMJRf1CWLd5MjW+hJT+qrTFSweYp+4e72JGmC/MMB8wHy5eM8Q655aOWSHdYQPiO+0+RXTWXfw2zpdaa+UBqZl/NEAsmb0qRy2zRJykrtOidbKBrALuo4MQRiVofMDESWLYls51QA1453Ex6IWuqM2W5GqsW9wnF9Vh1MOgxA1VPKIFCaZg0oBlAeJ/5TtqGYiNPs2F+9ueLYLBHhYBPeFNihkO35F/asFlUJ8Ajji7zSefCIIYYL+rfk1RD55dbfd1vbHV8NezfBlPrLDAtUNEEWrvo0mCRJGhu5uihz+gC3i1kAOCkDaYAERtjuIEA=","authorEmailMD5":"7303b498db923f32f44778477daadb2b","message":"Hello, thanks for the great article!  \r\nNow, I'm reading below article together and getting a glimpse of the difference between event-based & computing-based async operation.  \r\n[https://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-dont-use.html](https://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-dont-use.html)\r\n\r\nFor the 1st event-driven TCS example, I would consume the TCS.Task with TaskAwaiter<t> in a main thread which is from method calling DoStuffAsync().\r\n\r\nSo, from this, may I ask you a question?\r\n\r\nIn the other article, you said that Task.Run should be fired in a main thread for a better efficiency. When you call 'DoStuffAsync()' and get an TaskAwaiter in a main thread, on which thread does this happen? Does it still fall into a category 'Conclusion: do not use Task.Run in the implementation of the method; instead, use Task.Run to call the method.'?\r\n\r\nI'm considering below two scenarios.\r\n\r\n// Below is an event-based approach  \r\nclass Program  \r\n{  \r\n static void Main(string[] args)  \r\n {  \r\n Console.WriteLine(\"Hello\");\r\n\r\n TaskAwaiter<int> awaiter = GetInt32().GetAwaiter();  \r\n awaiter.OnCompleted(() =>  \r\n {  \r\n Console.WriteLine(string.Format(\"The result is {0}\", awaiter.GetResult()));  \r\n });\r\n\r\n Console.WriteLine(\"Start Non-blocking-calculation with TaskCompletionSource\");  \r\n Console.ReadLine();  \r\n }\r\n\r\n static Task<int> GetInt32()  \r\n {  \r\n TaskCompletionSource<int> completionSource = new TaskCompletionSource<int>();  \r\n System.Timers.Timer timer = new System.Timers.Timer(5000);  \r\n timer.Elapsed += delegate  \r\n {  \r\n timer.Dispose();  \r\n completionSource.SetResult(42);  \r\n };  \r\n timer.Start();  \r\n return completionSource.Task;  \r\n }  \r\n}\r\n\r\n// Below is computing-based approach\r\n\r\nclass Program  \r\n{  \r\n static void Main(string[] args)  \r\n {  \r\n Console.WriteLine(\"Hello\");\r\n\r\n TaskAwaiter<int> awaiter = GetInt32().GetAwaiter();  \r\n awaiter.OnCompleted(() =>  \r\n {  \r\n Console.WriteLine(string.Format(\"Result is {0}\", awaiter.GetResult()));  \r\n });  \r\n Console.WriteLine(\"Start Unblocking calculating\");\r\n\r\n Console.ReadLine();  \r\n }\r\n\r\n static Task<int> GetInt32()  \r\n {  \r\n Task<int> my_task = Task.Run(() =>  \r\n {  \r\n Thread.Sleep(5000);  \r\n return 42;  \r\n });  \r\n return my_task;  \r\n }  \r\n}","postId":"2012_02_creating-tasks-1fddee42-566c-340d-b868-e60118f33285","replyTo":"","date":"2018-01-07T09:31:48Z","timestamp":1515317508,"authorUserId":"disqus:disqus_dyYQnhsWs6"}