{"_id":"01e7d0c0-38ce-11eb-bd92-0d7160b16954","postId":"2020_03_valuetask-b9bb171a-f89c-302e-8f06-64dd691d79fc","postUri":"https://blog.stephencleary.com/2020/03/valuetask.html","replyTo":"f7bbde70-1663-11eb-b051-e57aaab1653d","authorEmailEncrypted":"KnkqVLisGtovutl0kj4GU0EgNvgBp4p5O1tmPPyE2HLd6QT7WY8phiJLt6Q+IQqjOZGk8FsAkbPHLYhuv2RHB0SRCwiTCHcd/1QMnpDeRRNbkIkYU5QMBjal8EyJ2GVVVasBeGIRuUSOl7aFCduC6XYD9Xhm89Wk95rKo+pgB7cX4rNYPSMZ4y4ZeAxXaKYci+IQzIhT73NY7v3RQiYfx5e6Koi4HZpoynkGNVakPyTtz3lRypNkHkzFSkPd+eEm60BdThroQsgiSj4bmfINhx0jVbVGZJx63V886H2xHm8r+mwNXQfhqAx7p9KtvpY+Sk3yNe8/cUhmgwNLqtT/zZN7F2oXNtre3T7CZaZqFRC0K5jac+HCAItFWvw7hKjqxewoYooydYRWM+j6+FphQKTeppjVrhNH/PRAfwUPLM1KHGgyypW7XqAEIjzmOuXUkGWK7hz0JDXc+fID0TnpbJ2MV9AiCr+89mIplC8jhWRhmqZTyPE80pw9zbp7yR6eEWtiiY3odEf5kE1iKMekB+w3iY/yS1lzMm3ng/ZOGDzxgooL8+Pdvr1GWQ0CL1mlprxg+Z9oI3+yZc7EKfLEWb9wAVWpYVpo8Uivr3pR3bpEdlrTkWkNHybAdaR4GKXEMG540OwLusUCjQf65jdlvihk/9V8mxEeCO5qyBmFFpo=","authorEmailMD5":"e6c5c7c14bc32251ca80dbb406485ce7","authorName":"Theodore Tsirpanis","authorUri":"https://github.com/teo-tsirpanis","message":"`GetAwaiter().GetResult()` on `ValueTasks` must not be called when the `ValueTask` is _not completed_, i.e. when `GetAwaiter().IsCompleted == false`. If you check for `IsCompleted` first, you can call `GetResult()`.\r\n\r\nIn fact, that's roughly the code the compiler emits when you write `await foo`, with `foo` being either a `Task` or a `ValueTask`. It first checks for `foo.GetAwaiter().IsCompleted` and if it is `true`, it calls `foo.GetAwaiter().GetResult()` and continues syncronously. If it is `false`, the task has not yet completed, and using `foo.GetAwaiter().OnCompleted()`, it schedules a callback for when the task completes. When it happens, it tries again, with the task now being surely completed, and the `foo.GetAwaiter.GetResult()` call being as a result always legal.","date":"2020-12-07T20:51:41.416Z"}