{"_id":"91e2c710-8b6c-11ec-acf1-c908b2ed19dc","postId":"2020_03_valuetask-b9bb171a-f89c-302e-8f06-64dd691d79fc","postUri":"https://blog.stephencleary.com/2020/03/valuetask.html","replyTo":"3a40b410-88e5-11ec-a3b6-e3c8cc2ff473","authorEmailEncrypted":"h1bDECfqFu42J3DA8bi2tN7qBjQfLMJnkaQ06hi5WJYiOl2SG7Twhi4iLiaf5hSjuB4Hu+oQ4nJDjtY+hBOFdLXAWkpo+T5Yd6OvD2kbLKWczN26UpgaHA+f9bu339QmeY5y70lyFPIhGEE5K2QDKrrfd6QSdpZ+UltdYdkXlyNHtqy6uDvs5UjNYJMRtLEJnCuBEJkCgyKi2gGMN31AWT93IRjhmss21e7UiJYIarQixJ+3mPqcQHGirNH0LckBdnsofNEAEFj5Bk7RyBc7oCiqqsPkK8mYKxw0eCKXXXUg0uAfWA8Jie8cVouVsyrqhDv9OJqGhmHc9pX6rvsm+v0goV/5Hgyxe7XwrYHTv+c2vlhXrk3gPJ//NZi4NjPYF8PONfwzCLypyZLuIpCkvC05ZbnpZzfCdFqiUMEQwagxsGYRpx2hZHC90NuL1NJGqK2qXdWRO9Hk+rSdAkIJEzPitI22JCzahGn+eo7L4yVZ1iD/9rut56CCXOf32w3D+GTBwbQ/a5eIQ8UAAS9JbelQGoZ6XIyAP3vox14Ujrqv1X7Y8YwnSK5a2eAiqVxChFAtLz73vONxYwzjMPXfQQGbXeeE8NdW4fkBtzFwg8l4U3VqekjLXmBR7idPTxu0LvsQkBJnLhvvwbT3/QDXCDw+In4Egqv8UJ+uuBGKIx0=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"> I'm less confident it would be a good idea to introduce ValueTask in trivial/semi-trivial use cases.\r\n\r\nYour example code is doing synchronous work and then wrapping it in a `ValueTask<T>`. I don't see any point to that; it's adding the wrapper for (AFAICT) no benefit at all. `ValueTask<T>` doesn't change how purely synchronous code should be written. Synchronous code should still have a synchronous API, just like it always has.\r\n\r\n> I get why it could be more beneficial in some use cases than the corresponding Task counterpart, but not so much at what point it becomes beneficial to introduce over a synchronous method call.\r\n\r\n`ValueTask<T>` gets most of its benefit in scenarios where the method may complete synchronously. Say, if you're making a network call but your code returns a cached value instead. Then `ValueTask<T>` avoids the allocation of a `Task<T>` instance, which is a small savings but can add up over time.\r\n\r\n`ValueTask<T>` also gets a benefit if the implementation is able to pool its tasks. In this case, again it avoids allocating `Task<T>` instances beyond what's used simultaneously.\r\n\r\nIf you do need to shift synchronous work to the thread pool, `Task.Run` is still the best solution. There's no API returning `ValueTask<T>` for queueing thread pool work yet.","date":"2022-02-11T18:58:16.400Z"}