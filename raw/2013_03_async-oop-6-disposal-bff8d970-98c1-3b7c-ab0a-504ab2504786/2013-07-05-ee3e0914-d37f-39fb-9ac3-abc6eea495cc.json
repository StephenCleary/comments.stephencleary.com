{"_id":"ee3e0914-d37f-39fb-9ac3-abc6eea495cc","authorName":"Thomas Levesque","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/17821784613704879657","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen,  \r\n\r\nVery interesting article, thanks!  \r\n\r\nHowever I'm not really convinced by the \"Complete method/Completion property\" approach, because it lacks an important feature of the IDisposable pattern: \"using\" blocks. Disposable objects should always be disposed when they reach the end of their scope, even if an error occurred, and the using statement is the easiest way to achieve this. But the Completion property needs to be awaited, and await cannot be used in a finally clause, so there's no easy way to ensure that disposal is complete before an exception bubbles up.  \r\n\r\nI came up with a pattern that mimics the using statement, allowing for async disposal, you can find it [here](https://gist.github.com/thomaslevesque/5936421).  \r\n\r\n(of course, 5 minutes later I found that [someone else had almost the same idea](http://softwareblog.alcedo.com/post/2011/12/09/Using-blocks-and-asynchronous-operations.aspx) long before me, but not using async/await since they didn't exist yet...)  ","postId":"2013_03_async-oop-6-disposal-bff8d970-98c1-3b7c-ab0a-504ab2504786","replyTo":"","date":"2013-07-05T23:11:32Z","timestamp":1373065892}