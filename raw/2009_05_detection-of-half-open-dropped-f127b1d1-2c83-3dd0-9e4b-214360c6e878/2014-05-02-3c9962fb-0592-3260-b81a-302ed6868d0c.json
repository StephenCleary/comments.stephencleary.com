{"_id":"3c9962fb-0592-3260-b81a-302ed6868d0c","authorName":"Bruce Stephenson","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/01321631245118583318","authorUserId":"","authorFallbackAvatar":"","message":"Hi Stephen,  \r\n\r\nI was hoping you could shed some light on my trouble detecting a half-open connection.  \r\n\r\nI'm trying to heed all of the wisdom presented in this article as I'm tackling my first TCP server implementation. It's probably a similar scenario to your \"true story\", where there's one server, just one client, and just one long-running connection. It's exceedingly simple: every 20 minutes or so the client sends a small message, server receives it and sends back a simple response. So far, I've got my server using the Begin*/End* approach to receiving and sending. So, according to the advice I read in another one of your articles, there is always an asynchronous receive in effect: as soon as the read-processing is done, a BeginSend() is queued and we go back to BeginReceive. Elsewhere, I've got a 3 second timer that performs a non-blocking, synchronous, zero-length Send() test (as per MSDN). The head-scratching thing is, this test always succeeds--even when the network cable on the remote side is unplugged. I thought it was clear from this article that doing a send while there was a physical break in connection would quickly uncover the connection issue, and allow the server to close its socket, thereby preventing the half-open connection problem you described. What am I missing?  \r\n\r\nThanks for any help.","postId":"2009_05_detection-of-half-open-dropped-f127b1d1-2c83-3dd0-9e4b-214360c6e878","replyTo":"","date":"2014-05-02T17:17:54Z","timestamp":1399051074}