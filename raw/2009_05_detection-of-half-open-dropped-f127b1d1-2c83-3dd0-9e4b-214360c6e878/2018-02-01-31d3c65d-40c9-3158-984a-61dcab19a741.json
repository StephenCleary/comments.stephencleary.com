{"_id":"31d3c65d-40c9-3158-984a-61dcab19a741","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The problem is that there's only one timer that must be shared between all sockets in the select call.\r\n\r\nConsider an example where you are using select with two sockets, one of which is in a half-open state. Each time you call select, socket A gets some data available before the timeout, but socket B doesn't.\r\n\r\nIf your logic is \"if any socket reads data, then don't close any sockets\", then socket B (the one in a half-open state) will never be closed.\r\n\r\nIf your logic is \"close any socket that doesn't read data on every select call\", then socket B will be closed. However, your code will also end up closing all other sockets any time any socket reads data.\r\n\r\nThe only way to avoid this problem is to have a completely separate timer for each socket. This can be done by only using select with a single socket (which largely defeats the point of select). Or you could use explicit timers for sockets, checking each socket's timeout by hand each time select returns. But there's no way to get the select timeout itself working as a keep-alive (except for the trivial case of one socket in the select call).","postId":"2009_05_detection-of-half-open-dropped-f127b1d1-2c83-3dd0-9e4b-214360c6e878","replyTo":"fe5d9016-2256-3450-8482-9f1bcf12c983","date":"2018-02-01T03:02:05Z","timestamp":1517454125}