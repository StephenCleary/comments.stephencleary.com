{"_id":"b6b46950-2d5c-11eb-8c49-c53e7dd59920","postId":"2009_05_detection-of-half-open-dropped-f127b1d1-2c83-3dd0-9e4b-214360c6e878","postUri":"https://blog.stephencleary.com/2009/05/detection-of-half-open-dropped.html","replyTo":"aa77cbf0-2b5e-11eb-8cee-8fa79486417c","authorEmailEncrypted":"RTY7rciXnhR/2EVewy8K5DInM58pS4g0R1x29Y11l6QE+DBVHAKMI4u9XWY+nBfhIlrfPLbVmTW5nAFIDLzeWCVmymQbvjRrTUE5bz234+osaMKaTVivRXoJQ2WfadIXlT2bYgbp/pOs35dKc7ZOAFbMsKL2xmFbPNuMtNfmZwP+ghsx22WXrcl9bkV8RoeoOlNz57fHRJPN1L8ef0VNDVmiW4RAx7N0haZ2RI6AU2IeSL+o4yIhaotlKRFOqeYk4fIU9i++i6Nz6vQHJglCzTqIRfGZou5kh41H72pl+U3JoFAiScwPYmDOGzeXI/a8pWPTuLLGtqyQUqoDnJ/pNx+/k6DTLnpxoCh1AK9pI+wCepYunRSO6fX5SWVZy2GghITTCk1eVdvNrqZ2XDMxlhnofXrL63l/3bAr7nexb0iN5cVG0dxxCNBNkyBZXj7F7UPXX85wJHQcdyR7JOzZzTP2eXGPQ3ZeoVugazGLlGlxXN30MEJRQq2CqjgwOLrJSBjXQoffzoFVLG3I39pLZS/LnNi/sIQEPuUz433FtKr85NLcr7F4nD/1EKb//eRrW0FCQUU/vHHEc0c4xcFZUU9w0heig+7tt5bYohHHBU4+1h/RX4GZRxbrIT/uZAGV5H1+uUAxf1xp8F6lkSS4SFbbt7HUMBqFD2rJO9psJNU=","authorEmailMD5":"b8e9a0fa98af352d2a9133d5d5c650d8","authorName":"John","authorUri":"","message":"Thanks for your response Stephen. Unfortunately, I do not have access to these extension methods since I am working on an older version of .NET (standard 2.0). Is my best option just closing the socket if the timeout timer task has finished ahead of the ReadAsync task? Or should I be looking into the  older APM/SocketAsyncEventArgs approaches? \r\n\r\nAs of now, I don't really see the downside of closing the socket. My only concern is that consumers might find it inconsistent that the synchronous version of my method using the blocking Receive does not dispose the socket on timeout while the asynchronous version does.","date":"2020-11-23T07:22:59.338Z"}