{"_id":"abe40150-0503-11ec-9443-1bd44fcc4cae","postId":"2016_10_async-pushstreamcontent-5049ebdc-8d32-3bf1-b970-f0ccb6d5b458","postUri":"https://blog.stephencleary.com/2016/10/async-pushstreamcontent.html","replyTo":"aaf6ec60-04ba-11ec-85a6-9721f9cb04ea","authorEmailEncrypted":"ho34UdiC2/483DzFNCKqf4EQt2mC4PnJjahtfeqlNbLDK5JZgkG18cPCdZ0mTbvk7dfD9Gn8eq9HiwFT6LdH0Ziu9VTTezd4jtCW/X5U3W6+mwQMLHmljnInywzD2kWLr1CW6+yozlkVIXShVZBoGg5UhEpg4C4Bxc4bUvLQF6f0wF0QUw0C0bl6l7jIGhMws+yUUV9RiykNi7wFZNT9OiL7q1KRHlGwJKbIggiVE55/rPvdywJlzslZDKcuFnwTr/iwvTl0QgmvlvH4QIalfCgNECIML4MicdNaA8aVGa+W3yKsi0rNccsguXU4YrnHiKlMvmMcWKXPCqRKwbYsQxZ9U41d85ut3K7yF2cltr5xJa6OB226acBtP9/OgiNfUz7MfRYkhFWXlMfzKnBJmTj3sx/M2p1T9EDNEv9pzjvANrmCDxv5fYkCsXC0skn8CIRZV26PHHQ4e7TKCjzAsxKgguM88DqW5o2+sTem1jTbpYJSzzV5j49qIiJ+CyDggF3EvlxfCOanQGn0z4INKn6ZUfafx8IjHTjQOG/p8AsfPefSwXx41CLZx/yV8qar+1uVafqclARfsup0m0pRGD4HUNsDqcRwi9iyvF/NUw/GGcZfYg7KajYTuHFUbrg1z27ixk1SMHupW9dFNwFKn0kvP0FGaaMUYm7vxPCv6S4=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"There are buffers, to be sure, but it shouldn't be anything big enough to cause memory pressure.\r\n\r\nThe OS has an incoming socket buffer; the .NET socket may also have its own buffer backing the network stream. Then there's definitely a buffer used for copying the stream, another buffer on the outgoing .NET network stream, and another OS outgoing socket buffer. But these are most likely in the 8k-64k range each, so *maybe* 1 MB of memory overhead per function instance doing this kind of copy. It *should* be unnoticeably small.\r\n\r\nIf you're sure that this is the operation that's causing the memory pressure, then you can create a repro and try to track down where the in-memory buffering is happening by changing your copying code (e.g., is the memory jump between the calls to `HttpClient.GetStreamAsync` and `DataLakeFileClient.UploadStreamAsync`, or is it after the upload starts). Alternatively, you can start reading the source code.\r\n\r\nThe two most likely things to check would be:\r\n1. Maybe Data Lake needs the size of the stream? I'm pretty sure the stream returned by `HttpClient` never has `Length` set, even if the source sends a `Content-Length` header, so if Data Lake has to know the size of the stream (to set its own `Content-Length` header), it would need to read the entire stream into memory just to measure it.\r\n1. Maybe HttpClient isn't working as advertised? The docs say that `GetStreamAsync` should not buffer the entire response in memory (i.e., it should always act as though `HttpCompletionOptions.ResponseHeadersRead` was specified). But maybe it is anyway for some reason. There have been several versions of `HttpClient` through the years, so diving into the source might be a good idea there.\r\n\r\nThose are my guesses, anyway! Good luck!","date":"2021-08-24T17:49:47.036Z"}