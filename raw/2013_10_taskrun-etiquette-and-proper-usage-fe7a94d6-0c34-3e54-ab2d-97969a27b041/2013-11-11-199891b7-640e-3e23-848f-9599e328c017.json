{"_id":"199891b7-640e-3e23-848f-9599e328c017","authorName":"Vitalii Vasylenko","authorEmailEncrypted":"NVQ+2XBZzrHm6/aeHGlOIYBlunSSL/N+wwnY4phVOnK02ey1ToGlbFsC4n0i8fO+e0bmnO+tbAxU/r+5hcmtBjYWMXKx2E1E9JzKG4qx13eTnt3LtOzVw89E50gNPdwxYauIH7GJaU4PrjR1tQESDyrzhb1cZ7dv5HWzsdh0VcI+6fK34IufmG62J8dNlRTCFShxPpdhfJZ90XZW4TO1ey5nwFaREKjm62ww5wQG5DFl62pLxJsaM2OmipXGpTdPsYPAXGiHTMlhMP6M41g517VZ4hemrD3vR8Drikh3DmRRKtj+DVMT+8dDOtGtW7IWCxrtivnvlNYl5pawcDce8FEwLFnROScyjrqbVQ6fCn1Fxt5H8icOHYFcd8RriGL08708vCNiQyTSj0lzIMfyHSe5zly/RsGmqeeXqgDa57Jrx3rIVIVeqn+zIp8ip9/lBxk3XvItqB9R/mIVsHdgqvUKlR00LCIRAQTljY9aIuUid+vvnQm/Q94bTR2U/pD5AhWFHq5OsTbmBkRlqZC/TiySsnqz8U8OmygM7H62KVPH5d/oMKNDmcLFZvEtWKe4JYcd/oClbqFUinCrxfD+c3kKzxEmOz8EZbfCfz+je5jsppveM41rZOphyWnZQlgtgOLE9xjFw/QlsC9gHmVUKqpkLEtj/HWplJgXaZTKKe4=","authorEmailMD5":"bedf632d04d2cb0f456635486e5523fd","message":"Hi,  \r\n\r\nThanks for a great article and blog in general!  \r\n\r\nHowever, this is not that clean. as for me.  \r\n// What if I have a reusable method that uses significant amounts of both I/O and CPU? Should I use Task.Run for the CPU-bound parts? The answer is still no.  \r\n\r\nHow would you recommend to improve next sample:  \r\n\r\nasync public Task RequestServerAsync()  \r\n {  \r\n var resultString = await new NetworkManager().GetAsync(Constants.SERVER_REQUEST); // Just a wrapper for await httpWebRequest.GetResponseAsync() and await postStreamReader.ReadToEndAsync()  \r\n\r\n var answer = await ParseCategoriesFromString(resultString); // await TaskEx.Run(() => JsonConvert.DeserializeObject(resultString));  \r\n\r\n return answer;  \r\n }","postId":"2013_10_taskrun-etiquette-and-proper-usage-fe7a94d6-0c34-3e54-ab2d-97969a27b041","replyTo":"","date":"2013-11-11T22:11:57Z","timestamp":1384207917,"authorUserId":""}