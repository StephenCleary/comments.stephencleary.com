{"_id":"cf4f0a5b-b5ea-36da-982e-331daa501af2","authorName":"Stephen Cleary","authorEmailEncrypted":"awB+G/melfuM17U/KC2Qb10JkPFXWqhZaeyLpAkSAFsFl2g7x1kzaionO0fvjqOagn6Wn6n9uPQy5sdnv0b5RJDbDBTh/WuIb7EBSXPPUjTWKCrYcEB5Fh7/lyh9BeWujBEpor9ptxLoL2WyN7JlUXYqCoWdhnTKLaLOqAroCDhyHtlZNJHvAJaKxexOGNLMtwKVt/3TgekpxcaiQz3PuiH9ZTXDBTD0e7Ug4IQqPiVc9ZkMLlk6aYYazX5SIRHZsVCjKFm20lbXcvwaYk8YH+l7bi5oxCggoNQVISOSMROj9zrcpJr23YrfgXCpM0+AjPaptQMIXK8vyY/+06NWX8mfS9dcx0Q/TFPNh9PDYP429X0JwKS7lgSE4UGm/djvylqS0pnQTOhGl3Qc+mCnMP5O0N9N4/P6vyhOEewtu7IVpIcoM3ahwNXiZXNZ0cRMsML0VQbE8xaHUVYB13xZZ3vW97mCCurp1LLvd7N1ctTT4bR5mVvJbIxFrKPQZ/QGr/GN/QFQnZo4JpF9f9cm1gCARb3ucutrDTLMVNyzOauAAFGIU7qlQuz3DsoURQJX1ASXT3io4JeFNhb9rVMVYRvzbVXoojKwdORZ0PD5B4mKzXDxuMRF1HbKTqTe4RKZP9vEDoC0gbDokVumNFp3owjmudj7UtyCoSPj2uATklg=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","authorUri":"","authorUserId":"","message":"SLaks has a good answer here: [http://stackoverflow.com/questions/19912343/async-json-net-deserialization](http://stackoverflow.com/questions/19912343/async-json-net-deserialization)  \r\n\r\nMost of the time, you're not going to be needing JSON deserialization on a background thread. Unless you're processing a *lot* of JSON.  \r\n\r\nIf you apply the guidelines in this blog post to your reusable method, you'd get:  \r\n\r\n///   \r\n/// Note: this method is partially CPU-bound.  \r\n///   \r\nasync public Task RequestServerAsync()  \r\n{  \r\n var resultString = await new NetworkManager().GetAsync(Constants.SERVER_REQUEST);  \r\n var answer = ParseCategoriesFromString(resultString); // JsonConvert.DeserializeObject(resultString);  \r\n return answer;  \r\n}  \r\n\r\nAlso see my blog post here:  \r\n [http://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-even-in.html](http://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-even-in.html)","postId":"2013_10_taskrun-etiquette-and-proper-usage-fe7a94d6-0c34-3e54-ab2d-97969a27b041","replyTo":"","date":"2013-11-11T23:29:09Z","timestamp":1384212549}