{"_id":"6fabfe1d-5d56-4dc7-b0b8-2176a3628af7","postId":"2023_09_memory-mapped-files-overlaid-structs-51f9e146-9b2e-376e-8fdd-d63a07e7ab29","postUri":"https://blog.stephencleary.com/2023/09/memory-mapped-files-overlaid-structs.html","replyTo":"005659cb-0c2d-4fb3-b02b-20bd03231113","authorEmailEncrypted":"ctffbO7Z27SwKQ\u002Bgch6\u002BaCmo16VjpKpMjTxs5F4IkXfE5SfwbehBevmc0\u002Bpr8pSyOGcLlSJTSvpbiok68ucir1li96JW4BDGy4ivZ1rxfh0rcoCNV1d5uXmc6XE6ndOs9F/0IBXDBzzLlxG4a/oyHrGJwNLycltTNAsrRQy1lE0nWpw2Day/GW8KWHb\u002BfUVLejfLe88j2AcY0cSfykofwndn7Px1aWJzxCjxkZZOJQiBYojTE58H6EI3o1sUt64lpd7SUKTMczrtOW9EUPnpX/kwZk/0e5TTRFCshesbTn\u002B4MIKZv6Y3zCN1O6AEazUzTuUWhtNuKsOOTDajx8xliSs8qHjJKumWQniRTGFestfytg\u002BShzA4KO4jLRSyEOc4vaWJ09eYpSxbkKKvs6YtBi6z8A9lxXdCzm1ZkHVcYN6UIm9nqgWM5DRdbdOPoFr5HveRjWeentWB/YpwFj1RcEX4CEcyCkpUY4N3MQX4TkmqyW1ikMqJDhBKD9leeQ6K\u002Bamgq1HkXH1gBavDBhihqvzf\u002BEP7w5chmYV3GoSk8rL80lSfo4enHH8Uia2pPDtRIq2wZ3hkAWFHrffHwFHdvNNEZoU7jgHN57cENYqTvaPn9JKQ2MvsRnivqUxCUha\u002B0CExleQ9VjQZfYUPiqSGSKrQfVVdBfEWa4VgfWUBsnQ=","authorEmailMD5":"58e46aa002ca1df0b310d912a243f29a","authorName":"Ant\u00F3nio","authorUri":"","message":"MMF is designed to work with big files where other options fails. And a cleaver aproach is the right direction. Creating parallel accessors pointing distinct file positions you dont need to care with the file locks... Kernel knows that and avoids any internal lock mechanism. But, you must be parallel writing in distinct ViewAccessors. If you want concurrent write/read comitted to the same file/memory portion, then you have to use any available lock mechanism, like mutex or other option.","date":"2024-11-19T23:33:55.0362092Z"}