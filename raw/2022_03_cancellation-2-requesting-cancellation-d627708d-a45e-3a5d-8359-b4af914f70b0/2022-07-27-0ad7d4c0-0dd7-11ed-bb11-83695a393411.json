{"_id":"0ad7d4c0-0dd7-11ed-bb11-83695a393411","postId":"2022_03_cancellation-2-requesting-cancellation-d627708d-a45e-3a5d-8359-b4af914f70b0","postUri":"https://blog.stephencleary.com/2022/03/cancellation-2-requesting-cancellation.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Jess Rod","authorUri":"","message":"_\"For example, you might choose to keep the start button enabled and just have it implicitly cancel the previous operation (if any).\"_ \r\n\r\nIn case we opted for this approach (not even having a cancel button), would you please shed some light on the best practice to cancel the previous operation (if any)? Thanks! \r\n\r\nI'm not sure if the following would be a bad practice. If we used \"using\", by the next time the start button was pressed (if the previous operation was still running), _cts would be invalid (disposed).\r\n\r\n    async void StartButton_Click(..)\r\n    {\r\n        _cts?.Cancel();\r\n        _cts?.Dispose();\r\n        _cts = new();\r\n\r\n        try\r\n        {\r\n            await DoSomethingAsync(_cts.Token);\r\n            // ...\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            // ...\r\n        }\r\n    }","date":"2022-07-27T18:07:57.148Z"}