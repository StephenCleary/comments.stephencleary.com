{"_id":"892d2a07-a231-3d12-8a2c-192e8463239f","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"You can do asynchronous concurrency with Task.WhenAll:\r\n\r\nTask upload1 = UploadAsync(1);  \r\nTask upload2 = UploadAsync(2);  \r\nTask fetch1 = FetchAsync(1);  \r\nTask fetch2 = FetchAsync(2);  \r\nawait Task.WhenAll(upload1, upload2, fetch1, fetch2);\r\n\r\nThere's nothing about task scheduling or parallelism here; since these are I/O-bound operations, I assume you can just use naturally-asynchronous methods.\r\n\r\nFor your other question: if you start code executing in Task.Run, and that code is not cancelable, then yes, it must run to completion.","postId":"2015_03_a-tour-of-task-part-9-delegate-tasks-9af23aee-8e1f-399b-b58b-2e0858eb53d8","replyTo":"30c1eea7-75af-3c1e-b47a-234108a4d5de","date":"2015-03-23T12:18:41Z","timestamp":1427113121}