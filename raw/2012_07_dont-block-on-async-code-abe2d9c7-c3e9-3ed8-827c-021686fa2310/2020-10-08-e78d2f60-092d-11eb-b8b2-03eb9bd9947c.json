{"_id":"e78d2f60-092d-11eb-b8b2-03eb9bd9947c","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","postUri":"https://blog.stephencleary.com/2012/07/dont-block-on-async-code.html","replyTo":"a5bb857d-c4a2-380e-8549-c05c4bbbd561","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"handlespeed","authorUri":"","message":"Hi Stephen, thanks for great article, just want to confirm the knowledge. \r\nBased on understanding of continuation of await, can following code avoid deadlock in a ctx environment? Briefly what I want to confirm is can we avoid deadlock by adding .ConfigureAwait(false) just to \"Every\" \"First\" async sub methods inside every method, because second sub async method in \"same\" method is in continuation of the first await, so that although second sub method \"want to\" capture ctx, but it cannot achieve that as there is no ctx thanks for first await ConfigureAwait(false). For example, B and C.  \r\n(I know we should add ConfigureAwait(false) to D() as shown)\r\n\r\nIf what I said is incorrect, only thing I can guess is the scenario of \"fast Completed Task\" I remember I heard somewhere. And in that case, that continuation will still in same \"thread\" even if we add .ConfigureAwait(false) so that the second sub method still run in old thread ? Could you please give some clarification on that ?\r\n\r\nPlease help clarify those, thanks Stephen !\r\n\r\n       void CustomerCall()\r\n        {\r\n            A().GetAwaiter().GetResult();\r\n        }\r\n\r\n        async Task A()\r\n        {\r\n            await B().ConfigureAwait(false);\r\n            await C();\r\n        }\r\n\r\n        private async Task B()\r\n        {\r\n            await D().ConfigureAwait(false);\r\n            await E();\r\n        }","date":"2020-10-08T06:17:13.057Z"}