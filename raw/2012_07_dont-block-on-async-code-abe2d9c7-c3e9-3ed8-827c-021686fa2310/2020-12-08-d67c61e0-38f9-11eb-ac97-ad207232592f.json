{"_id":"d67c61e0-38f9-11eb-ac97-ad207232592f","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","postUri":"https://blog.stephencleary.com/2012/07/dont-block-on-async-code.html","replyTo":"216130e0-38f6-11eb-ac97-ad207232592f","authorEmailEncrypted":"QM5cCD0wX12NoO4VsEVEDxR60ah+/eu615yPr75KY6CiGFeC2aJ/r0Lp3bwqBfS88MYVawsECzUJyIHXCC/BriLybnZaFfL2u7i9GOlx3pJxPDnoJ9R2dkHj46m+zjpmqFCL0jaw4yMlNjwiVzh0dsIn8ZP8XWokT0ckRYcwSCPSaE2YJeLcrGkRgGtcrFz2yKsmJ73dNKns8S3JG+hTXDVeHH1OwS2t/GSsWH2h5n29QGcAxBDU9KZjGSEmEIr+kLEFehEAukYTjmAV1O8FYXCHIgmMcHI6CQp/vmzPdLuScY/MSqyvuxMdslhT+AohDxELodKSQjX23YeUWzVJ5wzEk3t9G92y4E4oA7C5BZiK/Iewh0xqXkULxTfGJ/jjyjrPkhRUg+7n8PUzk5LyBGR7z1IAhpuG9sGjQw1FmEOBqoB0v07Wv3ifD7dSPjojqZW4o/IvkKLY6c7r6acFVDpX03lg3CLuBSR+5iDnW+kH8Vj1rWPvjGwe0TPwMR8YdGQCoEay75U+3BW5oGI4GGs6PKqI8gBXoMXoP30sKWAQDkFRIzFTHSqDg06FjIlWy1LELN+FDrZOUCbaq5iIszm9PqynkRiDBcaMO2rZL5GVPHr0hejDUEmZMiQWe4FS2v3iRuy0ks1LMSLlCQE+I3wELiUISUtupy5xLcds/58=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"That is sort of possible, and there's been some work done in that area (automatic deadlock detection). The example here is quite simple; what you usually end up with is one method awaiting another method awaiting another method... so the `async` method that is attempting to continue is different than the one being blocked on. It's possible to generate a kind of \"asynchronous causality chain\", including hooking some APIs like `Task.WhenAll` and `Task.WhenAny`. It's pretty complex, but there has been some work done in that area.\r\n\r\nBut it's a *lot* easier to add a static code analyzer that just says \"don't block on tasks\". So more people do that.","date":"2020-12-08T02:05:26.341Z"}