{"_id":"4226db98-b543-3cb4-bf1a-57dacfb4ba52","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"That approach shouldn't cause a deadlock (assuming that `ProblemMethodAsync` doesn't send updates to the UI thread or anything like that). It *does* assume that `ProblemMethodAsync` can be called on a thread pool thread, which is not always the case.\r\n\r\nMore info in my async brownfield article: [https://msdn.microsoft.com/en-us/magazine/mt238404.aspx](https://msdn.microsoft.com/en-us/magazine/mt238404.aspx)\r\n\r\nP.S. Use GetAwaiter().GetResult() instead of Wait() to avoid the AggregateException wrapper.","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","replyTo":"94c52a81-918c-3d83-b4fd-6dddc828d2cc","date":"2016-09-08T13:23:50Z","timestamp":1473341030}