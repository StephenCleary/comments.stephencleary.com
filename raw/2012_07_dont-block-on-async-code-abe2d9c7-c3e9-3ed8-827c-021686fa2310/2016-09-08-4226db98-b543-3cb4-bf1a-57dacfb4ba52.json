{"_id":"4226db98-b543-3cb4-bf1a-57dacfb4ba52","authorName":"Stephen Cleary","authorEmailEncrypted":"WfJ6wmgwv8TBLPCmb3IkHOh8SF0pibCrk9l+bq3XjPEQtdDZ6iTeIc+MfCSRX6YAjlBdjikEnAQk6fLpaJl7jQovWiUk7ijoeluQxolbdWuPCqbQq869ND+axVR968Cl3E2JKBYJioF3RGgjN+u6e8aWF8q5zGwudR4aAzMKqtM1XGkW0+56k1/nNDrz9fqjeocGRG9AlsYy0EyxGaDxt142sUCCfXVA4OQUHnb/M5ZD9pEU6okxbMGGWHEpSHdmctyrFmvYI++vf3y0CHn7+0HrGuek1+IaYUkrZpdynI550EGHGzLxZGoG1E/90lIaMcpHZbxDhXvJYyB3+7cogRreWWE4ZBKHxu0y32ofEv/JFpiHty2BEpk4UowmUYgs3mYmB6AiIW0rJ/NArl34FBU29NlJ298VZFs/oRgv1gmx5T4CvaviFa5vZ2zAYmB4yGFjWXuJi/iRpbnHubsDOv05Q/+C3IYE9QmUP7QUpUDPvZ/ZKOSuCJ+C1Gs42tgzdiCGIBwuOod1MV+Rf4ClF0roNsMp3z1Zdse+0fN+8WdMS6LIQjNQUknfJEeELAfHd09cJhYSgCNSo31bYv6UWvSDhXxmYAwsxm26qs6S7DBeBnKqRHDK5Ife3p6KinMLvO+P15khrVzCttkkUgfZW2z4fLPYsi+mIvWot6L3wKA=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","authorUri":"http://stephencleary.com/","authorUserId":"disqus:stephen_cleary","authorFallbackAvatar":"https://disqus.com/api/users/avatars/stephen_cleary.jpg","message":"That approach shouldn't cause a deadlock (assuming that `ProblemMethodAsync` doesn't send updates to the UI thread or anything like that). It *does* assume that `ProblemMethodAsync` can be called on a thread pool thread, which is not always the case.\r\n\r\nMore info in my async brownfield article: [https://msdn.microsoft.com/en-us/magazine/mt238404.aspx](https://msdn.microsoft.com/en-us/magazine/mt238404.aspx)\r\n\r\nP.S. Use GetAwaiter().GetResult() instead of Wait() to avoid the AggregateException wrapper.","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","replyTo":"94c52a81-918c-3d83-b4fd-6dddc828d2cc","date":"2016-09-08T13:23:50Z","timestamp":1473341030}