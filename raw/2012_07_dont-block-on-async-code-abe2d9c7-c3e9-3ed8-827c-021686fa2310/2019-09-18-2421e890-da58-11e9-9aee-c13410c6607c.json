{"_id":"2421e890-da58-11e9-9aee-c13410c6607c","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","postUri":"https://blog.stephencleary.com/2012/07/dont-block-on-async-code.html","replyTo":"ab9442b0-d6f6-11e9-861d-8db674c2d163","authorEmailEncrypted":"RZV01V0hT7RijCCE5Nseme96LRPXYKfJBldYToyZmI8RQ3GYanFLkh+JhgdQ+XbMyferRliwQdGYETCmRIQL4st87g1p0Rls/6JoeIX5Atz8Jk5gVrWR+8LJPkQ7T3BuAbdMUk6lYb2Wh+0QGhGNhhmzkU218QkqXfslG479X1gXTAGTpdNlaYozbjgX1pDLDnkUDdRSnuhjm44En7B4PG6p91jbSR4qvv+tLb3gLfP7SAfKCcwlsg0icN+YyMXalqal7dkqbGjT8CDaG934N1WgDTu5JWF8NGDfqo6xQB64hx5950k19s/vOeEtwpGnL8akPY4TZ6ej/fejaWQoYiB7LvkoMSgvfzl05QRMCUMZMgsjXSAQpjILfcr2Byecrq9PW55SIKg30/rp5fUT4VtjFHhvad7g93soD8tmPVuprvqASDSym/A4LD4DKRLJp1H0snqlUqZRrqrkuTdqfDQA2IfGpY/WDQEkbMwRyynthwCmnoxVN99/s+KUrkTB1K0ORguwNnoaiB5q7J3Qv+62mwj2QguL2Qu2EWreBUB1qYibJ7IR/grV2OirF+lmDlz/+cmCGzezwA30lfX4Qpp4DcscONLlSKUJ/cPzn1QpTO3iGuDIxwRRWuQ4s+JCMOSwdt2isWU5ZNXHMUrIbKy5oGG+DWbi5VluYQu4vH4=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"> Once async is in a branch you have to use it above and below to avoid these deadlocks.\r\n\r\nFor true asynchronous behavior, `async` only has to be used by the caller (all the way). It doesn't have to be used by everything \"below\".\r\n\r\n> If at the highest level (Main, UI Events, MVC routes, unit tests) async is not supported you need to break on async code.\r\n\r\nMVC routes have been supported since ASP.NET 4.5 in 2012. Every unit test framework also supported `async` in 2012. UI events have been supported out of the box with `async` since the first prerelease in 2010. `async Main` is relatively new, but it's also not necessary since you *can* block without issues in the `Main` method.\r\n\r\n> If at the lowest level async is not supported you won't get any benefit and will have to break.\r\n\r\nYes and no. If you want a fully asynchronous system, then yes, the lowest level APIs used by your code need to support asynchrony. But if your app is a GUI app and you don't have asynchronous-supporting APIs, you can use `await Task.Run` to work around that, at the cost of a thread pool thread.\r\n\r\n> So if you are writing an API or framework you now need to write async and sync, or half of developers can't really use your code properly.\r\n\r\nMost API calls are either naturally asynchronous or naturally synchronous. I recommend only exposing an asynchronous API for methods that are naturally asynchronous (e.g., using I/O).\r\n\r\n> If you think a synchronous model is a better fit or have to support a synchronous legacy API; tough! The async / sync boundary will always have problems, and it seems we have set them up in a fight to the death..\r\n\r\nThis has always been the case. Asynchronous code has caused this kind of bifurcation since before .NET existed.","date":"2019-09-18T21:06:11.298Z"}