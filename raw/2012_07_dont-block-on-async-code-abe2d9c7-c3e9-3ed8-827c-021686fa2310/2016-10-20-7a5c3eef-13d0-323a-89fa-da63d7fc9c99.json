{"_id":"7a5c3eef-13d0-323a-89fa-da63d7fc9c99","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"If there's no way around it, then you'll have to block.\r\n\r\nThe problem with using Task.Run on ASP.NET is one of scalability and efficiency (and, as you pointed out, that the code is run outside the request context). Most (>95%) of people using Task.Run on ASP.NET are not in your situation; they just want to \"make it async so it can scale\", and don't realize that by using Task.Run, their app is *less* scalable.\r\n\r\nIn your case, I'd say to first request asynchronous support from your library. And second, use the thread pool if you *have* to: Task.Run(() => foo()).GetAwaiter().GetResult().\r\n\r\nMore info on \"brownfield async\": [https://msdn.microsoft.com/en-us/magazine/mt238404.aspx](https://msdn.microsoft.com/en-us/magazine/mt238404.aspx)","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","replyTo":"d760cfce-e6ad-31d5-91d2-4c2972ac62e9","date":"2016-10-20T13:34:55Z","timestamp":1476970495}