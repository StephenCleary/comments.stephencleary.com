{"_id":"0db0e19e-8ae0-311d-9594-f82de41bc7b6","authorName":"Stephen Cleary","authorEmailEncrypted":"Ow6chSDSSGWDp073toyam2m4Gi4tf9nsL4bCx9HM/10fBsu49j4Qhe8hCooXOsqarBrxvi1iesGTaAoc6EFQIWUwV6RQ5lMt1gUlhyTduNIVd4RZ9JsZKMoNZ+c3RFmeEEGpa+q8daYk2ERlkOQZmymfkSdpyCa+k3w6hwyowG3ikk0G71qszIgp2bsLCQn4XEhm7tLjVi//kpx1i7/uMVtHAdOi6iDdEu+JsvMpBSeehbjGsfYpc0zSEPOGMT0JNLauVfONYC1wcwvwamze6nFoKZ3LFj23Cj2r1U0Q0tZW0gE+It3ofg8d6tAm72j0k97OdJavj4EkFjrELCG84EnAjyHhH4//Fdzu0F+6cDPBL3kFT3pUILYd6PiEAnfKXqeIoMlGJFrID3vRJIokAw02Cxv3bDXrm1+0g54aKihR6aNmtC5sHmokRhLNTZONeBWo80/q08XVHZOYjcG9/TgzWxvU31ZWLmukglBGWxK2NXrE7RtdyQFw8+ka0uII6E6MnHyBeShGfSu3XHeUhQoVFY9ry20FP/TVq/BLnFOmeZyRk6rIb02CszRCFYtaPTtwVW19OIfNIyih9MjKvuFwhy9Byg9DRNZ/d7u1HM9rvvuyKoT/LGC0JcaFpq2u7doy1nZwJVPad/QCpaJqnF/0ZhDCLw72QGGPekLFF5Y=","authorEmailMD5":"28dde5772b48c92e08b8050411aa5ba8","message":"> I want to pass an singleton(context) down to another http message handler which would execute later.\r\n\r\nMy first suggestion would be to use dependency injection, rather than an implicit context.\r\n\r\n> use HttpContext.Current, and any code before it in the function should use await without ConfigureAwait(false)\r\n\r\nYes.\r\n\r\n> CallContext.LogicalData is not reliable... It's possible that CallContext.LogicalData will be lost under heavy load, together with async programming.\r\n\r\nNo, this is not correct. If you're having problems with LogicalData, verify that you have httpRuntime.targetFramework set correctly in your web.config. If you continue to see problems, open a support case with Microsoft.\r\n\r\n> neither does thread local storage and thread static data\r\n\r\nThis is correct; since await may resume on another thread, thread-specific storage will not suffice for your needs.\r\n\r\n> And I remember you mentioned somewhere, we should create a context boundary in the codebase, for context-dependent/without ConfigureAwait(false), context-free/with ConfigureAwait(false), respectively, correct ?\r\n\r\nYes. In your case I would separate the code that uses the singleton context from the code that gets the singleton context from HttpContext.Current.. That way, your actual logic (that uses the singleton context) does not have a dependency on ASP.NET and is more easily testable.\r\n\r\n> this.EditControl1.Disabled = false; should fail in some way, correct? because the resumed thread didn't load back the SynchronizationContext, but in my test, it actually works, any part I missed?\r\n\r\nYes and no. The runtime behavior depends on the UI framework. Some of the more advanced/heavyweight frameworks will do the thread marshaling for you; while some of the lighter-weight frameworks will throw. And even the heavyweights do not always marshal; automatic marshaling is sometimes done for single properties (e.g., Disabled), but data-bound properties are another thing, and data-bound collections are yet another thing. Different frameworks have different automatic marshaling. Since I've written a lot of cross-platform code, I follow a strict rule in my code about never touching the UI from a background thread, even if some frameworks support it. That way my code always works.","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","replyTo":"fb685f31-1d3c-3ac8-9936-c4301457db0f","date":"2018-01-20T14:49:37Z","timestamp":1516459777,"authorUserId":"disqus:stephen_cleary"}