{"_id":"35191810-a26e-3238-8b06-25a7c5134b12","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I assume you mean WCF instead of MVC. It sounds like the root host is still ASP.NET (i.e., your WCF is hosted within ASP.NET).  \r\n\r\nYou can look at your current context by doing a \"Debug.WriteLine(SynchronizationContext.Current.GetType().Name)\".  \r\n\r\nTo solve the problem, it's best to actually make everything async (WCF in 4.5 does have built-in support for asynchronous implementations, and if you make your server async it won't affect your clients at all). If you can't do that, then you can put in a workaround such as ConfigureAwait. Stephen Toub describes several options here: [http://blogs.msdn.com/b/pfxteam/archive/2012/04/13/10293638.aspx](http://blogs.msdn.com/b/pfxteam/archive/2012/04/13/10293638.aspx)  \r\n\r\nThe disadvantage to ConfigureAwait is that you lose your request context after the first await. So you can't access anything on the HttpContext, or depend on things like culture being set appropriately.","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","replyTo":"","date":"2013-08-23T00:59:07Z","timestamp":1377219547}