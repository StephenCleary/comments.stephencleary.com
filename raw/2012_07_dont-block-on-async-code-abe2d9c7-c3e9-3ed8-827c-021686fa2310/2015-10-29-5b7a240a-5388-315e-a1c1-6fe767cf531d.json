{"_id":"5b7a240a-5388-315e-a1c1-6fe767cf531d","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I agree that languages get bloated and end up with bad design that is then kept for backwards-compatibility reasons. C# has a fair amount of this. But I disagree that async/await is an example of this. :)\r\n\r\nI think the primary difference in reasoning is that async/await has nothing to do with threads. Using async/await to, e.g., download a file, is *completely different* than spinning up a thread to download the file. It's because of this fundamental difference that you have to use async/await all the way. (The MSDN example doesn't deadlock if you call it with `await`).\r\n\r\nOn a side note, the new async/await can work fine alongside threading. If you want to download a file with a thread, you can just do `Task.Run(() => DownloadFile());` - and then you can block on it if you really want to (I can't say I recommend that, though).\r\n\r\nAlso, it is possible to use callbacks with tasks (Continuation Passing Style). You can attach callbacks to the Task object by using ContinueWith. This is essentially what await is doing under the covers (wiring up the \"remainder\" of the method as a continuation of the task). After writing much asynchronous code, I can say with confidence that the async/await approach results in cleaner code than callbacks. This is why languages currently using CPS are moving to async/await (including JavaScript and TypeScript).","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","replyTo":"80339fa2-ba0f-3128-bee5-6225eb28cf31","date":"2015-10-29T13:57:18Z","timestamp":1446127038}