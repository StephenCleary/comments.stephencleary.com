{"_id":"acde32c3-9dd5-38dd-8695-36c7f60cc8c1","authorName":"Anthony Plant","authorEmailEncrypted":"j601XYewJBRooQ3/HFFSIrb/Sew+RlRFYfUzoPwZMRK1VcZ64MZPBx5/K7g1/DrqH3V6Go7fS70ELd/QicfAUuNfLRQ4qbm2ZvjRXdwjXzbT3ujJ3TfH4POU1OH7ZmC62syXsWVLqdNADyZR/Pvn+f3afN5uAAaKagpFTEdcNdJXakoO7CinVtrFvNBefAKmnR0EFvLQlX/TIi0SqgaRnuCG9fyLa8DSbhtPDY04CP+qt4lFzlGqOX1yU0osgqMkfBQ0G41QM5NvM++F6sd4HGBVBoQEYbJFUPYphwxa3OHfDNDsopErrAOcFaxSnV+UbvCnOwMjugSG0p35HOphJZlznJ89SPuVDwWbjmMAzZRtWQQfYcRZBiD0zt//rnSlGSIihYDKhNjRyKgqxEHVgu32CTqcTd+RbCo5aLM5cM3v2nU4QJc4fEX8wAs8/n381DYpq5X5jbzCx0N+tgGjs2rryxc5tQROyJAXOk9oMtgU3AAlH1hQeCkjypGLF/rj9jVjTdSBYOsoUlQCo3h8yMooX2co/Baxf+c+wKh9sf90z7nWII5lTfNu3r/tgjXujff6v+hyRo8p/0W8blXuWKN1MmvOT++wlKG12h6qxXSUmx5RPsPWq1hNIYx4VlT3rGAbacFqerYaJp6S5rf89hahMkDQ+pV+9ewbJKFML4o=","authorEmailMD5":"bbc5ecbb4bdcaad916239ffd687d028b","message":"This is a great post and a really useful follow-up to your equally great introduction to async/await. This is a real bugbear of mine, though. I can happily block on a Task unless that Task happens to come from an async method, in which case I get deadlocks.\r\n\r\nFrom an interface/implementation point of view, it *should* be the case that - as far as the consumer is concerned (and given that it's all that's specified by the contract) - a Task is a Task is a Task.\r\n\r\nNot that I would encourage blocking on async code in *principle* either; however, it seems to me that something's not quite right (from an encapsulation perspective) when the caller needs to be aware of implementation details of the interface method it's calling in order to know what is/isn't a valid invocation pattern.","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","replyTo":"","date":"2015-07-29T15:22:19Z","timestamp":1438183339,"authorUserId":"disqus:anthony_plant"}