{"_id":"ff5f686b-c6cf-3c0a-af10-197889527b8a","authorName":"Stephen Cleary","authorEmailEncrypted":"GfVe9628TdBpR1hB7PbykCVyGLFYHNjwVKXFSc0mcf/jAxuygl6DtwZQhdodGY28wAKK9KurEmzaW9DogiWpxj9zw2ssSdkQtG1oCaeq/m4+tPH2JmxwkLNttIxNAc9nNy5S9U3SBvhHL41QyDcMncpuPVK2qusgWMcWsQd20VQ7YpSJIZwcEhW7m580m1Wdt5io10CUWoI7KpsgzUIrbTBIyWkurJjzDjUqgOvOF43utpNPlXS5U/1TL5dR52V8I1w1MHSbFbdJYQGnpO0fEXZjPLaIpeGEGjdnGJx+jhUxIx8xvdruFoVwAqfJEH+qOEP8LO/s7Po5EhgOVYDo/K/6vczEObd0v61uM5rzSSCScuJIkRN4de6Ibbpcu1rmEsWD0ER2c/ztyUuzPAG3p5lQDLO6Cz0XCK/df9UK5JCuggF1DAvxJQCm6LRmx+6hLYkSAZjjtn9d7WsBItNX9Cog5/R4zTXXcP9grLxa5FwApA2rMN7mSUSiuD/5EScHQwm+pPQGNhTCNLOc/jxB0TW/nw97mIDPCiCntG4F2HOmoa7J3nAe0/9NDJ2IqXIM493IlpxZNkjk/tccz0v9eRQYNi5zOjiNaAPKRDnmT8gWDDCMu/ffUjnFWpolqZDM4iF4P2pMdI+aB0sm9/Tcgz/bbNu9hyxVwZtgZMAAOmI=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"I don't think ConfigureAwait(false) should be used everywhere. It should only be used in methods that do not need to resume on their calling context.\r\n\r\nThere are two components to this deadlock. The SynchronizationContext is one component; the async method resuming on a one-thread-at-a-time context is the other. If you remove either, there is no deadlock. Real-world UI or ASP.NET applications cannot just decide to be Console applications instead, so \"make it a Console app\" is not a realistic way to avoid the deadlock. That leaves the other part of the deadlock - the async capturing of the context - which is avoided by ConfigureAwait(false).\r\n\r\nSince the default behavior of await is equivalent to ConfigureAwait(true), it doesn't make sense to only apply ConfigureAwait(true) to a UI layer. You can just use the default behavior.\r\n\r\nRegarding \"If you are writing a class library used in both UI and non-UI applications, you should not be concerned with ConfigureAwait inside the library, but only outside.\" - that is not actually possible. It would be nice if it was, but it's not. If you're going to use ConfigureAwait(false), then every method you call should also use ConfigureAwait(false).\r\n\r\nThink of it this way: if some code calls a library method like this: `await FuncAsync().ConfigureAwait(false);`, this is roughly equivalent to `var task = FuncAsync(); await task.ConfigureAwait(false);`. So `FuncAsync` has already been called, it has already executed to its first `await`, and it has already captured the context before it returns its task, and before the calling code executes `ConfigureAwait(false)`. It's too late at that point.","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","replyTo":"dd990e1e-dbbd-3904-bd06-999567348960","date":"2017-01-25T17:46:56Z","timestamp":1485366416,"authorUserId":"disqus:stephen_cleary"}