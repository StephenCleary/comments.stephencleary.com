{"_id":"231ab970-8649-11ea-b597-f3b7e1123625","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","postUri":"https://blog.stephencleary.com/2012/07/dont-block-on-async-code.html","replyTo":"","authorEmailEncrypted":"f2hMFETbJW4J+lOkYH+ZzJhg93GPVgC29AmLtaK84F1ejIew7F6u65ZKd8qtEzqTMSd/yn/ruzGIjmi2GoAQkjVCAnb708sEz69JSx89GyLj+qh2f6JaRxsWoJgtjTH+N7TZ1PQzlAIkfKc1O0cszDJPDtJYe0uBbQ4J6mtB0Av+4p2D5CKcWz2yMzeQEgSS9VWqsyNCo9L9ukgYdiMydt7fF9m41KiWbruPX4CwLlhdvbhw2Ioj2AmsfpUpbhAarD5Mosc7gDCG3VhoQCGKjE/dyJNDTw6oVODl0sxBWntIiqJZsdZIi+QYjJFHDFoJV+ESiI/TplNuk2kCJ/+FavgcXtCXHD/mWOjc1RdE7iSbWCT71w4gAZPsPQDoF6I+Fw3auK3TuAjkxrptbf4lx7rKFdbXxonceHXEBQcXQK0rWHs2Qc+BtARA5091BAjW5+ooDOrISrS53Sq/9RBVNQraoc2yKfaBGPWhEwIi+PiDzLOM+OblShH47tQg60SKgSSmTxmE0LGHGy/JWuo+oWSg2nyjPZQNiE5FTa+bhwNCVp7O0UiK1gcOEoU3uqWcmeuLWdQ+pBdAV9CE8T7PoPhYJArcSg5CGJjZ3aIe96gskXrUxXNMPcSHKnPqOqOFbYygbAthRtMc3hjTQBM8YkI07lyL86Dig61k4cQjGaA=","authorEmailMD5":"522c028945b5860f6e7f8480866db96b","authorName":"Dan","authorUri":"","message":"This saved me from a massive headache.  This is the second time one of your blogs has opened my eyes to something new regarding C#'s async/await.  Last time, it was the fundamental difference between being truly asynchronous and simply blocking a different thread.  Anyway, thank you very much!\r\n\r\nRegarding this post, you recommend never blocking on async code.  I have an API where I must pass in a delegate which can't be asynchronous.  At the same time, I can derive some benefit from asynchronous code *within* the method the delegate refers to, because it makes several I/O calls for which Async methods exist.  That's what led to the deadlock which led me here.  I was easily able to solve the problem with ConfigureAwait(false) as all my code is written as if execution resumes on the thread pool, but if I shouldn't block on async code at all, period, how *should* I handle situations like this?  Avoid using async at all?","date":"2020-04-24T16:32:07.147Z"}