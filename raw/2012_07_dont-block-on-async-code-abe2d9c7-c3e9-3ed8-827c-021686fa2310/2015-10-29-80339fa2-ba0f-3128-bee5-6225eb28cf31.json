{"_id":"80339fa2-ba0f-3128-bee5-6225eb28cf31","authorName":"jeremiah johnson","authorEmailEncrypted":"fGZ6awrroNqHbXwm+kyu12I+SoeGI30S+CxSvHqnhIuPhXEH9I6c8X4eVqIz7cp+6S6Btmu8K1KpapB8x7+vVi9aI+LUBeqzQRE7E0rIREgqXZjp3CpCVlJLMl6Hy5ougCjxj0GAL7kQhTSph7DCZVF11YlxAYZpD6nP1v+o3i3Oy3f70gVqOCHhJzDF1V8p3kKP/rn3O1qAa0gZIEkuC3L39+rj6E1WT//w4Devjbx0jv/eMtvyFDu6fQ5PNHKYTjiqEWG0C4xoPLccYg9H0uNUnpPkDgROzJlzef+EAQVsooC+B1n//A1XuR3UuWDeawb4lQ0mmKAseqwpMPTNq/jJBjJS4kSCcow+2iltCx83HtPJt2KIT5BMKB+c7DmlRpYtPv01ZAGdooVuN3ppjL2LBX2gFkwVBmParFMznT9uOupDv4p9ChHy16mE0s4+rbjQ9bKZbF+vTTj/W6RW3pNMXallpJ1nAnR2nWAexJyPbPEW5EhTZ2whgI1YPea/96NRBnTK6ECdlpBSsQ8BB0yolqBQFhRbs3aRUgDcnSni45HbFI8foh39ou2nfqI52mgvDLUxgEPnW4YGQp6Ztoa9/M7MiViGXYBsdMcB5Xrykk42pWbjcXriFlBkpC7NyljA6IzcNPohCyzfrw2tScguG3uLX0pUX49/OWxXStE=","authorEmailMD5":"54c3a69343a951a798a6c436ac66bc7f","authorUri":"","authorUserId":"disqus:naikrovek","authorFallbackAvatar":"https://disqus.com/api/users/avatars/naikrovek.jpg","message":"And I apologize that I was a bit offensive (in that I was on the offensive when I posted.)\r\n\r\nI agree that asynchronous design is the way of the future, and a better way to develop in general, but I disagree that the async & await keywords are the best way to go about it (if that's actually what you meant.)\r\n\r\nI absolutely love how JS, TypeScript, and (I think) any other functional language handle it, and possibly even languages with event support, which include C#.\r\n\r\nI would much rather spawn a thread, then fire an event or call a function upon completion or status update than use async and await. I just hate how async was done in C#. And I hate that it's the only asynchronous paradigm allowed in the UWP APIs.\r\n\r\nAfter reading a few blog posts like yours on this (now that I know what to look for) the solution isn't going to be so hard for me to find in the future, which is nice. It simply reeks of bad language design when the clear-cut, bare minimum await & async example that MS publishes freaking deadlocks when run from a GUI. That is ... well, like I said, this is one of those stretch marks you see when a language gets too big or starts doing things poorly; it's evidence of a fundamental design flaw in the language.\r\n\r\nIt's like how cracks in a wall (which are an easy thing to cover up) point to a building foundation that is not as sound as it should be.\r\n\r\nProgramming languages should not get in the way of the programmer. They should not interfere with the programmer's intent. As a programmer/developer, any language whose syntax is not well defined enough that ambiguity is *introduced* when I type in the code, is a language whose design is probably fundamentally flawed. Sadly I can't think of a programming language that is not fundamentally flawed in this way. There are probably a few out there, but I don't know of them.","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","replyTo":"11a5ad5a-a039-373a-95ea-9cb7d8cb8d08","date":"2015-10-29T13:38:54Z","timestamp":1446125934}