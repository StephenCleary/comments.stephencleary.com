{"_id":"7e29ca66-56a7-3648-a1f1-8d09a9d4cc17","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"I disagree with your interpretation of the repository pattern; I think exposing IQueryable is both acceptable and preferable.\r\n\r\nRegarding exceptions, there is no need to make the code sync to translate exceptions. You can just as easily keep it async and use await. Just use try/catch exactly like you normally would and use await to call your asynchronous APIs, and it will all work fine.\r\n\r\n> in practice how can a dev tell when he's dealing with a \"plagued\" async method like \"GetStringAsync()\" that can cause the dreaded deadlocks?\r\n\r\nThere is no way to know, short of inspecting the actual source code. This is one reason why I do not recommend depending on code not to deadlock. OK, it works today, but what about in the next version? Or on a different platform (HttpClient is an interesting use case where it never deadlocks on desktop but it can on Windows Phone)? Or in a different scenario (e.g., cached responses returned synchronously can cause the code to take a different execution path)?\r\n\r\nIt's far better to avoid doing sync-over-async in the first place. That way you have code that will always work.","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","replyTo":"2ec2bd25-6238-35df-9e9f-dcfda1b58f6a","date":"2017-10-18T01:29:32Z","timestamp":1508290172}