{"_id":"2ec2bd25-6238-35df-9e9f-dcfda1b58f6a","authorName":"x Disruptor","authorEmailEncrypted":"FqgmEiLUa2be5uyzsIxBijlAgLqLjcAV64g9dhQ/IlCAAZmdwrQyqcahZ7Ra44e8M3lfwy5OvixU5sFAZK8VjZ1bzr4Iwj32oWwkqRaT7Pi+lNYifbRnWALZAfzx+rWEFW+9S3LOAe7iC+YgtR3p1TI+q7QfGMX3S+oYKE0ljmzUgQRN1bsd3DHXqRiIslCGLYzP27YNn5FXhFHZ9NJSvyDAqpjhKj9ZrY2VJREZNv++/Y6WcDJjxFQiSV3sXHY6iHrbHjTOGQ5P8y9TMbumMqM+SFUyX22U/jbYyM/9C6o/Eldv4Z1PJbL7q65wvnVsuZXJK58DDXyexKWdIXC2Skgz5/nkHP5hh3n30xlQVElgi7jY3+LZivweZvsWwDrBNcFza6fur+nRDFpzy8wf4cEdm/UZZpg0qSiLdMuMwXy60zf1l7nvIXjpG7N9HJAfzp2+bBgehJiAfneNoDeLhPuRrnnhgbqYoJxRI3L/V/4R1oyParA2+jJXY6VI7/Mk4BxPqqCdG+TaUyCUXKTV4GzcGtzJ7QSI4sHUBHpkumSbePLdBatFSAeB1A3qrMAFGtV6lCF67/nayCN5eWMNRPm3qUx7qku8VmT7Ppnmxk7EytewNXByhhy3u/V+AAiQzTTlK/5RO3ESPeDivHRWfOlJLiDR7T6YwRMAKDu1nuE=","authorEmailMD5":"ad46e1336e43614ea24e0f42b9a383af","message":"Thank you so much for the prompt response. I apologize in advance in case I have misinterpreted anything regarding your answer. But first some background on why I'm probing into all this:\r\n\r\nAccording to the repository pattern there shouldn't be leaks of references of any kind (IQueryable, db-related-exceptions) to the upper-level layers (mvc-controllers in my case). I thus tried to find a way to \"materialize\" the result of the queries inside my services so that the \"materialization\" won't happen inside my mvc-controllers. At least that was the only approach I could come up with -given my limited knowledge in all things async- to force db-related exceptions to be thrown->intercepted->wrapped-into-my-own-exceptions and propagated in a sanitized fashion to the upper-layers (mvc-controllers).\r\n\r\nIn a nutshell I'm trying to sync-call async-repository-methods so that I can intercept any db-exceptions in the lower rather than the upper layers. The above snippet was one of the techniques I tested. If you are aware of a better approach to achieve the desired effect with an alternative technique -one that is clean and performs well- please feel free to link resources that point to it for me to study.\r\n\r\nBecause, even though things worked in my dev-machine there was a lingering suspicion in my mind that the approach shown in the snippet might lead to obscure deadlocks in production environments:\r\n\r\nBased on your answer I surmise -and I'ld be happy to stand corrected if I've interpreted your answer the wrong way- that whether a deadlock does occur in [asp.net](http://asp.net \"asp.net\"), depends on how the Async methods involved are implemented internally. In other words 'FirstOrDefaultAsync()' might not be plagued with the shortcomings of 'GetStringAsync()'.\r\n\r\nin practice how can a dev tell when he's dealing with a \"plagued\" async method like \"GetStringAsync()\" that can cause the dreaded deadlocks?\r\n\r\nAs a sidenote: I studied the linked material\r\n\r\n[https://blogs.msdn.microsof...](https://blogs.msdn.microsoft.com/pfxteam/2012/04/13/should-i-expose-synchronous-wrappers-for-asynchronous-methods/ \"https://blogs.msdn.microsoft.com/pfxteam/2012/04/13/should-i-expose-synchronous-wrappers-for-asynchronous-methods/\")\r\n\r\nAnd the author gives the following example:\r\n\r\n public TResult Foo(…) => FooAsync(…).Result;\r\n\r\nwhich -at least to my novice eyes- looks very similar to the code I'm field-testing. The author then proceeds to explain that this can deadlock. The author speaks generically as if it doesn't matter whether FooAsync() is an EF method or whether it is being invoked from an ASP.NET controller-action or not. I guess I'm missing something here. This particular aspect makes me feel so conflicted about all this deadlock issue.","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","replyTo":"fac220eb-d9c7-32a0-84b1-73be101ad75d","date":"2017-10-16T23:32:01Z","timestamp":1508196721,"authorUserId":"disqus:xdisruptor"}