{"_id":"864f7182-0020-3f04-b548-f8d700cd8d1f","authorName":"greggwon","authorEmailEncrypted":"k4DOrm6pyDJBTOoq/0CTGMX5/3nQkrALccN0/jOypIze6HwiPmAvNqRLLgN82W2elkSG8bUkTUCMIfZBrDC0awmEEoc9ZP6Z22ephW9KbbN3wLmD4UqA3dkfDdnR2G6yxxMY1e/498INLEtMHBM/z6hs6007BJSjYuAc3y35eGb3QWsfEwhmpYRB+qOTeOIne+zP5kRmRYfDdMs2S6N8k+XuTKQHTeHL9XY7IbtW2/XF71/Lx4awkD1RvawciwvSPuigq/3yCfoe4agRwCgPATT42oXvUogehZG3gd8qUNci5y72PHA07cZ2u43CxpebUfCPMViMgnvSjdKg/P5NVwhtbsaSDr7NOkmc3AONDF6k7k+eGiXCnHqs5dvjZ7ivG96ZuMqd0CAoZTrVSPE9ErZdoTJXfV+SB9GSrsjEOLiXldkpsA6izCQ080WO0n+HsAnxRoJ8esyMoerX+xRAsG3eL2RAM4jmcVCdm08a5u2ihwqlQpDF7DFydZcDdizi8DZOQSnT0Rd44Z0ZRgGwtBxyDXngDF8QgNy4A1mu1+6tcly+HR+lWxLnYY/J3rnuRSK86vdKtqrT+FC+6RBaquAJv3cnn//h05kDhZ0dRvLXSLmPVfdjthW0US+QgrU1U4I95oX4S44BGWe8awLJ9XBQfGnZ36fRmwCvinytmBw=","authorEmailMD5":"142c71b27a71ba2448701da921b0d14e","message":"The problem is that getting the result and using the result are mixed in together. The better design is to clearly manage the three phases of async data gathering and use, into an API which includes managing state so that \"dispatching\" windows actions happens in the right context.\r\n\r\npublic interface DispatchManagement<t> {  \r\n void SetupUI();  \r\n T PerformAsync();  \r\n HandleResult( T value );  \r\n HandleError( Exception ex );  \r\n}\r\n\r\nNow, implement some classes around this interface, and have the base class use the correct Dispatcher, for your context, in SetupUI() and the Handle* methods and dispatch PerformAsync with a Task/Thread that comes from a pool.\r\n\r\nNow, you have something that will actually work. You could use delegates for these methods instead, so that lambdas could be used instead of whole classes. However you package it, then, there is no \"context\" different from the code, and there is no thread lock nonsense involved in creating linear code flow between two threads.","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","replyTo":"","date":"2017-09-15T19:13:52Z","timestamp":1505502832,"authorUserId":"disqus:greggwon"}