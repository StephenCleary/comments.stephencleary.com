{"_id":"09126190-1b73-11ea-91f4-bd5a4438eddf","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","postUri":"https://blog.stephencleary.com/2012/07/dont-block-on-async-code.html","replyTo":"a7833950-da4e-11e9-9aee-c13410c6607c","authorEmailEncrypted":"G6UpZ54Iwj1cpDqwit/UVx8jidnL5a0T9OUNLgvEg1cSHVyRcRPEuWvX4WdAaqUnoOQTfw/EFjEi513e/qpGuo5wuUgjOhGNQV2kbEdX5V7vN1AbFdtjhz2idsSHPEHeC4pNPhUvV3ApthPgV+jLhjhnOvWCvGjn+NwAhk/lvZDIb8+w+LrMMEuSyMb1chmcPk5hrReFp/0/ma5RCdccoORRTGitbz54hpXTxpkj30wE/+o08Fedn5y5l2dqBrevYDPDWeXPzTEbHPRG/dzpkjj36WzXWyVi4tXr845C8VmIKCX7ZKEwq/EOuSFdWWpXgsMfSSXcRYcXmJA85IPAuEflphmP5yHejtrrExCbUxCUcdgR2PjVVw6cvaMW8z6imkZ0oXj43nmsC3LJL87pashefIFhV7vALqCG0hhVsGpPiZ2P6aktkUt8gEOwg92bz2xMHI8h5iccM3UGF5aUoyeJMSv09rhnKHiXzKE+n4kbARtOzq/m1PtfDhXOEOsxVmN6DBRUzKZ8iFmzdDeB1J0mzOw/+MtJoLj0u/otAwk0asL2hTdL18l9q2+Xpo1NDBCTEIoPAw+RyKO4enTw1v9lWhctyVKzxQFYIlyPJWTHEcohmc9K9uMyMw4+wssUyJ+h+qKfeOXS51lUdoolNmWUVtAseu2mRuKAz6SWuWY=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Yes, that does prevent deadlocks. It still blocks a thread, though, since it uses `Wait`/`Result`. Also - as a side note - exception handling is different when using `Wait`/`Result`; use `GetAwaiter().GetResult()` if you want to avoid `AggregateException` wrappers.\r\n\r\nThe reason this avoids the deadlock is that there's no context captured. `Task.Run` runs its delegate without a context, so any `await`s in `CallHttp` will not capture a context. But it does block a thread, so it's better to convert `Get` to use `async` and `await` if possible.\r\n\r\nIf that's not possible and you *need* to mix synchronous and asynchronous code, see my article on [Brownfield Async](https://docs.microsoft.com/en-us/archive/msdn-magazine/2015/july/async-programming-brownfield-async-development).","date":"2019-12-10T17:32:28.218Z"}