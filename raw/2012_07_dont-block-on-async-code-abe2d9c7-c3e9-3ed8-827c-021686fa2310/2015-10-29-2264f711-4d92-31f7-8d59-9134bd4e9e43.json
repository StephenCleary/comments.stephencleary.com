{"_id":"2264f711-4d92-31f7-8d59-9134bd4e9e43","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The deadlock you're seeing is precisely because it is in a *single*-threaded context.\r\n\r\nThe thread is blocked on the Task, waiting for it to complete. Meanwhile, the async method is ready to continue, but it's blocked waiting for the thread/context to be free so it can finish executing.\r\n\r\nAsync code enables single-threaded concurrency, and so permits single-threaded deadlocks.\r\n\r\nWhile I agree that it would be nice to avoid the \"async all the way\" rule, there is simply no way to do that. No language is going to avoid this. In functional language terms, async is a \"future monad\". And in functional languages, all monads spread through your code \"all the way\" just like async does in C#.","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","replyTo":"313ed9bf-9461-3363-9941-37c40e29a3e6","date":"2015-10-29T18:29:35Z","timestamp":1446143375}