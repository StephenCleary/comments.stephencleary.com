{"_id":"3977220d-0733-3870-be56-dafb767ffdc0","authorName":"Edouard Paumier","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","message":"Hello,   \r\n\r\nFirst of all, thank you very much for your post. It saved me a very long investigation, I believe.  \r\n\r\nI just have on small question. What does it mean, for the asynchronous call, to not collect the synchronization context?   \r\n\r\nIn my case, I'm in the opposite situation. I got an In-Memory WebAPI server, which I call from a long stack of non-async methods, which in turns is called by MVC (don't ask me why a MVC server would send a request to an In-Memory WebAPI server, I feel we would drift away ;) ). The non-async method waits for the response of the call to the SendRequestAsync of the in-memory server, and in a MVC context, it's the deadlock.  \r\n\r\nTherefore, I either have to change all that stack to make it async (and I don't even know if that's possible), or to simply drop the synchronization context capture from the In-Memory WebAPI server, using Configure Await.  \r\n\r\nI assume there are some data that would not be available anymore? What's the con, what would I loose?  \r\n\r\nThanks a lot.","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","replyTo":"","date":"2013-08-22T11:46:01Z","timestamp":1377171961}