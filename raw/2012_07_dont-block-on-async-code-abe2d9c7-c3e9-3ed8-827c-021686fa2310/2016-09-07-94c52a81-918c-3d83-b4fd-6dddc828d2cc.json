{"_id":"94c52a81-918c-3d83-b4fd-6dddc828d2cc","authorName":"Jason Shuler","authorEmailEncrypted":"F02pWGafONumV/4Yudg4eouo8fYjiyHS8wBxT/0kvmwWAGnBFYPK+2xA4DuZiA5Nfqlqbd8g+nnCG9B3DDHr1Ucl8JNNj6Ak33UTf9u2spm1wt5xN2zQkwXarfIKHdUdPIAWVTUFBMp17IFxVQlcojU/g1R4sgUWW1QYFanAYAeIKcbPkE0vke3fJtAdIGNFk1zk1h1KEpVwIF4iCTR1n1xZBjrCHBD+2X4QbQOw+teYJBmukPf50TJwjt0P6L35oSYtcliWMlN8k0EWJFY3dH+F981Mwfb/hxeNE6hRpXTlPmzLlk4qGAP/bZD/1Sx+SWdIra1eRWZGImllqBlTDCzVzH9X8pEm5BD0STP9rg8Xr7iChZr6Q0gJZcO/4X4nRutKNCPRjbZ5FeFiIfGyrBd/p98SDD/3szFe7A8HBTWsjjqNhwjDYowzF8C8dbzbvwmRTmJwKm7xT0esaTt5FTQoeS+G2FJ3DP6X6fVUcR49tLrUCwimrjzGM1VUDWWwgXtoYuix1Ulhm0zGANXGdW4FoAhuKB7ZwDbpLeUciVwnoWd6+T1jh3ObLZysWXBbP6MPhikjUgQRlfGaqj18eoupwcgVmGfvuUUEiEbYxtRjwDxbd1iK/7sjULzS7YNuXLJdv9s0wlwWB3hI7sHsb7cKOVbuSN88fKGd3os1BLc=","authorEmailMD5":"54072bce77fea3110f906f91a705fa81","authorUri":"","authorUserId":"disqus:disqus_Tff2hDjHfb","message":"Thanks for this very helpful post - I do have a question however. I have encountered a situation where I have no control over the library implementation, and I do not have the option of using async/await. For whatever reason the library authors decided to remove all the synchronous versions of the methods, and I am implementing an abstract method on a base class that cannot be defined as async.\r\n\r\nIt appears that using the following avoids the deadlock:\r\n\r\nvar t = Task.Run(() => problemObject.ProblemMethodAsync());  \r\nt.Wait();\r\n\r\nBut I have read that this may not be 100% foolproof - some people suggested that it still could be possible for the task to end up on the UI thread and deadlock.\r\n\r\nAny ideas?\r\n\r\nThanks!","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","replyTo":"","date":"2016-09-07T19:24:47Z","timestamp":1473276287}