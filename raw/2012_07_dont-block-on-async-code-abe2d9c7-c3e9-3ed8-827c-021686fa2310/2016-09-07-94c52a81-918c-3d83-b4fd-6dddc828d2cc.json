{"_id":"94c52a81-918c-3d83-b4fd-6dddc828d2cc","authorName":"Jason Shuler","authorEmailEncrypted":"r0ZEFD2bCswCMNxVII5gAns30HhVN8psLFBFCFoHDKL2vRcYCmMs7kjr781cGsOMKuz60AjACGn4kwLqggu8WWdQUgW179T9jaCPfzdQSS8sh1F2ma9Hnrudwr8s4GwBLB45LvGql6okVSoGrsh4ieGxdZKPuiEMGFlVFh9REm3wQIoyyVZQGN9yXHYT9KB6yHDXwQMWzM7dOGCedfx3Yi/qc7whVikYiESeeJYUOFAz4QfXgtgtQUc30YukcggQwgU20KiWzPSGA3bqJysm4Yie8nbPcrvr7JID0sQYaIZs8veaTsxIl2JcBq32p3bfgKADTIyfW3z6gfleWDqfQOHodfVhrhoW95VH2IP97/VALFpX7EydG+9pWFz5rC997f2euHsuXaMXgH5OnEo2AWVmYAb2jzUhsRGCmq5kmW698vjTinnFrkj0+recP/9C8ampyzxUEVEGff7vUewzSgS13332Qvure+W+cfHXwNklri0W3OvLDQp3NmZbdowsHFjrlwqWQ2wf4qWkS72lIITE5QWS8hO0MvZ8U3nueTTWqVtCbGRsrfeMToeFrOJ1cWl02Fl22u9/rqkdkEW8JYhFbeeZLsMpMqifLapf3hgYDPIXHeeXjkJEcZ7BonxS290ibHF0wdsXIwi04ebDt0rO52r8EN158GjZvqDBoJ0=","authorEmailMD5":"54072bce77fea3110f906f91a705fa81","message":"Thanks for this very helpful post - I do have a question however. I have encountered a situation where I have no control over the library implementation, and I do not have the option of using async/await. For whatever reason the library authors decided to remove all the synchronous versions of the methods, and I am implementing an abstract method on a base class that cannot be defined as async.\r\n\r\nIt appears that using the following avoids the deadlock:\r\n\r\nvar t = Task.Run(() => problemObject.ProblemMethodAsync());  \r\nt.Wait();\r\n\r\nBut I have read that this may not be 100% foolproof - some people suggested that it still could be possible for the task to end up on the UI thread and deadlock.\r\n\r\nAny ideas?\r\n\r\nThanks!","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","replyTo":"","date":"2016-09-07T19:24:47Z","timestamp":1473276287,"authorUserId":"disqus:disqus_Tff2hDjHfb"}