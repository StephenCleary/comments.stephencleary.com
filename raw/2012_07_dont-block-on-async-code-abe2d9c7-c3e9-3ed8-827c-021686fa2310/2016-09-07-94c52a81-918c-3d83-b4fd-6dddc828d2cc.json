{"_id":"94c52a81-918c-3d83-b4fd-6dddc828d2cc","authorName":"Jason Shuler","authorEmailEncrypted":"qGy2fe3H11XErksEt22+njWhjnIfS88+W4uM+wWq9U7F2G94OVIKS7rWGsV3GGcat2lrdTzF7tzzp9imbjutO//YCh1mNdi4Xi/Su+Ij3J4l2rtthSnCd73b9mn04h32aj55KHI1U/nv/8BlY/8tp5v7fq49KfisKXtIpI5z8nVMQT8p9PlGSU0iBh5Js2RHSGSyAhY/sGSV2C0UegLYU5sd7yOktRDtGdIypsOsFvr8vJcaYFu1DP8oJPdP1tkM12XJwD1/SL44m7ZuCZ5m4iZefRjo4xhtikeL/cNGcVtxKuAFcDm2PKKYFrQVjTA6tNFCINyrzOl2BTXN+lm2Sw72TQ28ulILm4r4T0OPuae+rX7zbrUHzJmiyFfKOdjMbv8k5iJW3vngcIaE+5wdikHblA/JtIMe4W4uMJntjnPA4pY4TKpCkLXYyQIsuR/wj/Ymx2LoGzY/Pm4m1bkW6p4fLWkjwIEOGf2FIYWS5r18jxf45eMi1Hqp4BjmcSEuZvA+u8XiJS/ugVDgkUZvnqLAzQGZO579xtOrB0srB6KSgZqkzoCsYifT/QIt3fdG3AVDqPj2GzGdtLj7UAyZfTGROyqXX1Dbkvw1j+QteesoN81VRBTD3Y+iWpIcA1zXn2RYQu5KcgiI3SiLS/HQ6svjfaM0vDhHqS62SGBl6u0=","authorEmailMD5":"54072bce77fea3110f906f91a705fa81","message":"Thanks for this very helpful post - I do have a question however. I have encountered a situation where I have no control over the library implementation, and I do not have the option of using async/await. For whatever reason the library authors decided to remove all the synchronous versions of the methods, and I am implementing an abstract method on a base class that cannot be defined as async.\r\n\r\nIt appears that using the following avoids the deadlock:\r\n\r\nvar t = Task.Run(() => problemObject.ProblemMethodAsync());  \r\nt.Wait();\r\n\r\nBut I have read that this may not be 100% foolproof - some people suggested that it still could be possible for the task to end up on the UI thread and deadlock.\r\n\r\nAny ideas?\r\n\r\nThanks!","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","replyTo":"","date":"2016-09-07T19:24:47Z","timestamp":1473276287,"authorUserId":"disqus:disqus_Tff2hDjHfb"}