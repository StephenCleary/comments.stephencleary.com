{"_id":"94c52a81-918c-3d83-b4fd-6dddc828d2cc","authorName":"Jason Shuler","authorEmailEncrypted":"UrFiQ/Qbb51OX24e2RGbo9/+dOr7pijioqrzYg8g5sABQGHGYtoeJA3m+o4LuM7AXev0iugOOB3iPdh4A/pNzU8HKT28Oxiw91SYeOdeNYDHblWC3ifARGBLDHpnYW/3TBv8BcTq1Rjfmj1GB1KK2H3GbHEx/1tztq4aGgg+6yJj61M2LgsFCknU6vcUi4yoaHdQFVaq1HInsSLwdPg3uOgwOuKdkCxHU+lXbURXeVaIfG9Ob68igGNulnE4LsVz/IVF/nlbNlN+ltWVDV0jMW/0369NIxnwB7S9Dw/tgGckMDpEn6JTdXWmEj+Kn9wICvN5Cz1uIXdiy7oBtczAs7oFMMkAgypcjjPCTyQb/x99Jb6JdDFAt6kKyDCQulP6n6xziOjW9Dj05njxx3ykeML+Hh9nhYDugKot+m/kAGT6anc1HFZN6lRNW5g17sKNxOEyJU8aT1FSVv4I1GibMYVDDWe8Yq7dj2uqSH/Z7ZUCpukH9Dnt5ZQ7ZOcYTFyTwr896WnJPCO6OvyKt6s5fTu3OX69utntu7SkQVhnHxkrDbFOHokoir9JcZ68YoZJ4wkPXIF20KOAqHJJUWzclq91JsIyke4Ho5BcM7/TIimV3rKdTTw2t8h4xCrBoVPcOC/pJPnENlbhyaGMmGVWz/TNnli8OqrRxY+eY/3Jj+g=","authorEmailMD5":"54072bce77fea3110f906f91a705fa81","message":"Thanks for this very helpful post - I do have a question however. I have encountered a situation where I have no control over the library implementation, and I do not have the option of using async/await. For whatever reason the library authors decided to remove all the synchronous versions of the methods, and I am implementing an abstract method on a base class that cannot be defined as async.\r\n\r\nIt appears that using the following avoids the deadlock:\r\n\r\nvar t = Task.Run(() => problemObject.ProblemMethodAsync());  \r\nt.Wait();\r\n\r\nBut I have read that this may not be 100% foolproof - some people suggested that it still could be possible for the task to end up on the UI thread and deadlock.\r\n\r\nAny ideas?\r\n\r\nThanks!","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","replyTo":"","date":"2016-09-07T19:24:47Z","timestamp":1473276287,"authorUserId":"disqus:disqus_Tff2hDjHfb"}