{"_id":"b8b80388-cfbb-3b50-a6c4-cabc282ebc96","authorName":"Stephen Cleary","authorEmailEncrypted":"oN22fDTAXwxtJBKKPvfhl1iWsQnP+3XIghTTn4j3HIacOcPAUrTMV67FPMEfW6bQXv2zmkXu1v02C9CCmKvYFyjc/Cp1yxB035IGyVbdU/auUpANo4T/Pk/7zwvaukuw/RSb+DhMULSMh6CFGrKUg6z2xrXRkcQ2saFuDsnwKaVTuKUwfWO8n1r5R++D390fcFD7OaCb9tSajxhWJkJTBhw57uYWqMHkCLzoVf+kY+TQ10lJ+V8O9KrdjHMHg8c4kmczf9jNioVolWa3XcmEMfN2oQ/ktLhacgnzGAZSoNxjhBKl+yVDPKVDTx0zEviZ/k/4ZNjJ0DRPSC18QPxh58OZqmKr3Fm8cDoIw++jTrVuwMQbDtuSUF72ZkVLWYiI/xswDdM+D4g/B/z2EL/A+9EjmIm8TV3XMR6gz/D5NLxtlJ0Swy5q+9TijWwVTSLqAsOLAld8CxSBNOCz07TVr58NijL24R2d8sbdU1bmnZXEgvHqhz+DsPf7CFtLUeHHXjGJO1J48korMOvMb1SYWqKCFesviAfNzH4uS3wQah+k41c/FX5lq+pQkomx2wpeuNTUqPjm8idPt1F/Nptr1LC3pGZz6kbNVOwLeOQcbT8zeGc+VdbyS47N/jzpqOzO538MRN4VqPvrn5y0c0agGV4qku6wrgRl343j9DBtrH8=","authorEmailMD5":"ad2250182ff26a84dda974e50cd94382","message":"No, it won't always cause a deadlock. It only deadlocks if the calling code is in a context, the task needs to sync to that context to complete, and that context only allows one thread at a time.\r\n\r\nIf the calling code isn't in a context (i.e., it's in a Console app or a contextless thread pool thread), then it won't block that context.\r\n\r\nIf the task doesn't need to sync to that context (i.e., it uses ConfigureAwait(false) all the way through), then it won't need to enter that context to complete.\r\n\r\nIf the context allows multiple threads (i.e., a custom context, or a limited concurrency context that permits multiple threads), then the calling code blocking in the context won't prevent the task from entering the context. This is extremely uncommon, especially for asynchronous code.\r\n\r\nHowever, I do strongly recommend against using the Result property for asynchronous code, because both of the common conditions can easily change.\r\n\r\nAsynchronous code running on a Console app is usually proof-of-concept code that is later put into a UI or ASP.NET application, where it suddenly *is* called from a context. Asynchronous code running in a contextless thread pool thread is usually in the middle of being refactored from threaded to asynchronous, to run on the UI or ASP.NET request thread.\r\n\r\nDepending on all the asynchronous code using ConfigureAwait(false) is dangerous. If one of them is missed, then it's possible to have a race condition where sometimes the context is avoided and sometimes it's not. This is easy to miss even for experienced developers. It also assumes that all your libraries fully use ConfigureAwait(false) properly, which, again, is easy to miss. Note that even the common and excellent HttpClient library has some platforms where they missed this.\r\n\r\nSo, I always recommend against Result in asynchronous code, unless it absolutely cannot be avoided (e.g., the Main method of Console apps). Even if Result doesn't deadlock, it will wrap exceptions in AggregateException, so even in the rare cases where it's needed, I'd say to use GetAwaiter().GetResult() instead.\r\n\r\nI've written more about Result and other ways to retrieve results here: [http://blog.stephencleary.c...](http://blog.stephencleary.com/2014/12/a-tour-of-task-part-6-results.html \"http://blog.stephencleary.com/2014/12/a-tour-of-task-part-6-results.html\")\r\n\r\n-\r\n\r\n***If*** you're writing Dynamic Task-Based Parallel code ([https://msdn.microsoft.com/...](https://msdn.microsoft.com/en-us/library/Ff963551.aspx) \"https://msdn.microsoft.com/en-us/library/Ff963551.aspx)\") (which is very advanced), then using Result is appropriate.","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","replyTo":"c49570dd-ae97-3846-aff1-423b4651f05c","date":"2015-09-08T12:56:48Z","timestamp":1441717008,"authorUserId":"disqus:stephen_cleary"}