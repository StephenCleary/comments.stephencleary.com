{"_id":"fb685f31-1d3c-3ac8-9936-c4301457db0f","authorName":"Bowen Zhu","authorEmailEncrypted":"uenk9XWBmht8G/ZTIHFYnamcYZOIErW1qsjob2zTPb88quhyNEu/aHwFKn4Fwb9u1LTZ1eK4JXFzufEJnMvJZaaMMtmiEbUPIRGMmzXLQhVPXMmH8iYFTVOMlcGAnJnnnDuXUwnN3ywiJ9ySU7YYkPtCZO2LrBj/PH01LRc3E5tGp8o5T7tVHxrFF94grJyr66j6qUvewrxyZ24nWZ/vh/pzUyzkkRVsLX6eTl5cz1zVxtEfyFLEDveRcHPbfzpdh7NU5NduwKvhm5Kk3DT/tXcr8LdqKUOs6PZJC5NvQEqHifxsyl0firt+Lsak8gbTh4mS81DeL0M+gmsJqdEyYeKIgQUKf96kOGtJTwaY/ZKNbXsXArm3bjPYOt+53SnzSzC37CIKyPaGJAhO+100uUhmopDqZEd/OR8hWuPwwp1xpc8u6m48uOwojjtHwEXsPHv4PpD8kXLEmgkPeG/Aih+jmrMA1Xz7UmKt583YTFvNABVEBFusLkcAwDOMq06gRiPAoniiaw6lnXZFXsglebV3vE4a2keSrc7fCu2t1qUCze51yqyr5nlUv9Cy2Q75XQFz5fYb3ePAfw9jvx0PMObilMD/x4ZoGQIYnvLqapM/zCdhzuiFd49hh2M+R/gDxelODJjk/YPSkh5OjhMKFtDnhkE2Qo2FsSjZ8x0Ti/I=","authorEmailMD5":"b6420a5dd5fb035ae3c24e4081b3604d","message":"Thanks for your insight. I have been trying to figure out one thing all day, but still not very sure of my finding. Could you help take a look at it?  \r\nIn an Asp.Net async api controller, I want to pass an singleton(context) down to another http message handler which would execute later. The only correct way is to use HttpContext.Current, and any code before it in the function should use await without ConfigureAwait(false), if any, which means to use back the SynchronizationContext.   \r\nCallContext.LogicalData is not reliable, neither does thread local storage and thread static data. It's possible that CallContext.LogicalData will be lost under heavy load, together with async programming.  \r\nAre above statements all true?  \r\nAnd I remember you mentioned somewhere, we should create a context boundary in the codebase, for context-dependent/without ConfigureAwait(false), context-free/with ConfigureAwait(false), respectively, correct ?\r\n\r\nAnd another question, so in a WinForm UI program, consider below code  \r\npublic async void button1_eventhandler()  \r\n{  \r\n await InvokeFuncAsync().ConfigureAwait(false);  \r\n this.EditControl1.Disabled = false;  \r\n}\r\n\r\nthis.EditControl1.Disabled = false; should fail in some way, correct? because the resumed thread didn't load back the SynchronizationContext, but in my test, it actually works, any part I missed?","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","replyTo":"aaad59d2-a97a-3e69-a557-5dd693d32ad5","date":"2018-01-20T02:17:17Z","timestamp":1516414637,"authorUserId":"disqus:bowen_zhu"}