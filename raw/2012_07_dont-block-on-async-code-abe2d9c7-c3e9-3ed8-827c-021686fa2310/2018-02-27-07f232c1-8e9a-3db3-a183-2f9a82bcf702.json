{"_id":"07f232c1-8e9a-3db3-a183-2f9a82bcf702","authorName":"Varun Bhargava","authorEmailEncrypted":"vKLVBlLc/DLINzR5Tq82v4daZ0dLslnxQgzQjwvsQ8Qt8H00QA8XPcHH+lFvIRXnsuU9OsIPeeO7Gm2C5qD9Ujq/4xjNxlEcMKerig+0TtXsnWQOPZu+x9XLd6kTBiT7NSf7kuKMdJYrc4TUnP+5EiyQJzLR+ZjPlDP/qZEKBafot8uOF965RqGAIOH7c7mJkeI0ubkMHHdMuAgN1ZAAv9/sYWPrPQcPBw3lvuFfC8uBz7hClaugGp3BzFzVS4vGfLF8Uch3JZg129xFend+JpvdLyQ3Ke1FKoz1On8IJOJZ58DmlpVnyqDX56eGh79uavrwq2KYRRJ882TDepQVtnkaj1jzd1yag+koC4jO2/JklhJx0p2dXk9/XOo/ACACWZJ3qXKGL9IwJLEdfr7wFoP83Qvs0bAoXfidC4tg6z/8zhVaK+EjcooO8WsLuQjCGoIzbEa7iZllKdpoXh1z/2aMUBgPP2y8liUUZFzilXXaPxcX1RPVVW2y3TWwKGuT0MaQdfOlYUWrNfVPkSmbaa7ETYFKJvErd6che5p2IxwYiOzo1OgFhYfCPHeCV/Wp1wfkHn9Ww95DS8G3/SYnn3WwC8auKBg2mfT7miMfNwF9ZwUh77+djaV7EqbmpCpIXBXenejvxgD6hApRJHlO5oD+PF/bVYHlLQChZfJC85Q=","authorEmailMD5":"4126b5c5e664cb207ef3cdb64858fda8","message":"Thanks Stephen. This is what we're trying to do\r\n\r\npublic string MethodSyncVersion(string secretName)  \r\n{  \r\n return this.MethodAsync(secretName).GetAwaiter().GetResult();  \r\n}  \r\npublic async Task<string> MethodAsync(string key)  \r\n{  \r\n return (await ANetworkCall.GetSomething(key).ConfigureAwait(false)).Value;  \r\n}\r\n\r\nDue to some reason we have to have an synchronous version of our method which under the covers is just calling the async method and blocking on it.\r\n\r\nThe consuming code calls  \r\nvar result = MethodSyncVersion(key);\r\n\r\nThis is the line that intermittently gets deadlocks. Another thing worth mentioning is that these calls happen inside an IOC container during instantiation of an object bound in singleton scope (which will have locks of its own).\r\n\r\nJust so I can understand better, what could be the exact reason that this sometimes works and sometimes doesn't?","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","replyTo":"febe2270-e37c-3014-aa10-9c4b959cb219","date":"2018-02-27T22:54:25Z","timestamp":1519772065,"authorUserId":"disqus:disqus_ZZpGv0gXZl"}