{"_id":"c8f0fa50-097d-11eb-a788-5943ba6534e2","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","postUri":"https://blog.stephencleary.com/2012/07/dont-block-on-async-code.html","replyTo":"e78d2f60-092d-11eb-b8b2-03eb9bd9947c","authorEmailEncrypted":"SfCNW7Z+R6fZUZz6w6j+LrNACXGe9P1s+iIKf4c27u0dG/NKx0MbwS4n2JMK+Krmo0YkC47ryuE5gjnWRk00aGcmQl1m35GXVsfzdpW+mEKslpOb5gR3y1C8IaYMkZlJ1Hn0rexOMFIHHn7xYE4ECRgFO/d/SRzTR2jh1N5hRxSJTp3KQnh3RdkqOnouplfCtR0rJsD4AU8ntEQ1WQ3c1O363OKUYv2nqAPQVJJC0u4YOny8LwTC3AA2w/uEDB5Eq47Gb8Pl9P5SQ9hD+owPw71MvX1WAkrhs0botIRK+sI/vEj7Jc3Fdg5qsgBihuYErlhXR5jJCrdXVTuU9N4z65LUCZWPSIpUNj1VUO0/9JqsBDTl8MG9x+edKSZNDVepJEvwa9VnLd3XtfzCuMPVnSX6bXitMjoSTNa+VtG14MeK3cXQaVYzNWMjDBLFv0UWhfR+T45wet5b6q79Ad7aNNI+xyWc6buTIbV8/yMIUgyM7YQ9TwsdorJIBHKDEbT6N00sKjdfsj9svDv0j2gqsawTk148bqO7axXO2UWDHY22EDNkjR83E8VoG0MXHmn6cs34sIqdlgTP0dEP91E7M5b8Js+LEg2AVgH2ufMlun9xa3rke745HtWrFub3NEjH9a75EbuRpwW1KJuZTUxWejTJvhL5JnV+Sf+soRF8cWM=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"The reason I don't recommend that solution is that it's less easy to understand and maintain. For example, what happens when someone refactors the method to call `C` before `B`? That said, this pattern will work, but only under these conditions:\r\n\r\n1) The *transitive closure* of all methods being `await`ed first must use `ConfigureAwait(false)`. In your example, `D` would also have to be sure to follow this pattern.\r\n2) If the any of the first methods complete synchronously, then this pattern no longer works. As I describe in my [async intro](https://blog.stephencleary.com/2012/02/async-and-await.html), every `await` may continue synchronously if its task is already complete. E.g., this may happen if someone changes `D` to return a cached result if possible - in the case of a cache hit, `D` completes synchronously and the `ConfigureAwait(false)` on `D` has no effect. This can also happen in some surprising scenarios that you don't have control over; e.g., `HttpClient` will cache HTTP responses on mobile devices.\r\n\r\nAs a reminder, `ConfigureAwait(false)` is not a workaround to avoid a deadlock. The best way to avoid that deadlock is to *not block on async code in the first place*. If you absolutely cannot avoid it, then consider one of the hacks in my [brownfield async article](https://docs.microsoft.com/en-us/archive/msdn-magazine/2015/july/async-programming-brownfield-async-development). For example, just wrapping the top-level call in `Task.Run` (i.e., the \"thread pool hack\") removes the context from the very beginning of `A`:\r\n\r\n```\r\nvoid CustomerCall()\r\n{\r\n  Task.Run(() => A()).GetAwaiter().GetResult();\r\n}\r\n```","date":"2020-10-08T15:49:01.880Z"}