{"_id":"c6711b9c-b80d-30ec-8d7a-93499189df30","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"It would not deadlock if ANetworkCall.GetSomething(key) returned a task that was complete by the time MethodSyncVersion called GetAwaiter().GetResult(). This can happen if you have a caching network provider (e.g., mobile platforms will cache more aggressively than desktop).\r\n\r\nSync-over-async is an antipattern, as described here: [https://blogs.msdn.microsoft.com/pfxteam/2012/04/13/should-i-expose-synchronous-wrappers-for-asynchronous-methods/](https://blogs.msdn.microsoft.com/pfxteam/2012/04/13/should-i-expose-synchronous-wrappers-for-asynchronous-methods/)\r\n\r\nIf you need to support both APIs, I recommend using the boolean argument hack: [https://msdn.microsoft.com/en-us/magazine/mt238404.aspx](https://msdn.microsoft.com/en-us/magazine/mt238404.aspx)","postId":"2012_07_dont-block-on-async-code-abe2d9c7-c3e9-3ed8-827c-021686fa2310","replyTo":"07f232c1-8e9a-3db3-a183-2f9a82bcf702","date":"2018-02-28T00:26:27Z","timestamp":1519777587}