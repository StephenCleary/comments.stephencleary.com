{"_id":"26bb3051-408f-301b-a00e-9ccebd04d10e","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"In the code you posted, `ProgressBar.Value` is not being run on a different thread. Assuming this code is called from the UI thread, `ProgressBar.Value` is only being set from the UI thread. I have an async/await intro that explains how this works: [http://blog.stephencleary.com/2012/02/async-and-await.html](http://blog.stephencleary.com/2012/02/async-and-await.html)\r\n\r\nUnless you mean that `SomeCpuIntensiveWorkAsync` is also updating `ProgressBar.Value`. In that case, *some* frameworks will allow setting UI control properties from background threads. WinForms usually does not, but I'm not 100% sure about their ProgressBar. WPF does allow setting simple values, but other MVVM frameworks do not.\r\n\r\nWith the range of support for this, I recommend not to do it, ever. If you use `IProgress<int>` / `Progress<int>`, then your code will always work for all platforms.","postId":"2010_08_various-implementations-of-asynchronous-a4e088a3-0b76-3708-ae71-e29e4bbdd132","replyTo":"c4fb70cb-d224-3ae3-8be3-fbed40906a24","date":"2016-02-26T20:01:30Z","timestamp":1456516890}