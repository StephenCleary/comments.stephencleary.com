{"_id":"87ce3dc0-1b77-11ea-91f4-bd5a4438eddf","postId":"2010_08_various-implementations-of-asynchronous-a4e088a3-0b76-3708-ae71-e29e4bbdd132","postUri":"https://blog.stephencleary.com/2010/08/various-implementations-of-asynchronous.html","replyTo":"ecda43d0-025e-11ea-be6b-ab7117916579","authorEmailEncrypted":"hUaKQN+OQ91GHhXsyYRYOqOKv9H8NwNsh8SHGiKhTLFmOCJA5ZR86rUtXr0v814K/pcDRqOYErsHIhtwlq2EU5hB9uJecjvDvz+HVffEzH8OyN+EnHSKngETwWyafuRFM2j2oV9nAYlKPWG8gbvbbkecD9WWJsVnTz1RNV/olAApxrWdH1x0b6WL50wnZEtrLtkVVoHxIBS88tR1sLqay+xtkgdsBX5wtQ816+kYpMD0pzi00uG6MYeRItRzlTPRJ1B+9MbWi0xBarG129iJYv1yJA4r9jgAljNS+OtR1gcGBPgL44yLkHhI/iQ6lM1Z4AlgESNAtVc4Iv+qlEJD2nsoJ7Eeb0isGKDZ1QOK6fy+zrOv1vzt2uLQS469dC8hq7oaCigzDLME7ivbVHXHeioNxF6WSwlKYZBrMX7m01p+TNcGVd2j2xwR/s5G/44U+wppEpWXWCRFRPJzPeq9zfxFqOphneWs5xXjWfF7r3Gectze/TnaEmqpQYltwTVk8YhL8/JwjZi09xn3+y40/dP7DW/VARtRd54jzFhhx9U7ZVgA0dOwvu6OwecO+Hi7kWn+8TAQni9qxXUT5lUMkScV4dIthTJFTM6fE7bZGWnzBAz+saGGfvz0rqZNgToNq6Q4IqVWMWmM+NMLVKce0hUxBEDU1Tw4nQAoaWOFznQ=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I recommend `System.Threading.Channels` for high-throughput scenarios.\r\n\r\nIt sounds like you have a lot of very small work items. I've not had problems with TPL handling some pretty significant load; they have some pretty smart partitioning built-in, and you can also [provide your own partitioners](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl) if that isn't sufficient.\r\n\r\nWhile you can always eke out a bit more performance using low-level techniques, this is always true. Hand-tuned assembler would be even faster. You do get higher performance, but *lower* developer productivity when moving from TPL to Thread and from .NET to assembler.","date":"2019-12-10T18:04:38.472Z"}