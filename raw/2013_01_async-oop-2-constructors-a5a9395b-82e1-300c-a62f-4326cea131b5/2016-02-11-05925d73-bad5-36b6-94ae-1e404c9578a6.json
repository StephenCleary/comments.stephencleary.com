{"_id":"05925d73-bad5-36b6-94ae-1e404c9578a6","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"For singletons, I recommend the async factory pattern. So, instead of `public static MyClass Instance()` you could have `public static Task<myclass> InstanceAsync()`. Since your `Initialization` is private, you can just make it `Task<myclass>` instead of `Task`, and return `this` at the end of `InitializeAsync`. Your implementation of `InstanceAsync` then is just `return _instance.Initialization;` (or you can just expose it as an `InstanceTask` property).\r\n\r\nAsyncLazy is a good possibility if you want *lazy*-initialized singletons, but it looks like yours is eagerly initialized.\r\n\r\nRegarding these questions:  \r\n> I would still need an 'await', right? Which would imply another AsyncInitialization?  \r\n> Would it be possible to avoid the 'await' when retrieving the instance? Perhaps by implementing a 'Result' inside AsyncLazy?\r\n\r\nNot easily. The best approach is to go \"async all the way\": [https://msdn.microsoft.com/en-us/magazine/jj991977.aspx](https://msdn.microsoft.com/en-us/magazine/jj991977.aspx)","postId":"2013_01_async-oop-2-constructors-a5a9395b-82e1-300c-a62f-4326cea131b5","replyTo":"00a64f59-50df-3e2e-aadf-f5d0ad69848c","date":"2016-02-11T18:49:43Z","timestamp":1455216583}