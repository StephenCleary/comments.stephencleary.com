{"_id":"0a3789b0-1554-3b14-a017-255ccd42b93b","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Hello, Sam -  \r\n\r\nThe socket classes in the Nito.Async library use the Event-Based Asynchronous Pattern. Part of this pattern is synchronizing the event callbacks with the originating thread. The problem with \"threads without a synchronization context\" is that they don't have a way to synchronize event callbacks.  \r\n\r\nIf you wish to use the Nito socket classes (or any other EBAP-based class) from a child thread, windows service, or console application, then you'll need to provide your own synchronization context for that thread. Nito.Async does provide a class that helps with this: ActionDispatcher. I know there isn't example code (this will be addressed in the next release), but hopefully the docs will get you started.  \r\n\r\nThe idea is that a child thread will call ActionDispatcher.Run to enter a message loop; the thread has a synchronization context as long as it is executing Run(). Other threads (or that same thread) may call ActionDispatcher.QueueAction to queue up work for that thread (i.e., a \"ConnectToServer\" delegate). Any EBAP components used by that thread's queued actions will use its sync context, so all their events end up getting queued in the same way. When it is time for the thread to exit, some thread calls ActionDispatcher.QueueExit, which causes Run to return.  \r\n\r\nNote: ActionDispatcher should not be used by ThreadPool threads.  \r\n\r\nHope this is enough to get you started; if you have any questions, feel free to post to the CodePlex discussions or here.","postId":"2009_01_announcing-release-of-nitoasync-9749f435-6a79-35e6-811e-4ea59bfb7743","replyTo":"","date":"2009-08-07T16:52:20Z","timestamp":1249663940}