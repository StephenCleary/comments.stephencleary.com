[{"_id":"68748ae1-cb91-38e2-af4b-318a0d146258","authorName":"Jeff","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/11213112075138656823","authorUserId":"","authorFallbackAvatar":"","message":"What's the assignment in the Start() method for?  \r\n(\"var unused = instance.Value;\")  \r\n\r\nDoes calling instance.Value trigger the lazy initialization?","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"","date":"2012-08-16T22:11:28Z","timestamp":1345155088},{"_id":"adb967cf-302e-3c8a-8a5c-68495c1be110","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Yes. There are some use cases where you want to start the initialization but won't actually need the result until later.  \r\n\r\nOf course, you can just do \"var unused = myResource.Value;\" yourself, but I think calling a method is cleaner.  \r\n\r\nWhen you read \"Value\", you get back a Task which represents the factory delegate running on a thread pool thread. Accessing the \"Value\" property kicks off the factory delegate (if it's not already running).","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"","date":"2012-08-16T22:46:47Z","timestamp":1345157207},{"_id":"539e6a19-e628-3c46-8354-1804100fdd34","authorName":"Robert","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/05976305300895266292","authorUserId":"","authorFallbackAvatar":"","message":"Thanks! A couple of stray \"span\" tags in the code.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"","date":"2013-07-04T13:28:23Z","timestamp":1372944503},{"_id":"3231f8bd-fb2e-37f4-be45-81aad54cd069","authorName":"Eric Ouellet","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"http://www.blogger.com/profile/14693445246397141501","authorUserId":"","authorFallbackAvatar":"","message":"Very nice! What about a new one with INotifyPropertyChanged to notify when loaded(initialized) :-) !","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"","date":"2014-02-08T02:57:34Z","timestamp":1391828254},{"_id":"756b8c59-40d2-33b0-9876-040f3de51767","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"AsyncLazy is intended for use when your code awaits the asynchronous initialization. If you're doing data binding, use NotifyTaskCompletion instead:  \r\n [https://nitoasyncex.codeplex.com/wikipage?title=NotifyTaskCompletion](https://nitoasyncex.codeplex.com/wikipage?title=NotifyTaskCompletion)  \r\n [http://blog.stephencleary.com/2013/01/async-oop-3-properties.html](http://blog.stephencleary.com/2013/01/async-oop-3-properties.html)","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"","date":"2014-02-08T06:10:46Z","timestamp":1391839846},{"_id":"49f49d89-0fb5-38b1-bd81-84152de24e73","authorName":"dotnetchris","authorEmailEncrypted":"qXZ06zR0/FrbeykkRm2hh1jyBA/QhL9u2IbbK7b22wPdeyofVTtzqN3urWyy7RAjAS5L+H2yXpN0Z8roeaPdksGvitD4oK+LRtjzOF5IQrPHFHLETzEkIHV0cHQveSDjwwC3h2O+Vvt0cHBxMvwR+fwgZ4l5x2etMApFGAmBIlYrEsjR1sKofgT7UTwe7WsHY5n+pN14eZegEDUOv1+5DIIjC9BGTDhHEJC+6B1ntn+GslpwrXjRPuPvs27gzk407f5wPonprY8S83g1yMg1Dnj9+f7yQALHc6Ob6oXhcuF7GNtbKCnGj6PIsTqt+BPHVQx3wijP9SHjI+fDsW4NViMdwg/k9YI3I0PnSXJPiAgKZE2XjxD0bnyG6Bz3AsIbHIxOdjMJb6iWnTL+Jh75V2L8yoGPu95FNZbcmTXnkx319d+hrOh36AyXwL1ePqUKCys0UfBgVrJkVV2xiu+coZj9vPNQhNKdJ8zsa04xhOfSYB70CLflro3RcTwJzXzafFmrzWNFLdTnc3+TRR8L2IzHscgQaQYev9tkEjlDX7XDwa1V2VZZDMRaJeN7tBGyrUANqqaZB3scTdls6EGh9NDRdcnCTF6DaxLUFBjYKwLhhKkQ6PXpxKomMVEiL//E+k0vtcfUV21lvFhQKiw+cxrPyjfjt1NJ08bjUCsBhRc=","authorEmailMD5":"f0e7c2d0d5d83c928cfcfce66928160e","authorUri":"http://www.Marisic.Net/","authorUserId":"disqus:dotnetchris","authorFallbackAvatar":"https://disqus.com/api/users/avatars/dotnetchris.jpg","message":"Yes, the .Value property invocates the lazy, the assignment isn't specifically necessary.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"68748ae1-cb91-38e2-af4b-318a0d146258","date":"2015-06-02T18:25:39Z","timestamp":1433269539},{"_id":"71b4b46b-fec3-36c9-9dad-5bef347b3ebc","authorName":"dotnetchris","authorEmailEncrypted":"Q2cm5TXpD7ofrMMuxY/vFtBa5GlalokQfy/fflJ7RBOa32h8b0WiRus5Uo8qPKnptTfg8RqIQ8ftUKYlv/pHYNYm7FkeImRU4HaM1Cwyh4cOodE+4g9MA9TV5imuXbWJSQMX4mct42hH8m9cuRbmTqtOX1lbQk7rX/RrFJpYIwm7hg+IfiLlsq21lDZaa3VB8rBrEVVLe93nNAWZGh1YtUgXWhUI0n7K8XV0ooelTHgZPr8El4yHrDkWGZdt/jORB0K7jJfZhskZgVF1ZfPBAsPcgdJJbO1a8Hkszw4QJ3NxIMlvc+x4MJ7gpM31jgh7C3Tx7XXq4KVE6fRQ8sKGLKdcAaXp41mw5XZD9HGJ7AOvhfmGNWgckNb/QRC8rjtRfyIEgI4jANyDvBSnz3Aex4fEXsh9bwwGVwJVHwc5vHXEsBd1TxN8rWWG1Ti9lQf/Y3NviVYModTT+r2W2bOSYCnMTsSQK31O9/lK0TptLPc2Pxmn5WY6oDvYZ+LT02M3a8eHdZZPOGRWd3zHtAskB5bobhAJsm89qTHlUg7TihIU9q2JwOIY36/r9w+iQS52Xos5QDr2fxyD9LF4KpBBpoSBHkR+zOh2I0LuvfRqrK1MbEutSK6PQEhvWvrFggLU40QfmkukAU54dpkEYLKPQcabEeIAuz84t0nDo1/BRs0=","authorEmailMD5":"f0e7c2d0d5d83c928cfcfce66928160e","authorUri":"http://www.Marisic.Net/","authorUserId":"disqus:dotnetchris","authorFallbackAvatar":"https://disqus.com/api/users/avatars/dotnetchris.jpg","message":"Fair point about the AggregateException. This usage would be under a console application or windows service. If this was ever executed under ASP.NET or WPF it would need to be outside of the request context or UI worker thread as the application would be in an undefined state prior to the completion of the Lazy. If a UI thread or request thread tried to access the Result prior to completion i would expect to either block or return some kind of not ready error perhaps time out based.\r\n\r\nCreateFoo() will take approximately 10 minutes to run during which there's nothing else for the application to do, but the internals of CreateFoo are massively concurrent. CreateFoo spawns somewhere on the order of 50 threads all returning back to the single thread.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"e654d7aa-fca5-388a-ad25-d87cb5db5b34","date":"2015-06-02T19:07:10Z","timestamp":1433272030},{"_id":"7a589abc-e0ca-3fd2-ae55-8f89434bfef4","authorName":"dotnetchris","authorEmailEncrypted":"VR8jdPQvoBsa8HJ5peuqd7D/MCZH7fmZr7Lf+WBxD1w4WEoYopBZjEPsU6TVxsBWFHH3JECfE4dVFTf0m7pMBcmtw7Us+sdVxlrJd4ZTDlm4ClU+szz2jkkjQHncANMKamY2+YlFUPmDo5D8kVtoEmJdlgViOvNjnqLDNYCFLFz8YPAa78bxtthbu4sLRby852FFPVNCQUmL1XQo1N+45pfoyf4EO373Or0hYu+TScfi8xuyJL2owxsPNSmjKq5Ia08TMEWq9CJyE40tHaWI+NVOxfhT7DJazonz6RX9b/i8q4FWuSahr0cq6q3apKb2x1V3GYqMOBiXLT36tzKK+1ciL6f7J591s5KRJLHG0O1khDig3heKco5xIQnJjkAbaBYJywe3oENyQkVTfSx39jZuBdJM2yOFUhG3xhjnahYojwcuL91SliMES82BR+/07EMQtygcvS8exBvcovFo+0UHQkJ7zAj3ynlABlRxkgTYK965xgEIvlEntKbvW4t1I3aX3SdCDww7kI0nA7tXfdKQrSCXCjC+3KrgLHAIULWTNqug7lS3C26ql1PoREoSglbhKBC+BXf7PjV8KqNGwnXj4YPKZcoiQzhDmMeN3sP8EqGB2II/ElgAEZSNmWhEpbL/ysP5kQDMo0h15FoueBsyiMLbNeXOa3UDqIBP7qQ=","authorEmailMD5":"f0e7c2d0d5d83c928cfcfce66928160e","authorUri":"http://www.Marisic.Net/","authorUserId":"disqus:dotnetchris","authorFallbackAvatar":"https://disqus.com/api/users/avatars/dotnetchris.jpg","message":"Are there any pitfalls to doing:\r\n\r\n``","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"","date":"2015-06-02T18:15:16Z","timestamp":1433268916},{"_id":"e654d7aa-fca5-388a-ad25-d87cb5db5b34","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"There's a few pitfalls.\r\n\r\nFirst, Result will wrap exceptions in an AggregateException. This is easily avoided by using GetAwaiter().GetResult() instead of Result.\r\n\r\nNext, the AsyncLazy<t> will complete the Lazy factory in a very short amount of time; it is only locked while creating the Task<t>. Then all awaiters that consume the AsyncLazy<t> share the same underlying Task<t>. A plain Lazy<t> will (synchronously) block all callers until FooCreate completes.\r\n\r\nFinally, you inherit all the downfalls of performing sync-over-async. For example, this can easily cause deadlocks if called from UI or ASP.NET request contexts.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"7a589abc-e0ca-3fd2-ae55-8f89434bfef4","date":"2015-06-02T18:33:02Z","timestamp":1433269982},{"_id":"41c3203e-fddc-3d39-b306-212c781fec93","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"In that case, you certainly could use blocking. AsyncLazy is intended for situations where (possibly multiple) consumers want to wait for the single resource asynchronously. If they need to wait synchronously, Lazy is a better choice.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"71b4b46b-fec3-36c9-9dad-5bef347b3ebc","date":"2015-06-03T01:37:03Z","timestamp":1433295423},{"_id":"871af978-4bc3-33cb-a365-646b48bc306f","authorName":"dotnetchris","authorEmailEncrypted":"oM2g7TfzMaQqacSVK4m5UQ1s+afy95JNySjhlhmg/7eNc5ejMyiZknkhJjGjJLno0WUd+FEaOBl7lC7AKMeOETzxXpCN+ApjoZ1HM8uH9jfMr1iHr7a0KwzUMlEjUco8FUldbKGCEwz22LdPqPake73PxRzohCudYG50KN6neqz1szW3iY5o0fyMEQIyehBPC6caJOVeYtS16d9wZK+V7v/x0BeGDOA55u9awNEV8gebsKGCIpjCN5m7m63wDS39MJuulgy7smWpjWO5jR/dUTje+DaJA2BEzhI9WYnqz2fUu/YfZWDkkuYeD9hlp4qf7h8N6ApBqbaO0oYfyBwfrBLq7l+97GMgek0k7N+3CscodQiScSUgVSrkFciJHNCDGicbbGERxWsFnyg1O1vFmfkXv2wm5W3wkhXVvE5kfaQtx/FDOIoLG6M2vPOeE7AP2NFusBNqLBcQkDcegLMA5A8Dm267zuQDBgpBZ6drSQIlBdmOqOqKKF4HZUpFWyy+3TNSgeX6Mbkj+JHVrdIAy76GEYJYpSiE1fUmCDFP23j6ibxrQBmfggKflip8W9HM/0knYag2nVbZWKx/y4JQ1JrCcll8OE1ccUzIuuDGuJQQEmyq9DEjaRZxUHYfHtPZxW91o5gBj1gMYBF5UXgxJN2/fzpp6/VqYTWiZ84K408=","authorEmailMD5":"f0e7c2d0d5d83c928cfcfce66928160e","authorUri":"http://www.Marisic.Net/","authorUserId":"disqus:dotnetchris","authorFallbackAvatar":"https://disqus.com/api/users/avatars/dotnetchris.jpg","message":"Thanks alot for your input, also great work on your book. Of course one of the times I really wanted to double check it i have it at home 1000 miles away from the office.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"41c3203e-fddc-3d39-b306-212c781fec93","date":"2015-06-03T15:01:01Z","timestamp":1433343661},{"_id":"7ca88b7e-62da-3b91-bf66-28346cf67748","authorName":"Morten Hartlev Lindhart","authorEmailEncrypted":"dbdSs+xsQjpRgBak3bI81WEA75Wy++URaE0L8Ifxk18+vFmpD9bm/mO9DIaYAu8JLJwCH+rs2ogZWhTfwWmxMMC0SBVRkG8RTXD6cl4Wkug526pe8b6mNtteu6CXVwKIO+p+g88DdezTl8q9uAdjsyZ4H9/qN2az0HMHZHSwjeA/QfO3HYHxs2hM7wPfHt+bRo5skXgxuTn85jdjtkNs/V6NZFePNYF94Kh8OPDcWN7v/3SCfrKJWtG3LAE2wbNP9YsYP8glqoddAT4GBEnRQbfq+4/0Z+xOqxp7knO4175yDm6w8tVvhJ/m1R4mDYkCImre4apoq2LEj7XBYOXvV9ebCOapYWIiBK111Z0/AOG2nFRo0ic5zaPWsdGeNNwGuo6zpUApIJsofobvR9bQJRiyJtPSHhoEPzqvShOMZ1HPsgSYgVmQB1v6LBAa2ISf+xINEKc22pd3CG2WTwUmKCbKkHYmDnjqG6RTeV02gWLmJWQyYLt6eYRdtOqyqMgIKnx5EGPylJsvDISlO+r6CVrfD0xKYpCen9CT33kshjw0EdRBjY/SGZUGw8eQ2ktXL1dSKz5aKuSKpEr9X5x9oSsHBt97q3pNB01RQjWFBzHP5rY2qPoXlnOe6VY6x/I8ydtU93nV9VhUw62fWmwKIXZjyv/3dx0zD0KOuxDdp4g=","authorEmailMD5":"cc0ee0e44f61f25ee49857e1cd93e00a","authorUri":"","authorUserId":"disqus:mortenhartlevlindhart","authorFallbackAvatar":"","message":"I'm a bit uncertain to why Task.Run is used, since this uses a new thread. Wouldn't the \"right\" async-await pattern try to avoid that?\r\n\r\nThere probably is a very good reason which I would like to know as to why the following constructor isn't there:  \r\n/// <summary>  \r\n/// Initializes a new instance of the <see cref=\"AsyncLazy&lt;T&gt;\"/> class.  \r\n/// </summary>  \r\n/// <param name=\"factory\">The asynchronous delegate that is invoked to produce the value when it is needed.</param>  \r\npublic AsyncLazy(Func<task<t>> factory)  \r\n{  \r\ninstance = new Lazy<task<t>>(factory);  \r\n}","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"","date":"2016-10-31T12:44:42Z","timestamp":1477917882},{"_id":"97856346-5792-3560-834b-4e777b86c1f4","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The Task.Run is just for consistency. In many cases of lazy initialization, the factory function could be invoked from different contexts. This *could* create a race condition in some scenarios where the factory function may run on the UI thread *sometimes*, or on one of several ASP.NET contexts. To keep the context predictable, it is always run on a thread pool thread.\r\n\r\nHowever, this is not always desirable either. So the current version of AsyncLazy<t> ( [https://github.com/StephenCleary/AsyncEx.Coordination/blob/master/src/Nito.AsyncEx.Coordination/AsyncLazy.cs](https://github.com/StephenCleary/AsyncEx.Coordination/blob/master/src/Nito.AsyncEx.Coordination/AsyncLazy.cs) ) takes a flag argument that allows you to skip the Task.Run call.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"7ca88b7e-62da-3b91-bf66-28346cf67748","date":"2016-10-31T13:13:50Z","timestamp":1477919630},{"_id":"902dcb3a-8935-3d8a-90b3-76917704e4f6","authorName":"Anthony","authorEmailEncrypted":"tTigzIC50Lie8toQ024Yc2uch5k3oAbFudOvtP2/aD+Y4pnI0V/0TgInbbsOYqcK4eDMOsrKaBRKrJbwfy3fSU2DVNm+Y4C2DuqizFPYz6BfdrBzqVSDU1FMqXSZtFKlUDw7O4jQWBOPKl8pSwhGBMurmUu5rFAuSoEUvAvQOr1uF0BZlEnKMWkPPd/Bc0fGwSt9G6KA05IQnzJ7n159VuIikH6smMizfFpZ647ttlAM/rd0Wv4d3mIqAdNuqfR00CyeWDmaRiNtygCQVxUW9CV5zZ09CIv4t/ibruDgIW0p2o3ZxYowP66z9CTxpjHO3dLeKbjQkXGSC8RCNbeXqGIi2P0VF+CBRQNXM/uNxyBoejWmcoqkPRvIqqoWQWnXQn42v5sKNccmRuBYMgQKPzboQ8lwSaiz1+QFCjgsnnIA2LzFMwtfoZjjWeH5OMePQr5JEa8rjct7plGCF7bFUMZJwH5rstvgRHrkld9boM87KhGjv9AnS0aZWbmnh4BdeaR/HLnkPaxmJ+2SIVQww8Z5NQNeiZTTTPvulrQ6FpdPpoQtlQlE8/GvlsdolkgNvPo5KzmfLSBaO8S5X9hHFkZWmGnVMmvgQ9b5tpQN3LsS+YvcXR2qQDcQFJArtbflsUDdzXWB0NnNKDSbyyxUVUqg8I74XBtBSs61o1VrYW4=","authorEmailMD5":"93a2fb94cec652062074c28dacadf2fc","authorUri":"","authorUserId":"disqus:ahocquet","authorFallbackAvatar":"","message":"In the most recent version of your code, there is a mutex to manage concurrent access to the lazy instance. Why so? Isn't Lazy type supposed to be thread safe?","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"","date":"2017-03-12T20:27:54Z","timestamp":1489350474},{"_id":"8480e4a3-c37b-3ce7-97d0-789d2e76359d","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"The most recent version added a flag to only \"save\" successful initialization attempts. So the Lazy instance itself must be replaced if it fails.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"902dcb3a-8935-3d8a-90b3-76917704e4f6","date":"2017-03-13T13:38:05Z","timestamp":1489412285},{"_id":"3a872801-35a7-3a73-8dd9-f0bc420fa8c2","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"If you *never* want to have a null return value, then you'll have to handle retries and whatnot inside your factory method.\r\n\r\nIf you want a single null return value but then have that mean \"recompute this next time\", then there isn't a way to support that - yet. I'm working on it: [https://github.com/StephenCleary/AsyncEx/issues/91](https://github.com/StephenCleary/AsyncEx/issues/91)\r\n\r\nIn the meantime, you could throw an exception from your factory method instead of returning null (and have your consuming code catch the exception and treat that as a null), and use AsyncLazyFlags.RetryOnFailure.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"7842025c-1d44-3d38-8463-36acc819cb57","date":"2017-05-29T14:47:23Z","timestamp":1496069243},{"_id":"7842025c-1d44-3d38-8463-36acc819cb57","authorName":"BastiS","authorEmailEncrypted":"JyuoMgr4q1FsD4CgAKS7dl+L+Yf7/xafwT0ljNOFJs2cv+fgDe0aH+fE41UgJEZmu/AwjzHay/Y9vbQ51YJpgCAVh90RsMJGx6g6BCO3qJQUAW8SO0wioCTQLmfO2Ahozf3/iB/m1n6Ggz/Taz23UsgZZOo79n/lwZg/CcITA4GYlVvIKx6Z94DaolUF1XtXoeGfCXjsjx+36WRnElOv65hJF+8rr4z+/r9ynL1jwSmedzD6vGqLwuTPOxJVXfz39D5xLKGDk+itBRAChmP473ps8LdnBB/2Cuz9O4r8Rp5eXvPH5FNowFBHRRWyXqnTVUFDzf8QgWFm6cMNYhun3ukJ3cv9xsaoOCvoPu6UW5eybAHDfrDAhQcB9DLyecHMNVx++dqWrCc/2nRFjG0G9srcTL/C3VJE8o7TGExuaNDfnDEtyVhLyR+iEloUwyUWwMCHy8xgYf1jqTaQDmifWO+VW3de4rS/gBnpEFmAxygOyD26jyRJbQFemWC6zaxGACokjoms2HaHZxynholjwdNnqIXHpQQyfovRII2+kjAwivbTQJSrKaUaIR5pYz8GC7E4QYVdXcYLHvU0JThHnfsANumnQnknRMeJXccMe3Fy2MDKf4UW9tqPXcO3ILMPI4lHwwifqjG+0hZegdWBJTog0E384W6Dr9jjQDDX+zs=","authorEmailMD5":"871743a29f2406548acaa83c1722a81d","authorUri":"","authorUserId":"disqus:disqus_NhGpW5t85b","authorFallbackAvatar":"","message":"What do I need to change to run the function again when the property is queried and the return value was null? I do not want to accept null values.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"","date":"2017-05-29T10:54:37Z","timestamp":1496055277},{"_id":"10b8ad1b-4261-3eeb-b228-25aa19d7c7b7","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"Ah, yes. AsyncEx 4.x supports PCLs, but AsyncEx 5.x only supports netstandard (and those flags were added in 5.0).\r\n\r\nEventually, this will resolve itself. Microsoft will update the Visual Studio tooling (hopefully this year) so that AsyncEx 5.0 will work with (some) PCLs.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"f30915a3-0d33-3a62-8105-cb8e8ef0c4f9","date":"2017-05-31T12:13:54Z","timestamp":1496232834},{"_id":"f30915a3-0d33-3a62-8105-cb8e8ef0c4f9","authorName":"BastiS","authorEmailEncrypted":"av6vOiQTUIMJvmoNMcINsNFM3vgLffbyS5XlaZ9H3s33noY1igI0m32k7TUvdvJZY+NY667dNGlXpG7tbfaZtGyLKtRAKAreHIADVzM9t0XjrO7if9UytsIHckmJ8Vq/sbg24n54c0HTmue6dBz7M0Re3QOexZS+yZrcZOWTzYavNo5i5P6WgUJycrGfYhTv6lUYE6Tviqu2IWuobibOdzIOfjUz5t8cpP8HRMcfuh/PzENYIvClnrcsAGj7yQkSY9+JZLSsoeqeVvmn2lAf8MMG8a+RzvZpzl+zW5igs1JwUQ0l3LwOGueP1y8csskQi293uhY1+/PgGIxud18casEQLzg75UhB2QVIW9cTi5Pqp24PCdCGJJacTuwOpB90eQYK0aluIW46XvPI+ZHG9Yw56dssUnDkO1xCqp8ZH+Lcf99Lq68dMoBpobFL9M/XNaLjcf9RZf8Iwap9Ovrg0wadtGgEWkXIXLG94oeTVYklgVWMoiqvoksP7vzZUyZQcMQ2R3Je4uCx2oh81m2qFascA/Sz1cQhOXHx+ptk8ePHkrg2Ak9qHiL/DXoFEYBy4iXD9GdMJhwS+jQOmsYm/unhryZ7knr5CoqZSbTdeyPzuXZnPOVml1zufFng+3njIUVSsxic5+F/chDskDuvpetPCmhzehqTLBIklIQOGMk=","authorEmailMD5":"871743a29f2406548acaa83c1722a81d","authorUri":"","authorUserId":"disqus:disqus_NhGpW5t85b","authorFallbackAvatar":"","message":"Thank you for your quick answer. Since I use the above code in a PCL, I can not install the Nuget package Nito.AsyncEx and therefore have no AsyncLazyFlags.   \r\nI will try to get the necessary code from your git repository.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"3a872801-35a7-3a73-8dd9-f0bc420fa8c2","date":"2017-05-31T10:35:58Z","timestamp":1496226958},{"_id":"072b6467-5adc-3582-b275-3c20ce884f5c","authorName":"Stephen Cleary","authorEmailEncrypted":"","authorEmailMD5":"3db7b6e14d9da42751e4bab03bc4d034","authorUri":"https://stephencleary.com/","authorUserId":"","authorFallbackAvatar":"","message":"`lock` includes a spinlock, so it only blocks (and thus only does limited pumping) when there's contention on the Lazy instance. So, unless you've got contention (e.g., a bunch of threads accessing the AsyncLazy for the first time simultaneously), it shouldn't be a problem.","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"7646841b-dba3-3259-8efb-715bfbeef7a0","date":"2018-02-28T18:36:09Z","timestamp":1519842969},{"_id":"7646841b-dba3-3259-8efb-715bfbeef7a0","authorName":"Nathan Phillip Brink","authorEmailEncrypted":"N0KYSEsdoKSrLjjjJtv5/2ACjYk7ioL0qW3lM/oxOSQOG49TKMpa8d+J2v4kbu61MV9mLi2MzyQhoS1kr9kFVqo2wirDIdear9GHAhzihD6jvSqoULX88G69BOaYCA1BiXaOkIacSL9u84gsqvuJrrpiYFnrz7s3p1lDNKr/8oxvm+XpqB9iClg+r8Hn2tQIkjdVdpcYh/N/xuGSN/oggD/stSZpJDKqTlnlJjzF91HSxcsDMK5PVFPm4QbIgKk/Jm/NTtFg7Sw3KKDwT7nAAEQ9/gs9vh9aR3Dkvrhec3/RmMRlvo6diHKbxEeCp91QU6fWTcHbpqADPukV8+UNJ6zPlXeRLpRYtfTq5ChfHIUpqrG866IZSwPrN5p/U0LlTbUx4tfffcI+vc5szoh18QNEfU0kF7T6aZBXVsULtnVz+Py+mf7/VwncO5OnP7xE6RJPMq2IekCUWGOtqd3cT7YPrRT5o+CWd+UHqJEsEHwDyFOKuTPmDDJjg9GwNuffAgJFFlNbo2eOg5BkhbC0moKQUActTNv4HqWGdSDKLM65la1O2ydq4mQYUGSuSS3p5MjwBpfmLD8kMu7vKNM7ublCYnY9B8lRQ0Uhm9ZHU3lxPiY3OiB2JIZkvZgVu1wP5pKiFLL6PR6Obk568FoBdCKjsn2POeHHRKcIW8FswI8=","authorEmailMD5":"a8defe14b1c80bc2bd59a1fab3848cfb","authorUri":"http://ohnopublishing.net/~ohnobinki/","authorUserId":"disqus:ohnobinki","authorFallbackAvatar":"https://disqus.com/api/users/avatars/ohnobinki.jpg","message":"Could the necessary synchronization be achieved with something like `Interlocked.CompareExchange()` (only replacing if the _instance matches the value it had at invocation) instead? lock(){} is “alertable” and can cause issues when accessed from a GUI thread: [https://stackoverflow.com/q/8431221/429091](https://stackoverflow.com/q/8431221/429091) (yes, I'm still using winforms, and I recently refactored something from using lock() to using Task+SynchronizationContext just to avoid the slowdown described by that SO question. Also, I’m still using an old enough version of AsyncEx that it doesn’t have that lock(){} in it yet—and I don’t need the feature it supports, so I guess I could just avoid updating too ;-)).","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","replyTo":"8480e4a3-c37b-3ce7-97d0-789d2e76359d","date":"2018-02-28T17:57:55Z","timestamp":1519840675},{"_id":"eb212030-e40b-11e8-8d83-dfd41e9d7292","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","postUri":"https://blog.stephencleary.com/2012/08/asynchronous-lazy-initialization.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"","authorUri":"","message":"If you call `Start()` but then never access `Task`, could this result in an `TaskScheduler.UnobservedTaskException` that tears down the application on .NET Framework 4.0 if the function errors?","date":"2018-11-09T10:40:47.974Z"},{"_id":"f2729df0-e429-11e8-8d83-dfd41e9d7292","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","postUri":"https://blog.stephencleary.com/2012/08/asynchronous-lazy-initialization.html","replyTo":"eb212030-e40b-11e8-8d83-dfd41e9d7292","authorEmailEncrypted":"MxKShCqlarVf7qm3aHYq9K0XTBj+uoP89AqMoeB0hSHxg6IMbSnxqWhC17pX3K2Qj/wGF4Ib4a2F4DxFr7UYM7LmQchZEceShqwqEZu/R2eYZvRfax6sERIK8nTBD4nBr4+LvkqrsH52haPN/2/t5vo22E4T2tRv5xrFWJ0tF0+v4MurTo6zjhm9CTMmjNslCZ8GdCEi5wutxbPQH33v9cUf+5IonsMcI2a8MB4YwMJ/63A54kcSBsfBxwElTzwH9ikErKtpYtCD3H0cfj8/U0cEIW0K8M2W8yMjV82xCZUur62jIcMnDqaZv+Bfl5zZW+Le4ds4rF8wehF/ZmMS4Feq/SLa4Z/IUbCtx5j4E+iaHLKsX534WhKLDtHXp+LS0ELE5RZW+wrJcrmaxTrYsIQYEbViD03HYvZp1p7xdoE9/wklqa2A6UgsrjmztQYvXv3rSH3GnVZ/CB7tk8TfOn7llTH6E+s2oEkxivMABsglccrLdsGk14m31ElwnTF0S//Qvgd3HaWxWSGL21in8cona/16zvtMSRJuJKrULmPGnMkftrdcYmk6r9XA5E2FzH5gonSgJufzZ2WGcFh7gpVeo7ZKDZhqfOJ9cyVN3H22g0XzqIJ9VS4fw+jYn2V4Op83kAyqE+lWpF8mJifhbHTcpV639GHqhZrdtSZMLc0=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Technically yes, but several things have to conspire for that to happen:\r\n- The code in the task delegate must throw an uncaught exception.\r\n- The `Task` must be garbage collected.\r\n- The runtime environment must be .NET Framework 4.0. If any newer version is installed, then the newer behavior takes effect and the exception does not terminate the process.","date":"2018-11-09T14:15:45.245Z"},{"_id":"94bdde50-a70f-11e9-b721-3daf964aec70","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","postUri":"https://blog.stephencleary.com/2012/08/asynchronous-lazy-initialization.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Rory","authorUri":"","message":"Hi Stephen, what about cancellation?  I'm trying to figure out the best way to use this approach so the underlying async operation can be cancelled during the await call.","date":"2019-07-15T14:48:17.900Z"},{"_id":"a2a1d9f0-a727-11e9-b721-3daf964aec70","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","postUri":"https://blog.stephencleary.com/2012/08/asynchronous-lazy-initialization.html","replyTo":"94bdde50-a70f-11e9-b721-3daf964aec70","authorEmailEncrypted":"HMlTgaC3+p69EKBx5fhlTMxNGj6TVjXV4bMluyBdVHLrrATOl6r3uEG3q8y2/KZU3UNdQDjukEOSza3UBjpA6X12FVWZm+b0/v1j8f/dGKollzMV0Wh5GPpInfbvADBpJyvCxGhCA5JG2tpNHzG/BZJb7k7YvvsEn+20lEf49bkWnE2Zjv4UdDXKZMXEaR8xKWrskcJm2DKBjhVjGDspxp3vOUGTTqnmclx7nbDe2CQObttglc66Wt2mnoqDbtTh1irU95sk751mP1tgidqHuzbb+Y4Ucgez+f332qalfQYjWuQSEhKHX1TLmFbFdirI6ykACHM23mct2l8wB3rMe7NDS/n2rEig/BCXf9nx1ZBvuHdIju/Tfz7AXJnkqUC+h5SqnM4zLZZ/F+zPGyR8FWStbpwjl663hsUGi2lOYRKmrMS0a7KP3MdYi/nnUS9zcZMxnWKM7+a548ipLYfgdnJbu7nOCcbvMkKjoJoqtDuzThPUyPwiMc3kNEiEw18coacIJhnLMU9x+aq0bU9EbdT7D9M8aUYq2LRZF+Jz5ICkiTlPqLDMdqGhWQw/XA8k0vSVwHPpB/TQZ/TqoUsd3Nf5By+xMXGRGEJ0zu6YxPUd/D5qL6u1oCfFt3HlKxXnEioYjZtQXFbjDzToTOqQTdSzzOEI1vIuRHl14QnHBl0=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I'm trying to imagine how you would want cancellation of an `AsyncLazy<T>` to work. Would each `await`er supply its own cancellation token? Or would there be a single external cancellation source?\r\n\r\nEither way, you can cancel the delegate passed to `AsyncLazy<T>` just like you could any other asynchronous code. If you do cancel an `AsyncLazy<T>`, you would probably want to use the [`RetryOnFailure` flag](https://github.com/StephenCleary/AsyncEx/blob/76b27a3ee531554c0c81e55ab8425ac7caefaccb/src/Nito.AsyncEx.Coordination/AsyncLazy.cs#L27).","date":"2019-07-15T17:40:29.247Z"},{"_id":"30c30b80-87e9-11ea-b2b6-7d872f40276c","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","postUri":"https://blog.stephencleary.com/2012/08/asynchronous-lazy-initialization.html","replyTo":"e5e533a0-87e7-11ea-b2b6-7d872f40276c","authorEmailEncrypted":"SXO21V24eJQQy3rTtLv7+V4TnjpyFXxgDj/mano+Wts7/7MRCDcz9zOcb40l1EF0TPqmLohjjLNr6jzVQB9b32fE5nliZjawdOVMJ0y7xhU+yy6a+n9zEcAdl7AAniiQL01DUYLB+1hnLF8rh6xHZCUB8z96RduJsDmOINUhkHNP+ziInSFcCgMf0tYBNDv43x9Rm+Hz2dUeCMpuxJXBohZG+e/2aSJo0WeW/5dDw/3UiUD6DexV4Pgr8sf5RGpOVXDKYxhecx+LD+v7AndD5ZL+qqyshScjGAz4pAebBX7OPvdERenW0oa32nBAfmTJ33umx+xi+gl1jE6Axzr1XvxeI8XHTC9xpekDlOwxNlYVBjUztzvVItRWm18eFkWyHTrcFNHLAGr3lYsd/mqr2nIg38/bhGpi+ruoeW3s9rJkHJjNdGmV93EUQnAkhfoqxcJEWJYU9s3EmQPFh+0gHN46GBvOxTSKWQqUzHD5df1106vHKybH1mM86mcL63sPCqby0d/+9Lx9kKsCfOA8LpPsUT1GU2UrhvTVowFtI3IP3ZGrVrk7btfjpfwvX+rbGr2o5/dP62q1BbIAyHmfRlCLMgOiyGGRAoYO+7uR2zoR6todG4zPyXPSVwAzFhnYuzSbqNUh8JLWojDOeZGSxRU4nUDd7j+WE5hY2q45Db8=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"I'm not sure what you mean. `Func<T>` is provided by the BCL, not a NuGet package.","date":"2020-04-26T18:10:20.512Z"},{"_id":"e5e533a0-87e7-11ea-b2b6-7d872f40276c","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","postUri":"https://blog.stephencleary.com/2012/08/asynchronous-lazy-initialization.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Nemanja","authorUri":"","message":"The `Func<T>` constructor is missing in the NuGet Package. What do you suggest for those scenarios?","date":"2020-04-26T18:01:05.517Z"},{"_id":"f3fdd5d0-87e9-11ea-b2b6-7d872f40276c","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","postUri":"https://blog.stephencleary.com/2012/08/asynchronous-lazy-initialization.html","replyTo":"30c30b80-87e9-11ea-b2b6-7d872f40276c","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"Nemanja","authorUri":"","message":"`public AsyncLazy(Func<T> factory)\r\n    {\r\n        instance = new Lazy<Task<T>>(() => Task.Run(factory));\r\n    }`<br/>\r\nThis constructor from the example in the blog post is not available in the AsyncEx NuGet package, only this one: <br/>`public AsyncLazy(Func<Task<T>> factory)`","date":"2020-04-26T18:15:48.064Z"},{"_id":"4327e070-8866-11ea-9ac8-a9797f246b9e","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","postUri":"https://blog.stephencleary.com/2012/08/asynchronous-lazy-initialization.html","replyTo":"f3fdd5d0-87e9-11ea-b2b6-7d872f40276c","authorEmailEncrypted":"YKCVf209zO2R2B9opAwqZXIP2i7oD7hDq4sWlWQVBLpofmVcn+jzNKCn2rzTu8QsAcCbu+Rg+Md/sqi09YpvVlF0Ni1sIjNzyv493kK0hKg7gBmfko4mVCFXQFDIT+koe9bMiQbN788gsaeRbZcT67x/V02HMwo0wpCY0kIkULL8lH5iaN8lqkYL//yXl9BP2Cd0bmZBLO+K4Zhf9EH0t7SdMgXhcjQq6Fvj4Yur23IDvE0xga5LAKSm8FVgJnnRSPwIoNbX56dsHUq+n+Oc/rNfU6aDmtWlhChIf7x1VAnaIFSPVotKhHrjN/6UyCUXou8NYQJHwLqpXvgZ4u9brORLYK4/V4OnOEOqHed+zfmb+6C3FI6fmSVBee9Ok6vOdrAYE7sJnTqft+COaIetNnbRzrBeTcp2y57vK1qxWBjDqNLTxhqKF8TtvA+exP1rvaC3eUzANlLqiEJtDfIUBWm4IecqPwU3pxZLDODX0tWt94HR54KrYZF7djo77CLPuTPC8ztdGYGVQylJ+vVH5YBqhC4dHkgp03JLOiioKpwafdtWjYqiIDd0vzeTngyC5nc10HZvA7mXPAVLwIUrxWWi/hz1Z/sAkz7NfN6Jjjmfj8jj9olET17TVI0L0hdg5yzQ7SiWCsU1th2tAlZMiYqVHkiE9KwZ5Nv69FcSGpM=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Ah, I see what you mean.\r\n\r\nYes, that constructor is not available in the library. I felt it didn't make sufficient sense for an *asynchronous* lazy to take a synchronous delegate. You can still get the same behavior by wrapping your `Func<T>` in a `Task.Run`.","date":"2020-04-27T09:05:38.526Z"},{"_id":"e3b95250-96e2-11ea-b16b-496d2f20f240","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","postUri":"https://blog.stephencleary.com/2012/08/asynchronous-lazy-initialization.html","replyTo":"","authorEmailEncrypted":"oX6b15LXRSPK1x1DugLI288akMPH6jH6YKrvSpCO/r9dOA/R1SDaWyeQLQw++F8ddpUdv3G11uixZLrxjesSpWpHGFQSHW1NLJVj59BUuZYrota1nT93yD8PytEr42hqS1odT2ezZMfauQD7TiFEElPywF+G9ELP0neFQJWbcrkQDqNnzL3evcokWv/wTzdjxjCQHilF/YC7I4F/NY1042QngkoDzIsgCO72SYHmPQbLWsPX2i9ArGiaegOtqRnto5Et6nucx/Oyg1wSb+CIzhw93wiV6zV1KF+MPM+6deGVQGm4vTETv8DgOFSiSws1PL5oAZWgCA4gz6UPKvwQ96Govsj9VgGApDsgWBLPxrmh225iOQ+mNJYjKD9C5l+lsQLj9aZCToFrB8x/q/lz1pTlSA0g4jppQtaQ9HUlkYUIDZdvEG7GZ28M9tpwAKEg86YfPXQuYVlvvNmzViyoTFajesbRyBpcVMg3xV8LKsxUy+jo3//zOfdPmp6EZxaxg6Vqb8ly6p6uapMe+zOecnYTqhMqW8lXRnQOx/SuIQe9Gbc3n6+QzHRIHBW4yZ4WXnYrSEIL24UdNf6NHJI4Wpzo31yPbp5ydXGZEHS0hvk4QtCKLQ2xIrFYJys8rsJVoyCBJVcGEvnu+kt0xVOBPxknbWg+Z96vVRrKmtQ8UB4=","authorEmailMD5":"c315f0c5bd7b1dca88c9d6070d4f873d","authorName":"Dmytro Kontsevoy","authorUri":"","message":"What about factory with input parameters, like Func&lt;T1, T2, Task&lt;TResult&gt;&gt;? Should I use Task.Factory.StartNew for that, function is not longruning and actually not require a new thread?","date":"2020-05-15T19:33:01.884Z"},{"_id":"c5714070-9721-11ea-aaef-318665cfb908","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","postUri":"https://blog.stephencleary.com/2012/08/asynchronous-lazy-initialization.html","replyTo":"e3b95250-96e2-11ea-b16b-496d2f20f240","authorEmailEncrypted":"qw/3vGdA708NY0gsVOQhm47SlPn50TQaIDmKGFVdnPhzq6v4tYLOuENz5lu8aoauLEdlriclGtwUgWZxvxlcIx5+d9uLtYx6HfwjLyweK/haGWKtp7mj52Hv/U59nur3XLWXlvXe5aMKRnqU45LuexwrvnzgFfyIQPekWHwjK2AR8euqcWW3q94X/6Sov+TWW3x035LP3eN6ZyCdjHO+sZuSdVBxYR9Z5JQ2bR1EKOiy/YDRcglACLpt7R2PqiFQsZpJOHSOQh3zDfNRzJfiCNOCsQaAvcyhYAfxl6YGw8G7BGoHlL9lMi63WHTaebLoQgzgnjZIEhY++YY1uBKcqECtPt688dnzEtZoQWGJow2QEWgy8vOW8cmpCkhe31I+mBtuH9NqGaAq3k4xMK8zmi4ro/1RHHhGf8emsY3KWOOYHgpCVBxWqZospbrLV/9LABBWh6EfbSqDObApLKFAOV2JhApB4EIjkCiYF/slKHoT4IxZ14Pb1mnSTkjd/M4QRb4lKWXHx16zy+FMzD1/cEiR6/HqKRTx79iILCuVzOvOolXMlHOg7ETH4QPeJxvGtuP8YDqZKyVrxL3iwqxqU7u7GkEzHRw6v7zmkQYv0pB06GJd9EHWHf79GkexlWs4SRf0NlFM8boeApvZjZiArV96Y2H/wE8tHD83aR/4W0c=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"[You wouldn't want to use `StartNew`](https://blog.stephencleary.com/2013/08/startnew-is-dangerous.html).\r\n\r\nI'm not clear on why the parameters make a difference, or how you envision the resulting API would look like. For an async lazy scenario, if a constructor took parameters they would be bound during the creation of the async lazy itself.","date":"2020-05-16T03:03:09.366Z"},{"_id":"ebe89c90-9766-11ea-85f9-d963faf51bb2","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","postUri":"https://blog.stephencleary.com/2012/08/asynchronous-lazy-initialization.html","replyTo":"c5714070-9721-11ea-aaef-318665cfb908","authorEmailEncrypted":"B45bXJX49nXq9rFfb0xZQSQwNJQqTDe4eVr3cVYdeVojI9jf1gUPg7rNfGhu+HdQFwftjuY2UAhqw6Z3/LKxwcV+QPuFmhNzpZwk05/Ik71ZtZXQGKQ50UtOAFwQEa8wc8kAVy8VLZQY8CLgmdBhGRUtACw06lpd/5miqmsj/l8AkHL2dQ5GgYVe5yXxFgHMjE/FBqKuYgY+DMGKRvIoxSJ0MHCKGtFC1cclNszIfqTWVjWSOCTpAWdut+i6Hk9xYPIuzws9kTV6mCXuO2jw2YI9WNFhJc4L7LAvnS+RpwsDgiQOlAo84VxFSJ5lAYu7bVVhVeI5AA42StujdrOFasDPOphr3kP2p/7hRmAH0z6EqZqv+ov3MXfqTBEeiL/4gN3Uc6pTSd3WhbY8ne8sh+7oCOs9O8lcdPGlLcU2GjraF8r2iGRPMtsgEzFyTv4L5baSuDF7w+mdlM65oiEROlybRO04H1Pv8uhcH/jggnHyeJvOqZfVqNEfwiJOA4Pj+kdCayvTAnT0ImnNsa0P4t80yUp7a4+1LAINIcu7bkKRp+vQjOZCj2dnhsxDRlx62nWCH5eDfD5L8xdakyRrWUkrmxxj1fH4qXM1SySBvT0w6PMMb3pdI6IxA9n9160OCa0V51DkP7KCgTdABE6i+FlK9hQj/SQlER6seYwPDnU=","authorEmailMD5":"c315f0c5bd7b1dca88c9d6070d4f873d","authorName":"Dmytro Kontsevoy","authorUri":"","message":"Hi Stephen, thank you for such a quick answer. The blog post you mentioned is actually a reason why I am asking.<br/>\r\nI will try to extend the context... I am writing async memory cache class to cache expensive(on server-side) calls to server and of course those calls are async, so I want each caller(from multiple threads) to wait same task that was created by first caller and if value is already returned then get it from cache. The tricky part is that I need to pass arguments to factory function, assume that all other callers will pass same arguments or in any case all other will be ignored by cache nature if key is already exist (for now. it is possible that I will be asked to make a change to delete cached value and get new one if arguments are different).<br/><br/>\r\nMy simple implementation of AsyncLazy class looks like this:<br/>\r\n<pre>\r\n<code>\r\nclass AsyncLazy<T1, T2, TResult> : Lazy<Task<TResult>>\r\n{\r\n    public AsyncLazy(Func<T1, T2, TResult> valueFactory, T1 arg1, T2 arg2)\r\n       : base(() => Task.Factory.StartNew(() => valueFactory(arg1, arg2)))\r\n    { }\r\n\r\n    public AsyncLazy(Func<T1, T2, Task<TResult>> taskFactory, T1 arg1, T2 arg2)\r\n        : base(() => Task.Factory.StartNew(() => taskFactory(arg1, arg2)).Unwrap())\r\n    { }\r\n}\r\n</code>\r\n</pre>\r\nand this is a part of cache class:\r\n<pre>\r\n<code>\r\n...\r\npublic Task<TResult> AddOrGetExistingAsync<T1, T2, TResult>(string key, Func<T1, T2, TResult> valueFactory, T1 arg1, T2 arg2, CacheItemPolicy cacheItemPolicy = null)\r\n{\r\n    var lazyValue = new AsyncLazy<T1, T2, TResult>(valueFactory, arg1, arg2);\r\n    return AddOrGetExistingAsync(key, lazyValue, cacheItemPolicy ?? _defaultCacheItemPolicy);\r\n}\r\n\r\npublic Task<TResult> AddOrGetExistingAsync<T1, T2, TResult>(string key, Func<T1, T2, Task<TResult>> taskFactory, T1 arg1, T2 arg2, CacheItemPolicy cacheItemPolicy = null)\r\n{\r\n    var lazyValue = new AsyncLazy<T1, T2, TResult>(taskFactory, arg1, arg2);\r\n    return AddOrGetExistingAsync(key, lazyValue, cacheItemPolicy ?? _defaultCacheItemPolicy);\r\n}\r\n\r\nprivate async Task<TResult> AddOrGetExistingAsync<TResult>(string key, Lazy<Task<TResult>> lazyValue, CacheItemPolicy cacheItemPolicy)\r\n{\r\n    var cachedItem = _cache.AddOrGetExisting(key, lazyValue, cacheItemPolicy) as Lazy<Task<TResult>>;\r\n\r\n    try\r\n    {\r\n        return await (cachedItem ?? lazyValue).Value;\r\n    }\r\n    catch\r\n    {\r\n        _cache.Remove(key);\r\n        throw;\r\n    }\r\n}\r\n...\r\n</code>\r\n</pre>\r\nMaybe you have some thoughts that can help me. Maybe I do not need to make/use AsyncLazy at all?<br/>\r\nThanks in advance.","date":"2020-05-16T11:18:09.069Z"},{"_id":"29d6d320-987d-11ea-81de-7f5f3317fff0","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","postUri":"https://blog.stephencleary.com/2012/08/asynchronous-lazy-initialization.html","replyTo":"ebe89c90-9766-11ea-85f9-d963faf51bb2","authorEmailEncrypted":"C2tV6ttUyYEocyhjAepyfDHrFYhwcIhuNj+CkJbsTNyOnmA7cFSIJaV1ok+BiEtw0tQBEWj0Jk+DehL3VpWjzI2t6kbml3cquwt6YAUhqyBX/tewCi8+WEOyBIW+D/yiFoE5hYyvNSOMoGucpXu86KvgcCiG4G1xjvGJiXa/McJR1IGTFWGmoBsGz93FkyqqbwNX9e27ig3W9LNhMJ+9HRfeMMMWByUtiTKmvVIifOG662tlh2XuZR9PYLQbyFt+zVkDGowQwmEvNYwKCRP0Nfij49jcfVq52GPWyzM6pslfHL8rskFmAihoRFcwZ1yvfwcB3E68cTNMCqiDOuTx6PG5wh8oEMX7rXtc9z6IEMXTtn0rqryz74+Fba+1dxdea8O7V9eqUsV6uILqX4BbIK1sBuWSa0zsaV9u+OGvMywZJevRsN9evUhR92i4r6nUvB2bf3FvQNX8FjSRYx/fYcrZW3wrTEjAXtU/DFDER79Mnx/ejl4qNEiBEZFeggxn6HRiVRq8ejGwcoaq1KW9sdGzej0SAso7XoCRmvAk/QJj01Z52SLOf53FPQQh15nmKaVgkeDfZviIEqR0p50AozcEwOQUvulLgREwMmQAWPRNMb4d9i2TemTHY/WmK+iuL9unGAn4AbNWgQzPm4TeX5IRZMp/9JGFNw/EIZujz7U=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Ah, yes. There isn't a really good implementation of an asynchronous cache that I'm aware of, at least right now.\r\n\r\nThat said, I don't see any benefit of using `AsyncLazy<T>` in a cache. By definition, if it isn't in the cache (and so your code creates a new instance), it would want to run it *immediately*, so it will never actually be *lazy*.\r\n\r\nOne approach for asynchronous caches is to cache the `Task<T>` itself. You do need to handle the scenario where the task fails; e.g., remove the cache entry if the fetch failed. But that's the general approach I would attempt.","date":"2020-05-17T20:29:53.164Z"},{"_id":"a4c0a2a0-0e07-11eb-ad39-4f7fd2834151","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","postUri":"https://blog.stephencleary.com/2012/08/asynchronous-lazy-initialization.html","replyTo":"","authorEmailEncrypted":"qwRRy+FjoL3PQxmKvDDnr6eSkgjPcRQKYAuRgI8ecE5a0DVr2TBiv9buI5lrWlccGVh4T3i3LJldrZ0MRHdZDAAACEA3jBOpOBi/vTc7SVhQK3j6ObJKd0cTlprUb5O3YyONrRUQL2HaIIzpWDXUBHccyGdm5E+dPtRJbgVwdlYQKY8Qnz3rUCZq8mhTV2LN2wjdDu/OFxGQu68e3LHQsxo2Op2qmGHUubi1uys62ZdAviSDAJTWD2YUFH2/eB9LutVfyU060cx/fe3wwxiG4SJlmALoUt+hn/LBFrCjZwDka0GbbqM4xPL8RK2lpmsW/SEugQGb1f+TKBsqugk67ZI93FgEmbhTVijxKUOCBkShpSo5xiE618WGEPPVr3JFn4AixDAJi9l4s1veL5Bzu6xKrzZA0fQCI+vmzj+lpsRtcflT3BQB/ItSXqZIB63zVDJzvBMIPxOSBJgDrZA5LodP1zXiyWr3fHv73QtZ1eRiEWlSQ4TEW0bh7O2UsyAG3RJa1r5nyv6/F5NnPP6o1SZ+/rIjomHvH0iKD4z4ZHWgJp0F9G2tEVt2Adq5/HiGNOA2/gcpo7qQmJGmLrwpdk3FSFZymUyxFt4AsC/PrrE0wp3pbFB6eAm0LV0gEgxYNlmHK8W8GxpRPtv6meWSqvUky9C8zjV0BSz+DRxRZ/I=","authorEmailMD5":"ba54e699a7c8f52e0fe6b38555b9ded9","authorName":"Ian Kemp","authorUri":"","message":"Stephen, you might want to change the URL for Nito.AsyncEx (end of the post) to point directly to https://github.com/StephenCleary/AsyncEx instead of the now-defunct CodePlex.\r\n\r\nFurther, there's a proposal to add an AsyncLazy (or equivalent) to the language at https://github.com/dotnet/runtime/issues/27510 - if you have any thoughts on this, it would be really great if you could add them to that issue.","date":"2020-10-14T10:25:55.966Z"},{"_id":"b80f4040-2299-11eb-a090-3b27858fcd8f","postId":"2012_08_asynchronous-lazy-initialization-248a82a4-1ad6-39c8-867f-974206a56b23","postUri":"https://blog.stephencleary.com/2012/08/asynchronous-lazy-initialization.html","replyTo":"a4c0a2a0-0e07-11eb-ad39-4f7fd2834151","authorEmailEncrypted":"ZUAnyUpH/Dp+Ia+96TKytZwOV8cEe2/9LTobgZ+lE+63l8n3cZGTCMF/nTFnR7Nf2oRzlIIjxsO03kjsFGRR32iqDxF6tiD+xuAactMyzen9G057aNSVjrCEbnHUdUdhSoibgdODMBWUnn2jLizWZaBSlw8FPv7jDsy0bfduoTO8QpSuYdpNM9BPcYbVp1jeoUeKfNkYn9kjMH48ykAtuaJ/2fZ5p06/gSOFlns0qyoOMtvaIV+MmGmsz1/bMGK6T3YdqPpQHn2nNhn+BwKTA2wVwyWnvFRGTYTfwiTDvsAa24gj5BNizr45oh73ptr50e0BDSvGuHQKRYxhXVUMsImsuea4LYcM87VtCfDQczxNB8a1GTJogPF0ZEEgyWxlW6rxqtXM1wdbNAvl4M2pZlU69IQ2pNuSbE1zjU4eC/UPjeDMfAiRZWkeVM1ZCN7CcsdFEf1kKwbkt4maQiDq+csleRFxOkjQfPkik+ecQ0pvmO6x1iG/i5udXMeKRV6aC2SOCLmesyWaWEyrpgnhI+d1zqZlJIqgzzk24yy4JN5HAE/+QyIwWjdMsII87HrR9rsoOfXPN1Ue9fxvVqguSCX2OrjmeBz4+RxJL0iq4t5HzJyBvcecN0Qiyno+F6CKsMwb8vnmgcHm3lQEvDZveOtOSOlcM75mVhrtWOwpU54=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"Thanks!","date":"2020-11-09T14:41:58.043Z"}]