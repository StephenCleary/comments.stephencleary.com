[{"_id":"475b9c5b-d67c-3ea3-b45a-3ac99a16f687","authorName":"Anonymous","authorEmailEncrypted":"","authorEmailMD5":"","authorUri":"","authorUserId":"","authorFallbackAvatar":"","message":"Thank you for this piece of code!  \r\nHint: In recent versions of AsyncEx NotifyOne() was renamed to Notify()","postId":"2012_12_async-producer-consumer-queue-3-more-b1cf2757-bf65-330c-b981-d3dc90f7b4be","replyTo":"","date":"2014-05-15T10:49:19Z","timestamp":1400150959},{"_id":"6b2bf2f2-b653-4d44-8aa2-a7f1b6550d7b","postId":"2012_12_async-producer-consumer-queue-3-more-b1cf2757-bf65-330c-b981-d3dc90f7b4be","postUri":"https://blog.stephencleary.com/2012/12/async-producer-consumer-queue-3-more.html","replyTo":"e2184fc1-146c-4675-838b-e5b736e658a2","authorEmailEncrypted":"UnopXEpPx2fTEtxltWMPIdabLJB1z6eQPWGcL6p//u1yxIdb5SfJQK/3GaosZ/J6Oi3NSxgFSR58K9t29FKApDokjTFlMWIlrnk+YgUWfUpGsaWGdHf3xN5kxfNYfxNnK4zqyDY+PUXMTRyUFO2nO+/qI2IMnoJN096T4/sU6v0FgX47GkSAyAb/WHbACFRC2WkTRG8AyCdETgweyGJetOH0idmq9PC6VYtC/ww7PPUvFF3+4gtcUd898PmvJHzAFkiUqfFbRYz9GoVG9m09BMozggCcBI8+RW7ptzd0O+bw/Lrq8mKkkwOGJ7I61dRGravE6lR6PL5S7jhGydQZIWDCV60+L0Z3owWRfZDf279BuXyhPPtOrjgRWm04eHup1jUBdbILAbMLIlOg6QKaGs8wpFSSoXyTDDFfGjQMzQMwot/CgBLw8MEXeQKEQNXI8nFkyqqVyh/8D9rpVgJqgU9AedZaTZdw1ViAMTUul9cYMQvKn7fiHxWFQk6SFZjr/xcXDLcx/wIaAgoGlxx1hirx35tu6YE21r1qnUvzVyL+mhCcN2rh7hq+jgCQYzc/5VP2u28bBiWEAI5027hUFxeaWF4ER0FMRy3b65qjexSKXJyxvadir3p1GJj28OXHv2lPTJboeTQXkPva18F9rcPH2AjhVaij7nYNH2YbRHQ=","authorEmailMD5":"23448e78d187fba56d8bc263081ac5d8","authorName":"Stephen Cleary","authorUri":"https://stephencleary.com","message":"There isn't a deadlock, because of how condition variables work: when waiting, the mutex is released.","date":"2023-04-26T16:34:04.3724302Z"},{"_id":"e2184fc1-146c-4675-838b-e5b736e658a2","postId":"2012_12_async-producer-consumer-queue-3-more-b1cf2757-bf65-330c-b981-d3dc90f7b4be","postUri":"https://blog.stephencleary.com/2012/12/async-producer-consumer-queue-3-more.html","replyTo":"","authorEmailEncrypted":"","authorEmailMD5":"","authorName":"","authorUri":"","message":"I believe that there is a deadlock in the code. Calling TakeAsync first will take a lock on the mutex and 'notEmpty.AwaitAsync()' will never return, because AddAsync waits on the same mutex and will never reach 'notEmpty.NotifyOne()'.","date":"2023-04-26T07:25:46.1693620Z"}]